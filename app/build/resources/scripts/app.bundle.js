/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 80);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_assert__ = __webpack_require__(60);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_0__src_assert__["a"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "C", function() { return __WEBPACK_IMPORTED_MODULE_0__src_assert__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_crypt__ = __webpack_require__(61);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "n", function() { return __WEBPACK_IMPORTED_MODULE_1__src_crypt__["b"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "p", function() { return __WEBPACK_IMPORTED_MODULE_1__src_crypt__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_constants__ = __webpack_require__(30);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "o", function() { return __WEBPACK_IMPORTED_MODULE_2__src_constants__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_deepCopy__ = __webpack_require__(127);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_3__src_deepCopy__["a"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_3__src_deepCopy__["b"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_3__src_deepCopy__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_deferred__ = __webpack_require__(128);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "J", function() { return __WEBPACK_IMPORTED_MODULE_4__src_deferred__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_environment__ = __webpack_require__(129);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_5__src_environment__["a"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "v", function() { return __WEBPACK_IMPORTED_MODULE_5__src_environment__["b"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "w", function() { return __WEBPACK_IMPORTED_MODULE_5__src_environment__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_errors__ = __webpack_require__(130);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_6__src_errors__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_json__ = __webpack_require__(62);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "j", function() { return __WEBPACK_IMPORTED_MODULE_7__src_json__["b"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "k", function() { return __WEBPACK_IMPORTED_MODULE_7__src_json__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_jwt__ = __webpack_require__(132);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "t", function() { return __WEBPACK_IMPORTED_MODULE_8__src_jwt__["a"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "u", function() { return __WEBPACK_IMPORTED_MODULE_8__src_jwt__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_obj__ = __webpack_require__(63);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_9__src_obj__["a"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_9__src_obj__["b"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "q", function() { return __WEBPACK_IMPORTED_MODULE_9__src_obj__["c"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "r", function() { return __WEBPACK_IMPORTED_MODULE_9__src_obj__["d"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "s", function() { return __WEBPACK_IMPORTED_MODULE_9__src_obj__["e"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "A", function() { return __WEBPACK_IMPORTED_MODULE_9__src_obj__["f"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "B", function() { return __WEBPACK_IMPORTED_MODULE_9__src_obj__["g"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "D", function() { return __WEBPACK_IMPORTED_MODULE_9__src_obj__["h"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "E", function() { return __WEBPACK_IMPORTED_MODULE_9__src_obj__["i"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "F", function() { return __WEBPACK_IMPORTED_MODULE_9__src_obj__["j"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "K", function() { return __WEBPACK_IMPORTED_MODULE_9__src_obj__["k"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "L", function() { return __WEBPACK_IMPORTED_MODULE_9__src_obj__["l"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_query__ = __webpack_require__(133);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "G", function() { return __WEBPACK_IMPORTED_MODULE_10__src_query__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_sha1__ = __webpack_require__(134);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "m", function() { return __WEBPACK_IMPORTED_MODULE_11__src_sha1__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_subscribe__ = __webpack_require__(135);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_12__src_subscribe__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_validation__ = __webpack_require__(137);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "y", function() { return __WEBPACK_IMPORTED_MODULE_13__src_validation__["a"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "z", function() { return __WEBPACK_IMPORTED_MODULE_13__src_validation__["b"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "H", function() { return __WEBPACK_IMPORTED_MODULE_13__src_validation__["c"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "I", function() { return __WEBPACK_IMPORTED_MODULE_13__src_validation__["d"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_utf8__ = __webpack_require__(136);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "l", function() { return __WEBPACK_IMPORTED_MODULE_14__src_utf8__["a"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "x", function() { return __WEBPACK_IMPORTED_MODULE_14__src_utf8__["b"]; });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


















/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return LUIDGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return sha1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return logger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return enableLogging; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return logWrapper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return error; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return fatal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return warn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return warnIfPageIsSecure; });
/* unused harmony export warnAboutUnsupportedMethod */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return isInvalidJSONNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return executeWhenDOMReady; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return MIN_NAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return MAX_NAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return nameCompare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return stringCompare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return requireKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return ObjectToUniqueKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return splitStringBySize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return each; });
/* unused harmony export bindCallback */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return doubleToIEEE754String; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return isChromeExtensionContentScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return isWindowsStoreApp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return errorForServerCode; });
/* unused harmony export INTEGER_REGEXP_ */
/* unused harmony export tryParseInt */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return exceptionGuard; });
/* unused harmony export callUserCallback */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return beingCrawled; });
/* unused harmony export exportPropGetter */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return setTimeoutNonBlocking; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__storage_storage__ = __webpack_require__(21);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Returns a locally-unique ID (generated by just incrementing up from 0 each time its called).
 * @type {function(): number} Generated ID.
 */
var LUIDGenerator = (function () {
    var id = 1;
    return function () {
        return id++;
    };
})();
/**
 * Sha1 hash of the input string
 * @param {!string} str The string to hash
 * @return {!string} The resulting hash
 */
var sha1 = function (str) {
    var utf8Bytes = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["l" /* stringToByteArray */])(str);
    var sha1 = new __WEBPACK_IMPORTED_MODULE_0__firebase_util__["m" /* Sha1 */]();
    sha1.update(utf8Bytes);
    var sha1Bytes = sha1.digest();
    return __WEBPACK_IMPORTED_MODULE_0__firebase_util__["n" /* base64 */].encodeByteArray(sha1Bytes);
};
/**
 * @param {...*} var_args
 * @return {string}
 * @private
 */
var buildLogMessage_ = function () {
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        var_args[_i] = arguments[_i];
    }
    var message = '';
    for (var i = 0; i < var_args.length; i++) {
        if (Array.isArray(var_args[i]) ||
            (var_args[i] &&
                typeof var_args[i] === 'object' &&
                typeof var_args[i].length === 'number')) {
            message += buildLogMessage_.apply(null, var_args[i]);
        }
        else if (typeof var_args[i] === 'object') {
            message += __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["j" /* stringify */])(var_args[i]);
        }
        else {
            message += var_args[i];
        }
        message += ' ';
    }
    return message;
};
/**
 * Use this for all debug messages in Firebase.
 * @type {?function(string)}
 */
var logger = null;
/**
 * Flag to check for log availability on first log message
 * @type {boolean}
 * @private
 */
var firstLog_ = true;
/**
 * The implementation of Firebase.enableLogging (defined here to break dependencies)
 * @param {boolean|?function(string)} logger_ A flag to turn on logging, or a custom logger
 * @param {boolean=} persistent Whether or not to persist logging settings across refreshes
 */
var enableLogging = function (logger_, persistent) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(!persistent || (logger_ === true || logger_ === false), "Can't turn on custom loggers persistently.");
    if (logger_ === true) {
        if (typeof console !== 'undefined') {
            if (typeof console.log === 'function') {
                logger = console.log.bind(console);
            }
            else if (typeof console.log === 'object') {
                // IE does this.
                logger = function (message) {
                    console.log(message);
                };
            }
        }
        if (persistent)
            __WEBPACK_IMPORTED_MODULE_1__storage_storage__["b" /* SessionStorage */].set('logging_enabled', true);
    }
    else if (typeof logger_ === 'function') {
        logger = logger_;
    }
    else {
        logger = null;
        __WEBPACK_IMPORTED_MODULE_1__storage_storage__["b" /* SessionStorage */].remove('logging_enabled');
    }
};
/**
 *
 * @param {...(string|Arguments)} var_args
 */
var log = function () {
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        var_args[_i] = arguments[_i];
    }
    if (firstLog_ === true) {
        firstLog_ = false;
        if (logger === null && __WEBPACK_IMPORTED_MODULE_1__storage_storage__["b" /* SessionStorage */].get('logging_enabled') === true)
            enableLogging(true);
    }
    if (logger) {
        var message = buildLogMessage_.apply(null, var_args);
        logger(message);
    }
};
/**
 * @param {!string} prefix
 * @return {function(...[*])}
 */
var logWrapper = function (prefix) {
    return function () {
        var var_args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            var_args[_i] = arguments[_i];
        }
        log.apply(void 0, [prefix].concat(var_args));
    };
};
/**
 * @param {...string} var_args
 */
var error = function () {
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        var_args[_i] = arguments[_i];
    }
    if (typeof console !== 'undefined') {
        var message = 'FIREBASE INTERNAL ERROR: ' + buildLogMessage_.apply(void 0, var_args);
        if (typeof console.error !== 'undefined') {
            console.error(message);
        }
        else {
            console.log(message);
        }
    }
};
/**
 * @param {...string} var_args
 */
var fatal = function () {
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        var_args[_i] = arguments[_i];
    }
    var message = buildLogMessage_.apply(void 0, var_args);
    throw new Error('FIREBASE FATAL ERROR: ' + message);
};
/**
 * @param {...*} var_args
 */
var warn = function () {
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        var_args[_i] = arguments[_i];
    }
    if (typeof console !== 'undefined') {
        var message = 'FIREBASE WARNING: ' + buildLogMessage_.apply(void 0, var_args);
        if (typeof console.warn !== 'undefined') {
            console.warn(message);
        }
        else {
            console.log(message);
        }
    }
};
/**
 * Logs a warning if the containing page uses https. Called when a call to new Firebase
 * does not use https.
 */
var warnIfPageIsSecure = function () {
    // Be very careful accessing browser globals. Who knows what may or may not exist.
    if (typeof window !== 'undefined' &&
        window.location &&
        window.location.protocol &&
        window.location.protocol.indexOf('https:') !== -1) {
        warn('Insecure Firebase access from a secure page. ' +
            'Please use https in calls to new Firebase().');
    }
};
/**
 * @param {!String} methodName
 */
var warnAboutUnsupportedMethod = function (methodName) {
    warn(methodName +
        ' is unsupported and will likely change soon.  ' +
        'Please do not use.');
};
/**
 * Returns true if data is NaN, or +/- Infinity.
 * @param {*} data
 * @return {boolean}
 */
var isInvalidJSONNumber = function (data) {
    return (typeof data === 'number' &&
        (data != data || // NaN
            data == Number.POSITIVE_INFINITY ||
            data == Number.NEGATIVE_INFINITY));
};
/**
 * @param {function()} fn
 */
var executeWhenDOMReady = function (fn) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["f" /* isNodeSdk */])() || document.readyState === 'complete') {
        fn();
    }
    else {
        // Modeled after jQuery. Try DOMContentLoaded and onreadystatechange (which
        // fire before onload), but fall back to onload.
        var called_1 = false;
        var wrappedFn_1 = function () {
            if (!document.body) {
                setTimeout(wrappedFn_1, Math.floor(10));
                return;
            }
            if (!called_1) {
                called_1 = true;
                fn();
            }
        };
        if (document.addEventListener) {
            document.addEventListener('DOMContentLoaded', wrappedFn_1, false);
            // fallback to onload.
            window.addEventListener('load', wrappedFn_1, false);
        }
        else if (document.attachEvent) {
            // IE.
            document.attachEvent('onreadystatechange', function () {
                if (document.readyState === 'complete')
                    wrappedFn_1();
            });
            // fallback to onload.
            window.attachEvent('onload', wrappedFn_1);
            // jQuery has an extra hack for IE that we could employ (based on
            // http://javascript.nwbox.com/IEContentLoaded/) But it looks really old.
            // I'm hoping we don't need it.
        }
    }
};
/**
 * Minimum key name. Invalid for actual data, used as a marker to sort before any valid names
 * @type {!string}
 */
var MIN_NAME = '[MIN_NAME]';
/**
 * Maximum key name. Invalid for actual data, used as a marker to sort above any valid names
 * @type {!string}
 */
var MAX_NAME = '[MAX_NAME]';
/**
 * Compares valid Firebase key names, plus min and max name
 * @param {!string} a
 * @param {!string} b
 * @return {!number}
 */
var nameCompare = function (a, b) {
    if (a === b) {
        return 0;
    }
    else if (a === MIN_NAME || b === MAX_NAME) {
        return -1;
    }
    else if (b === MIN_NAME || a === MAX_NAME) {
        return 1;
    }
    else {
        var aAsInt = tryParseInt(a), bAsInt = tryParseInt(b);
        if (aAsInt !== null) {
            if (bAsInt !== null) {
                return aAsInt - bAsInt == 0 ? a.length - b.length : aAsInt - bAsInt;
            }
            else {
                return -1;
            }
        }
        else if (bAsInt !== null) {
            return 1;
        }
        else {
            return a < b ? -1 : 1;
        }
    }
};
/**
 * @param {!string} a
 * @param {!string} b
 * @return {!number} comparison result.
 */
var stringCompare = function (a, b) {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
};
/**
 * @param {string} key
 * @param {Object} obj
 * @return {*}
 */
var requireKey = function (key, obj) {
    if (obj && key in obj) {
        return obj[key];
    }
    else {
        throw new Error('Missing required key (' + key + ') in object: ' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["j" /* stringify */])(obj));
    }
};
/**
 * @param {*} obj
 * @return {string}
 */
var ObjectToUniqueKey = function (obj) {
    if (typeof obj !== 'object' || obj === null)
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["j" /* stringify */])(obj);
    var keys = [];
    for (var k in obj) {
        keys.push(k);
    }
    // Export as json, but with the keys sorted.
    keys.sort();
    var key = '{';
    for (var i = 0; i < keys.length; i++) {
        if (i !== 0)
            key += ',';
        key += __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["j" /* stringify */])(keys[i]);
        key += ':';
        key += ObjectToUniqueKey(obj[keys[i]]);
    }
    key += '}';
    return key;
};
/**
 * Splits a string into a number of smaller segments of maximum size
 * @param {!string} str The string
 * @param {!number} segsize The maximum number of chars in the string.
 * @return {Array.<string>} The string, split into appropriately-sized chunks
 */
var splitStringBySize = function (str, segsize) {
    var len = str.length;
    if (len <= segsize) {
        return [str];
    }
    var dataSegs = [];
    for (var c = 0; c < len; c += segsize) {
        if (c + segsize > len) {
            dataSegs.push(str.substring(c, len));
        }
        else {
            dataSegs.push(str.substring(c, c + segsize));
        }
    }
    return dataSegs;
};
/**
 * Apply a function to each (key, value) pair in an object or
 * apply a function to each (index, value) pair in an array
 * @param {!(Object|Array)} obj The object or array to iterate over
 * @param {function(?, ?)} fn The function to apply
 */
var each = function (obj, fn) {
    if (Array.isArray(obj)) {
        for (var i = 0; i < obj.length; ++i) {
            fn(i, obj[i]);
        }
    }
    else {
        /**
         * in the conversion of code we removed the goog.object.forEach
         * function which did a value,key callback. We standardized on
         * a single impl that does a key, value callback. So we invert
         * to not have to touch the `each` code points
         */
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["h" /* forEach */])(obj, function (key, val) { return fn(val, key); });
    }
};
/**
 * Like goog.bind, but doesn't bother to create a closure if opt_context is null/undefined.
 * @param {function(*)} callback Callback function.
 * @param {?Object=} context Optional context to bind to.
 * @return {function(*)}
 */
var bindCallback = function (callback, context) {
    return context ? callback.bind(context) : callback;
};
/**
 * Borrowed from http://hg.secondlife.com/llsd/src/tip/js/typedarray.js (MIT License)
 * I made one modification at the end and removed the NaN / Infinity
 * handling (since it seemed broken [caused an overflow] and we don't need it).  See MJL comments.
 * @param {!number} v A double
 * @return {string}
 */
var doubleToIEEE754String = function (v) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(!isInvalidJSONNumber(v), 'Invalid JSON number'); // MJL
    var ebits = 11, fbits = 52;
    var bias = (1 << (ebits - 1)) - 1, s, e, f, ln, i, bits, str;
    // Compute sign, exponent, fraction
    // Skip NaN / Infinity handling --MJL.
    if (v === 0) {
        e = 0;
        f = 0;
        s = 1 / v === -Infinity ? 1 : 0;
    }
    else {
        s = v < 0;
        v = Math.abs(v);
        if (v >= Math.pow(2, 1 - bias)) {
            // Normalized
            ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);
            e = ln + bias;
            f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));
        }
        else {
            // Denormalized
            e = 0;
            f = Math.round(v / Math.pow(2, 1 - bias - fbits));
        }
    }
    // Pack sign, exponent, fraction
    bits = [];
    for (i = fbits; i; i -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = Math.floor(f / 2);
    }
    for (i = ebits; i; i -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = Math.floor(e / 2);
    }
    bits.push(s ? 1 : 0);
    bits.reverse();
    str = bits.join('');
    // Return the data as a hex string. --MJL
    var hexByteString = '';
    for (i = 0; i < 64; i += 8) {
        var hexByte = parseInt(str.substr(i, 8), 2).toString(16);
        if (hexByte.length === 1)
            hexByte = '0' + hexByte;
        hexByteString = hexByteString + hexByte;
    }
    return hexByteString.toLowerCase();
};
/**
 * Used to detect if we're in a Chrome content script (which executes in an
 * isolated environment where long-polling doesn't work).
 * @return {boolean}
 */
var isChromeExtensionContentScript = function () {
    return !!(typeof window === 'object' &&
        window['chrome'] &&
        window['chrome']['extension'] &&
        !/^chrome/.test(window.location.href));
};
/**
 * Used to detect if we're in a Windows 8 Store app.
 * @return {boolean}
 */
var isWindowsStoreApp = function () {
    // Check for the presence of a couple WinRT globals
    return typeof Windows === 'object' && typeof Windows.UI === 'object';
};
/**
 * Converts a server error code to a Javascript Error
 * @param {!string} code
 * @param {!Query} query
 * @return {Error}
 */
var errorForServerCode = function (code, query) {
    var reason = 'Unknown Error';
    if (code === 'too_big') {
        reason =
            'The data requested exceeds the maximum size ' +
                'that can be accessed with a single request.';
    }
    else if (code == 'permission_denied') {
        reason = "Client doesn't have permission to access the desired data.";
    }
    else if (code == 'unavailable') {
        reason = 'The service is unavailable';
    }
    var error = new Error(code + ' at ' + query.path.toString() + ': ' + reason);
    error.code = code.toUpperCase();
    return error;
};
/**
 * Used to test for integer-looking strings
 * @type {RegExp}
 * @private
 */
var INTEGER_REGEXP_ = new RegExp('^-?\\d{1,10}$');
/**
 * If the string contains a 32-bit integer, return it.  Else return null.
 * @param {!string} str
 * @return {?number}
 */
var tryParseInt = function (str) {
    if (INTEGER_REGEXP_.test(str)) {
        var intVal = Number(str);
        if (intVal >= -2147483648 && intVal <= 2147483647) {
            return intVal;
        }
    }
    return null;
};
/**
 * Helper to run some code but catch any exceptions and re-throw them later.
 * Useful for preventing user callbacks from breaking internal code.
 *
 * Re-throwing the exception from a setTimeout is a little evil, but it's very
 * convenient (we don't have to try to figure out when is a safe point to
 * re-throw it), and the behavior seems reasonable:
 *
 * * If you aren't pausing on exceptions, you get an error in the console with
 *   the correct stack trace.
 * * If you're pausing on all exceptions, the debugger will pause on your
 *   exception and then again when we rethrow it.
 * * If you're only pausing on uncaught exceptions, the debugger will only pause
 *   on us re-throwing it.
 *
 * @param {!function()} fn The code to guard.
 */
var exceptionGuard = function (fn) {
    try {
        fn();
    }
    catch (e) {
        // Re-throw exception when it's safe.
        setTimeout(function () {
            // It used to be that "throw e" would result in a good console error with
            // relevant context, but as of Chrome 39, you just get the firebase.js
            // file/line number where we re-throw it, which is useless. So we log
            // e.stack explicitly.
            var stack = e.stack || '';
            warn('Exception was thrown by user callback.', stack);
            throw e;
        }, Math.floor(0));
    }
};
/**
 * Helper function to safely call opt_callback with the specified arguments.  It:
 * 1. Turns into a no-op if opt_callback is null or undefined.
 * 2. Wraps the call inside exceptionGuard to prevent exceptions from breaking our state.
 *
 * @param {?Function=} callback Optional onComplete callback.
 * @param {...*} var_args Arbitrary args to be passed to opt_onComplete
 */
var callUserCallback = function (callback) {
    var var_args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        var_args[_i - 1] = arguments[_i];
    }
    if (typeof callback === 'function') {
        exceptionGuard(function () {
            callback.apply(void 0, var_args);
        });
    }
};
/**
 * @return {boolean} true if we think we're currently being crawled.
 */
var beingCrawled = function () {
    var userAgent = (typeof window === 'object' &&
        window['navigator'] &&
        window['navigator']['userAgent']) ||
        '';
    // For now we whitelist the most popular crawlers.  We should refine this to be the set of crawlers we
    // believe to support JavaScript/AJAX rendering.
    // NOTE: Google Webmaster Tools doesn't really belong, but their "This is how a visitor to your website
    // would have seen the page" is flaky if we don't treat it as a crawler.
    return (userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0);
};
/**
 * Export a property of an object using a getter function.
 *
 * @param {!Object} object
 * @param {string} name
 * @param {!function(): *} fnGet
 */
var exportPropGetter = function (object, name, fnGet) {
    Object.defineProperty(object, name, { get: fnGet });
};
/**
 * Same as setTimeout() except on Node.JS it will /not/ prevent the process from exiting.
 *
 * It is removed with clearTimeout() as normal.
 *
 * @param {Function} fn Function to run.
 * @param {number} time Milliseconds to wait before running.
 * @return {number|Object} The setTimeout() return value.
 */
var setTimeoutNonBlocking = function (fn, time) {
    var timeout = setTimeout(fn, time);
    if (typeof timeout === 'object' && timeout['unref']) {
        timeout['unref']();
    }
    return timeout;
};



/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ValidationPath; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * An immutable object representing a parsed path.  It's immutable so that you
 * can pass them around to other functions without worrying about them changing
 * it.
 */
var Path = /** @class */ (function () {
    /**
     * @param {string|Array.<string>} pathOrString Path string to parse,
     *      or another path, or the raw tokens array
     * @param {number=} pieceNum
     */
    function Path(pathOrString, pieceNum) {
        if (pieceNum === void 0) {
            this.pieces_ = pathOrString.split('/');
            // Remove empty pieces.
            var copyTo = 0;
            for (var i = 0; i < this.pieces_.length; i++) {
                if (this.pieces_[i].length > 0) {
                    this.pieces_[copyTo] = this.pieces_[i];
                    copyTo++;
                }
            }
            this.pieces_.length = copyTo;
            this.pieceNum_ = 0;
        }
        else {
            this.pieces_ = pathOrString;
            this.pieceNum_ = pieceNum;
        }
    }
    Object.defineProperty(Path, "Empty", {
        /**
         * Singleton to represent an empty path
         *
         * @const
         */
        get: function () {
            return new Path('');
        },
        enumerable: true,
        configurable: true
    });
    Path.prototype.getFront = function () {
        if (this.pieceNum_ >= this.pieces_.length)
            return null;
        return this.pieces_[this.pieceNum_];
    };
    /**
     * @return {number} The number of segments in this path
     */
    Path.prototype.getLength = function () {
        return this.pieces_.length - this.pieceNum_;
    };
    /**
     * @return {!Path}
     */
    Path.prototype.popFront = function () {
        var pieceNum = this.pieceNum_;
        if (pieceNum < this.pieces_.length) {
            pieceNum++;
        }
        return new Path(this.pieces_, pieceNum);
    };
    /**
     * @return {?string}
     */
    Path.prototype.getBack = function () {
        if (this.pieceNum_ < this.pieces_.length)
            return this.pieces_[this.pieces_.length - 1];
        return null;
    };
    Path.prototype.toString = function () {
        var pathString = '';
        for (var i = this.pieceNum_; i < this.pieces_.length; i++) {
            if (this.pieces_[i] !== '')
                pathString += '/' + this.pieces_[i];
        }
        return pathString || '/';
    };
    Path.prototype.toUrlEncodedString = function () {
        var pathString = '';
        for (var i = this.pieceNum_; i < this.pieces_.length; i++) {
            if (this.pieces_[i] !== '')
                pathString += '/' + encodeURIComponent(String(this.pieces_[i]));
        }
        return pathString || '/';
    };
    /**
     * Shallow copy of the parts of the path.
     *
     * @param {number=} begin
     * @return {!Array<string>}
     */
    Path.prototype.slice = function (begin) {
        if (begin === void 0) { begin = 0; }
        return this.pieces_.slice(this.pieceNum_ + begin);
    };
    /**
     * @return {?Path}
     */
    Path.prototype.parent = function () {
        if (this.pieceNum_ >= this.pieces_.length)
            return null;
        var pieces = [];
        for (var i = this.pieceNum_; i < this.pieces_.length - 1; i++)
            pieces.push(this.pieces_[i]);
        return new Path(pieces, 0);
    };
    /**
     * @param {string|!Path} childPathObj
     * @return {!Path}
     */
    Path.prototype.child = function (childPathObj) {
        var pieces = [];
        for (var i = this.pieceNum_; i < this.pieces_.length; i++)
            pieces.push(this.pieces_[i]);
        if (childPathObj instanceof Path) {
            for (var i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) {
                pieces.push(childPathObj.pieces_[i]);
            }
        }
        else {
            var childPieces = childPathObj.split('/');
            for (var i = 0; i < childPieces.length; i++) {
                if (childPieces[i].length > 0)
                    pieces.push(childPieces[i]);
            }
        }
        return new Path(pieces, 0);
    };
    /**
     * @return {boolean} True if there are no segments in this path
     */
    Path.prototype.isEmpty = function () {
        return this.pieceNum_ >= this.pieces_.length;
    };
    /**
     * @param {!Path} outerPath
     * @param {!Path} innerPath
     * @return {!Path} The path from outerPath to innerPath
     */
    Path.relativePath = function (outerPath, innerPath) {
        var outer = outerPath.getFront(), inner = innerPath.getFront();
        if (outer === null) {
            return innerPath;
        }
        else if (outer === inner) {
            return Path.relativePath(outerPath.popFront(), innerPath.popFront());
        }
        else {
            throw new Error('INTERNAL ERROR: innerPath (' +
                innerPath +
                ') is not within ' +
                'outerPath (' +
                outerPath +
                ')');
        }
    };
    /**
     * @param {!Path} left
     * @param {!Path} right
     * @return {number} -1, 0, 1 if left is less, equal, or greater than the right.
     */
    Path.comparePaths = function (left, right) {
        var leftKeys = left.slice();
        var rightKeys = right.slice();
        for (var i = 0; i < leftKeys.length && i < rightKeys.length; i++) {
            var cmp = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["p" /* nameCompare */])(leftKeys[i], rightKeys[i]);
            if (cmp !== 0)
                return cmp;
        }
        if (leftKeys.length === rightKeys.length)
            return 0;
        return leftKeys.length < rightKeys.length ? -1 : 1;
    };
    /**
     *
     * @param {Path} other
     * @return {boolean} true if paths are the same.
     */
    Path.prototype.equals = function (other) {
        if (this.getLength() !== other.getLength()) {
            return false;
        }
        for (var i = this.pieceNum_, j = other.pieceNum_; i <= this.pieces_.length; i++, j++) {
            if (this.pieces_[i] !== other.pieces_[j]) {
                return false;
            }
        }
        return true;
    };
    /**
     *
     * @param {!Path} other
     * @return {boolean} True if this path is a parent (or the same as) other
     */
    Path.prototype.contains = function (other) {
        var i = this.pieceNum_;
        var j = other.pieceNum_;
        if (this.getLength() > other.getLength()) {
            return false;
        }
        while (i < this.pieces_.length) {
            if (this.pieces_[i] !== other.pieces_[j]) {
                return false;
            }
            ++i;
            ++j;
        }
        return true;
    };
    return Path;
}()); // end Path

/**
 * Dynamic (mutable) path used to count path lengths.
 *
 * This class is used to efficiently check paths for valid
 * length (in UTF8 bytes) and depth (used in path validation).
 *
 * Throws Error exception if path is ever invalid.
 *
 * The definition of a path always begins with '/'.
 */
var ValidationPath = /** @class */ (function () {
    /**
     * @param {!Path} path Initial Path.
     * @param {string} errorPrefix_ Prefix for any error messages.
     */
    function ValidationPath(path, errorPrefix_) {
        this.errorPrefix_ = errorPrefix_;
        /** @type {!Array<string>} */
        this.parts_ = path.slice();
        /** @type {number} Initialize to number of '/' chars needed in path. */
        this.byteLength_ = Math.max(1, this.parts_.length);
        for (var i = 0; i < this.parts_.length; i++) {
            this.byteLength_ += __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["x" /* stringLength */])(this.parts_[i]);
        }
        this.checkValid_();
    }
    Object.defineProperty(ValidationPath, "MAX_PATH_DEPTH", {
        /** @const {number} Maximum key depth. */
        get: function () {
            return 32;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValidationPath, "MAX_PATH_LENGTH_BYTES", {
        /** @const {number} Maximum number of (UTF8) bytes in a Firebase path. */
        get: function () {
            return 768;
        },
        enumerable: true,
        configurable: true
    });
    /** @param {string} child */
    ValidationPath.prototype.push = function (child) {
        // Count the needed '/'
        if (this.parts_.length > 0) {
            this.byteLength_ += 1;
        }
        this.parts_.push(child);
        this.byteLength_ += __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["x" /* stringLength */])(child);
        this.checkValid_();
    };
    ValidationPath.prototype.pop = function () {
        var last = this.parts_.pop();
        this.byteLength_ -= __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["x" /* stringLength */])(last);
        // Un-count the previous '/'
        if (this.parts_.length > 0) {
            this.byteLength_ -= 1;
        }
    };
    ValidationPath.prototype.checkValid_ = function () {
        if (this.byteLength_ > ValidationPath.MAX_PATH_LENGTH_BYTES) {
            throw new Error(this.errorPrefix_ +
                'has a key path longer than ' +
                ValidationPath.MAX_PATH_LENGTH_BYTES +
                ' bytes (' +
                this.byteLength_ +
                ').');
        }
        if (this.parts_.length > ValidationPath.MAX_PATH_DEPTH) {
            throw new Error(this.errorPrefix_ +
                'path specified exceeds the maximum depth that can be written (' +
                ValidationPath.MAX_PATH_DEPTH +
                ') or object contains a cycle ' +
                this.toErrorString());
        }
    };
    /**
     * String for use in error messages - uses '.' notation for path.
     *
     * @return {string}
     */
    ValidationPath.prototype.toErrorString = function () {
        if (this.parts_.length == 0) {
            return '';
        }
        return "in property '" + this.parts_.join('.') + "'";
    };
    return ValidationPath;
}());




/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = React;

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = setNodeFromJSON;
/* harmony export (immutable) */ __webpack_exports__["c"] = setMaxNode;
/* unused harmony export PriorityIndex */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PRIORITY_INDEX; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Index__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Node__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__LeafNode__ = __webpack_require__(19);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var nodeFromJSON;
var MAX_NODE;
function setNodeFromJSON(val) {
    nodeFromJSON = val;
}
function setMaxNode(val) {
    MAX_NODE = val;
}
/**
 * @constructor
 * @extends {Index}
 * @private
 */
var PriorityIndex = /** @class */ (function (_super) {
    __extends(PriorityIndex, _super);
    function PriorityIndex() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @inheritDoc
     */
    PriorityIndex.prototype.compare = function (a, b) {
        var aPriority = a.node.getPriority();
        var bPriority = b.node.getPriority();
        var indexCmp = aPriority.compareTo(bPriority);
        if (indexCmp === 0) {
            return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_util__["p" /* nameCompare */])(a.name, b.name);
        }
        else {
            return indexCmp;
        }
    };
    /**
     * @inheritDoc
     */
    PriorityIndex.prototype.isDefinedOn = function (node) {
        return !node.getPriority().isEmpty();
    };
    /**
     * @inheritDoc
     */
    PriorityIndex.prototype.indexedValueChanged = function (oldNode, newNode) {
        return !oldNode.getPriority().equals(newNode.getPriority());
    };
    /**
     * @inheritDoc
     */
    PriorityIndex.prototype.minPost = function () {
        return __WEBPACK_IMPORTED_MODULE_2__Node__["a" /* NamedNode */].MIN;
    };
    /**
     * @inheritDoc
     */
    PriorityIndex.prototype.maxPost = function () {
        return new __WEBPACK_IMPORTED_MODULE_2__Node__["a" /* NamedNode */](__WEBPACK_IMPORTED_MODULE_1__util_util__["u" /* MAX_NAME */], new __WEBPACK_IMPORTED_MODULE_3__LeafNode__["a" /* LeafNode */]('[PRIORITY-POST]', MAX_NODE));
    };
    /**
     * @param {*} indexValue
     * @param {string} name
     * @return {!NamedNode}
     */
    PriorityIndex.prototype.makePost = function (indexValue, name) {
        var priorityNode = nodeFromJSON(indexValue);
        return new __WEBPACK_IMPORTED_MODULE_2__Node__["a" /* NamedNode */](name, new __WEBPACK_IMPORTED_MODULE_3__LeafNode__["a" /* LeafNode */]('[PRIORITY-POST]', priorityNode));
    };
    /**
     * @return {!string} String representation for inclusion in a query spec
     */
    PriorityIndex.prototype.toString = function () {
        return '.priority';
    };
    return PriorityIndex;
}(__WEBPACK_IMPORTED_MODULE_0__Index__["a" /* Index */]));

var PRIORITY_INDEX = new PriorityIndex();



/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(139);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_firebase_app__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_firebase_app___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_firebase_app__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_varyd_utils__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__LoginView__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Sidebar__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__TrackView__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__EvaluateView__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__CustomizeView__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__SettingsView__ = __webpack_require__(76);

// Imports















// Constants


// Class

class App extends __WEBPACK_IMPORTED_MODULE_0_react__["Component"] {

  // Constructor

  constructor() {

    super();

    this.handleModeChange = newMode => {

      this.setState({
        mode: newMode
      });
    };

    this.handleGoogleLoginClick = () => {

      var provider = new __WEBPACK_IMPORTED_MODULE_2_firebase_app___default.a.auth.GoogleAuthProvider();

      __WEBPACK_IMPORTED_MODULE_2_firebase_app___default.a.auth().signInWithRedirect(provider).then(result => console.log(result)).catch(error => console.log(error));
    };

    this.handleAnonymousLoginClick = () => {

      __WEBPACK_IMPORTED_MODULE_2_firebase_app___default.a.auth().signInAnonymously().catch(error => {
        console.log(error);
      });
    };

    this.initState();
    this.initFirebase();
  }

  initState() {

    this.state = {
      user: undefined,
      mode: 'track'
    };
  }
  initFirebase() {

    this.unsubscribeAuth = __WEBPACK_IMPORTED_MODULE_2_firebase_app___default.a.auth().onAuthStateChanged(user => {
      this.setState({
        user: user
      });
    });
  }

  // Event handlers

  // Methods


  // React

  componentWillUnmount() {

    if (this.unsubscribeAuth) {
      this.unsubscribeAuth();
    }
  }

  render() {

    if (!this.state.user) return __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](__WEBPACK_IMPORTED_MODULE_4__LoginView__["a" /* default */], {
      onGoogleLoginClick: this.handleGoogleLoginClick,
      onAnonymousLoginClick: this.handleAnonymousLoginClick });

    const isTrack = this.state.mode === 'track',
          isEvaluate = this.state.mode === 'evaluate',
          isCustomize = this.state.mode === 'customize',
          isSettings = this.state.mode === 'settings';

    return __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
      'div',
      {
        className: 'wrap-all' },
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](__WEBPACK_IMPORTED_MODULE_5__Sidebar__["a" /* default */], {
        mode: this.state.mode,
        onModeChange: this.handleModeChange }),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'main',
        null,
        isTrack && __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](__WEBPACK_IMPORTED_MODULE_6__TrackView__["a" /* default */], null),
        isEvaluate && __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](__WEBPACK_IMPORTED_MODULE_7__EvaluateView__["a" /* default */], null),
        isCustomize && __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](__WEBPACK_IMPORTED_MODULE_8__CustomizeView__["a" /* default */], null),
        isSettings && __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](__WEBPACK_IMPORTED_MODULE_9__SettingsView__["a" /* default */], null)
      )
    );
  }

}
/* harmony export (immutable) */ __webpack_exports__["a"] = App;


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ChildrenNode; });
/* unused harmony export MaxNode */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return MAX_NODE; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_SortedMap__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Node__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__snap__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__indexes_PriorityIndex__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__indexes_KeyIndex__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__IndexMap__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__LeafNode__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__comparators__ = __webpack_require__(46);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();










// TODO: For memory savings, don't store priorityNode_ if it's empty.
var EMPTY_NODE;
/**
 * ChildrenNode is a class for storing internal nodes in a DataSnapshot
 * (i.e. nodes with children).  It implements Node and stores the
 * list of children in the children property, sorted by child name.
 *
 * @constructor
 * @implements {Node}
 */
var ChildrenNode = /** @class */ (function () {
    /**
     *
     * @param {!SortedMap.<string, !Node>} children_ List of children
     * of this node..
     * @param {?Node} priorityNode_ The priority of this node (as a snapshot node).
     * @param {!IndexMap} indexMap_
     */
    function ChildrenNode(children_, priorityNode_, indexMap_) {
        this.children_ = children_;
        this.priorityNode_ = priorityNode_;
        this.indexMap_ = indexMap_;
        this.lazyHash_ = null;
        /**
         * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use
         * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own
         * class instead of an empty ChildrenNode.
         */
        if (this.priorityNode_) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__snap__["a" /* validatePriorityNode */])(this.priorityNode_);
        }
        if (this.children_.isEmpty()) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(!this.priorityNode_ || this.priorityNode_.isEmpty(), 'An empty node cannot have a priority');
        }
    }
    Object.defineProperty(ChildrenNode, "EMPTY_NODE", {
        get: function () {
            return (EMPTY_NODE ||
                (EMPTY_NODE = new ChildrenNode(new __WEBPACK_IMPORTED_MODULE_2__util_SortedMap__["b" /* SortedMap */](__WEBPACK_IMPORTED_MODULE_9__comparators__["b" /* NAME_COMPARATOR */]), null, __WEBPACK_IMPORTED_MODULE_7__IndexMap__["a" /* IndexMap */].Default)));
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritDoc */
    ChildrenNode.prototype.isLeafNode = function () {
        return false;
    };
    /** @inheritDoc */
    ChildrenNode.prototype.getPriority = function () {
        return this.priorityNode_ || EMPTY_NODE;
    };
    /** @inheritDoc */
    ChildrenNode.prototype.updatePriority = function (newPriorityNode) {
        if (this.children_.isEmpty()) {
            // Don't allow priorities on empty nodes
            return this;
        }
        else {
            return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.getImmediateChild = function (childName) {
        // Hack to treat priority as a regular child
        if (childName === '.priority') {
            return this.getPriority();
        }
        else {
            var child = this.children_.get(childName);
            return child === null ? EMPTY_NODE : child;
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.getChild = function (path) {
        var front = path.getFront();
        if (front === null)
            return this;
        return this.getImmediateChild(front).getChild(path.popFront());
    };
    /** @inheritDoc */
    ChildrenNode.prototype.hasChild = function (childName) {
        return this.children_.get(childName) !== null;
    };
    /** @inheritDoc */
    ChildrenNode.prototype.updateImmediateChild = function (childName, newChildNode) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(newChildNode, 'We should always be passing snapshot nodes');
        if (childName === '.priority') {
            return this.updatePriority(newChildNode);
        }
        else {
            var namedNode = new __WEBPACK_IMPORTED_MODULE_3__Node__["a" /* NamedNode */](childName, newChildNode);
            var newChildren = void 0, newIndexMap = void 0, newPriority = void 0;
            if (newChildNode.isEmpty()) {
                newChildren = this.children_.remove(childName);
                newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);
            }
            else {
                newChildren = this.children_.insert(childName, newChildNode);
                newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);
            }
            newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;
            return new ChildrenNode(newChildren, newPriority, newIndexMap);
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.updateChild = function (path, newChildNode) {
        var front = path.getFront();
        if (front === null) {
            return newChildNode;
        }
        else {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(path.getFront() !== '.priority' || path.getLength() === 1, '.priority must be the last token in a path');
            var newImmediateChild = this.getImmediateChild(front).updateChild(path.popFront(), newChildNode);
            return this.updateImmediateChild(front, newImmediateChild);
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.isEmpty = function () {
        return this.children_.isEmpty();
    };
    /** @inheritDoc */
    ChildrenNode.prototype.numChildren = function () {
        return this.children_.count();
    };
    /** @inheritDoc */
    ChildrenNode.prototype.val = function (exportFormat) {
        if (this.isEmpty())
            return null;
        var obj = {};
        var numKeys = 0, maxKey = 0, allIntegerKeys = true;
        this.forEachChild(__WEBPACK_IMPORTED_MODULE_5__indexes_PriorityIndex__["a" /* PRIORITY_INDEX */], function (key, childNode) {
            obj[key] = childNode.val(exportFormat);
            numKeys++;
            if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {
                maxKey = Math.max(maxKey, Number(key));
            }
            else {
                allIntegerKeys = false;
            }
        });
        if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {
            // convert to array.
            var array = [];
            for (var key in obj)
                array[key] = obj[key];
            return array;
        }
        else {
            if (exportFormat && !this.getPriority().isEmpty()) {
                obj['.priority'] = this.getPriority().val();
            }
            return obj;
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.hash = function () {
        if (this.lazyHash_ === null) {
            var toHash_1 = '';
            if (!this.getPriority().isEmpty())
                toHash_1 +=
                    'priority:' +
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__snap__["b" /* priorityHashText */])(this.getPriority().val()) +
                        ':';
            this.forEachChild(__WEBPACK_IMPORTED_MODULE_5__indexes_PriorityIndex__["a" /* PRIORITY_INDEX */], function (key, childNode) {
                var childHash = childNode.hash();
                if (childHash !== '')
                    toHash_1 += ':' + key + ':' + childHash;
            });
            this.lazyHash_ = toHash_1 === '' ? '' : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_util__["x" /* sha1 */])(toHash_1);
        }
        return this.lazyHash_;
    };
    /** @inheritDoc */
    ChildrenNode.prototype.getPredecessorChildName = function (childName, childNode, index) {
        var idx = this.resolveIndex_(index);
        if (idx) {
            var predecessor = idx.getPredecessorKey(new __WEBPACK_IMPORTED_MODULE_3__Node__["a" /* NamedNode */](childName, childNode));
            return predecessor ? predecessor.name : null;
        }
        else {
            return this.children_.getPredecessorKey(childName);
        }
    };
    /**
     * @param {!Index} indexDefinition
     * @return {?string}
     */
    ChildrenNode.prototype.getFirstChildName = function (indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            var minKey = idx.minKey();
            return minKey && minKey.name;
        }
        else {
            return this.children_.minKey();
        }
    };
    /**
     * @param {!Index} indexDefinition
     * @return {?NamedNode}
     */
    ChildrenNode.prototype.getFirstChild = function (indexDefinition) {
        var minKey = this.getFirstChildName(indexDefinition);
        if (minKey) {
            return new __WEBPACK_IMPORTED_MODULE_3__Node__["a" /* NamedNode */](minKey, this.children_.get(minKey));
        }
        else {
            return null;
        }
    };
    /**
     * Given an index, return the key name of the largest value we have, according to that index
     * @param {!Index} indexDefinition
     * @return {?string}
     */
    ChildrenNode.prototype.getLastChildName = function (indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            var maxKey = idx.maxKey();
            return maxKey && maxKey.name;
        }
        else {
            return this.children_.maxKey();
        }
    };
    /**
     * @param {!Index} indexDefinition
     * @return {?NamedNode}
     */
    ChildrenNode.prototype.getLastChild = function (indexDefinition) {
        var maxKey = this.getLastChildName(indexDefinition);
        if (maxKey) {
            return new __WEBPACK_IMPORTED_MODULE_3__Node__["a" /* NamedNode */](maxKey, this.children_.get(maxKey));
        }
        else {
            return null;
        }
    };
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.forEachChild = function (index, action) {
        var idx = this.resolveIndex_(index);
        if (idx) {
            return idx.inorderTraversal(function (wrappedNode) {
                return action(wrappedNode.name, wrappedNode.node);
            });
        }
        else {
            return this.children_.inorderTraversal(action);
        }
    };
    /**
     * @param {!Index} indexDefinition
     * @return {SortedMapIterator}
     */
    ChildrenNode.prototype.getIterator = function (indexDefinition) {
        return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);
    };
    /**
     *
     * @param {!NamedNode} startPost
     * @param {!Index} indexDefinition
     * @return {!SortedMapIterator}
     */
    ChildrenNode.prototype.getIteratorFrom = function (startPost, indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            return idx.getIteratorFrom(startPost, function (key) { return key; });
        }
        else {
            var iterator = this.children_.getIteratorFrom(startPost.name, __WEBPACK_IMPORTED_MODULE_3__Node__["a" /* NamedNode */].Wrap);
            var next = iterator.peek();
            while (next != null && indexDefinition.compare(next, startPost) < 0) {
                iterator.getNext();
                next = iterator.peek();
            }
            return iterator;
        }
    };
    /**
     * @param {!Index} indexDefinition
     * @return {!SortedMapIterator}
     */
    ChildrenNode.prototype.getReverseIterator = function (indexDefinition) {
        return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);
    };
    /**
     * @param {!NamedNode} endPost
     * @param {!Index} indexDefinition
     * @return {!SortedMapIterator}
     */
    ChildrenNode.prototype.getReverseIteratorFrom = function (endPost, indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            return idx.getReverseIteratorFrom(endPost, function (key) {
                return key;
            });
        }
        else {
            var iterator = this.children_.getReverseIteratorFrom(endPost.name, __WEBPACK_IMPORTED_MODULE_3__Node__["a" /* NamedNode */].Wrap);
            var next = iterator.peek();
            while (next != null && indexDefinition.compare(next, endPost) > 0) {
                iterator.getNext();
                next = iterator.peek();
            }
            return iterator;
        }
    };
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.compareTo = function (other) {
        if (this.isEmpty()) {
            if (other.isEmpty()) {
                return 0;
            }
            else {
                return -1;
            }
        }
        else if (other.isLeafNode() || other.isEmpty()) {
            return 1;
        }
        else if (other === MAX_NODE) {
            return -1;
        }
        else {
            // Must be another node with children.
            return 0;
        }
    };
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.withIndex = function (indexDefinition) {
        if (indexDefinition === __WEBPACK_IMPORTED_MODULE_6__indexes_KeyIndex__["a" /* KEY_INDEX */] ||
            this.indexMap_.hasIndex(indexDefinition)) {
            return this;
        }
        else {
            var newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);
            return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);
        }
    };
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.isIndexed = function (index) {
        return index === __WEBPACK_IMPORTED_MODULE_6__indexes_KeyIndex__["a" /* KEY_INDEX */] || this.indexMap_.hasIndex(index);
    };
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        else if (other.isLeafNode()) {
            return false;
        }
        else {
            var otherChildrenNode = other;
            if (!this.getPriority().equals(otherChildrenNode.getPriority())) {
                return false;
            }
            else if (this.children_.count() === otherChildrenNode.children_.count()) {
                var thisIter = this.getIterator(__WEBPACK_IMPORTED_MODULE_5__indexes_PriorityIndex__["a" /* PRIORITY_INDEX */]);
                var otherIter = otherChildrenNode.getIterator(__WEBPACK_IMPORTED_MODULE_5__indexes_PriorityIndex__["a" /* PRIORITY_INDEX */]);
                var thisCurrent = thisIter.getNext();
                var otherCurrent = otherIter.getNext();
                while (thisCurrent && otherCurrent) {
                    if (thisCurrent.name !== otherCurrent.name ||
                        !thisCurrent.node.equals(otherCurrent.node)) {
                        return false;
                    }
                    thisCurrent = thisIter.getNext();
                    otherCurrent = otherIter.getNext();
                }
                return thisCurrent === null && otherCurrent === null;
            }
            else {
                return false;
            }
        }
    };
    /**
     * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used
     * instead.
     *
     * @private
     * @param {!Index} indexDefinition
     * @return {?SortedMap.<NamedNode, Node>}
     */
    ChildrenNode.prototype.resolveIndex_ = function (indexDefinition) {
        if (indexDefinition === __WEBPACK_IMPORTED_MODULE_6__indexes_KeyIndex__["a" /* KEY_INDEX */]) {
            return null;
        }
        else {
            return this.indexMap_.get(indexDefinition.toString());
        }
    };
    /**
     * @private
     * @type {RegExp}
     */
    ChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
    return ChildrenNode;
}());

/**
 * @constructor
 * @extends {ChildrenNode}
 * @private
 */
var MaxNode = /** @class */ (function (_super) {
    __extends(MaxNode, _super);
    function MaxNode() {
        return _super.call(this, new __WEBPACK_IMPORTED_MODULE_2__util_SortedMap__["b" /* SortedMap */](__WEBPACK_IMPORTED_MODULE_9__comparators__["b" /* NAME_COMPARATOR */]), ChildrenNode.EMPTY_NODE, __WEBPACK_IMPORTED_MODULE_7__IndexMap__["a" /* IndexMap */].Default) || this;
    }
    MaxNode.prototype.compareTo = function (other) {
        if (other === this) {
            return 0;
        }
        else {
            return 1;
        }
    };
    MaxNode.prototype.equals = function (other) {
        // Not that we every compare it, but MAX_NODE is only ever equal to itself
        return other === this;
    };
    MaxNode.prototype.getPriority = function () {
        return this;
    };
    MaxNode.prototype.getImmediateChild = function (childName) {
        return ChildrenNode.EMPTY_NODE;
    };
    MaxNode.prototype.isEmpty = function () {
        return false;
    };
    return MaxNode;
}(ChildrenNode));

/**
 * Marker that will sort higher than any other snapshot.
 * @type {!MAX_NODE}
 * @const
 */
var MAX_NODE = new MaxNode();
Object.defineProperties(__WEBPACK_IMPORTED_MODULE_3__Node__["a" /* NamedNode */], {
    MIN: {
        value: new __WEBPACK_IMPORTED_MODULE_3__Node__["a" /* NamedNode */](__WEBPACK_IMPORTED_MODULE_1__util_util__["v" /* MIN_NAME */], ChildrenNode.EMPTY_NODE)
    },
    MAX: {
        value: new __WEBPACK_IMPORTED_MODULE_3__Node__["a" /* NamedNode */](__WEBPACK_IMPORTED_MODULE_1__util_util__["u" /* MAX_NAME */], MAX_NODE)
    }
});
/**
 * Reference Extensions
 */
__WEBPACK_IMPORTED_MODULE_6__indexes_KeyIndex__["b" /* KeyIndex */].__EMPTY_NODE = ChildrenNode.EMPTY_NODE;
__WEBPACK_IMPORTED_MODULE_8__LeafNode__["a" /* LeafNode */].__childrenNodeConstructor = ChildrenNode;
__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__snap__["c" /* setMaxNode */])(MAX_NODE);
__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__indexes_PriorityIndex__["c" /* setMaxNode */])(MAX_NODE);



/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NamedNode; });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *
 * @param {!string} name
 * @param {!Node} node
 * @constructor
 * @struct
 */
var NamedNode = /** @class */ (function () {
    function NamedNode(name, node) {
        this.name = name;
        this.node = node;
    }
    /**
     *
     * @param {!string} name
     * @param {!Node} node
     * @return {NamedNode}
     */
    NamedNode.Wrap = function (name, node) {
        return new NamedNode(name, node);
    };
    return NamedNode;
}());




/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return classNames;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return OperationType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OperationSource; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 *
 * @enum
 */
var OperationType;
(function (OperationType) {
    OperationType[OperationType["OVERWRITE"] = 0] = "OVERWRITE";
    OperationType[OperationType["MERGE"] = 1] = "MERGE";
    OperationType[OperationType["ACK_USER_WRITE"] = 2] = "ACK_USER_WRITE";
    OperationType[OperationType["LISTEN_COMPLETE"] = 3] = "LISTEN_COMPLETE";
})(OperationType = OperationType || (OperationType = {}));
/**
 * @param {boolean} fromUser
 * @param {boolean} fromServer
 * @param {?string} queryId
 * @param {boolean} tagged
 * @constructor
 */
var OperationSource = /** @class */ (function () {
    function OperationSource(fromUser, fromServer, queryId, tagged) {
        this.fromUser = fromUser;
        this.fromServer = fromServer;
        this.queryId = queryId;
        this.tagged = tagged;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(!tagged || fromServer, 'Tagged queries must be from server.');
    }
    /**
     * @const
     * @type {!OperationSource}
     */
    OperationSource.User = new OperationSource(
    /*fromUser=*/ true, false, null, 
    /*tagged=*/ false);
    /**
     * @const
     * @type {!OperationSource}
     */
    OperationSource.Server = new OperationSource(false, 
    /*fromServer=*/ true, null, 
    /*tagged=*/ false);
    /**
     * @param {string} queryId
     * @return {!OperationSource}
     */
    OperationSource.forServerTaggedQuery = function (queryId) {
        return new OperationSource(false, 
        /*fromServer=*/ true, queryId, 
        /*tagged=*/ true);
    };
    return OperationSource;
}());




/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export INVALID_KEY_REGEX_ */
/* unused harmony export INVALID_PATH_REGEX_ */
/* unused harmony export MAX_LEAF_SIZE_ */
/* unused harmony export isValidKey */
/* unused harmony export isValidPathString */
/* unused harmony export isValidRootPathString */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isValidPriority; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return validateFirebaseDataArg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return validateFirebaseData; });
/* unused harmony export validateFirebaseMergePaths */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return validateFirebaseMergeDataArg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return validatePriority; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return validateEventType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return validateKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return validatePathString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return validateRootPathString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return validateWritablePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return validateUrl; });
/* unused harmony export validateCredential */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return validateBoolean; });
/* unused harmony export validateString */
/* unused harmony export validateObject */
/* unused harmony export validateObjectContainsKey */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util__ = __webpack_require__(1);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * True for invalid Firebase keys
 * @type {RegExp}
 * @private
 */
var INVALID_KEY_REGEX_ = /[\[\].#$\/\u0000-\u001F\u007F]/;
/**
 * True for invalid Firebase paths.
 * Allows '/' in paths.
 * @type {RegExp}
 * @private
 */
var INVALID_PATH_REGEX_ = /[\[\].#$\u0000-\u001F\u007F]/;
/**
 * Maximum number of characters to allow in leaf value
 * @type {number}
 * @private
 */
var MAX_LEAF_SIZE_ = 10 * 1024 * 1024;
/**
 * @param {*} key
 * @return {boolean}
 */
var isValidKey = function (key) {
    return (typeof key === 'string' && key.length !== 0 && !INVALID_KEY_REGEX_.test(key));
};
/**
 * @param {string} pathString
 * @return {boolean}
 */
var isValidPathString = function (pathString) {
    return (typeof pathString === 'string' &&
        pathString.length !== 0 &&
        !INVALID_PATH_REGEX_.test(pathString));
};
/**
 * @param {string} pathString
 * @return {boolean}
 */
var isValidRootPathString = function (pathString) {
    if (pathString) {
        // Allow '/.info/' at the beginning.
        pathString = pathString.replace(/^\/*\.info(\/|$)/, '/');
    }
    return isValidPathString(pathString);
};
/**
 * @param {*} priority
 * @return {boolean}
 */
var isValidPriority = function (priority) {
    return (priority === null ||
        typeof priority === 'string' ||
        (typeof priority === 'number' && !__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["r" /* isInvalidJSONNumber */])(priority)) ||
        (priority && typeof priority === 'object' && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["i" /* contains */])(priority, '.sv')));
};
/**
 * Pre-validate a datum passed as an argument to Firebase function.
 *
 * @param {string} fnName
 * @param {number} argumentNumber
 * @param {*} data
 * @param {!Path} path
 * @param {boolean} optional
 */
var validateFirebaseDataArg = function (fnName, argumentNumber, data, path, optional) {
    if (optional && data === undefined)
        return;
    validateFirebaseData(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["z" /* errorPrefix */])(fnName, argumentNumber, optional), data, path);
};
/**
 * Validate a data object client-side before sending to server.
 *
 * @param {string} errorPrefix
 * @param {*} data
 * @param {!Path|!ValidationPath} path_
 */
var validateFirebaseData = function (errorPrefix, data, path_) {
    var path = path_ instanceof __WEBPACK_IMPORTED_MODULE_0__Path__["a" /* Path */] ? new __WEBPACK_IMPORTED_MODULE_0__Path__["b" /* ValidationPath */](path_, errorPrefix) : path_;
    if (data === undefined) {
        throw new Error(errorPrefix + 'contains undefined ' + path.toErrorString());
    }
    if (typeof data === 'function') {
        throw new Error(errorPrefix +
            'contains a function ' +
            path.toErrorString() +
            ' with contents = ' +
            data.toString());
    }
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["r" /* isInvalidJSONNumber */])(data)) {
        throw new Error(errorPrefix + 'contains ' + data.toString() + ' ' + path.toErrorString());
    }
    // Check max leaf size, but try to avoid the utf8 conversion if we can.
    if (typeof data === 'string' &&
        data.length > MAX_LEAF_SIZE_ / 3 &&
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["x" /* stringLength */])(data) > MAX_LEAF_SIZE_) {
        throw new Error(errorPrefix +
            'contains a string greater than ' +
            MAX_LEAF_SIZE_ +
            ' utf8 bytes ' +
            path.toErrorString() +
            " ('" +
            data.substring(0, 50) +
            "...')");
    }
    // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON
    // to save extra walking of large objects.
    if (data && typeof data === 'object') {
        var hasDotValue_1 = false, hasActualChild_1 = false;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["h" /* forEach */])(data, function (key, value) {
            if (key === '.value') {
                hasDotValue_1 = true;
            }
            else if (key !== '.priority' && key !== '.sv') {
                hasActualChild_1 = true;
                if (!isValidKey(key)) {
                    throw new Error(errorPrefix +
                        ' contains an invalid key (' +
                        key +
                        ') ' +
                        path.toErrorString() +
                        '.  Keys must be non-empty strings ' +
                        'and can\'t contain ".", "#", "$", "/", "[", or "]"');
                }
            }
            path.push(key);
            validateFirebaseData(errorPrefix, value, path);
            path.pop();
        });
        if (hasDotValue_1 && hasActualChild_1) {
            throw new Error(errorPrefix +
                ' contains ".value" child ' +
                path.toErrorString() +
                ' in addition to actual children.');
        }
    }
};
/**
 * Pre-validate paths passed in the firebase function.
 *
 * @param {string} errorPrefix
 * @param {Array<!Path>} mergePaths
 */
var validateFirebaseMergePaths = function (errorPrefix, mergePaths) {
    var i, curPath;
    for (i = 0; i < mergePaths.length; i++) {
        curPath = mergePaths[i];
        var keys = curPath.slice();
        for (var j = 0; j < keys.length; j++) {
            if (keys[j] === '.priority' && j === keys.length - 1) {
                // .priority is OK
            }
            else if (!isValidKey(keys[j])) {
                throw new Error(errorPrefix +
                    'contains an invalid key (' +
                    keys[j] +
                    ') in path ' +
                    curPath.toString() +
                    '. Keys must be non-empty strings ' +
                    'and can\'t contain ".", "#", "$", "/", "[", or "]"');
            }
        }
    }
    // Check that update keys are not descendants of each other.
    // We rely on the property that sorting guarantees that ancestors come
    // right before descendants.
    mergePaths.sort(__WEBPACK_IMPORTED_MODULE_0__Path__["a" /* Path */].comparePaths);
    var prevPath = null;
    for (i = 0; i < mergePaths.length; i++) {
        curPath = mergePaths[i];
        if (prevPath !== null && prevPath.contains(curPath)) {
            throw new Error(errorPrefix +
                'contains a path ' +
                prevPath.toString() +
                ' that is ancestor of another path ' +
                curPath.toString());
        }
        prevPath = curPath;
    }
};
/**
 * pre-validate an object passed as an argument to firebase function (
 * must be an object - e.g. for firebase.update()).
 *
 * @param {string} fnName
 * @param {number} argumentNumber
 * @param {*} data
 * @param {!Path} path
 * @param {boolean} optional
 */
var validateFirebaseMergeDataArg = function (fnName, argumentNumber, data, path, optional) {
    if (optional && data === undefined)
        return;
    var errorPrefix = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["z" /* errorPrefix */])(fnName, argumentNumber, optional);
    if (!(data && typeof data === 'object') || Array.isArray(data)) {
        throw new Error(errorPrefix + ' must be an object containing the children to replace.');
    }
    var mergePaths = [];
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["h" /* forEach */])(data, function (key, value) {
        var curPath = new __WEBPACK_IMPORTED_MODULE_0__Path__["a" /* Path */](key);
        validateFirebaseData(errorPrefix, value, path.child(curPath));
        if (curPath.getBack() === '.priority') {
            if (!isValidPriority(value)) {
                throw new Error(errorPrefix +
                    "contains an invalid value for '" +
                    curPath.toString() +
                    "', which must be a valid " +
                    'Firebase priority (a string, finite number, server value, or null).');
            }
        }
        mergePaths.push(curPath);
    });
    validateFirebaseMergePaths(errorPrefix, mergePaths);
};
var validatePriority = function (fnName, argumentNumber, priority, optional) {
    if (optional && priority === undefined)
        return;
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["r" /* isInvalidJSONNumber */])(priority))
        throw new Error(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["z" /* errorPrefix */])(fnName, argumentNumber, optional) +
            'is ' +
            priority.toString() +
            ', but must be a valid Firebase priority (a string, finite number, ' +
            'server value, or null).');
    // Special case to allow importing data with a .sv.
    if (!isValidPriority(priority))
        throw new Error(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["z" /* errorPrefix */])(fnName, argumentNumber, optional) +
            'must be a valid Firebase priority ' +
            '(a string, finite number, server value, or null).');
};
var validateEventType = function (fnName, argumentNumber, eventType, optional) {
    if (optional && eventType === undefined)
        return;
    switch (eventType) {
        case 'value':
        case 'child_added':
        case 'child_removed':
        case 'child_changed':
        case 'child_moved':
            break;
        default:
            throw new Error(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["z" /* errorPrefix */])(fnName, argumentNumber, optional) +
                'must be a valid event type = "value", "child_added", "child_removed", ' +
                '"child_changed", or "child_moved".');
    }
};
var validateKey = function (fnName, argumentNumber, key, optional) {
    if (optional && key === undefined)
        return;
    if (!isValidKey(key))
        throw new Error(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["z" /* errorPrefix */])(fnName, argumentNumber, optional) +
            'was an invalid key = "' +
            key +
            '".  Firebase keys must be non-empty strings and ' +
            'can\'t contain ".", "#", "$", "/", "[", or "]").');
};
var validatePathString = function (fnName, argumentNumber, pathString, optional) {
    if (optional && pathString === undefined)
        return;
    if (!isValidPathString(pathString))
        throw new Error(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["z" /* errorPrefix */])(fnName, argumentNumber, optional) +
            'was an invalid path = "' +
            pathString +
            '". Paths must be non-empty strings and ' +
            'can\'t contain ".", "#", "$", "[", or "]"');
};
var validateRootPathString = function (fnName, argumentNumber, pathString, optional) {
    if (pathString) {
        // Allow '/.info/' at the beginning.
        pathString = pathString.replace(/^\/*\.info(\/|$)/, '/');
    }
    validatePathString(fnName, argumentNumber, pathString, optional);
};
var validateWritablePath = function (fnName, path) {
    if (path.getFront() === '.info') {
        throw new Error(fnName + " failed = Can't modify data under /.info/");
    }
};
var validateUrl = function (fnName, argumentNumber, parsedUrl) {
    // TODO = Validate server better.
    var pathString = parsedUrl.path.toString();
    if (!(typeof parsedUrl.repoInfo.host === 'string') ||
        parsedUrl.repoInfo.host.length === 0 ||
        !isValidKey(parsedUrl.repoInfo.namespace) ||
        (pathString.length !== 0 && !isValidRootPathString(pathString))) {
        throw new Error(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["z" /* errorPrefix */])(fnName, argumentNumber, false) +
            'must be a valid firebase URL and ' +
            'the path can\'t contain ".", "#", "$", "[", or "]".');
    }
};
var validateCredential = function (fnName, argumentNumber, cred, optional) {
    if (optional && cred === undefined)
        return;
    if (!(typeof cred === 'string'))
        throw new Error(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["z" /* errorPrefix */])(fnName, argumentNumber, optional) +
            'must be a valid credential (a string).');
};
var validateBoolean = function (fnName, argumentNumber, bool, optional) {
    if (optional && bool === undefined)
        return;
    if (typeof bool !== 'boolean')
        throw new Error(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["z" /* errorPrefix */])(fnName, argumentNumber, optional) + 'must be a boolean.');
};
var validateString = function (fnName, argumentNumber, string, optional) {
    if (optional && string === undefined)
        return;
    if (!(typeof string === 'string')) {
        throw new Error(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["z" /* errorPrefix */])(fnName, argumentNumber, optional) +
            'must be a valid string.');
    }
};
var validateObject = function (fnName, argumentNumber, obj, optional) {
    if (optional && obj === undefined)
        return;
    if (!(obj && typeof obj === 'object') || obj === null) {
        throw new Error(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["z" /* errorPrefix */])(fnName, argumentNumber, optional) +
            'must be a valid object.');
    }
};
var validateObjectContainsKey = function (fnName, argumentNumber, obj, key, optional, opt_type) {
    var objectContainsKey = obj && typeof obj === 'object' && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["i" /* contains */])(obj, key);
    if (!objectContainsKey) {
        if (optional) {
            return;
        }
        else {
            throw new Error(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["z" /* errorPrefix */])(fnName, argumentNumber, optional) +
                'must contain the key "' +
                key +
                '"');
        }
    }
    if (opt_type) {
        var val = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["s" /* safeGet */])(obj, key);
        if ((opt_type === 'number' && !(typeof val === 'number')) ||
            (opt_type === 'string' && !(typeof val === 'string')) ||
            (opt_type === 'boolean' && !(typeof val === 'boolean')) ||
            (opt_type === 'function' && !(typeof val === 'function')) ||
            (opt_type === 'object' && !(typeof val === 'object') && val)) {
            if (optional) {
                throw new Error(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["z" /* errorPrefix */])(fnName, argumentNumber, optional) +
                    'contains invalid value for key "' +
                    key +
                    '" (must be of type "' +
                    opt_type +
                    '")');
            }
            else {
                throw new Error(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["z" /* errorPrefix */])(fnName, argumentNumber, optional) +
                    'must contain the key "' +
                    key +
                    '" with type "' +
                    opt_type +
                    '"');
            }
        }
    }
};



/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

__webpack_require__(123);
module.exports = __webpack_require__(14).default;


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Change; });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @constructor
 * @struct
 * @param {!string} type The event type
 * @param {!Node} snapshotNode The data
 * @param {string=} childName The name for this child, if it's a child event
 * @param {Node=} oldSnap Used for intermediate processing of child changed events
 * @param {string=} prevName The name for the previous child, if applicable
 */
var Change = /** @class */ (function () {
    function Change(type, snapshotNode, childName, oldSnap, prevName) {
        this.type = type;
        this.snapshotNode = snapshotNode;
        this.childName = childName;
        this.oldSnap = oldSnap;
        this.prevName = prevName;
    }
    /**
     * @param {!Node} snapshot
     * @return {!Change}
     */
    Change.valueChange = function (snapshot) {
        return new Change(Change.VALUE, snapshot);
    };
    /**
     * @param {string} childKey
     * @param {!Node} snapshot
     * @return {!Change}
     */
    Change.childAddedChange = function (childKey, snapshot) {
        return new Change(Change.CHILD_ADDED, snapshot, childKey);
    };
    /**
     * @param {string} childKey
     * @param {!Node} snapshot
     * @return {!Change}
     */
    Change.childRemovedChange = function (childKey, snapshot) {
        return new Change(Change.CHILD_REMOVED, snapshot, childKey);
    };
    /**
     * @param {string} childKey
     * @param {!Node} newSnapshot
     * @param {!Node} oldSnapshot
     * @return {!Change}
     */
    Change.childChangedChange = function (childKey, newSnapshot, oldSnapshot) {
        return new Change(Change.CHILD_CHANGED, newSnapshot, childKey, oldSnapshot);
    };
    /**
     * @param {string} childKey
     * @param {!Node} snapshot
     * @return {!Change}
     */
    Change.childMovedChange = function (childKey, snapshot) {
        return new Change(Change.CHILD_MOVED, snapshot, childKey);
    };
    //event types
    /** Event type for a child added */
    Change.CHILD_ADDED = 'child_added';
    /** Event type for a child removed */
    Change.CHILD_REMOVED = 'child_removed';
    /** Event type for a child changed */
    Change.CHILD_CHANGED = 'child_changed';
    /** Event type for a child moved */
    Change.CHILD_MOVED = 'child_moved';
    /** Event type for a value change */
    Change.VALUE = 'value';
    return Change;
}());




/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = num;
/* harmony export (immutable) */ __webpack_exports__["b"] = int;
/* harmony export (immutable) */ __webpack_exports__["d"] = boolean;
/* unused harmony export sign */
/* unused harmony export bit */
/* unused harmony export norm */
/* unused harmony export sort */
/* unused harmony export wiggle */
/* harmony export (immutable) */ __webpack_exports__["e"] = shuffle;
/* unused harmony export index */
/* harmony export (immutable) */ __webpack_exports__["f"] = item;
/* harmony export (immutable) */ __webpack_exports__["c"] = items;

// Get

function num(min = 1, max = NaN) {
  if (isNaN(max)) {
    max  = min;
    min  = 0;
  }
  return (Math.random() * (max - min)) + min;
}
function int(min, max = NaN) {
  if (isNaN(max)) {
    max  = min;
    min  = 0;
  }
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function boolean(chance = 0.5) {
  return (Math.random() < chance);
}
function sign(chance = 0.5) {
  return (Math.random() < chance) ? 1 : -1;
}
function bit(chance = 0.5) {
  return (Math.random() < chance) ? 1 : 0;
}

function norm(times = 2) {
  let sum  = 0;
  for (let i = 0; i < times; i++) {
    sum += Math.random();
  }
  return sum/times;
}

function sort(a, b) {
  return sign();
}

function wiggle(n, freedom) {
  return n + num(-freedom, freedom);
}


// Arrays

function shuffle(a, times = 5) {
  if (a.length <= 1) return a;
  let r  = a.slice();
  for (let i = 0; i < times; i++) {
    r.sort(sort);
  }
  return r;
}

function index(a) {
  return (a.length) ? int(a.length - 1) : -1;
}

function item(a) {
  return a[index(a)];
}
function items(a, count) {
  return shuffle(a).slice(0, count);
}


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "firebase", function() { return firebase; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_firebaseApp__ = __webpack_require__(86);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var firebase = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__src_firebaseApp__["a" /* createFirebaseNamespace */])();
/* harmony default export */ __webpack_exports__["default"] = (firebase);




/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return KeyIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return KEY_INDEX; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Index__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Node__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var __EMPTY_NODE;
var KeyIndex = /** @class */ (function (_super) {
    __extends(KeyIndex, _super);
    function KeyIndex() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(KeyIndex, "__EMPTY_NODE", {
        get: function () {
            return __EMPTY_NODE;
        },
        set: function (val) {
            __EMPTY_NODE = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    KeyIndex.prototype.compare = function (a, b) {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_util__["p" /* nameCompare */])(a.name, b.name);
    };
    /**
     * @inheritDoc
     */
    KeyIndex.prototype.isDefinedOn = function (node) {
        // We could probably return true here (since every node has a key), but it's never called
        // so just leaving unimplemented for now.
        throw __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__firebase_util__["C" /* assertionError */])('KeyIndex.isDefinedOn not expected to be called.');
    };
    /**
     * @inheritDoc
     */
    KeyIndex.prototype.indexedValueChanged = function (oldNode, newNode) {
        return false; // The key for a node never changes.
    };
    /**
     * @inheritDoc
     */
    KeyIndex.prototype.minPost = function () {
        return __WEBPACK_IMPORTED_MODULE_1__Node__["a" /* NamedNode */].MIN;
    };
    /**
     * @inheritDoc
     */
    KeyIndex.prototype.maxPost = function () {
        // TODO: This should really be created once and cached in a static property, but
        // NamedNode isn't defined yet, so I can't use it in a static.  Bleh.
        return new __WEBPACK_IMPORTED_MODULE_1__Node__["a" /* NamedNode */](__WEBPACK_IMPORTED_MODULE_2__util_util__["u" /* MAX_NAME */], __EMPTY_NODE);
    };
    /**
     * @param {*} indexValue
     * @param {string} name
     * @return {!NamedNode}
     */
    KeyIndex.prototype.makePost = function (indexValue, name) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__firebase_util__["g" /* assert */])(typeof indexValue === 'string', 'KeyIndex indexValue must always be a string.');
        // We just use empty node, but it'll never be compared, since our comparator only looks at name.
        return new __WEBPACK_IMPORTED_MODULE_1__Node__["a" /* NamedNode */](indexValue, __EMPTY_NODE);
    };
    /**
     * @return {!string} String representation for inclusion in a query spec
     */
    KeyIndex.prototype.toString = function () {
        return '.key';
    };
    return KeyIndex;
}(__WEBPACK_IMPORTED_MODULE_0__Index__["a" /* Index */]));

var KEY_INDEX = new KeyIndex();



/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = nodeFromJSON;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ChildrenNode__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__LeafNode__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Node__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__childSet__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__comparators__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__IndexMap__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__indexes_PriorityIndex__ = __webpack_require__(4);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









var USE_HINZE = true;
/**
 * Constructs a snapshot node representing the passed JSON and returns it.
 * @param {*} json JSON to create a node for.
 * @param {?string|?number=} priority Optional priority to use.  This will be ignored if the
 * passed JSON contains a .priority property.
 * @return {!Node}
 */
function nodeFromJSON(json, priority) {
    if (priority === void 0) { priority = null; }
    if (json === null) {
        return __WEBPACK_IMPORTED_MODULE_0__ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE;
    }
    if (typeof json === 'object' && '.priority' in json) {
        priority = json['.priority'];
    }
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__firebase_util__["g" /* assert */])(priority === null ||
        typeof priority === 'string' ||
        typeof priority === 'number' ||
        (typeof priority === 'object' && '.sv' in priority), 'Invalid priority type found: ' + typeof priority);
    if (typeof json === 'object' && '.value' in json && json['.value'] !== null) {
        json = json['.value'];
    }
    // Valid leaf nodes include non-objects or server-value wrapper objects
    if (typeof json !== 'object' || '.sv' in json) {
        var jsonLeaf = json;
        return new __WEBPACK_IMPORTED_MODULE_1__LeafNode__["a" /* LeafNode */](jsonLeaf, nodeFromJSON(priority));
    }
    if (!(json instanceof Array) && USE_HINZE) {
        var children_1 = [];
        var childrenHavePriority_1 = false;
        var hinzeJsonObj_1 = json;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__firebase_util__["h" /* forEach */])(hinzeJsonObj_1, function (key, child) {
            if (typeof key !== 'string' || key.substring(0, 1) !== '.') {
                // Ignore metadata nodes
                var childNode = nodeFromJSON(hinzeJsonObj_1[key]);
                if (!childNode.isEmpty()) {
                    childrenHavePriority_1 =
                        childrenHavePriority_1 || !childNode.getPriority().isEmpty();
                    children_1.push(new __WEBPACK_IMPORTED_MODULE_2__Node__["a" /* NamedNode */](key, childNode));
                }
            }
        });
        if (children_1.length == 0) {
            return __WEBPACK_IMPORTED_MODULE_0__ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE;
        }
        var childSet = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__childSet__["a" /* buildChildSet */])(children_1, __WEBPACK_IMPORTED_MODULE_5__comparators__["a" /* NAME_ONLY_COMPARATOR */], function (namedNode) { return namedNode.name; }, __WEBPACK_IMPORTED_MODULE_5__comparators__["b" /* NAME_COMPARATOR */]);
        if (childrenHavePriority_1) {
            var sortedChildSet = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__childSet__["a" /* buildChildSet */])(children_1, __WEBPACK_IMPORTED_MODULE_7__indexes_PriorityIndex__["a" /* PRIORITY_INDEX */].getCompare());
            return new __WEBPACK_IMPORTED_MODULE_0__ChildrenNode__["a" /* ChildrenNode */](childSet, nodeFromJSON(priority), new __WEBPACK_IMPORTED_MODULE_6__IndexMap__["a" /* IndexMap */]({ '.priority': sortedChildSet }, { '.priority': __WEBPACK_IMPORTED_MODULE_7__indexes_PriorityIndex__["a" /* PRIORITY_INDEX */] }));
        }
        else {
            return new __WEBPACK_IMPORTED_MODULE_0__ChildrenNode__["a" /* ChildrenNode */](childSet, nodeFromJSON(priority), __WEBPACK_IMPORTED_MODULE_6__IndexMap__["a" /* IndexMap */].Default);
        }
    }
    else {
        var node_1 = __WEBPACK_IMPORTED_MODULE_0__ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE;
        var jsonObj_1 = json;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__firebase_util__["h" /* forEach */])(jsonObj_1, function (key, childData) {
            if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__firebase_util__["i" /* contains */])(jsonObj_1, key)) {
                if (key.substring(0, 1) !== '.') {
                    // ignore metadata nodes.
                    var childNode = nodeFromJSON(childData);
                    if (childNode.isLeafNode() || !childNode.isEmpty())
                        node_1 = node_1.updateImmediateChild(key, childNode);
                }
            }
        });
        return node_1.updatePriority(nodeFromJSON(priority));
    }
}
__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__indexes_PriorityIndex__["b" /* setNodeFromJSON */])(nodeFromJSON);



/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = lerp;
/* unused harmony export coserp */
/* harmony export (immutable) */ __webpack_exports__["d"] = norm;
/* harmony export (immutable) */ __webpack_exports__["e"] = map;
/* unused harmony export uniToBi */
/* unused harmony export biToUni */
/* harmony export (immutable) */ __webpack_exports__["i"] = nextWithin;
/* harmony export (immutable) */ __webpack_exports__["j"] = prevWithin;
/* unused harmony export addWithin */
/* unused harmony export subtractWithin */
/* harmony export (immutable) */ __webpack_exports__["g"] = wrap;
/* harmony export (immutable) */ __webpack_exports__["h"] = wrapNum;
/* harmony export (immutable) */ __webpack_exports__["f"] = clamp;
/* unused harmony export sign */
/* unused harmony export roundTo */
/* unused harmony export diff */
/* unused harmony export avg */
/* unused harmony export ease */
/* harmony export (immutable) */ __webpack_exports__["c"] = isInt;
/* unused harmony export divisibleBy */

const TAO = Math.PI * 2;
/* harmony export (immutable) */ __webpack_exports__["a"] = TAO;



// 0.0 ... 1.0

function lerp(min, max, val = 0.5, doClamp = false) {
  if (doClamp) {
    return clamp((min * (1 - val)) + (max * val), min, max);
  } else {
    return (min * (1 - val)) + (max * val)
  }
}

function coserp(min, max, val = 0.5, doClamp = false) {
  if (doClamp) {
    return clamp(lerp(min, max, (1 - Math.cos(val * Math.PI)) / 2), min, max);
  } else {
    return lerp(min, max, (1 - Math.cos(val * Math.PI)) / 2);
  }
}

function norm(val, min, max, doClamp = false) {
  if (doClamp) {
    return clamp((val - min) / (max - min), 0, 1);
  } else {
    return (val - min) / (max - min);
  }
}

function map(val, min, max, tmin, tmax, doClamp = false) {
  return lerp(tmin, tmax, norm(val, min, max, doClamp));
}

function uniToBi(val) {
  return map(val, 0, 1, -1, 1);
}

function biToUni(val) {
  return norm(val, -1, 1);
}


// Loops & ranges

function nextWithin(num, min, max, doClamp = false) {
  if (doClamp) {
    return clamp(num + 1, min, max);
  } else {
    return addWithin(num, 1, min, max);
  }
}
function prevWithin(num, min, max, doClamp = false) {
  if (doClamp) {
    return clamp(num - 1, min, max);
  } else {
    return subtractWithin(num, 1, min, max);
  }
}

function addWithin(num, inc, min, max) {
  return wrap(num + inc, min, max);
}
function subtractWithin(num, sub, min, max) {
  return wrap(num - sub, min, max);
}

function wrap(num, min, max) {
  let r = max - min + 1,
      n = ((num - min) % r);
  if (n < 0) {
    return max + n + 1;
  } else {
    return min + n;
  }
}

function wrapNum(num, min = 0, max = 1) {
  if (num < min) {
    return max - (min - num) % (max - min);
  } else {
    return min + (num - min) % (max - min);
  }
}

function clamp(num, min = 0, max = 1) {
  if (min <= max) {
    return Math.max(min, Math.min(max, num));
  } else {
    return Math.min(max, Math.min(min, num));
  }
}


// Misc

function sign(n) {
  return (n > 0) ? 1 : ((n < 0) ? -1 : 0);
}

function roundTo(n, decimals) {
  let m = Math.pow(10, decimals);
  return Math.round(n * m) / m;
}

function diff(a, b) {
  return Math.abs(a - b);
}

function avg(...nums) {
  return nums.reduce((acc, cur, i) => (acc + cur)) / nums.length;
}

function ease(val, trgt, factor = 0.5, threshold = 1) {
  return (isNaN(val) || diff(val, trgt) < threshold) ? trgt : lerp(val, trgt, factor);
}

function isInt(val) {
  return val == Math.floor(val);
}

function divisibleBy(val, divisor) {
  return (val % divisor) === 0;
}


/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Repo; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_ServerValues__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__snap_nodeFromJSON__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__SparseSnapshotTree__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__SyncTree__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__SnapshotHolder__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__AuthTokenProvider__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__stats_StatsManager__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__stats_StatsReporter__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__stats_StatsListener__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__view_EventQueue__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__PersistentConnection__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__ReadonlyRestClient__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__api_Database__ = __webpack_require__(36);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

















var INTERRUPT_REASON = 'repo_interrupt';
/**
 * A connection to a single data repository.
 */
var Repo = /** @class */ (function () {
    /**
     * @param {!RepoInfo} repoInfo_
     * @param {boolean} forceRestClient
     * @param {!FirebaseApp} app
     */
    function Repo(repoInfo_, forceRestClient, app) {
        var _this = this;
        this.repoInfo_ = repoInfo_;
        this.app = app;
        this.dataUpdateCount = 0;
        this.statsListener_ = null;
        this.eventQueue_ = new __WEBPACK_IMPORTED_MODULE_12__view_EventQueue__["a" /* EventQueue */]();
        this.nextWriteId_ = 1;
        this.interceptServerDataCallback_ = null;
        // A list of data pieces and paths to be set when this client disconnects.
        this.onDisconnect_ = new __WEBPACK_IMPORTED_MODULE_3__SparseSnapshotTree__["a" /* SparseSnapshotTree */]();
        /**
         * TODO: This should be @private but it's used by test_access.js and internal.js
         * @type {?PersistentConnection}
         */
        this.persistentConnection_ = null;
        /** @type {!AuthTokenProvider} */
        var authTokenProvider = new __WEBPACK_IMPORTED_MODULE_8__AuthTokenProvider__["a" /* AuthTokenProvider */](app);
        this.stats_ = __WEBPACK_IMPORTED_MODULE_9__stats_StatsManager__["a" /* StatsManager */].getCollection(repoInfo_);
        if (forceRestClient || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__util_util__["t" /* beingCrawled */])()) {
            this.server_ = new __WEBPACK_IMPORTED_MODULE_14__ReadonlyRestClient__["a" /* ReadonlyRestClient */](this.repoInfo_, this.onDataUpdate_.bind(this), authTokenProvider);
            // Minor hack: Fire onConnect immediately, since there's no actual connection.
            setTimeout(this.onConnectStatus_.bind(this, true), 0);
        }
        else {
            var authOverride = app.options['databaseAuthVariableOverride'];
            // Validate authOverride
            if (typeof authOverride !== 'undefined' && authOverride !== null) {
                if (typeof authOverride !== 'object') {
                    throw new Error('Only objects are supported for option databaseAuthVariableOverride');
                }
                try {
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__firebase_util__["j" /* stringify */])(authOverride);
                }
                catch (e) {
                    throw new Error('Invalid authOverride provided: ' + e);
                }
            }
            this.persistentConnection_ = new __WEBPACK_IMPORTED_MODULE_13__PersistentConnection__["a" /* PersistentConnection */](this.repoInfo_, this.onDataUpdate_.bind(this), this.onConnectStatus_.bind(this), this.onServerInfoUpdate_.bind(this), authTokenProvider, authOverride);
            this.server_ = this.persistentConnection_;
        }
        authTokenProvider.addTokenChangeListener(function (token) {
            _this.server_.refreshAuthToken(token);
        });
        // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),
        // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.
        this.statsReporter_ = __WEBPACK_IMPORTED_MODULE_9__stats_StatsManager__["a" /* StatsManager */].getOrCreateReporter(repoInfo_, function () { return new __WEBPACK_IMPORTED_MODULE_10__stats_StatsReporter__["a" /* StatsReporter */](_this.stats_, _this.server_); });
        this.transactions_init_();
        // Used for .info.
        this.infoData_ = new __WEBPACK_IMPORTED_MODULE_5__SnapshotHolder__["a" /* SnapshotHolder */]();
        this.infoSyncTree_ = new __WEBPACK_IMPORTED_MODULE_4__SyncTree__["a" /* SyncTree */]({
            startListening: function (query, tag, currentHashFn, onComplete) {
                var infoEvents = [];
                var node = _this.infoData_.getNode(query.path);
                // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events
                // on initial data...
                if (!node.isEmpty()) {
                    infoEvents = _this.infoSyncTree_.applyServerOverwrite(query.path, node);
                    setTimeout(function () {
                        onComplete('ok');
                    }, 0);
                }
                return infoEvents;
            },
            stopListening: function () { }
        });
        this.updateInfo_('connected', false);
        this.serverSyncTree_ = new __WEBPACK_IMPORTED_MODULE_4__SyncTree__["a" /* SyncTree */]({
            startListening: function (query, tag, currentHashFn, onComplete) {
                _this.server_.listen(query, currentHashFn, tag, function (status, data) {
                    var events = onComplete(status, data);
                    _this.eventQueue_.raiseEventsForChangedPath(query.path, events);
                });
                // No synchronous events for network-backed sync trees
                return [];
            },
            stopListening: function (query, tag) {
                _this.server_.unlisten(query, tag);
            }
        });
    }
    /**
     * @return {string}  The URL corresponding to the root of this Firebase.
     */
    Repo.prototype.toString = function () {
        return ((this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host);
    };
    /**
     * @return {!string} The namespace represented by the repo.
     */
    Repo.prototype.name = function () {
        return this.repoInfo_.namespace;
    };
    /**
     * @return {!number} The time in milliseconds, taking the server offset into account if we have one.
     */
    Repo.prototype.serverTime = function () {
        var offsetNode = this.infoData_.getNode(new __WEBPACK_IMPORTED_MODULE_2__util_Path__["a" /* Path */]('.info/serverTimeOffset'));
        var offset = offsetNode.val() || 0;
        return new Date().getTime() + offset;
    };
    /**
     * Generate ServerValues using some variables from the repo object.
     * @return {!Object}
     */
    Repo.prototype.generateServerValues = function () {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util_ServerValues__["a" /* generateWithValues */])({
            timestamp: this.serverTime()
        });
    };
    /**
     * Called by realtime when we get new messages from the server.
     *
     * @private
     * @param {string} pathString
     * @param {*} data
     * @param {boolean} isMerge
     * @param {?number} tag
     */
    Repo.prototype.onDataUpdate_ = function (pathString, data, isMerge, tag) {
        // For testing.
        this.dataUpdateCount++;
        var path = new __WEBPACK_IMPORTED_MODULE_2__util_Path__["a" /* Path */](pathString);
        data = this.interceptServerDataCallback_
            ? this.interceptServerDataCallback_(pathString, data)
            : data;
        var events = [];
        if (tag) {
            if (isMerge) {
                var taggedChildren = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__firebase_util__["A" /* map */])(data, function (raw) {
                    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__snap_nodeFromJSON__["a" /* nodeFromJSON */])(raw);
                });
                events = this.serverSyncTree_.applyTaggedQueryMerge(path, taggedChildren, tag);
            }
            else {
                var taggedSnap = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__snap_nodeFromJSON__["a" /* nodeFromJSON */])(data);
                events = this.serverSyncTree_.applyTaggedQueryOverwrite(path, taggedSnap, tag);
            }
        }
        else if (isMerge) {
            var changedChildren = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__firebase_util__["A" /* map */])(data, function (raw) {
                return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__snap_nodeFromJSON__["a" /* nodeFromJSON */])(raw);
            });
            events = this.serverSyncTree_.applyServerMerge(path, changedChildren);
        }
        else {
            var snap = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__snap_nodeFromJSON__["a" /* nodeFromJSON */])(data);
            events = this.serverSyncTree_.applyServerOverwrite(path, snap);
        }
        var affectedPath = path;
        if (events.length > 0) {
            // Since we have a listener outstanding for each transaction, receiving any events
            // is a proxy for some change having occurred.
            affectedPath = this.rerunTransactions_(path);
        }
        this.eventQueue_.raiseEventsForChangedPath(affectedPath, events);
    };
    /**
     * TODO: This should be @private but it's used by test_access.js and internal.js
     * @param {?function(!string, *):*} callback
     * @private
     */
    Repo.prototype.interceptServerData_ = function (callback) {
        this.interceptServerDataCallback_ = callback;
    };
    /**
     * @param {!boolean} connectStatus
     * @private
     */
    Repo.prototype.onConnectStatus_ = function (connectStatus) {
        this.updateInfo_('connected', connectStatus);
        if (connectStatus === false) {
            this.runOnDisconnectEvents_();
        }
    };
    /**
     * @param {!Object} updates
     * @private
     */
    Repo.prototype.onServerInfoUpdate_ = function (updates) {
        var _this = this;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__util_util__["g" /* each */])(updates, function (value, key) {
            _this.updateInfo_(key, value);
        });
    };
    /**
     *
     * @param {!string} pathString
     * @param {*} value
     * @private
     */
    Repo.prototype.updateInfo_ = function (pathString, value) {
        var path = new __WEBPACK_IMPORTED_MODULE_2__util_Path__["a" /* Path */]('/.info/' + pathString);
        var newNode = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__snap_nodeFromJSON__["a" /* nodeFromJSON */])(value);
        this.infoData_.updateSnapshot(path, newNode);
        var events = this.infoSyncTree_.applyServerOverwrite(path, newNode);
        this.eventQueue_.raiseEventsForChangedPath(path, events);
    };
    /**
     * @return {!number}
     * @private
     */
    Repo.prototype.getNextWriteId_ = function () {
        return this.nextWriteId_++;
    };
    /**
     * @param {!Path} path
     * @param {*} newVal
     * @param {number|string|null} newPriority
     * @param {?function(?Error, *=)} onComplete
     */
    Repo.prototype.setWithPriority = function (path, newVal, newPriority, onComplete) {
        var _this = this;
        this.log_('set', {
            path: path.toString(),
            value: newVal,
            priority: newPriority
        });
        // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or
        // (b) store unresolved paths on JSON parse
        var serverValues = this.generateServerValues();
        var newNodeUnresolved = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__snap_nodeFromJSON__["a" /* nodeFromJSON */])(newVal, newPriority);
        var newNode = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util_ServerValues__["b" /* resolveDeferredValueSnapshot */])(newNodeUnresolved, serverValues);
        var writeId = this.getNextWriteId_();
        var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, writeId, true);
        this.eventQueue_.queueEvents(events);
        this.server_.put(path.toString(), newNodeUnresolved.val(/*export=*/ true), function (status, errorReason) {
            var success = status === 'ok';
            if (!success) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__util_util__["f" /* warn */])('set at ' + path + ' failed: ' + status);
            }
            var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId, !success);
            _this.eventQueue_.raiseEventsForChangedPath(path, clearEvents);
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        });
        var affectedPath = this.abortTransactions_(path);
        this.rerunTransactions_(affectedPath);
        // We queued the events above, so just flush the queue here
        this.eventQueue_.raiseEventsForChangedPath(affectedPath, []);
    };
    /**
     * @param {!Path} path
     * @param {!Object} childrenToMerge
     * @param {?function(?Error, *=)} onComplete
     */
    Repo.prototype.update = function (path, childrenToMerge, onComplete) {
        var _this = this;
        this.log_('update', { path: path.toString(), value: childrenToMerge });
        // Start with our existing data and merge each child into it.
        var empty = true;
        var serverValues = this.generateServerValues();
        var changedChildren = {};
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__firebase_util__["h" /* forEach */])(childrenToMerge, function (changedKey, changedValue) {
            empty = false;
            var newNodeUnresolved = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__snap_nodeFromJSON__["a" /* nodeFromJSON */])(changedValue);
            changedChildren[changedKey] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util_ServerValues__["b" /* resolveDeferredValueSnapshot */])(newNodeUnresolved, serverValues);
        });
        if (!empty) {
            var writeId_1 = this.getNextWriteId_();
            var events = this.serverSyncTree_.applyUserMerge(path, changedChildren, writeId_1);
            this.eventQueue_.queueEvents(events);
            this.server_.merge(path.toString(), childrenToMerge, function (status, errorReason) {
                var success = status === 'ok';
                if (!success) {
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__util_util__["f" /* warn */])('update at ' + path + ' failed: ' + status);
                }
                var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId_1, !success);
                var affectedPath = clearEvents.length > 0 ? _this.rerunTransactions_(path) : path;
                _this.eventQueue_.raiseEventsForChangedPath(affectedPath, clearEvents);
                _this.callOnCompleteCallback(onComplete, status, errorReason);
            });
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__firebase_util__["h" /* forEach */])(childrenToMerge, function (changedPath) {
                var affectedPath = _this.abortTransactions_(path.child(changedPath));
                _this.rerunTransactions_(affectedPath);
            });
            // We queued the events above, so just flush the queue here
            this.eventQueue_.raiseEventsForChangedPath(path, []);
        }
        else {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__util_util__["m" /* log */])("update() called with empty data.  Don't do anything.");
            this.callOnCompleteCallback(onComplete, 'ok');
        }
    };
    /**
     * Applies all of the changes stored up in the onDisconnect_ tree.
     * @private
     */
    Repo.prototype.runOnDisconnectEvents_ = function () {
        var _this = this;
        this.log_('onDisconnectEvents');
        var serverValues = this.generateServerValues();
        var resolvedOnDisconnectTree = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util_ServerValues__["c" /* resolveDeferredValueTree */])(this.onDisconnect_, serverValues);
        var events = [];
        resolvedOnDisconnectTree.forEachTree(__WEBPACK_IMPORTED_MODULE_2__util_Path__["a" /* Path */].Empty, function (path, snap) {
            events = events.concat(_this.serverSyncTree_.applyServerOverwrite(path, snap));
            var affectedPath = _this.abortTransactions_(path);
            _this.rerunTransactions_(affectedPath);
        });
        this.onDisconnect_ = new __WEBPACK_IMPORTED_MODULE_3__SparseSnapshotTree__["a" /* SparseSnapshotTree */]();
        this.eventQueue_.raiseEventsForChangedPath(__WEBPACK_IMPORTED_MODULE_2__util_Path__["a" /* Path */].Empty, events);
    };
    /**
     * @param {!Path} path
     * @param {?function(?Error, *=)} onComplete
     */
    Repo.prototype.onDisconnectCancel = function (path, onComplete) {
        var _this = this;
        this.server_.onDisconnectCancel(path.toString(), function (status, errorReason) {
            if (status === 'ok') {
                _this.onDisconnect_.forget(path);
            }
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        });
    };
    /**
     * @param {!Path} path
     * @param {*} value
     * @param {?function(?Error, *=)} onComplete
     */
    Repo.prototype.onDisconnectSet = function (path, value, onComplete) {
        var _this = this;
        var newNode = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__snap_nodeFromJSON__["a" /* nodeFromJSON */])(value);
        this.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), function (status, errorReason) {
            if (status === 'ok') {
                _this.onDisconnect_.remember(path, newNode);
            }
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        });
    };
    /**
     * @param {!Path} path
     * @param {*} value
     * @param {*} priority
     * @param {?function(?Error, *=)} onComplete
     */
    Repo.prototype.onDisconnectSetWithPriority = function (path, value, priority, onComplete) {
        var _this = this;
        var newNode = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__snap_nodeFromJSON__["a" /* nodeFromJSON */])(value, priority);
        this.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), function (status, errorReason) {
            if (status === 'ok') {
                _this.onDisconnect_.remember(path, newNode);
            }
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        });
    };
    /**
     * @param {!Path} path
     * @param {*} childrenToMerge
     * @param {?function(?Error, *=)} onComplete
     */
    Repo.prototype.onDisconnectUpdate = function (path, childrenToMerge, onComplete) {
        var _this = this;
        if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__firebase_util__["q" /* isEmpty */])(childrenToMerge)) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__util_util__["m" /* log */])("onDisconnect().update() called with empty data.  Don't do anything.");
            this.callOnCompleteCallback(onComplete, 'ok');
            return;
        }
        this.server_.onDisconnectMerge(path.toString(), childrenToMerge, function (status, errorReason) {
            if (status === 'ok') {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__firebase_util__["h" /* forEach */])(childrenToMerge, function (childName, childNode) {
                    var newChildNode = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__snap_nodeFromJSON__["a" /* nodeFromJSON */])(childNode);
                    _this.onDisconnect_.remember(path.child(childName), newChildNode);
                });
            }
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        });
    };
    /**
     * @param {!Query} query
     * @param {!EventRegistration} eventRegistration
     */
    Repo.prototype.addEventCallbackForQuery = function (query, eventRegistration) {
        var events;
        if (query.path.getFront() === '.info') {
            events = this.infoSyncTree_.addEventRegistration(query, eventRegistration);
        }
        else {
            events = this.serverSyncTree_.addEventRegistration(query, eventRegistration);
        }
        this.eventQueue_.raiseEventsAtPath(query.path, events);
    };
    /**
     * @param {!Query} query
     * @param {?EventRegistration} eventRegistration
     */
    Repo.prototype.removeEventCallbackForQuery = function (query, eventRegistration) {
        // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof
        // a little bit by handling the return values anyways.
        var events;
        if (query.path.getFront() === '.info') {
            events = this.infoSyncTree_.removeEventRegistration(query, eventRegistration);
        }
        else {
            events = this.serverSyncTree_.removeEventRegistration(query, eventRegistration);
        }
        this.eventQueue_.raiseEventsAtPath(query.path, events);
    };
    Repo.prototype.interrupt = function () {
        if (this.persistentConnection_) {
            this.persistentConnection_.interrupt(INTERRUPT_REASON);
        }
    };
    Repo.prototype.resume = function () {
        if (this.persistentConnection_) {
            this.persistentConnection_.resume(INTERRUPT_REASON);
        }
    };
    Repo.prototype.stats = function (showDelta) {
        if (showDelta === void 0) { showDelta = false; }
        if (typeof console === 'undefined')
            return;
        var stats;
        if (showDelta) {
            if (!this.statsListener_)
                this.statsListener_ = new __WEBPACK_IMPORTED_MODULE_11__stats_StatsListener__["a" /* StatsListener */](this.stats_);
            stats = this.statsListener_.get();
        }
        else {
            stats = this.stats_.get();
        }
        var longestName = Object.keys(stats).reduce(function (previousValue, currentValue) {
            return Math.max(currentValue.length, previousValue);
        }, 0);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__firebase_util__["h" /* forEach */])(stats, function (stat, value) {
            // pad stat names to be the same length (plus 2 extra spaces).
            for (var i = stat.length; i < longestName + 2; i++)
                stat += ' ';
            console.log(stat + value);
        });
    };
    Repo.prototype.statsIncrementCounter = function (metric) {
        this.stats_.incrementCounter(metric);
        this.statsReporter_.includeStat(metric);
    };
    /**
     * @param {...*} var_args
     * @private
     */
    Repo.prototype.log_ = function () {
        var var_args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            var_args[_i] = arguments[_i];
        }
        var prefix = '';
        if (this.persistentConnection_) {
            prefix = this.persistentConnection_.id + ':';
        }
        __WEBPACK_IMPORTED_MODULE_7__util_util__["m" /* log */].apply(void 0, [prefix].concat(var_args));
    };
    /**
     * @param {?function(?Error, *=)} callback
     * @param {!string} status
     * @param {?string=} errorReason
     */
    Repo.prototype.callOnCompleteCallback = function (callback, status, errorReason) {
        if (callback) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__util_util__["n" /* exceptionGuard */])(function () {
                if (status == 'ok') {
                    callback(null);
                }
                else {
                    var code = (status || 'error').toUpperCase();
                    var message = code;
                    if (errorReason)
                        message += ': ' + errorReason;
                    var error = new Error(message);
                    error.code = code;
                    callback(error);
                }
            });
        }
    };
    Object.defineProperty(Repo.prototype, "database", {
        get: function () {
            return this.__database || (this.__database = new __WEBPACK_IMPORTED_MODULE_15__api_Database__["a" /* Database */](this));
        },
        enumerable: true,
        configurable: true
    });
    return Repo;
}());




/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LeafNode; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__snap__ = __webpack_require__(49);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var __childrenNodeConstructor;
/**
 * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It
 * implements Node and stores the value of the node (a string,
 * number, or boolean) accessible via getValue().
 */
var LeafNode = /** @class */ (function () {
    /**
     * @implements {Node}
     * @param {!(string|number|boolean|Object)} value_ The value to store in this leaf node.
     *                                         The object type is possible in the event of a deferred value
     * @param {!Node=} priorityNode_ The priority of this node.
     */
    function LeafNode(value_, priorityNode_) {
        if (priorityNode_ === void 0) { priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE; }
        this.value_ = value_;
        this.priorityNode_ = priorityNode_;
        this.lazyHash_ = null;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(this.value_ !== undefined && this.value_ !== null, "LeafNode shouldn't be created with null/undefined value.");
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__snap__["a" /* validatePriorityNode */])(this.priorityNode_);
    }
    Object.defineProperty(LeafNode, "__childrenNodeConstructor", {
        get: function () {
            return __childrenNodeConstructor;
        },
        set: function (val) {
            __childrenNodeConstructor = val;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritDoc */
    LeafNode.prototype.isLeafNode = function () {
        return true;
    };
    /** @inheritDoc */
    LeafNode.prototype.getPriority = function () {
        return this.priorityNode_;
    };
    /** @inheritDoc */
    LeafNode.prototype.updatePriority = function (newPriorityNode) {
        return new LeafNode(this.value_, newPriorityNode);
    };
    /** @inheritDoc */
    LeafNode.prototype.getImmediateChild = function (childName) {
        // Hack to treat priority as a regular child
        if (childName === '.priority') {
            return this.priorityNode_;
        }
        else {
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        }
    };
    /** @inheritDoc */
    LeafNode.prototype.getChild = function (path) {
        if (path.isEmpty()) {
            return this;
        }
        else if (path.getFront() === '.priority') {
            return this.priorityNode_;
        }
        else {
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        }
    };
    /**
     * @inheritDoc
     */
    LeafNode.prototype.hasChild = function () {
        return false;
    };
    /** @inheritDoc */
    LeafNode.prototype.getPredecessorChildName = function (childName, childNode) {
        return null;
    };
    /** @inheritDoc */
    LeafNode.prototype.updateImmediateChild = function (childName, newChildNode) {
        if (childName === '.priority') {
            return this.updatePriority(newChildNode);
        }
        else if (newChildNode.isEmpty() && childName !== '.priority') {
            return this;
        }
        else {
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE
                .updateImmediateChild(childName, newChildNode)
                .updatePriority(this.priorityNode_);
        }
    };
    /** @inheritDoc */
    LeafNode.prototype.updateChild = function (path, newChildNode) {
        var front = path.getFront();
        if (front === null) {
            return newChildNode;
        }
        else if (newChildNode.isEmpty() && front !== '.priority') {
            return this;
        }
        else {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(front !== '.priority' || path.getLength() === 1, '.priority must be the last token in a path');
            return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(path.popFront(), newChildNode));
        }
    };
    /** @inheritDoc */
    LeafNode.prototype.isEmpty = function () {
        return false;
    };
    /** @inheritDoc */
    LeafNode.prototype.numChildren = function () {
        return 0;
    };
    /** @inheritDoc */
    LeafNode.prototype.forEachChild = function (index, action) {
        return false;
    };
    /**
     * @inheritDoc
     */
    LeafNode.prototype.val = function (exportFormat) {
        if (exportFormat && !this.getPriority().isEmpty())
            return {
                '.value': this.getValue(),
                '.priority': this.getPriority().val()
            };
        else
            return this.getValue();
    };
    /** @inheritDoc */
    LeafNode.prototype.hash = function () {
        if (this.lazyHash_ === null) {
            var toHash = '';
            if (!this.priorityNode_.isEmpty())
                toHash +=
                    'priority:' +
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__snap__["b" /* priorityHashText */])(this.priorityNode_.val()) +
                        ':';
            var type = typeof this.value_;
            toHash += type + ':';
            if (type === 'number') {
                toHash += __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_util__["w" /* doubleToIEEE754String */])(this.value_);
            }
            else {
                toHash += this.value_;
            }
            this.lazyHash_ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_util__["x" /* sha1 */])(toHash);
        }
        return this.lazyHash_;
    };
    /**
     * Returns the value of the leaf node.
     * @return {Object|string|number|boolean} The value of the node.
     */
    LeafNode.prototype.getValue = function () {
        return this.value_;
    };
    /**
     * @inheritDoc
     */
    LeafNode.prototype.compareTo = function (other) {
        if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {
            return 1;
        }
        else if (other instanceof LeafNode.__childrenNodeConstructor) {
            return -1;
        }
        else {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(other.isLeafNode(), 'Unknown node type');
            return this.compareToLeafNode_(other);
        }
    };
    /**
     * Comparison specifically for two leaf nodes
     * @param {!LeafNode} otherLeaf
     * @return {!number}
     * @private
     */
    LeafNode.prototype.compareToLeafNode_ = function (otherLeaf) {
        var otherLeafType = typeof otherLeaf.value_;
        var thisLeafType = typeof this.value_;
        var otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);
        var thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);
        if (otherIndex === thisIndex) {
            // Same type, compare values
            if (thisLeafType === 'object') {
                // Deferred value nodes are all equal, but we should also never get to this point...
                return 0;
            }
            else {
                // Note that this works because true > false, all others are number or string comparisons
                if (this.value_ < otherLeaf.value_) {
                    return -1;
                }
                else if (this.value_ === otherLeaf.value_) {
                    return 0;
                }
                else {
                    return 1;
                }
            }
        }
        else {
            return thisIndex - otherIndex;
        }
    };
    /**
     * @inheritDoc
     */
    LeafNode.prototype.withIndex = function () {
        return this;
    };
    /**
     * @inheritDoc
     */
    LeafNode.prototype.isIndexed = function () {
        return true;
    };
    /**
     * @inheritDoc
     */
    LeafNode.prototype.equals = function (other) {
        /**
         * @inheritDoc
         */
        if (other === this) {
            return true;
        }
        else if (other.isLeafNode()) {
            var otherLeaf = other;
            return (this.value_ === otherLeaf.value_ &&
                this.priorityNode_.equals(otherLeaf.priorityNode_));
        }
        else {
            return false;
        }
    };
    /**
     * The sort order for comparing leaf nodes of different types. If two leaf nodes have
     * the same type, the comparison falls back to their value
     * @type {Array.<!string>}
     * @const
     */
    LeafNode.VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];
    return LeafNode;
}());




/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Index; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Node__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_util__ = __webpack_require__(1);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 *
 * @constructor
 */
var Index = /** @class */ (function () {
    function Index() {
    }
    /**
     * @return {function(!NamedNode, !NamedNode):number} A standalone comparison function for
     * this index
     */
    Index.prototype.getCompare = function () {
        return this.compare.bind(this);
    };
    /**
     * Given a before and after value for a node, determine if the indexed value has changed. Even if they are different,
     * it's possible that the changes are isolated to parts of the snapshot that are not indexed.
     *
     * @param {!Node} oldNode
     * @param {!Node} newNode
     * @return {boolean} True if the portion of the snapshot being indexed changed between oldNode and newNode
     */
    Index.prototype.indexedValueChanged = function (oldNode, newNode) {
        var oldWrapped = new __WEBPACK_IMPORTED_MODULE_0__Node__["a" /* NamedNode */](__WEBPACK_IMPORTED_MODULE_1__util_util__["v" /* MIN_NAME */], oldNode);
        var newWrapped = new __WEBPACK_IMPORTED_MODULE_0__Node__["a" /* NamedNode */](__WEBPACK_IMPORTED_MODULE_1__util_util__["v" /* MIN_NAME */], newNode);
        return this.compare(oldWrapped, newWrapped) !== 0;
    };
    /**
     * @return {!NamedNode} a node wrapper that will sort equal to or less than
     * any other node wrapper, using this index
     */
    Index.prototype.minPost = function () {
        return __WEBPACK_IMPORTED_MODULE_0__Node__["a" /* NamedNode */].MIN;
    };
    return Index;
}());




/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PersistentStorage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return SessionStorage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__DOMStorageWrapper__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__MemoryStorage__ = __webpack_require__(106);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Helper to create a DOMStorageWrapper or else fall back to MemoryStorage.
 * TODO: Once MemoryStorage and DOMStorageWrapper have a shared interface this method annotation should change
 * to reflect this type
 *
 * @param {string} domStorageName Name of the underlying storage object
 *   (e.g. 'localStorage' or 'sessionStorage').
 * @return {?} Turning off type information until a common interface is defined.
 */
var createStoragefor = function (domStorageName) {
    try {
        // NOTE: just accessing "localStorage" or "window['localStorage']" may throw a security exception,
        // so it must be inside the try/catch.
        if (typeof window !== 'undefined' &&
            typeof window[domStorageName] !== 'undefined') {
            // Need to test cache. Just because it's here doesn't mean it works
            var domStorage = window[domStorageName];
            domStorage.setItem('firebase:sentinel', 'cache');
            domStorage.removeItem('firebase:sentinel');
            return new __WEBPACK_IMPORTED_MODULE_0__DOMStorageWrapper__["a" /* DOMStorageWrapper */](domStorage);
        }
    }
    catch (e) { }
    // Failed to create wrapper.  Just return in-memory storage.
    // TODO: log?
    return new __WEBPACK_IMPORTED_MODULE_1__MemoryStorage__["a" /* MemoryStorage */]();
};
/** A storage object that lasts across sessions */
var PersistentStorage = createStoragefor('localStorage');
/** A storage object that only lasts one session */
var SessionStorage = createStoragefor('sessionStorage');



/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export SortedMapIterator */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LLRBNode; });
/* unused harmony export LLRBEmptyNode */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return SortedMap; });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An iterator over an LLRBNode.
 */
var SortedMapIterator = /** @class */ (function () {
    /**
     * @template K, V, T
     * @param {LLRBNode|LLRBEmptyNode} node Node to iterate.
     * @param {?K} startKey
     * @param {function(K, K): number} comparator
     * @param {boolean} isReverse_ Whether or not to iterate in reverse
     * @param {(function(K, V):T)=} resultGenerator_
     */
    function SortedMapIterator(node, startKey, comparator, isReverse_, resultGenerator_) {
        if (resultGenerator_ === void 0) { resultGenerator_ = null; }
        this.isReverse_ = isReverse_;
        this.resultGenerator_ = resultGenerator_;
        /** @private
         * @type {Array.<!LLRBNode>}
         */
        this.nodeStack_ = [];
        var cmp = 1;
        while (!node.isEmpty()) {
            node = node;
            cmp = startKey ? comparator(node.key, startKey) : 1;
            // flip the comparison if we're going in reverse
            if (isReverse_)
                cmp *= -1;
            if (cmp < 0) {
                // This node is less than our start key. ignore it
                if (this.isReverse_) {
                    node = node.left;
                }
                else {
                    node = node.right;
                }
            }
            else if (cmp === 0) {
                // This node is exactly equal to our start key. Push it on the stack, but stop iterating;
                this.nodeStack_.push(node);
                break;
            }
            else {
                // This node is greater than our start key, add it to the stack and move to the next one
                this.nodeStack_.push(node);
                if (this.isReverse_) {
                    node = node.right;
                }
                else {
                    node = node.left;
                }
            }
        }
    }
    SortedMapIterator.prototype.getNext = function () {
        if (this.nodeStack_.length === 0)
            return null;
        var node = this.nodeStack_.pop();
        var result;
        if (this.resultGenerator_)
            result = this.resultGenerator_(node.key, node.value);
        else
            result = { key: node.key, value: node.value };
        if (this.isReverse_) {
            node = node.left;
            while (!node.isEmpty()) {
                this.nodeStack_.push(node);
                node = node.right;
            }
        }
        else {
            node = node.right;
            while (!node.isEmpty()) {
                this.nodeStack_.push(node);
                node = node.left;
            }
        }
        return result;
    };
    SortedMapIterator.prototype.hasNext = function () {
        return this.nodeStack_.length > 0;
    };
    SortedMapIterator.prototype.peek = function () {
        if (this.nodeStack_.length === 0)
            return null;
        var node = this.nodeStack_[this.nodeStack_.length - 1];
        if (this.resultGenerator_) {
            return this.resultGenerator_(node.key, node.value);
        }
        else {
            return { key: node.key, value: node.value };
        }
    };
    return SortedMapIterator;
}());

/**
 * Represents a node in a Left-leaning Red-Black tree.
 */
var LLRBNode = /** @class */ (function () {
    /**
     * @template K, V
     * @param {!K} key Key associated with this node.
     * @param {!V} value Value associated with this node.
     * @param {?boolean} color Whether this node is red.
     * @param {?(LLRBNode|LLRBEmptyNode)=} left Left child.
     * @param {?(LLRBNode|LLRBEmptyNode)=} right Right child.
     */
    function LLRBNode(key, value, color, left, right) {
        this.key = key;
        this.value = value;
        this.color = color != null ? color : LLRBNode.RED;
        this.left =
            left != null ? left : SortedMap.EMPTY_NODE;
        this.right =
            right != null ? right : SortedMap.EMPTY_NODE;
    }
    /**
     * Returns a copy of the current node, optionally replacing pieces of it.
     *
     * @param {?K} key New key for the node, or null.
     * @param {?V} value New value for the node, or null.
     * @param {?boolean} color New color for the node, or null.
     * @param {?LLRBNode|LLRBEmptyNode} left New left child for the node, or null.
     * @param {?LLRBNode|LLRBEmptyNode} right New right child for the node, or null.
     * @return {!LLRBNode} The node copy.
     */
    LLRBNode.prototype.copy = function (key, value, color, left, right) {
        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
    };
    /**
     * @return {number} The total number of nodes in the tree.
     */
    LLRBNode.prototype.count = function () {
        return this.left.count() + 1 + this.right.count();
    };
    /**
     * @return {boolean} True if the tree is empty.
     */
    LLRBNode.prototype.isEmpty = function () {
        return false;
    };
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param {function(!K, !V):*} action Callback function to be called for each
     *   node.  If it returns true, traversal is aborted.
     * @return {*} The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    LLRBNode.prototype.inorderTraversal = function (action) {
        return (this.left.inorderTraversal(action) ||
            action(this.key, this.value) ||
            this.right.inorderTraversal(action));
    };
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param {function(!Object, !Object)} action Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @return {*} True if traversal was aborted.
     */
    LLRBNode.prototype.reverseTraversal = function (action) {
        return (this.right.reverseTraversal(action) ||
            action(this.key, this.value) ||
            this.left.reverseTraversal(action));
    };
    /**
     * @return {!Object} The minimum node in the tree.
     * @private
     */
    LLRBNode.prototype.min_ = function () {
        if (this.left.isEmpty()) {
            return this;
        }
        else {
            return this.left.min_();
        }
    };
    /**
     * @return {!K} The maximum key in the tree.
     */
    LLRBNode.prototype.minKey = function () {
        return this.min_().key;
    };
    /**
     * @return {!K} The maximum key in the tree.
     */
    LLRBNode.prototype.maxKey = function () {
        if (this.right.isEmpty()) {
            return this.key;
        }
        else {
            return this.right.maxKey();
        }
    };
    /**
     *
     * @param {!Object} key Key to insert.
     * @param {!Object} value Value to insert.
     * @param {Comparator} comparator Comparator.
     * @return {!LLRBNode} New tree, with the key/value added.
     */
    LLRBNode.prototype.insert = function (key, value, comparator) {
        var cmp, n;
        n = this;
        cmp = comparator(key, n.key);
        if (cmp < 0) {
            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
        }
        else if (cmp === 0) {
            n = n.copy(null, value, null, null, null);
        }
        else {
            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
        }
        return n.fixUp_();
    };
    /**
     * @private
     * @return {!LLRBNode|LLRBEmptyNode} New tree, with the minimum key removed.
     */
    LLRBNode.prototype.removeMin_ = function () {
        if (this.left.isEmpty()) {
            return SortedMap.EMPTY_NODE;
        }
        var n = this;
        if (!n.left.isRed_() && !n.left.left.isRed_())
            n = n.moveRedLeft_();
        n = n.copy(null, null, null, n.left.removeMin_(), null);
        return n.fixUp_();
    };
    /**
     * @param {!Object} key The key of the item to remove.
     * @param {Comparator} comparator Comparator.
     * @return {!LLRBNode|LLRBEmptyNode} New tree, with the specified item removed.
     */
    LLRBNode.prototype.remove = function (key, comparator) {
        var n, smallest;
        n = this;
        if (comparator(key, n.key) < 0) {
            if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {
                n = n.moveRedLeft_();
            }
            n = n.copy(null, null, null, n.left.remove(key, comparator), null);
        }
        else {
            if (n.left.isRed_())
                n = n.rotateRight_();
            if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {
                n = n.moveRedRight_();
            }
            if (comparator(key, n.key) === 0) {
                if (n.right.isEmpty()) {
                    return SortedMap.EMPTY_NODE;
                }
                else {
                    smallest = n.right.min_();
                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());
                }
            }
            n = n.copy(null, null, null, null, n.right.remove(key, comparator));
        }
        return n.fixUp_();
    };
    /**
     * @private
     * @return {boolean} Whether this is a RED node.
     */
    LLRBNode.prototype.isRed_ = function () {
        return this.color;
    };
    /**
     * @private
     * @return {!LLRBNode} New tree after performing any needed rotations.
     */
    LLRBNode.prototype.fixUp_ = function () {
        var n = this;
        if (n.right.isRed_() && !n.left.isRed_())
            n = n.rotateLeft_();
        if (n.left.isRed_() && n.left.left.isRed_())
            n = n.rotateRight_();
        if (n.left.isRed_() && n.right.isRed_())
            n = n.colorFlip_();
        return n;
    };
    /**
     * @private
     * @return {!LLRBNode} New tree, after moveRedLeft.
     */
    LLRBNode.prototype.moveRedLeft_ = function () {
        var n = this.colorFlip_();
        if (n.right.left.isRed_()) {
            n = n.copy(null, null, null, null, n.right.rotateRight_());
            n = n.rotateLeft_();
            n = n.colorFlip_();
        }
        return n;
    };
    /**
     * @private
     * @return {!LLRBNode} New tree, after moveRedRight.
     */
    LLRBNode.prototype.moveRedRight_ = function () {
        var n = this.colorFlip_();
        if (n.left.left.isRed_()) {
            n = n.rotateRight_();
            n = n.colorFlip_();
        }
        return n;
    };
    /**
     * @private
     * @return {!LLRBNode} New tree, after rotateLeft.
     */
    LLRBNode.prototype.rotateLeft_ = function () {
        var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, nl, null);
    };
    /**
     * @private
     * @return {!LLRBNode} New tree, after rotateRight.
     */
    LLRBNode.prototype.rotateRight_ = function () {
        var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, nr);
    };
    /**
     * @private
     * @return {!LLRBNode} New tree, after colorFlip.
     */
    LLRBNode.prototype.colorFlip_ = function () {
        var left = this.left.copy(null, null, !this.left.color, null, null);
        var right = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, left, right);
    };
    /**
     * For testing.
     *
     * @private
     * @return {boolean} True if all is well.
     */
    LLRBNode.prototype.checkMaxDepth_ = function () {
        var blackDepth = this.check_();
        return Math.pow(2.0, blackDepth) <= this.count() + 1;
    };
    /**
     * @private
     * @return {number} Not sure what this returns exactly. :-).
     */
    LLRBNode.prototype.check_ = function () {
        var blackDepth;
        if (this.isRed_() && this.left.isRed_()) {
            throw new Error('Red node has red child(' + this.key + ',' + this.value + ')');
        }
        if (this.right.isRed_()) {
            throw new Error('Right child of (' + this.key + ',' + this.value + ') is red');
        }
        blackDepth = this.left.check_();
        if (blackDepth !== this.right.check_()) {
            throw new Error('Black depths differ');
        }
        else {
            return blackDepth + (this.isRed_() ? 0 : 1);
        }
    };
    LLRBNode.RED = true;
    LLRBNode.BLACK = false;
    return LLRBNode;
}());

/**
 * Represents an empty node (a leaf node in the Red-Black Tree).
 */
var LLRBEmptyNode = /** @class */ (function () {
    function LLRBEmptyNode() {
    }
    /**
     * Returns a copy of the current node.
     *
     * @return {!LLRBEmptyNode} The node copy.
     */
    LLRBEmptyNode.prototype.copy = function (key, value, color, left, right) {
        return this;
    };
    /**
     * Returns a copy of the tree, with the specified key/value added.
     *
     * @param {!K} key Key to be added.
     * @param {!V} value Value to be added.
     * @param {Comparator} comparator Comparator.
     * @return {!LLRBNode} New tree, with item added.
     */
    LLRBEmptyNode.prototype.insert = function (key, value, comparator) {
        return new LLRBNode(key, value, null);
    };
    /**
     * Returns a copy of the tree, with the specified key removed.
     *
     * @param {!K} key The key to remove.
     * @param {Comparator} comparator Comparator.
     * @return {!LLRBEmptyNode} New tree, with item removed.
     */
    LLRBEmptyNode.prototype.remove = function (key, comparator) {
        return this;
    };
    /**
     * @return {number} The total number of nodes in the tree.
     */
    LLRBEmptyNode.prototype.count = function () {
        return 0;
    };
    /**
     * @return {boolean} True if the tree is empty.
     */
    LLRBEmptyNode.prototype.isEmpty = function () {
        return true;
    };
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param {function(!K, !V):*} action Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @return {boolean} True if traversal was aborted.
     */
    LLRBEmptyNode.prototype.inorderTraversal = function (action) {
        return false;
    };
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param {function(!K, !V)} action Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @return {boolean} True if traversal was aborted.
     */
    LLRBEmptyNode.prototype.reverseTraversal = function (action) {
        return false;
    };
    /**
     * @return {null}
     */
    LLRBEmptyNode.prototype.minKey = function () {
        return null;
    };
    /**
     * @return {null}
     */
    LLRBEmptyNode.prototype.maxKey = function () {
        return null;
    };
    /**
     * @private
     * @return {number} Not sure what this returns exactly. :-).
     */
    LLRBEmptyNode.prototype.check_ = function () {
        return 0;
    };
    /**
     * @private
     * @return {boolean} Whether this node is red.
     */
    LLRBEmptyNode.prototype.isRed_ = function () {
        return false;
    };
    return LLRBEmptyNode;
}());

/**
 * An immutable sorted map implementation, based on a Left-leaning Red-Black
 * tree.
 */
var SortedMap = /** @class */ (function () {
    /**
     * @template K, V
     * @param {function(K, K):number} comparator_ Key comparator.
     * @param {LLRBNode=} root_ (Optional) Root node for the map.
     */
    function SortedMap(comparator_, root_) {
        if (root_ === void 0) { root_ = SortedMap.EMPTY_NODE; }
        this.comparator_ = comparator_;
        this.root_ = root_;
    }
    /**
     * Returns a copy of the map, with the specified key/value added or replaced.
     * (TODO: We should perhaps rename this method to 'put')
     *
     * @param {!K} key Key to be added.
     * @param {!V} value Value to be added.
     * @return {!SortedMap.<K, V>} New map, with item added.
     */
    SortedMap.prototype.insert = function (key, value) {
        return new SortedMap(this.comparator_, this.root_
            .insert(key, value, this.comparator_)
            .copy(null, null, LLRBNode.BLACK, null, null));
    };
    /**
     * Returns a copy of the map, with the specified key removed.
     *
     * @param {!K} key The key to remove.
     * @return {!SortedMap.<K, V>} New map, with item removed.
     */
    SortedMap.prototype.remove = function (key) {
        return new SortedMap(this.comparator_, this.root_
            .remove(key, this.comparator_)
            .copy(null, null, LLRBNode.BLACK, null, null));
    };
    /**
     * Returns the value of the node with the given key, or null.
     *
     * @param {!K} key The key to look up.
     * @return {?V} The value of the node with the given key, or null if the
     * key doesn't exist.
     */
    SortedMap.prototype.get = function (key) {
        var cmp;
        var node = this.root_;
        while (!node.isEmpty()) {
            cmp = this.comparator_(key, node.key);
            if (cmp === 0) {
                return node.value;
            }
            else if (cmp < 0) {
                node = node.left;
            }
            else if (cmp > 0) {
                node = node.right;
            }
        }
        return null;
    };
    /**
     * Returns the key of the item *before* the specified key, or null if key is the first item.
     * @param {K} key The key to find the predecessor of
     * @return {?K} The predecessor key.
     */
    SortedMap.prototype.getPredecessorKey = function (key) {
        var cmp, node = this.root_, rightParent = null;
        while (!node.isEmpty()) {
            cmp = this.comparator_(key, node.key);
            if (cmp === 0) {
                if (!node.left.isEmpty()) {
                    node = node.left;
                    while (!node.right.isEmpty())
                        node = node.right;
                    return node.key;
                }
                else if (rightParent) {
                    return rightParent.key;
                }
                else {
                    return null; // first item.
                }
            }
            else if (cmp < 0) {
                node = node.left;
            }
            else if (cmp > 0) {
                rightParent = node;
                node = node.right;
            }
        }
        throw new Error('Attempted to find predecessor key for a nonexistent key.  What gives?');
    };
    /**
     * @return {boolean} True if the map is empty.
     */
    SortedMap.prototype.isEmpty = function () {
        return this.root_.isEmpty();
    };
    /**
     * @return {number} The total number of nodes in the map.
     */
    SortedMap.prototype.count = function () {
        return this.root_.count();
    };
    /**
     * @return {?K} The minimum key in the map.
     */
    SortedMap.prototype.minKey = function () {
        return this.root_.minKey();
    };
    /**
     * @return {?K} The maximum key in the map.
     */
    SortedMap.prototype.maxKey = function () {
        return this.root_.maxKey();
    };
    /**
     * Traverses the map in key order and calls the specified action function
     * for each key/value pair.
     *
     * @param {function(!K, !V):*} action Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @return {*} The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    SortedMap.prototype.inorderTraversal = function (action) {
        return this.root_.inorderTraversal(action);
    };
    /**
     * Traverses the map in reverse key order and calls the specified action function
     * for each key/value pair.
     *
     * @param {function(!Object, !Object)} action Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @return {*} True if the traversal was aborted.
     */
    SortedMap.prototype.reverseTraversal = function (action) {
        return this.root_.reverseTraversal(action);
    };
    /**
     * Returns an iterator over the SortedMap.
     * @template T
     * @param {(function(K, V):T)=} resultGenerator
     * @return {SortedMapIterator.<K, V, T>} The iterator.
     */
    SortedMap.prototype.getIterator = function (resultGenerator) {
        return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);
    };
    SortedMap.prototype.getIteratorFrom = function (key, resultGenerator) {
        return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);
    };
    SortedMap.prototype.getReverseIteratorFrom = function (key, resultGenerator) {
        return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);
    };
    SortedMap.prototype.getReverseIterator = function (resultGenerator) {
        return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);
    };
    /**
     * Always use the same empty node, to reduce memory.
     * @const
     */
    SortedMap.EMPTY_NODE = new LLRBEmptyNode();
    return SortedMap;
}());




/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CacheNode; });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A cache node only stores complete children. Additionally it holds a flag whether the node can be considered fully
 * initialized in the sense that we know at one point in time this represented a valid state of the world, e.g.
 * initialized with data from the server, or a complete overwrite by the client. The filtered flag also tracks
 * whether a node potentially had children removed due to a filter.
 */
var CacheNode = /** @class */ (function () {
    /**
     * @param {!Node} node_
     * @param {boolean} fullyInitialized_
     * @param {boolean} filtered_
     */
    function CacheNode(node_, fullyInitialized_, filtered_) {
        this.node_ = node_;
        this.fullyInitialized_ = fullyInitialized_;
        this.filtered_ = filtered_;
    }
    /**
     * Returns whether this node was fully initialized with either server data or a complete overwrite by the client
     * @return {boolean}
     */
    CacheNode.prototype.isFullyInitialized = function () {
        return this.fullyInitialized_;
    };
    /**
     * Returns whether this node is potentially missing children due to a filter applied to the node
     * @return {boolean}
     */
    CacheNode.prototype.isFiltered = function () {
        return this.filtered_;
    };
    /**
     * @param {!Path} path
     * @return {boolean}
     */
    CacheNode.prototype.isCompleteForPath = function (path) {
        if (path.isEmpty()) {
            return this.isFullyInitialized() && !this.filtered_;
        }
        var childKey = path.getFront();
        return this.isCompleteForChild(childKey);
    };
    /**
     * @param {!string} key
     * @return {boolean}
     */
    CacheNode.prototype.isCompleteForChild = function (key) {
        return ((this.isFullyInitialized() && !this.filtered_) || this.node_.hasChild(key));
    };
    /**
     * @return {!Node}
     */
    CacheNode.prototype.getNode = function () {
        return this.node_;
    };
    return CacheNode;
}());




/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return PROTOCOL_VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return VERSION_PARAM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return TRANSPORT_SESSION_PARAM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return REFERER_PARAM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return FORGE_REF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return FORGE_DOMAIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return LAST_SESSION_PARAM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WEBSOCKET; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return LONG_POLLING; });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var PROTOCOL_VERSION = '5';
var VERSION_PARAM = 'v';
var TRANSPORT_SESSION_PARAM = 's';
var REFERER_PARAM = 'r';
var FORGE_REF = 'f';
var FORGE_DOMAIN = 'firebaseio.com';
var LAST_SESSION_PARAM = 'ls';
var WEBSOCKET = 'websocket';
var LONG_POLLING = 'long_polling';



/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Reference; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__onDisconnect__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__TransactionResult__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_util_NextPushId__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Query__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_Repo__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_util_Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_view_QueryParams__ = __webpack_require__(117);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_util_validation__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_SyncPoint__ = __webpack_require__(42);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();












var Reference = /** @class */ (function (_super) {
    __extends(Reference, _super);
    /**
     * Call options:
     *   new Reference(Repo, Path) or
     *   new Reference(url: string, string|RepoManager)
     *
     * Externally - this is the firebase.database.Reference type.
     *
     * @param {!Repo} repo
     * @param {(!Path)} path
     * @extends {Query}
     */
    function Reference(repo, path) {
        var _this = this;
        if (!(repo instanceof __WEBPACK_IMPORTED_MODULE_5__core_Repo__["a" /* Repo */])) {
            throw new Error('new Reference() no longer supported - use app.database().');
        }
        // call Query's constructor, passing in the repo and path.
        _this = _super.call(this, repo, path, __WEBPACK_IMPORTED_MODULE_7__core_view_QueryParams__["a" /* QueryParams */].DEFAULT, false) || this;
        return _this;
    }
    /** @return {?string} */
    Reference.prototype.getKey = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["y" /* validateArgCount */])('Reference.key', 0, 0, arguments.length);
        if (this.path.isEmpty())
            return null;
        else
            return this.path.getBack();
    };
    /**
     * @param {!(string|Path)} pathString
     * @return {!Reference}
     */
    Reference.prototype.child = function (pathString) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["y" /* validateArgCount */])('Reference.child', 1, 1, arguments.length);
        if (typeof pathString === 'number') {
            pathString = String(pathString);
        }
        else if (!(pathString instanceof __WEBPACK_IMPORTED_MODULE_6__core_util_Path__["a" /* Path */])) {
            if (this.path.getFront() === null)
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__core_util_validation__["g" /* validateRootPathString */])('Reference.child', 1, pathString, false);
            else
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__core_util_validation__["d" /* validatePathString */])('Reference.child', 1, pathString, false);
        }
        return new Reference(this.repo, this.path.child(pathString));
    };
    /** @return {?Reference} */
    Reference.prototype.getParent = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["y" /* validateArgCount */])('Reference.parent', 0, 0, arguments.length);
        var parentPath = this.path.parent();
        return parentPath === null ? null : new Reference(this.repo, parentPath);
    };
    /** @return {!Reference} */
    Reference.prototype.getRoot = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["y" /* validateArgCount */])('Reference.root', 0, 0, arguments.length);
        var ref = this;
        while (ref.getParent() !== null) {
            ref = ref.getParent();
        }
        return ref;
    };
    /** @return {!Database} */
    Reference.prototype.databaseProp = function () {
        return this.repo.database;
    };
    /**
     * @param {*} newVal
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */
    Reference.prototype.set = function (newVal, onComplete) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["y" /* validateArgCount */])('Reference.set', 1, 2, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__core_util_validation__["h" /* validateWritablePath */])('Reference.set', this.path);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__core_util_validation__["e" /* validateFirebaseDataArg */])('Reference.set', 1, newVal, this.path, false);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["H" /* validateCallback */])('Reference.set', 2, onComplete, true);
        var deferred = new __WEBPACK_IMPORTED_MODULE_9__firebase_util__["J" /* Deferred */]();
        this.repo.setWithPriority(this.path, newVal, 
        /*priority=*/ null, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {!Object} objectToMerge
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */
    Reference.prototype.update = function (objectToMerge, onComplete) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["y" /* validateArgCount */])('Reference.update', 1, 2, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__core_util_validation__["h" /* validateWritablePath */])('Reference.update', this.path);
        if (Array.isArray(objectToMerge)) {
            var newObjectToMerge = {};
            for (var i = 0; i < objectToMerge.length; ++i) {
                newObjectToMerge['' + i] = objectToMerge[i];
            }
            objectToMerge = newObjectToMerge;
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util_util__["f" /* warn */])('Passing an Array to Firebase.update() is deprecated. ' +
                'Use set() if you want to overwrite the existing data, or ' +
                'an Object with integer keys if you really do want to ' +
                'only update some of the children.');
        }
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__core_util_validation__["i" /* validateFirebaseMergeDataArg */])('Reference.update', 1, objectToMerge, this.path, false);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["H" /* validateCallback */])('Reference.update', 2, onComplete, true);
        var deferred = new __WEBPACK_IMPORTED_MODULE_9__firebase_util__["J" /* Deferred */]();
        this.repo.update(this.path, objectToMerge, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {*} newVal
     * @param {string|number|null} newPriority
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */
    Reference.prototype.setWithPriority = function (newVal, newPriority, onComplete) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["y" /* validateArgCount */])('Reference.setWithPriority', 2, 3, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__core_util_validation__["h" /* validateWritablePath */])('Reference.setWithPriority', this.path);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__core_util_validation__["e" /* validateFirebaseDataArg */])('Reference.setWithPriority', 1, newVal, this.path, false);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__core_util_validation__["j" /* validatePriority */])('Reference.setWithPriority', 2, newPriority, false);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["H" /* validateCallback */])('Reference.setWithPriority', 3, onComplete, true);
        if (this.getKey() === '.length' || this.getKey() === '.keys')
            throw 'Reference.setWithPriority failed: ' +
                this.getKey() +
                ' is a read-only object.';
        var deferred = new __WEBPACK_IMPORTED_MODULE_9__firebase_util__["J" /* Deferred */]();
        this.repo.setWithPriority(this.path, newVal, newPriority, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */
    Reference.prototype.remove = function (onComplete) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["y" /* validateArgCount */])('Reference.remove', 0, 1, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__core_util_validation__["h" /* validateWritablePath */])('Reference.remove', this.path);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["H" /* validateCallback */])('Reference.remove', 1, onComplete, true);
        return this.set(null, onComplete);
    };
    /**
     * @param {function(*):*} transactionUpdate
     * @param {(function(?Error, boolean, ?DataSnapshot))=} onComplete
     * @param {boolean=} applyLocally
     * @return {!Promise}
     */
    Reference.prototype.transaction = function (transactionUpdate, onComplete, applyLocally) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["y" /* validateArgCount */])('Reference.transaction', 1, 3, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__core_util_validation__["h" /* validateWritablePath */])('Reference.transaction', this.path);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["H" /* validateCallback */])('Reference.transaction', 1, transactionUpdate, false);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["H" /* validateCallback */])('Reference.transaction', 2, onComplete, true);
        // NOTE: applyLocally is an internal-only option for now.  We need to decide if we want to keep it and how
        // to expose it.
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__core_util_validation__["k" /* validateBoolean */])('Reference.transaction', 3, applyLocally, true);
        if (this.getKey() === '.length' || this.getKey() === '.keys')
            throw 'Reference.transaction failed: ' +
                this.getKey() +
                ' is a read-only object.';
        if (applyLocally === undefined)
            applyLocally = true;
        var deferred = new __WEBPACK_IMPORTED_MODULE_9__firebase_util__["J" /* Deferred */]();
        if (typeof onComplete === 'function') {
            deferred.promise.catch(function () { });
        }
        var promiseComplete = function (error, committed, snapshot) {
            if (error) {
                deferred.reject(error);
            }
            else {
                deferred.resolve(new __WEBPACK_IMPORTED_MODULE_1__TransactionResult__["a" /* TransactionResult */](committed, snapshot));
            }
            if (typeof onComplete === 'function') {
                onComplete(error, committed, snapshot);
            }
        };
        this.repo.startTransaction(this.path, transactionUpdate, promiseComplete, applyLocally);
        return deferred.promise;
    };
    /**
     * @param {string|number|null} priority
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */
    Reference.prototype.setPriority = function (priority, onComplete) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["y" /* validateArgCount */])('Reference.setPriority', 1, 2, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__core_util_validation__["h" /* validateWritablePath */])('Reference.setPriority', this.path);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__core_util_validation__["j" /* validatePriority */])('Reference.setPriority', 1, priority, false);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["H" /* validateCallback */])('Reference.setPriority', 2, onComplete, true);
        var deferred = new __WEBPACK_IMPORTED_MODULE_9__firebase_util__["J" /* Deferred */]();
        this.repo.setWithPriority(this.path.child('.priority'), priority, null, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {*=} value
     * @param {function(?Error)=} onComplete
     * @return {!Reference}
     */
    Reference.prototype.push = function (value, onComplete) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["y" /* validateArgCount */])('Reference.push', 0, 2, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__core_util_validation__["h" /* validateWritablePath */])('Reference.push', this.path);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__core_util_validation__["e" /* validateFirebaseDataArg */])('Reference.push', 1, value, this.path, true);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__firebase_util__["H" /* validateCallback */])('Reference.push', 2, onComplete, true);
        var now = this.repo.serverTime();
        var name = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__core_util_NextPushId__["a" /* nextPushId */])(now);
        // push() returns a ThennableReference whose promise is fulfilled with a regular Reference.
        // We use child() to create handles to two different references. The first is turned into a
        // ThennableReference below by adding then() and catch() methods and is used as the
        // return value of push(). The second remains a regular Reference and is used as the fulfilled
        // value of the first ThennableReference.
        var thennablePushRef = this.child(name);
        var pushRef = this.child(name);
        var promise;
        if (value != null) {
            promise = thennablePushRef.set(value, onComplete).then(function () { return pushRef; });
        }
        else {
            promise = Promise.resolve(pushRef);
        }
        thennablePushRef.then = promise.then.bind(promise);
        thennablePushRef.catch = promise.then.bind(promise, undefined);
        if (typeof onComplete === 'function') {
            promise.catch(function () { });
        }
        return thennablePushRef;
    };
    /**
     * @return {!OnDisconnect}
     */
    Reference.prototype.onDisconnect = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__core_util_validation__["h" /* validateWritablePath */])('Reference.onDisconnect', this.path);
        return new __WEBPACK_IMPORTED_MODULE_0__onDisconnect__["a" /* OnDisconnect */](this.repo, this.path);
    };
    Object.defineProperty(Reference.prototype, "database", {
        get: function () {
            return this.databaseProp();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "key", {
        get: function () {
            return this.getKey();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "parent", {
        get: function () {
            return this.getParent();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "root", {
        get: function () {
            return this.getRoot();
        },
        enumerable: true,
        configurable: true
    });
    return Reference;
}(__WEBPACK_IMPORTED_MODULE_4__Query__["a" /* Query */]));

/**
 * Define reference constructor in various modules
 *
 * We are doing this here to avoid several circular
 * dependency issues
 */
__WEBPACK_IMPORTED_MODULE_4__Query__["a" /* Query */].__referenceConstructor = Reference;
__WEBPACK_IMPORTED_MODULE_10__core_SyncPoint__["a" /* SyncPoint */].__referenceConstructor = Reference;



/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RepoManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Repo__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_libs_parser__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_validation__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Repo_transaction__ = __webpack_require__(96);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/** @const {string} */
var DATABASE_URL_OPTION = 'databaseURL';
var _staticInstance;
/**
 * Creates and caches Repo instances.
 */
var RepoManager = /** @class */ (function () {
    function RepoManager() {
        /**
         * @private {!Object.<string, Object<string, !fb.core.Repo>>}
         */
        this.repos_ = {};
        /**
         * If true, new Repos will be created to use ReadonlyRestClient (for testing purposes).
         * @private {boolean}
         */
        this.useRestClient_ = false;
    }
    RepoManager.getInstance = function () {
        if (!_staticInstance) {
            _staticInstance = new RepoManager();
        }
        return _staticInstance;
    };
    // TODO(koss): Remove these functions unless used in tests?
    RepoManager.prototype.interrupt = function () {
        for (var appName in this.repos_) {
            for (var dbUrl in this.repos_[appName]) {
                this.repos_[appName][dbUrl].interrupt();
            }
        }
    };
    RepoManager.prototype.resume = function () {
        for (var appName in this.repos_) {
            for (var dbUrl in this.repos_[appName]) {
                this.repos_[appName][dbUrl].resume();
            }
        }
    };
    /**
     * This function should only ever be called to CREATE a new database instance.
     *
     * @param {!FirebaseApp} app
     * @return {!Database}
     */
    RepoManager.prototype.databaseFromApp = function (app, url) {
        var dbUrl = url || app.options[DATABASE_URL_OPTION];
        if (dbUrl === undefined) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_util__["q" /* fatal */])("Can't determine Firebase Database URL.  Be sure to include " +
                DATABASE_URL_OPTION +
                ' option when calling firebase.intializeApp().');
        }
        var parsedUrl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__util_libs_parser__["a" /* parseRepoInfo */])(dbUrl);
        var repoInfo = parsedUrl.repoInfo;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__util_validation__["a" /* validateUrl */])('Invalid Firebase Database URL', 1, parsedUrl);
        if (!parsedUrl.path.isEmpty()) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_util__["q" /* fatal */])('Database URL must point to the root of a Firebase Database ' +
                '(not including a child path).');
        }
        var repo = this.createRepo(repoInfo, app);
        return repo.database;
    };
    /**
     * Remove the repo and make sure it is disconnected.
     *
     * @param {!Repo} repo
     */
    RepoManager.prototype.deleteRepo = function (repo) {
        var appRepos = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["s" /* safeGet */])(this.repos_, repo.app.name);
        // This should never happen...
        if (!appRepos || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["s" /* safeGet */])(appRepos, repo.repoInfo_.toURLString()) !== repo) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_util__["q" /* fatal */])("Database " + repo.app.name + "(" + repo.repoInfo_ + ") has already been deleted.");
        }
        repo.interrupt();
        delete appRepos[repo.repoInfo_.toURLString()];
    };
    /**
     * Ensures a repo doesn't already exist and then creates one using the
     * provided app.
     *
     * @param {!RepoInfo} repoInfo The metadata about the Repo
     * @param {!FirebaseApp} app
     * @return {!Repo} The Repo object for the specified server / repoName.
     */
    RepoManager.prototype.createRepo = function (repoInfo, app) {
        var appRepos = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["s" /* safeGet */])(this.repos_, app.name);
        if (!appRepos) {
            appRepos = {};
            this.repos_[app.name] = appRepos;
        }
        var repo = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["s" /* safeGet */])(appRepos, repoInfo.toURLString());
        if (repo) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_util__["q" /* fatal */])('Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.');
        }
        repo = new __WEBPACK_IMPORTED_MODULE_1__Repo__["a" /* Repo */](repoInfo, this.useRestClient_, app);
        appRepos[repoInfo.toURLString()] = repo;
        return repo;
    };
    /**
     * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.
     * @param {boolean} forceRestClient
     */
    RepoManager.prototype.forceRestClient = function (forceRestClient) {
        this.useRestClient_ = forceRestClient;
    };
    return RepoManager;
}());




/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return StatsManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__StatsCollection__ = __webpack_require__(103);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var StatsManager = /** @class */ (function () {
    function StatsManager() {
    }
    StatsManager.getCollection = function (repoInfo) {
        var hashString = repoInfo.toString();
        if (!this.collections_[hashString]) {
            this.collections_[hashString] = new __WEBPACK_IMPORTED_MODULE_0__StatsCollection__["a" /* StatsCollection */]();
        }
        return this.collections_[hashString];
    };
    StatsManager.getOrCreateReporter = function (repoInfo, creatorFunction) {
        var hashString = repoInfo.toString();
        if (!this.reporters_[hashString]) {
            this.reporters_[hashString] = creatorFunction();
        }
        return this.reporters_[hashString];
    };
    StatsManager.collections_ = {};
    StatsManager.reporters_ = {};
    return StatsManager;
}());




/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ImmutableTree; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__SortedMap__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var emptyChildrenSingleton;
/**
 * Singleton empty children collection.
 *
 * @const
 * @type {!SortedMap.<string, !ImmutableTree.<?>>}
 */
var EmptyChildren = function () {
    if (!emptyChildrenSingleton) {
        emptyChildrenSingleton = new __WEBPACK_IMPORTED_MODULE_0__SortedMap__["b" /* SortedMap */](__WEBPACK_IMPORTED_MODULE_2__util__["z" /* stringCompare */]);
    }
    return emptyChildrenSingleton;
};
/**
 * A tree with immutable elements.
 */
var ImmutableTree = /** @class */ (function () {
    /**
     * @template T
     * @param {?T} value
     * @param {SortedMap.<string, !ImmutableTree.<T>>=} children
     */
    function ImmutableTree(value, children) {
        if (children === void 0) { children = EmptyChildren(); }
        this.value = value;
        this.children = children;
    }
    /**
     * @template T
     * @param {!Object.<string, !T>} obj
     * @return {!ImmutableTree.<!T>}
     */
    ImmutableTree.fromObject = function (obj) {
        var tree = ImmutableTree.Empty;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__firebase_util__["h" /* forEach */])(obj, function (childPath, childSnap) {
            tree = tree.set(new __WEBPACK_IMPORTED_MODULE_1__Path__["a" /* Path */](childPath), childSnap);
        });
        return tree;
    };
    /**
     * True if the value is empty and there are no children
     * @return {boolean}
     */
    ImmutableTree.prototype.isEmpty = function () {
        return this.value === null && this.children.isEmpty();
    };
    /**
     * Given a path and predicate, return the first node and the path to that node
     * where the predicate returns true.
     *
     * TODO Do a perf test -- If we're creating a bunch of {path: value:} objects
     * on the way back out, it may be better to pass down a pathSoFar obj.
     *
     * @param {!Path} relativePath The remainder of the path
     * @param {function(T):boolean} predicate The predicate to satisfy to return a
     *   node
     * @return {?{path:!Path, value:!T}}
     */
    ImmutableTree.prototype.findRootMostMatchingPathAndValue = function (relativePath, predicate) {
        if (this.value != null && predicate(this.value)) {
            return { path: __WEBPACK_IMPORTED_MODULE_1__Path__["a" /* Path */].Empty, value: this.value };
        }
        else {
            if (relativePath.isEmpty()) {
                return null;
            }
            else {
                var front = relativePath.getFront();
                var child = this.children.get(front);
                if (child !== null) {
                    var childExistingPathAndValue = child.findRootMostMatchingPathAndValue(relativePath.popFront(), predicate);
                    if (childExistingPathAndValue != null) {
                        var fullPath = new __WEBPACK_IMPORTED_MODULE_1__Path__["a" /* Path */](front).child(childExistingPathAndValue.path);
                        return { path: fullPath, value: childExistingPathAndValue.value };
                    }
                    else {
                        return null;
                    }
                }
                else {
                    return null;
                }
            }
        }
    };
    /**
     * Find, if it exists, the shortest subpath of the given path that points a defined
     * value in the tree
     * @param {!Path} relativePath
     * @return {?{path: !Path, value: !T}}
     */
    ImmutableTree.prototype.findRootMostValueAndPath = function (relativePath) {
        return this.findRootMostMatchingPathAndValue(relativePath, function () { return true; });
    };
    /**
     * @param {!Path} relativePath
     * @return {!ImmutableTree.<T>} The subtree at the given path
     */
    ImmutableTree.prototype.subtree = function (relativePath) {
        if (relativePath.isEmpty()) {
            return this;
        }
        else {
            var front = relativePath.getFront();
            var childTree = this.children.get(front);
            if (childTree !== null) {
                return childTree.subtree(relativePath.popFront());
            }
            else {
                return ImmutableTree.Empty;
            }
        }
    };
    /**
     * Sets a value at the specified path.
     *
     * @param {!Path} relativePath Path to set value at.
     * @param {?T} toSet Value to set.
     * @return {!ImmutableTree.<T>} Resulting tree.
     */
    ImmutableTree.prototype.set = function (relativePath, toSet) {
        if (relativePath.isEmpty()) {
            return new ImmutableTree(toSet, this.children);
        }
        else {
            var front = relativePath.getFront();
            var child = this.children.get(front) || ImmutableTree.Empty;
            var newChild = child.set(relativePath.popFront(), toSet);
            var newChildren = this.children.insert(front, newChild);
            return new ImmutableTree(this.value, newChildren);
        }
    };
    /**
     * Removes the value at the specified path.
     *
     * @param {!Path} relativePath Path to value to remove.
     * @return {!ImmutableTree.<T>} Resulting tree.
     */
    ImmutableTree.prototype.remove = function (relativePath) {
        if (relativePath.isEmpty()) {
            if (this.children.isEmpty()) {
                return ImmutableTree.Empty;
            }
            else {
                return new ImmutableTree(null, this.children);
            }
        }
        else {
            var front = relativePath.getFront();
            var child = this.children.get(front);
            if (child) {
                var newChild = child.remove(relativePath.popFront());
                var newChildren = void 0;
                if (newChild.isEmpty()) {
                    newChildren = this.children.remove(front);
                }
                else {
                    newChildren = this.children.insert(front, newChild);
                }
                if (this.value === null && newChildren.isEmpty()) {
                    return ImmutableTree.Empty;
                }
                else {
                    return new ImmutableTree(this.value, newChildren);
                }
            }
            else {
                return this;
            }
        }
    };
    /**
     * Gets a value from the tree.
     *
     * @param {!Path} relativePath Path to get value for.
     * @return {?T} Value at path, or null.
     */
    ImmutableTree.prototype.get = function (relativePath) {
        if (relativePath.isEmpty()) {
            return this.value;
        }
        else {
            var front = relativePath.getFront();
            var child = this.children.get(front);
            if (child) {
                return child.get(relativePath.popFront());
            }
            else {
                return null;
            }
        }
    };
    /**
     * Replace the subtree at the specified path with the given new tree.
     *
     * @param {!Path} relativePath Path to replace subtree for.
     * @param {!ImmutableTree} newTree New tree.
     * @return {!ImmutableTree} Resulting tree.
     */
    ImmutableTree.prototype.setTree = function (relativePath, newTree) {
        if (relativePath.isEmpty()) {
            return newTree;
        }
        else {
            var front = relativePath.getFront();
            var child = this.children.get(front) || ImmutableTree.Empty;
            var newChild = child.setTree(relativePath.popFront(), newTree);
            var newChildren = void 0;
            if (newChild.isEmpty()) {
                newChildren = this.children.remove(front);
            }
            else {
                newChildren = this.children.insert(front, newChild);
            }
            return new ImmutableTree(this.value, newChildren);
        }
    };
    /**
     * Performs a depth first fold on this tree. Transforms a tree into a single
     * value, given a function that operates on the path to a node, an optional
     * current value, and a map of child names to folded subtrees
     * @template V
     * @param {function(Path, ?T, Object.<string, V>):V} fn
     * @return {V}
     */
    ImmutableTree.prototype.fold = function (fn) {
        return this.fold_(__WEBPACK_IMPORTED_MODULE_1__Path__["a" /* Path */].Empty, fn);
    };
    /**
     * Recursive helper for public-facing fold() method
     * @template V
     * @param {!Path} pathSoFar
     * @param {function(Path, ?T, Object.<string, V>):V} fn
     * @return {V}
     * @private
     */
    ImmutableTree.prototype.fold_ = function (pathSoFar, fn) {
        var accum = {};
        this.children.inorderTraversal(function (childKey, childTree) {
            accum[childKey] = childTree.fold_(pathSoFar.child(childKey), fn);
        });
        return fn(pathSoFar, this.value, accum);
    };
    /**
     * Find the first matching value on the given path. Return the result of applying f to it.
     * @template V
     * @param {!Path} path
     * @param {!function(!Path, !T):?V} f
     * @return {?V}
     */
    ImmutableTree.prototype.findOnPath = function (path, f) {
        return this.findOnPath_(path, __WEBPACK_IMPORTED_MODULE_1__Path__["a" /* Path */].Empty, f);
    };
    ImmutableTree.prototype.findOnPath_ = function (pathToFollow, pathSoFar, f) {
        var result = this.value ? f(pathSoFar, this.value) : false;
        if (result) {
            return result;
        }
        else {
            if (pathToFollow.isEmpty()) {
                return null;
            }
            else {
                var front = pathToFollow.getFront();
                var nextChild = this.children.get(front);
                if (nextChild) {
                    return nextChild.findOnPath_(pathToFollow.popFront(), pathSoFar.child(front), f);
                }
                else {
                    return null;
                }
            }
        }
    };
    /**
     *
     * @param {!Path} path
     * @param {!function(!Path, !T)} f
     * @returns {!ImmutableTree.<T>}
     */
    ImmutableTree.prototype.foreachOnPath = function (path, f) {
        return this.foreachOnPath_(path, __WEBPACK_IMPORTED_MODULE_1__Path__["a" /* Path */].Empty, f);
    };
    ImmutableTree.prototype.foreachOnPath_ = function (pathToFollow, currentRelativePath, f) {
        if (pathToFollow.isEmpty()) {
            return this;
        }
        else {
            if (this.value) {
                f(currentRelativePath, this.value);
            }
            var front = pathToFollow.getFront();
            var nextChild = this.children.get(front);
            if (nextChild) {
                return nextChild.foreachOnPath_(pathToFollow.popFront(), currentRelativePath.child(front), f);
            }
            else {
                return ImmutableTree.Empty;
            }
        }
    };
    /**
     * Calls the given function for each node in the tree that has a value.
     *
     * @param {function(!Path, !T)} f A function to be called with
     *   the path from the root of the tree to a node, and the value at that node.
     *   Called in depth-first order.
     */
    ImmutableTree.prototype.foreach = function (f) {
        this.foreach_(__WEBPACK_IMPORTED_MODULE_1__Path__["a" /* Path */].Empty, f);
    };
    ImmutableTree.prototype.foreach_ = function (currentRelativePath, f) {
        this.children.inorderTraversal(function (childName, childTree) {
            childTree.foreach_(currentRelativePath.child(childName), f);
        });
        if (this.value) {
            f(currentRelativePath, this.value);
        }
    };
    /**
     *
     * @param {function(string, !T)} f
     */
    ImmutableTree.prototype.foreachChild = function (f) {
        this.children.inorderTraversal(function (childName, childTree) {
            if (childTree.value) {
                f(childName, childTree.value);
            }
        });
    };
    ImmutableTree.Empty = new ImmutableTree(null);
    return ImmutableTree;
}());




/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IndexedFilter; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Change__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__snap_ChildrenNode__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__snap_indexes_PriorityIndex__ = __webpack_require__(4);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Doesn't really filter nodes but applies an index to the node and keeps track of any changes
 *
 * @constructor
 * @implements {NodeFilter}
 * @param {!Index} index
 */
var IndexedFilter = /** @class */ (function () {
    function IndexedFilter(index_) {
        this.index_ = index_;
    }
    IndexedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(snap.isIndexed(this.index_), 'A node must be indexed if only a child is updated');
        var oldChild = snap.getImmediateChild(key);
        // Check if anything actually changed.
        if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {
            // There's an edge case where a child can enter or leave the view because affectedPath was set to null.
            // In this case, affectedPath will appear null in both the old and new snapshots.  So we need
            // to avoid treating these cases as "nothing changed."
            if (oldChild.isEmpty() == newChild.isEmpty()) {
                // Nothing changed.
                // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.
                //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');
                return snap;
            }
        }
        if (optChangeAccumulator != null) {
            if (newChild.isEmpty()) {
                if (snap.hasChild(key)) {
                    optChangeAccumulator.trackChildChange(__WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].childRemovedChange(key, oldChild));
                }
                else {
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(snap.isLeafNode(), 'A child remove without an old child only makes sense on a leaf node');
                }
            }
            else if (oldChild.isEmpty()) {
                optChangeAccumulator.trackChildChange(__WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].childAddedChange(key, newChild));
            }
            else {
                optChangeAccumulator.trackChildChange(__WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].childChangedChange(key, newChild, oldChild));
            }
        }
        if (snap.isLeafNode() && newChild.isEmpty()) {
            return snap;
        }
        else {
            // Make sure the node is indexed
            return snap.updateImmediateChild(key, newChild).withIndex(this.index_);
        }
    };
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {
        if (optChangeAccumulator != null) {
            if (!oldSnap.isLeafNode()) {
                oldSnap.forEachChild(__WEBPACK_IMPORTED_MODULE_3__snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */], function (key, childNode) {
                    if (!newSnap.hasChild(key)) {
                        optChangeAccumulator.trackChildChange(__WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].childRemovedChange(key, childNode));
                    }
                });
            }
            if (!newSnap.isLeafNode()) {
                newSnap.forEachChild(__WEBPACK_IMPORTED_MODULE_3__snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */], function (key, childNode) {
                    if (oldSnap.hasChild(key)) {
                        var oldChild = oldSnap.getImmediateChild(key);
                        if (!oldChild.equals(childNode)) {
                            optChangeAccumulator.trackChildChange(__WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].childChangedChange(key, childNode, oldChild));
                        }
                    }
                    else {
                        optChangeAccumulator.trackChildChange(__WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].childAddedChange(key, childNode));
                    }
                });
            }
        }
        return newSnap.withIndex(this.index_);
    };
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.updatePriority = function (oldSnap, newPriority) {
        if (oldSnap.isEmpty()) {
            return __WEBPACK_IMPORTED_MODULE_2__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE;
        }
        else {
            return oldSnap.updatePriority(newPriority);
        }
    };
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.filtersNodes = function () {
        return false;
    };
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.getIndexedFilter = function () {
        return this;
    };
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.getIndex = function () {
        return this.index_;
    };
    return IndexedFilter;
}());




/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CONSTANTS; });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.
 */
var CONSTANTS = {
    /**
     * @define {boolean} Whether this is the client Node.js SDK.
     */
    NODE_CLIENT: false,
    /**
     * @define {boolean} Whether this is the Admin Node.js SDK.
     */
    NODE_ADMIN: false,
    /**
     * Firebase SDK Version
     */
    SDK_VERSION: '${JSCORE_VERSION}'
};



/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__maths__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__random__ = __webpack_require__(13);




class Range {

  // Constructor

  constructor(min = NaN, max = NaN) {

    if (isNaN(max) && isNaN(max)) {
      this.min  = 0;
      this.max  = 1;
    } else if (isNaN(max)) {
      this.min  = 0;
      this.max  = min;
    } else {
      this.min  = min;
      this.max  = max;
    }

  }

  // Get/set

  get middle() {
    return this.lerp(0.5);
  }
  get center() {
    return this.lerp(0.5);
  }

  get length() {
    return this.max - this.min;
  }
  get range() {
    return this.max - this.min;
  }

  get random() {
    return __WEBPACK_IMPORTED_MODULE_1__random__["a" /* num */](this.min, this.max);
  }
  get randomInt() {
    return __WEBPACK_IMPORTED_MODULE_1__random__["b" /* int */](this.min, this.max);
  }

  get isIntRange() {
    return __WEBPACK_IMPORTED_MODULE_0__maths__["c" /* isInt */](this.min) && __WEBPACK_IMPORTED_MODULE_0__maths__["c" /* isInt */](this.max);
  }


  // Methods

  lerp(val, clamp = false) {
    return __WEBPACK_IMPORTED_MODULE_0__maths__["b" /* lerp */](this.min, this.max, val, clamp);
  }
  norm(val, clamp = false) {
    return __WEBPACK_IMPORTED_MODULE_0__maths__["d" /* norm */](val, this.min, this.max, clamp);
  }

  mapFrom(val, fromMin, fromMax) {
    return __WEBPACK_IMPORTED_MODULE_0__maths__["e" /* map */](val, fromMin, fromMax, this.min, this.max);
  }
  mapTo(val, toMin, toMax) {
    return __WEBPACK_IMPORTED_MODULE_0__maths__["e" /* map */](val, this.min, this.max, toMin, toMax);
  }

  mapFromRange(val, fromRange, clamp = false) {
    return __WEBPACK_IMPORTED_MODULE_0__maths__["e" /* map */](val, fromRange.min, fromRange.max, this.min, this.max, clamp);
  }
  mapToRange(val, toRange, clamp = false) {
    return __WEBPACK_IMPORTED_MODULE_0__maths__["e" /* map */](val, this.min, this.max, toRange.min, toRange.max, clamp);
  }

  clamp(val) {
    return __WEBPACK_IMPORTED_MODULE_0__maths__["f" /* clamp */](val, this.min, this.max);
  }
  wrap(val) {
    if (__WEBPACK_IMPORTED_MODULE_0__maths__["c" /* isInt */](val) && isIntRange) {
      return __WEBPACK_IMPORTED_MODULE_0__maths__["g" /* wrap */](val, this.min, this.max);
    } else {
      return __WEBPACK_IMPORTED_MODULE_0__maths__["h" /* wrapNum */](val, this.min, this.max);
    }
  }

  contains(val) {
    return (val >= this.min) && (val <= this.max);
  }

  invert() {
    let temp = this.min;
    this.min = this.max;
    this.max = temp;
  }

  trim(trimMin, trimMax) {
    this.min = __WEBPACK_IMPORTED_MODULE_0__maths__["f" /* clamp */](this.min, trimMin, trimMax);
    this.max = __WEBPACK_IMPORTED_MODULE_0__maths__["f" /* clamp */](this.max, trimMin, trimMax);
  }

  toString() {
    return "[" + this.min + ".." + this.max + "]";
  }
  clone() {
    return new Range(this.min, this.max);
  }

  envelop(val) {
    this.min  = Math.min(this.min, val);
    this.max  = Math.min(this.max, val);
  }

}
/* harmony export (immutable) */ __webpack_exports__["default"] = Range;



/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_classnames__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_firebase_app__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_firebase_app___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_firebase_app__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__App__ = __webpack_require__(5);

// Imports








// Constants


// Component

class CustomizeActivityForm extends __WEBPACK_IMPORTED_MODULE_0_react__["Component"] {

  // Constructor

  constructor() {

    super();

    this.handleInputChange = e => {

      this.setState({
        [e.currentTarget.name]: e.currentTarget.value
      });
    };

    this.handleSubmit = e => {

      e.preventDefault();

      if (this.validate()) {

        const activity = {
          label: this.state.valLabel
        };

        this.activitiesRef.push(activity, error => {

          if (!error) {
            this.clearInput();
          }
        });
      }
    };

    this.initState();
  }

  initState() {

    this.state = {
      valLabel: ''
    };
  }

  // Event handlers

  // Methods

  clearInput() {

    this.setState({
      valLabel: ''
    });
  }

  validate() {

    const hasLabel = this.state.valLabel && this.state.valLabel.length;

    return hasLabel;
  }

  // React

  componentDidMount() {

    const userId = __WEBPACK_IMPORTED_MODULE_2_firebase_app___default.a.auth().currentUser.uid;

    this.activitiesRef = __WEBPACK_IMPORTED_MODULE_2_firebase_app___default.a.database().ref(`activities/${userId}`);
  }

  render() {

    return __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
      'form',
      {
        className: 'activity-input',
        onSubmit: this.handleSubmit },
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'h3',
        null,
        'Add Activity'
      ),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'p',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'label',
          {
            htmlFor: 'activity-input-label' },
          'Label'
        )
      ),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'p',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"]('input', {
          id: 'activity-input-label',
          type: 'text',
          name: 'valLabel',
          value: this.state.valLabel,
          onChange: this.handleInputChange })
      ),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'p',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"]('input', {
          id: 'activity-input-submit',
          type: 'submit',
          disabled: !this.validate() })
      )
    );
  }

}
/* harmony export (immutable) */ __webpack_exports__["a"] = CustomizeActivityForm;


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_firebase_app__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_firebase_app___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_firebase_app__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__App__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__CustomizeTableCell__ = __webpack_require__(72);

// Imports








// Constants


// Component

class CustomizeTable extends __WEBPACK_IMPORTED_MODULE_0_react__["Component"] {

  // Constructor

  constructor() {

    super();

    this.handleCategoriesValue = data => {

      this.setState({
        categories: data.val() ? data.val() : {}
      });
    };

    this.handleValuesValue = data => {

      this.setState({
        values: data.val() ? data.val() : {}
      });
    };

    this.handleActivitiesValue = data => {

      this.setState({
        activities: data.val() ? data.val() : {}
      });
    };

    this.handleWeightChange = (actKey, valLinkKey, weight) => {

      weight = Math.min(3, Math.max(0, weight));

      this.activitiesRef.child(actKey + '/values/' + valLinkKey).update({
        weight: weight
      });
    };

    this.initState();
  }

  initState() {

    this.state = {
      categories: undefined,
      values: undefined,
      activities: undefined
    };
  }

  // Event handlers

  // Methods

  deleteActivity(actKey) {

    this.activitiesRef.child(actKey).remove();
  }
  deleteValue(valKey) {

    this.valuesRef.child(valKey).remove();
  }

  getValuesByCategoryKey(catKey, values) {

    const obj = {};

    _.each(values, (value, valKey) => {

      if (value.category_key === catKey) {
        obj[valKey] = value;
      }
    });

    return obj;
  }

  // React

  componentDidMount() {

    const userId = __WEBPACK_IMPORTED_MODULE_1_firebase_app___default.a.auth().currentUser.uid;

    this.categoriesRef = __WEBPACK_IMPORTED_MODULE_1_firebase_app___default.a.database().ref(`categories/${userId}`);
    this.valuesRef = __WEBPACK_IMPORTED_MODULE_1_firebase_app___default.a.database().ref(`values/${userId}`);
    this.activitiesRef = __WEBPACK_IMPORTED_MODULE_1_firebase_app___default.a.database().ref(`activities/${userId}`);

    this.categoriesRef.on('value', this.handleCategoriesValue);
    this.valuesRef.on('value', this.handleValuesValue);
    this.activitiesRef.on('value', this.handleActivitiesValue);
  }

  componentWillUnmount() {

    if (this.categoriesRef) this.categoriesRef.off('value', this.handleCategoriesValue);
    if (this.valuesRef) this.valuesRef.off('value', this.handleValuesValue);
    if (this.activitiesRef) this.activitiesRef.off('value', this.handleActivitiesValue);
  }

  render() {

    const categories = this.state.categories,
          values = this.state.values,
          activities = this.state.activities;

    const dataLoaded = categories !== undefined && values !== undefined && activities !== undefined;

    const noData = _.isEmpty(categories) && _.isEmpty(values) && _.isEmpty(activities);

    if (!dataLoaded) {
      return __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'p',
        null,
        'Loading...'
      );
    } else if (noData) {
      return __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'p',
        null,
        'No data'
      );
    }

    return __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
      'table',
      {
        className: 'customize-table' },
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'thead',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'tr',
          null,
          __WEBPACK_IMPORTED_MODULE_0_react__["createElement"]('th', null),
          _.map(categories, (category, key) => {

            if (!category) return null;

            let catVals = this.getValuesByCategoryKey(key, values),
                count = _.size(catVals);

            if (count) {
              return __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
                'th',
                {
                  key: key,
                  colSpan: count },
                category.label
              );
            }
          })
        ),
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'tr',
          null,
          __WEBPACK_IMPORTED_MODULE_0_react__["createElement"]('th', null),
          _.map(categories, (category, catKey) => {

            let catVals = this.getValuesByCategoryKey(catKey, values);

            return _.map(catVals, (value, valKey) => __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
              'th',
              {
                key: valKey },
              value.label,
              '\xA0',
              __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
                'a',
                {
                  className: 'remove-btn',
                  onClick: () => this.deleteValue(valKey) },
                '\xD7'
              )
            ));
          })
        )
      ),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'tbody',
        null,
        _.map(activities, (activity, actKey) => __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'tr',
          { key: actKey },
          __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
            'th',
            null,
            activity.label,
            '\xA0',
            __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
              'a',
              {
                className: 'remove-btn',
                onClick: () => this.deleteActivity(actKey) },
              '\xD7'
            )
          ),
          _.map(categories, (category, catKey) => {

            let catVals = this.getValuesByCategoryKey(catKey, values);

            return _.map(catVals, (value, valKey) => {

              const valLink = _.find(activity.values, valLink => valLink.value_key === valKey);

              return __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](__WEBPACK_IMPORTED_MODULE_3__CustomizeTableCell__["a" /* default */], {
                key: valKey,
                actKey: actKey,
                activity: activity,
                valLinkKey: valKey,
                onWeightChange: this.handleWeightChange });
            });
          })
        ))
      )
    );
  }

}
/* harmony export (immutable) */ __webpack_exports__["a"] = CustomizeTable;


/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_classnames__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_firebase_app__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_firebase_app___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_firebase_app__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__App__ = __webpack_require__(5);

// Imports








// Constants


// Component

class CustomizeValueForm extends __WEBPACK_IMPORTED_MODULE_0_react__["Component"] {

  // Constructor

  constructor() {

    super();

    this.handleCategoriesValue = data => {

      const categories = data.val() ? data.val() : {},
            hasValCategory = this.state.valCategory && this.state.valCategory.length,
            valCategory = hasValCategory ? this.state.valCategory : _.keys(categories)[0];

      this.setState({
        categories: categories,
        valCategory: valCategory
      });
    };

    this.handleInputChange = e => {

      this.setState({
        [e.currentTarget.name]: e.currentTarget.value
      });
    };

    this.handleSubmit = e => {

      e.preventDefault();

      if (this.validate()) {

        const value = {
          category_key: this.state.valCategory,
          label: this.state.valLabel
        };

        this.valuesRef.push(value, error => {

          if (!error) {
            this.clearInput();
          }
        });
      }
    };

    this.initState();
  }

  initState() {

    this.state = {
      categories: undefined,
      valCategory: '',
      valLabel: ''
    };
  }

  // Event handlers

  // Methods

  clearInput() {

    this.setState({
      valLabel: ''
    });
  }

  validate() {

    const hasCategory = this.state.valCategory && this.state.valCategory.length;

    const hasLabel = this.state.valLabel && this.state.valLabel.length;

    return hasCategory && hasLabel;
  }

  // React

  componentDidMount() {

    const userId = __WEBPACK_IMPORTED_MODULE_2_firebase_app___default.a.auth().currentUser.uid;

    this.categoriesRef = __WEBPACK_IMPORTED_MODULE_2_firebase_app___default.a.database().ref(`categories/${userId}`);
    this.valuesRef = __WEBPACK_IMPORTED_MODULE_2_firebase_app___default.a.database().ref(`values/${userId}`);

    this.categoriesRef.on('value', this.handleCategoriesValue);
  }

  componentWillUnmount() {

    if (this.categoriesRef) this.categoriesRef.off('value', this.handleCategoriesValue);
  }

  render() {

    return __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
      'form',
      {
        className: 'value-input',
        onSubmit: this.handleSubmit },
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'h3',
        null,
        'Add Value'
      ),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'p',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'label',
          {
            htmlFor: 'value-select-category' },
          'Category'
        )
      ),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'p',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'select',
          {
            id: 'value-select-category',
            name: 'valCategory',
            value: this.state.valCategory,
            onChange: this.handleInputChange },
          _.map(this.state.categories, (category, catKey) => __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
            'option',
            {
              key: catKey,
              value: catKey },
            category.label
          ))
        )
      ),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'p',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'label',
          {
            htmlFor: 'value-input-label' },
          'Label'
        )
      ),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'p',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"]('input', {
          id: 'value-input-label',
          type: 'text',
          name: 'valLabel',
          value: this.state.valLabel,
          onChange: this.handleInputChange })
      ),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'p',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"]('input', {
          id: 'value-input-submit',
          type: 'submit',
          disabled: !this.validate() })
      )
    );
  }

}
/* harmony export (immutable) */ __webpack_exports__["a"] = CustomizeValueForm;


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DataSnapshot; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_util_validation__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_util_Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_snap_indexes_PriorityIndex__ = __webpack_require__(4);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Class representing a firebase data snapshot.  It wraps a SnapshotNode and
 * surfaces the public methods (val, forEach, etc.) we want to expose.
 */
var DataSnapshot = /** @class */ (function () {
    /**
     * @param {!Node} node_ A SnapshotNode to wrap.
     * @param {!Reference} ref_ The ref of the location this snapshot came from.
     * @param {!Index} index_ The iteration order for this snapshot
     */
    function DataSnapshot(node_, ref_, index_) {
        this.node_ = node_;
        this.ref_ = ref_;
        this.index_ = index_;
    }
    /**
     * Retrieves the snapshot contents as JSON.  Returns null if the snapshot is
     * empty.
     *
     * @return {*} JSON representation of the DataSnapshot contents, or null if empty.
     */
    DataSnapshot.prototype.val = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('DataSnapshot.val', 0, 0, arguments.length);
        return this.node_.val();
    };
    /**
     * Returns the snapshot contents as JSON, including priorities of node.  Suitable for exporting
     * the entire node contents.
     * @return {*} JSON representation of the DataSnapshot contents, or null if empty.
     */
    DataSnapshot.prototype.exportVal = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('DataSnapshot.exportVal', 0, 0, arguments.length);
        return this.node_.val(true);
    };
    // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary
    // for end-users
    DataSnapshot.prototype.toJSON = function () {
        // Optional spacer argument is unnecessary because we're depending on recursion rather than stringifying the content
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('DataSnapshot.toJSON', 0, 1, arguments.length);
        return this.exportVal();
    };
    /**
     * Returns whether the snapshot contains a non-null value.
     *
     * @return {boolean} Whether the snapshot contains a non-null value, or is empty.
     */
    DataSnapshot.prototype.exists = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('DataSnapshot.exists', 0, 0, arguments.length);
        return !this.node_.isEmpty();
    };
    /**
     * Returns a DataSnapshot of the specified child node's contents.
     *
     * @param {!string} childPathString Path to a child.
     * @return {!DataSnapshot} DataSnapshot for child node.
     */
    DataSnapshot.prototype.child = function (childPathString) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('DataSnapshot.child', 0, 1, arguments.length);
        // Ensure the childPath is a string (can be a number)
        childPathString = String(childPathString);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__core_util_validation__["d" /* validatePathString */])('DataSnapshot.child', 1, childPathString, false);
        var childPath = new __WEBPACK_IMPORTED_MODULE_2__core_util_Path__["a" /* Path */](childPathString);
        var childRef = this.ref_.child(childPath);
        return new DataSnapshot(this.node_.getChild(childPath), childRef, __WEBPACK_IMPORTED_MODULE_3__core_snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */]);
    };
    /**
     * Returns whether the snapshot contains a child at the specified path.
     *
     * @param {!string} childPathString Path to a child.
     * @return {boolean} Whether the child exists.
     */
    DataSnapshot.prototype.hasChild = function (childPathString) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('DataSnapshot.hasChild', 1, 1, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__core_util_validation__["d" /* validatePathString */])('DataSnapshot.hasChild', 1, childPathString, false);
        var childPath = new __WEBPACK_IMPORTED_MODULE_2__core_util_Path__["a" /* Path */](childPathString);
        return !this.node_.getChild(childPath).isEmpty();
    };
    /**
     * Returns the priority of the object, or null if no priority was set.
     *
     * @return {string|number|null} The priority.
     */
    DataSnapshot.prototype.getPriority = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('DataSnapshot.getPriority', 0, 0, arguments.length);
        // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)
        return this.node_.getPriority().val();
    };
    /**
     * Iterates through child nodes and calls the specified action for each one.
     *
     * @param {function(!DataSnapshot)} action Callback function to be called
     * for each child.
     * @return {boolean} True if forEach was canceled by action returning true for
     * one of the child nodes.
     */
    DataSnapshot.prototype.forEach = function (action) {
        var _this = this;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('DataSnapshot.forEach', 1, 1, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["H" /* validateCallback */])('DataSnapshot.forEach', 1, action, false);
        if (this.node_.isLeafNode())
            return false;
        var childrenNode = this.node_;
        // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...
        return !!childrenNode.forEachChild(this.index_, function (key, node) {
            return action(new DataSnapshot(node, _this.ref_.child(key), __WEBPACK_IMPORTED_MODULE_3__core_snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */]));
        });
    };
    /**
     * Returns whether this DataSnapshot has children.
     * @return {boolean} True if the DataSnapshot contains 1 or more child nodes.
     */
    DataSnapshot.prototype.hasChildren = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('DataSnapshot.hasChildren', 0, 0, arguments.length);
        if (this.node_.isLeafNode())
            return false;
        else
            return !this.node_.isEmpty();
    };
    Object.defineProperty(DataSnapshot.prototype, "key", {
        get: function () {
            return this.ref_.getKey();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the number of children for this DataSnapshot.
     * @return {number} The number of children that this DataSnapshot contains.
     */
    DataSnapshot.prototype.numChildren = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('DataSnapshot.numChildren', 0, 0, arguments.length);
        return this.node_.numChildren();
    };
    /**
     * @return {Reference} The Firebase reference for the location this snapshot's data came from.
     */
    DataSnapshot.prototype.getRef = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('DataSnapshot.ref', 0, 0, arguments.length);
        return this.ref_;
    };
    Object.defineProperty(DataSnapshot.prototype, "ref", {
        get: function () {
            return this.getRef();
        },
        enumerable: true,
        configurable: true
    });
    return DataSnapshot;
}());




/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Database; });
/* unused harmony export DatabaseInternals */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_util_libs_parser__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_util_Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Reference__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_Repo__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_RepoManager__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_util_validation__ = __webpack_require__(10);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Class representing a firebase database.
 * @implements {FirebaseService}
 */
var Database = /** @class */ (function () {
    /**
     * The constructor should not be called by users of our public API.
     * @param {!Repo} repo_
     */
    function Database(repo_) {
        this.repo_ = repo_;
        if (!(repo_ instanceof __WEBPACK_IMPORTED_MODULE_4__core_Repo__["a" /* Repo */])) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["q" /* fatal */])("Don't call new Database() directly - please use firebase.database().");
        }
        /** @type {Reference} */
        this.root_ = new __WEBPACK_IMPORTED_MODULE_3__Reference__["a" /* Reference */](repo_, __WEBPACK_IMPORTED_MODULE_2__core_util_Path__["a" /* Path */].Empty);
        this.INTERNAL = new DatabaseInternals(this);
    }
    Object.defineProperty(Database.prototype, "app", {
        get: function () {
            return this.repo_.app;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a reference to the root or the path specified in opt_pathString.
     * @param {string=} pathString
     * @return {!Reference} Firebase reference.
     */
    Database.prototype.ref = function (pathString) {
        this.checkDeleted_('ref');
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__firebase_util__["y" /* validateArgCount */])('database.ref', 0, 1, arguments.length);
        return pathString !== undefined ? this.root_.child(pathString) : this.root_;
    };
    /**
     * Returns a reference to the root or the path specified in url.
     * We throw a exception if the url is not in the same domain as the
     * current repo.
     * @param {string} url
     * @return {!Reference} Firebase reference.
     */
    Database.prototype.refFromURL = function (url) {
        /** @const {string} */
        var apiName = 'database.refFromURL';
        this.checkDeleted_(apiName);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__firebase_util__["y" /* validateArgCount */])(apiName, 1, 1, arguments.length);
        var parsedURL = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__core_util_libs_parser__["a" /* parseRepoInfo */])(url);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__core_util_validation__["a" /* validateUrl */])(apiName, 1, parsedURL);
        var repoInfo = parsedURL.repoInfo;
        if (repoInfo.host !== this.repo_.repoInfo_.host) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["q" /* fatal */])(apiName +
                ': Host name does not match the current database: ' +
                '(found ' +
                repoInfo.host +
                ' but expected ' +
                this.repo_.repoInfo_.host +
                ')');
        }
        return this.ref(parsedURL.path.toString());
    };
    /**
     * @param {string} apiName
     */
    Database.prototype.checkDeleted_ = function (apiName) {
        if (this.repo_ === null) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["q" /* fatal */])('Cannot call ' + apiName + ' on a deleted database.');
        }
    };
    // Make individual repo go offline.
    Database.prototype.goOffline = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__firebase_util__["y" /* validateArgCount */])('database.goOffline', 0, 0, arguments.length);
        this.checkDeleted_('goOffline');
        this.repo_.interrupt();
    };
    Database.prototype.goOnline = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__firebase_util__["y" /* validateArgCount */])('database.goOnline', 0, 0, arguments.length);
        this.checkDeleted_('goOnline');
        this.repo_.resume();
    };
    Database.ServerValue = {
        TIMESTAMP: {
            '.sv': 'timestamp'
        }
    };
    return Database;
}());

var DatabaseInternals = /** @class */ (function () {
    /** @param {!Database} database */
    function DatabaseInternals(database) {
        this.database = database;
    }
    /** @return {Promise<void>} */
    DatabaseInternals.prototype.delete = function () {
        this.database.checkDeleted_('delete');
        __WEBPACK_IMPORTED_MODULE_5__core_RepoManager__["a" /* RepoManager */].getInstance().deleteRepo(this.database.repo_);
        this.database.repo_ = null;
        this.database.root_ = null;
        this.database.INTERNAL = null;
        this.database = null;
        return Promise.resolve();
    };
    return DatabaseInternals;
}());




/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Query; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_snap_indexes_KeyIndex__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_snap_indexes_PriorityIndex__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_snap_indexes_ValueIndex__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_snap_indexes_PathIndex__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_util_Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_util_validation__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_view_EventRegistration__ = __webpack_require__(116);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











var __referenceConstructor;
/**
 * A Query represents a filter to be applied to a firebase location.  This object purely represents the
 * query expression (and exposes our public API to build the query).  The actual query logic is in ViewBase.js.
 *
 * Since every Firebase reference is a query, Firebase inherits from this object.
 */
var Query = /** @class */ (function () {
    function Query(repo, path, queryParams_, orderByCalled_) {
        this.repo = repo;
        this.path = path;
        this.queryParams_ = queryParams_;
        this.orderByCalled_ = orderByCalled_;
    }
    Object.defineProperty(Query, "__referenceConstructor", {
        get: function () {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(__referenceConstructor, 'Reference.ts has not been loaded');
            return __referenceConstructor;
        },
        set: function (val) {
            __referenceConstructor = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Validates start/end values for queries.
     * @param {!QueryParams} params
     * @private
     */
    Query.validateQueryEndpoints_ = function (params) {
        var startNode = null;
        var endNode = null;
        if (params.hasStart()) {
            startNode = params.getIndexStartValue();
        }
        if (params.hasEnd()) {
            endNode = params.getIndexEndValue();
        }
        if (params.getIndex() === __WEBPACK_IMPORTED_MODULE_1__core_snap_indexes_KeyIndex__["a" /* KEY_INDEX */]) {
            var tooManyArgsError = 'Query: When ordering by key, you may only pass one argument to ' +
                'startAt(), endAt(), or equalTo().';
            var wrongArgTypeError = 'Query: When ordering by key, the argument passed to startAt(), endAt(),' +
                'or equalTo() must be a string.';
            if (params.hasStart()) {
                var startName = params.getIndexStartName();
                if (startName != __WEBPACK_IMPORTED_MODULE_5__core_util_util__["v" /* MIN_NAME */]) {
                    throw new Error(tooManyArgsError);
                }
                else if (typeof startNode !== 'string') {
                    throw new Error(wrongArgTypeError);
                }
            }
            if (params.hasEnd()) {
                var endName = params.getIndexEndName();
                if (endName != __WEBPACK_IMPORTED_MODULE_5__core_util_util__["u" /* MAX_NAME */]) {
                    throw new Error(tooManyArgsError);
                }
                else if (typeof endNode !== 'string') {
                    throw new Error(wrongArgTypeError);
                }
            }
        }
        else if (params.getIndex() === __WEBPACK_IMPORTED_MODULE_2__core_snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */]) {
            if ((startNode != null && !__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__core_util_validation__["b" /* isValidPriority */])(startNode)) ||
                (endNode != null && !__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__core_util_validation__["b" /* isValidPriority */])(endNode))) {
                throw new Error('Query: When ordering by priority, the first argument passed to startAt(), ' +
                    'endAt(), or equalTo() must be a valid priority value (null, a number, or a string).');
            }
        }
        else {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(params.getIndex() instanceof __WEBPACK_IMPORTED_MODULE_4__core_snap_indexes_PathIndex__["a" /* PathIndex */] ||
                params.getIndex() === __WEBPACK_IMPORTED_MODULE_3__core_snap_indexes_ValueIndex__["a" /* VALUE_INDEX */], 'unknown index type.');
            if ((startNode != null && typeof startNode === 'object') ||
                (endNode != null && typeof endNode === 'object')) {
                throw new Error('Query: First argument passed to startAt(), endAt(), or equalTo() cannot be ' +
                    'an object.');
            }
        }
    };
    /**
     * Validates that limit* has been called with the correct combination of parameters
     * @param {!QueryParams} params
     * @private
     */
    Query.validateLimit_ = function (params) {
        if (params.hasStart() &&
            params.hasEnd() &&
            params.hasLimit() &&
            !params.hasAnchoredLimit()) {
            throw new Error("Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.");
        }
    };
    /**
     * Validates that no other order by call has been made
     * @param {!string} fnName
     * @private
     */
    Query.prototype.validateNoPreviousOrderByCall_ = function (fnName) {
        if (this.orderByCalled_ === true) {
            throw new Error(fnName + ": You can't combine multiple orderBy calls.");
        }
    };
    /**
     * @return {!QueryParams}
     */
    Query.prototype.getQueryParams = function () {
        return this.queryParams_;
    };
    /**
     * @return {!Reference}
     */
    Query.prototype.getRef = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('Query.ref', 0, 0, arguments.length);
        // This is a slight hack. We cannot goog.require('fb.api.Firebase'), since Firebase requires fb.api.Query.
        // However, we will always export 'Firebase' to the global namespace, so it's guaranteed to exist by the time this
        // method gets called.
        return new Query.__referenceConstructor(this.repo, this.path);
    };
    /**
     * @param {!string} eventType
     * @param {!function(DataSnapshot, string=)} callback
     * @param {(function(Error)|Object)=} cancelCallbackOrContext
     * @param {Object=} context
     * @return {!function(DataSnapshot, string=)}
     */
    Query.prototype.on = function (eventType, callback, cancelCallbackOrContext, context) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('Query.on', 2, 4, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__core_util_validation__["c" /* validateEventType */])('Query.on', 1, eventType, false);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["H" /* validateCallback */])('Query.on', 2, callback, false);
        var ret = Query.getCancelAndContextArgs_('Query.on', cancelCallbackOrContext, context);
        if (eventType === 'value') {
            this.onValueEvent(callback, ret.cancel, ret.context);
        }
        else {
            var callbacks = {};
            callbacks[eventType] = callback;
            this.onChildEvent(callbacks, ret.cancel, ret.context);
        }
        return callback;
    };
    /**
     * @param {!function(!DataSnapshot)} callback
     * @param {?function(Error)} cancelCallback
     * @param {?Object} context
     * @protected
     */
    Query.prototype.onValueEvent = function (callback, cancelCallback, context) {
        var container = new __WEBPACK_IMPORTED_MODULE_8__core_view_EventRegistration__["a" /* ValueEventRegistration */](callback, cancelCallback || null, context || null);
        this.repo.addEventCallbackForQuery(this, container);
    };
    /**
     * @param {!Object.<string, !function(!DataSnapshot, ?string)>} callbacks
     * @param {?function(Error)} cancelCallback
     * @param {?Object} context
     * @protected
     */
    Query.prototype.onChildEvent = function (callbacks, cancelCallback, context) {
        var container = new __WEBPACK_IMPORTED_MODULE_8__core_view_EventRegistration__["b" /* ChildEventRegistration */](callbacks, cancelCallback, context);
        this.repo.addEventCallbackForQuery(this, container);
    };
    /**
     * @param {string=} eventType
     * @param {(function(!DataSnapshot, ?string=))=} callback
     * @param {Object=} context
     */
    Query.prototype.off = function (eventType, callback, context) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('Query.off', 0, 3, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__core_util_validation__["c" /* validateEventType */])('Query.off', 1, eventType, true);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["H" /* validateCallback */])('Query.off', 2, callback, true);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["I" /* validateContextObject */])('Query.off', 3, context, true);
        var container = null;
        var callbacks = null;
        if (eventType === 'value') {
            var valueCallback = callback || null;
            container = new __WEBPACK_IMPORTED_MODULE_8__core_view_EventRegistration__["a" /* ValueEventRegistration */](valueCallback, null, context || null);
        }
        else if (eventType) {
            if (callback) {
                callbacks = {};
                callbacks[eventType] = callback;
            }
            container = new __WEBPACK_IMPORTED_MODULE_8__core_view_EventRegistration__["b" /* ChildEventRegistration */](callbacks, null, context || null);
        }
        this.repo.removeEventCallbackForQuery(this, container);
    };
    /**
     * Attaches a listener, waits for the first event, and then removes the listener
     * @param {!string} eventType
     * @param {!function(!DataSnapshot, string=)} userCallback
     * @param cancelOrContext
     * @param context
     * @return {!firebase.Promise}
     */
    Query.prototype.once = function (eventType, userCallback, cancelOrContext, context) {
        var _this = this;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('Query.once', 1, 4, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__core_util_validation__["c" /* validateEventType */])('Query.once', 1, eventType, false);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["H" /* validateCallback */])('Query.once', 2, userCallback, true);
        var ret = Query.getCancelAndContextArgs_('Query.once', cancelOrContext, context);
        // TODO: Implement this more efficiently (in particular, use 'get' wire protocol for 'value' event)
        // TODO: consider actually wiring the callbacks into the promise. We cannot do this without a breaking change
        // because the API currently expects callbacks will be called synchronously if the data is cached, but this is
        // against the Promise specification.
        var firstCall = true;
        var deferred = new __WEBPACK_IMPORTED_MODULE_0__firebase_util__["J" /* Deferred */]();
        // A dummy error handler in case a user wasn't expecting promises
        deferred.promise.catch(function () { });
        var onceCallback = function (snapshot) {
            // NOTE: Even though we unsubscribe, we may get called multiple times if a single action (e.g. set() with JSON)
            // triggers multiple events (e.g. child_added or child_changed).
            if (firstCall) {
                firstCall = false;
                _this.off(eventType, onceCallback);
                if (userCallback) {
                    userCallback.bind(ret.context)(snapshot);
                }
                deferred.resolve(snapshot);
            }
        };
        this.on(eventType, onceCallback, 
        /*cancel=*/ function (err) {
            _this.off(eventType, onceCallback);
            if (ret.cancel)
                ret.cancel.bind(ret.context)(err);
            deferred.reject(err);
        });
        return deferred.promise;
    };
    /**
     * Set a limit and anchor it to the start of the window.
     * @param {!number} limit
     * @return {!Query}
     */
    Query.prototype.limitToFirst = function (limit) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('Query.limitToFirst', 1, 1, arguments.length);
        if (typeof limit !== 'number' ||
            Math.floor(limit) !== limit ||
            limit <= 0) {
            throw new Error('Query.limitToFirst: First argument must be a positive integer.');
        }
        if (this.queryParams_.hasLimit()) {
            throw new Error('Query.limitToFirst: Limit was already set (by another call to limit, ' +
                'limitToFirst, or limitToLast).');
        }
        return new Query(this.repo, this.path, this.queryParams_.limitToFirst(limit), this.orderByCalled_);
    };
    /**
     * Set a limit and anchor it to the end of the window.
     * @param {!number} limit
     * @return {!Query}
     */
    Query.prototype.limitToLast = function (limit) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('Query.limitToLast', 1, 1, arguments.length);
        if (typeof limit !== 'number' ||
            Math.floor(limit) !== limit ||
            limit <= 0) {
            throw new Error('Query.limitToLast: First argument must be a positive integer.');
        }
        if (this.queryParams_.hasLimit()) {
            throw new Error('Query.limitToLast: Limit was already set (by another call to limit, ' +
                'limitToFirst, or limitToLast).');
        }
        return new Query(this.repo, this.path, this.queryParams_.limitToLast(limit), this.orderByCalled_);
    };
    /**
     * Given a child path, return a new query ordered by the specified grandchild path.
     * @param {!string} path
     * @return {!Query}
     */
    Query.prototype.orderByChild = function (path) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('Query.orderByChild', 1, 1, arguments.length);
        if (path === '$key') {
            throw new Error('Query.orderByChild: "$key" is invalid.  Use Query.orderByKey() instead.');
        }
        else if (path === '$priority') {
            throw new Error('Query.orderByChild: "$priority" is invalid.  Use Query.orderByPriority() instead.');
        }
        else if (path === '$value') {
            throw new Error('Query.orderByChild: "$value" is invalid.  Use Query.orderByValue() instead.');
        }
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__core_util_validation__["d" /* validatePathString */])('Query.orderByChild', 1, path, false);
        this.validateNoPreviousOrderByCall_('Query.orderByChild');
        var parsedPath = new __WEBPACK_IMPORTED_MODULE_6__core_util_Path__["a" /* Path */](path);
        if (parsedPath.isEmpty()) {
            throw new Error('Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.');
        }
        var index = new __WEBPACK_IMPORTED_MODULE_4__core_snap_indexes_PathIndex__["a" /* PathIndex */](parsedPath);
        var newParams = this.queryParams_.orderBy(index);
        Query.validateQueryEndpoints_(newParams);
        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);
    };
    /**
     * Return a new query ordered by the KeyIndex
     * @return {!Query}
     */
    Query.prototype.orderByKey = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('Query.orderByKey', 0, 0, arguments.length);
        this.validateNoPreviousOrderByCall_('Query.orderByKey');
        var newParams = this.queryParams_.orderBy(__WEBPACK_IMPORTED_MODULE_1__core_snap_indexes_KeyIndex__["a" /* KEY_INDEX */]);
        Query.validateQueryEndpoints_(newParams);
        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);
    };
    /**
     * Return a new query ordered by the PriorityIndex
     * @return {!Query}
     */
    Query.prototype.orderByPriority = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('Query.orderByPriority', 0, 0, arguments.length);
        this.validateNoPreviousOrderByCall_('Query.orderByPriority');
        var newParams = this.queryParams_.orderBy(__WEBPACK_IMPORTED_MODULE_2__core_snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */]);
        Query.validateQueryEndpoints_(newParams);
        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);
    };
    /**
     * Return a new query ordered by the ValueIndex
     * @return {!Query}
     */
    Query.prototype.orderByValue = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('Query.orderByValue', 0, 0, arguments.length);
        this.validateNoPreviousOrderByCall_('Query.orderByValue');
        var newParams = this.queryParams_.orderBy(__WEBPACK_IMPORTED_MODULE_3__core_snap_indexes_ValueIndex__["a" /* VALUE_INDEX */]);
        Query.validateQueryEndpoints_(newParams);
        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);
    };
    /**
     * @param {number|string|boolean|null} value
     * @param {?string=} name
     * @return {!Query}
     */
    Query.prototype.startAt = function (value, name) {
        if (value === void 0) { value = null; }
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('Query.startAt', 0, 2, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__core_util_validation__["e" /* validateFirebaseDataArg */])('Query.startAt', 1, value, this.path, true);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__core_util_validation__["f" /* validateKey */])('Query.startAt', 2, name, true);
        var newParams = this.queryParams_.startAt(value, name);
        Query.validateLimit_(newParams);
        Query.validateQueryEndpoints_(newParams);
        if (this.queryParams_.hasStart()) {
            throw new Error('Query.startAt: Starting point was already set (by another call to startAt ' +
                'or equalTo).');
        }
        // Calling with no params tells us to start at the beginning.
        if (value === undefined) {
            value = null;
            name = null;
        }
        return new Query(this.repo, this.path, newParams, this.orderByCalled_);
    };
    /**
     * @param {number|string|boolean|null} value
     * @param {?string=} name
     * @return {!Query}
     */
    Query.prototype.endAt = function (value, name) {
        if (value === void 0) { value = null; }
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('Query.endAt', 0, 2, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__core_util_validation__["e" /* validateFirebaseDataArg */])('Query.endAt', 1, value, this.path, true);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__core_util_validation__["f" /* validateKey */])('Query.endAt', 2, name, true);
        var newParams = this.queryParams_.endAt(value, name);
        Query.validateLimit_(newParams);
        Query.validateQueryEndpoints_(newParams);
        if (this.queryParams_.hasEnd()) {
            throw new Error('Query.endAt: Ending point was already set (by another call to endAt or ' +
                'equalTo).');
        }
        return new Query(this.repo, this.path, newParams, this.orderByCalled_);
    };
    /**
     * Load the selection of children with exactly the specified value, and, optionally,
     * the specified name.
     * @param {number|string|boolean|null} value
     * @param {string=} name
     * @return {!Query}
     */
    Query.prototype.equalTo = function (value, name) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('Query.equalTo', 1, 2, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__core_util_validation__["e" /* validateFirebaseDataArg */])('Query.equalTo', 1, value, this.path, false);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__core_util_validation__["f" /* validateKey */])('Query.equalTo', 2, name, true);
        if (this.queryParams_.hasStart()) {
            throw new Error('Query.equalTo: Starting point was already set (by another call to startAt or ' +
                'equalTo).');
        }
        if (this.queryParams_.hasEnd()) {
            throw new Error('Query.equalTo: Ending point was already set (by another call to endAt or ' +
                'equalTo).');
        }
        return this.startAt(value, name).endAt(value, name);
    };
    /**
     * @return {!string} URL for this location.
     */
    Query.prototype.toString = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('Query.toString', 0, 0, arguments.length);
        return this.repo.toString() + this.path.toUrlEncodedString();
    };
    // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary
    // for end-users.
    Query.prototype.toJSON = function () {
        // An optional spacer argument is unnecessary for a string.
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('Query.toJSON', 0, 1, arguments.length);
        return this.toString();
    };
    /**
     * An object representation of the query parameters used by this Query.
     * @return {!Object}
     */
    Query.prototype.queryObject = function () {
        return this.queryParams_.getQueryObject();
    };
    /**
     * @return {!string}
     */
    Query.prototype.queryIdentifier = function () {
        var obj = this.queryObject();
        var id = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__core_util_util__["o" /* ObjectToUniqueKey */])(obj);
        return id === '{}' ? 'default' : id;
    };
    /**
     * Return true if this query and the provided query are equivalent; otherwise, return false.
     * @param {Query} other
     * @return {boolean}
     */
    Query.prototype.isEqual = function (other) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('Query.isEqual', 1, 1, arguments.length);
        if (!(other instanceof Query)) {
            var error = 'Query.isEqual failed: First argument must be an instance of firebase.database.Query.';
            throw new Error(error);
        }
        var sameRepo = this.repo === other.repo;
        var samePath = this.path.equals(other.path);
        var sameQueryIdentifier = this.queryIdentifier() === other.queryIdentifier();
        return sameRepo && samePath && sameQueryIdentifier;
    };
    /**
     * Helper used by .on and .once to extract the context and or cancel arguments.
     * @param {!string} fnName The function name (on or once)
     * @param {(function(Error)|Object)=} cancelOrContext
     * @param {Object=} context
     * @return {{cancel: ?function(Error), context: ?Object}}
     * @private
     */
    Query.getCancelAndContextArgs_ = function (fnName, cancelOrContext, context) {
        var ret = { cancel: null, context: null };
        if (cancelOrContext && context) {
            ret.cancel = cancelOrContext;
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["H" /* validateCallback */])(fnName, 3, ret.cancel, true);
            ret.context = context;
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["I" /* validateContextObject */])(fnName, 4, ret.context, true);
        }
        else if (cancelOrContext) {
            // we have either a cancel callback or a context.
            if (typeof cancelOrContext === 'object' && cancelOrContext !== null) {
                // it's a context!
                ret.context = cancelOrContext;
            }
            else if (typeof cancelOrContext === 'function') {
                ret.cancel = cancelOrContext;
            }
            else {
                throw new Error(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["z" /* errorPrefix */])(fnName, 3, true) +
                    ' must either be a cancel callback or a context object.');
            }
        }
        return ret;
    };
    Object.defineProperty(Query.prototype, "ref", {
        get: function () {
            return this.getRef();
        },
        enumerable: true,
        configurable: true
    });
    return Query;
}());




/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PersistentConnection; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_VisibilityMonitor__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_OnlineMonitor__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__realtime_Connection__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ServerActions__ = __webpack_require__(40);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();













var RECONNECT_MIN_DELAY = 1000;
var RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)
var RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)
var RECONNECT_DELAY_MULTIPLIER = 1.3;
var RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.
var SERVER_KILL_INTERRUPT_REASON = 'server_kill';
// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.
var INVALID_AUTH_TOKEN_THRESHOLD = 3;
/**
 * Firebase connection.  Abstracts wire protocol and handles reconnecting.
 *
 * NOTE: All JSON objects sent to the realtime connection must have property names enclosed
 * in quotes to make sure the closure compiler does not minify them.
 */
var PersistentConnection = /** @class */ (function (_super) {
    __extends(PersistentConnection, _super);
    /**
     * @implements {ServerActions}
     * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to
     * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server
     * @param onConnectStatus_
     * @param onServerInfoUpdate_
     * @param authTokenProvider_
     * @param authOverride_
     */
    function PersistentConnection(repoInfo_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, authOverride_) {
        var _this = _super.call(this) || this;
        _this.repoInfo_ = repoInfo_;
        _this.onDataUpdate_ = onDataUpdate_;
        _this.onConnectStatus_ = onConnectStatus_;
        _this.onServerInfoUpdate_ = onServerInfoUpdate_;
        _this.authTokenProvider_ = authTokenProvider_;
        _this.authOverride_ = authOverride_;
        // Used for diagnostic logging.
        _this.id = PersistentConnection.nextPersistentConnectionId_++;
        _this.log_ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_util__["b" /* logWrapper */])('p:' + _this.id + ':');
        /** @private {Object} */
        _this.interruptReasons_ = {};
        _this.listens_ = {};
        _this.outstandingPuts_ = [];
        _this.outstandingPutCount_ = 0;
        _this.onDisconnectRequestQueue_ = [];
        _this.connected_ = false;
        _this.reconnectDelay_ = RECONNECT_MIN_DELAY;
        _this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;
        _this.securityDebugCallback_ = null;
        _this.lastSessionId = null;
        /** @private {number|null} */
        _this.establishConnectionTimer_ = null;
        /** @private {boolean} */
        _this.visible_ = false;
        // Before we get connected, we keep a queue of pending messages to send.
        _this.requestCBHash_ = {};
        _this.requestNumber_ = 0;
        /** @private {?{
         *   sendRequest(Object),
         *   close()
         * }} */
        _this.realtime_ = null;
        /** @private {string|null} */
        _this.authToken_ = null;
        _this.forceTokenRefresh_ = false;
        _this.invalidAuthTokenCount_ = 0;
        _this.firstConnection_ = true;
        _this.lastConnectionAttemptTime_ = null;
        _this.lastConnectionEstablishedTime_ = null;
        if (authOverride_ && !__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["f" /* isNodeSdk */])()) {
            throw new Error('Auth override specified in options, but not supported on non Node.js platforms');
        }
        _this.scheduleConnect_(0);
        __WEBPACK_IMPORTED_MODULE_4__util_VisibilityMonitor__["a" /* VisibilityMonitor */].getInstance().on('visible', _this.onVisible_, _this);
        if (repoInfo_.host.indexOf('fblocal') === -1) {
            __WEBPACK_IMPORTED_MODULE_5__util_OnlineMonitor__["a" /* OnlineMonitor */].getInstance().on('online', _this.onOnline_, _this);
        }
        return _this;
    }
    /**
     * @param {!string} action
     * @param {*} body
     * @param {function(*)=} onResponse
     * @protected
     */
    PersistentConnection.prototype.sendRequest = function (action, body, onResponse) {
        var curReqNum = ++this.requestNumber_;
        var msg = { r: curReqNum, a: action, b: body };
        this.log_(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["j" /* stringify */])(msg));
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["g" /* assert */])(this.connected_, "sendRequest call when we're not connected not allowed.");
        this.realtime_.sendRequest(msg);
        if (onResponse) {
            this.requestCBHash_[curReqNum] = onResponse;
        }
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.listen = function (query, currentHashFn, tag, onComplete) {
        var queryId = query.queryIdentifier();
        var pathString = query.path.toString();
        this.log_('Listen called for ' + pathString + ' ' + queryId);
        this.listens_[pathString] = this.listens_[pathString] || {};
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["g" /* assert */])(query.getQueryParams().isDefault() ||
            !query.getQueryParams().loadsAllData(), 'listen() called for non-default but complete query');
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["g" /* assert */])(!this.listens_[pathString][queryId], 'listen() called twice for same path/queryId.');
        var listenSpec = {
            onComplete: onComplete,
            hashFn: currentHashFn,
            query: query,
            tag: tag
        };
        this.listens_[pathString][queryId] = listenSpec;
        if (this.connected_) {
            this.sendListen_(listenSpec);
        }
    };
    /**
     * @param {!{onComplete(),
     *           hashFn():!string,
     *           query: !Query,
     *           tag: ?number}} listenSpec
     * @private
     */
    PersistentConnection.prototype.sendListen_ = function (listenSpec) {
        var _this = this;
        var query = listenSpec.query;
        var pathString = query.path.toString();
        var queryId = query.queryIdentifier();
        this.log_('Listen on ' + pathString + ' for ' + queryId);
        var req = { /*path*/ p: pathString };
        var action = 'q';
        // Only bother to send query if it's non-default.
        if (listenSpec.tag) {
            req['q'] = query.queryObject();
            req['t'] = listenSpec.tag;
        }
        req['h'] = listenSpec.hashFn();
        this.sendRequest(action, req, function (message) {
            var payload = message['d'];
            var status = message['s'];
            // print warnings in any case...
            PersistentConnection.warnOnListenWarnings_(payload, query);
            var currentListenSpec = _this.listens_[pathString] && _this.listens_[pathString][queryId];
            // only trigger actions if the listen hasn't been removed and readded
            if (currentListenSpec === listenSpec) {
                _this.log_('listen response', message);
                if (status !== 'ok') {
                    _this.removeListen_(pathString, queryId);
                }
                if (listenSpec.onComplete) {
                    listenSpec.onComplete(status, payload);
                }
            }
        });
    };
    /**
     * @param {*} payload
     * @param {!Query} query
     * @private
     */
    PersistentConnection.warnOnListenWarnings_ = function (payload, query) {
        if (payload && typeof payload === 'object' && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["i" /* contains */])(payload, 'w')) {
            var warnings = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["s" /* safeGet */])(payload, 'w');
            if (Array.isArray(warnings) && ~warnings.indexOf('no_index')) {
                var indexSpec = '".indexOn": "' +
                    query
                        .getQueryParams()
                        .getIndex()
                        .toString() +
                    '"';
                var indexPath = query.path.toString();
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_util__["f" /* warn */])("Using an unspecified index. Your data will be downloaded and " +
                    ("filtered on the client. Consider adding " + indexSpec + " at ") +
                    (indexPath + " to your security rules for better performance."));
            }
        }
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.refreshAuthToken = function (token) {
        this.authToken_ = token;
        this.log_('Auth token refreshed');
        if (this.authToken_) {
            this.tryAuth();
        }
        else {
            //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete
            //the credential so we dont become authenticated next time we connect.
            if (this.connected_) {
                this.sendRequest('unauth', {}, function () { });
            }
        }
        this.reduceReconnectDelayIfAdminCredential_(token);
    };
    /**
     * @param {!string} credential
     * @private
     */
    PersistentConnection.prototype.reduceReconnectDelayIfAdminCredential_ = function (credential) {
        // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).
        // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.
        var isFirebaseSecret = credential && credential.length === 40;
        if (isFirebaseSecret || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["t" /* isAdmin */])(credential)) {
            this.log_('Admin auth credential detected.  Reducing max reconnect time.');
            this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
        }
    };
    /**
     * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like
     * a auth revoked (the connection is closed).
     */
    PersistentConnection.prototype.tryAuth = function () {
        var _this = this;
        if (this.connected_ && this.authToken_) {
            var token_1 = this.authToken_;
            var authMethod = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["u" /* isValidFormat */])(token_1) ? 'auth' : 'gauth';
            var requestData = { cred: token_1 };
            if (this.authOverride_ === null) {
                requestData['noauth'] = true;
            }
            else if (typeof this.authOverride_ === 'object') {
                requestData['authvar'] = this.authOverride_;
            }
            this.sendRequest(authMethod, requestData, function (res) {
                var status = res['s'];
                var data = res['d'] || 'error';
                if (_this.authToken_ === token_1) {
                    if (status === 'ok') {
                        _this.invalidAuthTokenCount_ = 0;
                    }
                    else {
                        // Triggers reconnect and force refresh for auth token
                        _this.onAuthRevoked_(status, data);
                    }
                }
            });
        }
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.unlisten = function (query, tag) {
        var pathString = query.path.toString();
        var queryId = query.queryIdentifier();
        this.log_('Unlisten called for ' + pathString + ' ' + queryId);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["g" /* assert */])(query.getQueryParams().isDefault() ||
            !query.getQueryParams().loadsAllData(), 'unlisten() called for non-default but complete query');
        var listen = this.removeListen_(pathString, queryId);
        if (listen && this.connected_) {
            this.sendUnlisten_(pathString, queryId, query.queryObject(), tag);
        }
    };
    PersistentConnection.prototype.sendUnlisten_ = function (pathString, queryId, queryObj, tag) {
        this.log_('Unlisten on ' + pathString + ' for ' + queryId);
        var req = { /*path*/ p: pathString };
        var action = 'n';
        // Only bother sending queryId if it's non-default.
        if (tag) {
            req['q'] = queryObj;
            req['t'] = tag;
        }
        this.sendRequest(action, req);
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.onDisconnectPut = function (pathString, data, onComplete) {
        if (this.connected_) {
            this.sendOnDisconnect_('o', pathString, data, onComplete);
        }
        else {
            this.onDisconnectRequestQueue_.push({
                pathString: pathString,
                action: 'o',
                data: data,
                onComplete: onComplete
            });
        }
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.onDisconnectMerge = function (pathString, data, onComplete) {
        if (this.connected_) {
            this.sendOnDisconnect_('om', pathString, data, onComplete);
        }
        else {
            this.onDisconnectRequestQueue_.push({
                pathString: pathString,
                action: 'om',
                data: data,
                onComplete: onComplete
            });
        }
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.onDisconnectCancel = function (pathString, onComplete) {
        if (this.connected_) {
            this.sendOnDisconnect_('oc', pathString, null, onComplete);
        }
        else {
            this.onDisconnectRequestQueue_.push({
                pathString: pathString,
                action: 'oc',
                data: null,
                onComplete: onComplete
            });
        }
    };
    PersistentConnection.prototype.sendOnDisconnect_ = function (action, pathString, data, onComplete) {
        var request = { /*path*/ p: pathString, /*data*/ d: data };
        this.log_('onDisconnect ' + action, request);
        this.sendRequest(action, request, function (response) {
            if (onComplete) {
                setTimeout(function () {
                    onComplete(response['s'], response['d']);
                }, Math.floor(0));
            }
        });
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.put = function (pathString, data, onComplete, hash) {
        this.putInternal('p', pathString, data, onComplete, hash);
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.merge = function (pathString, data, onComplete, hash) {
        this.putInternal('m', pathString, data, onComplete, hash);
    };
    PersistentConnection.prototype.putInternal = function (action, pathString, data, onComplete, hash) {
        var request = {
            /*path*/ p: pathString,
            /*data*/ d: data
        };
        if (hash !== undefined)
            request['h'] = hash;
        // TODO: Only keep track of the most recent put for a given path?
        this.outstandingPuts_.push({
            action: action,
            request: request,
            onComplete: onComplete
        });
        this.outstandingPutCount_++;
        var index = this.outstandingPuts_.length - 1;
        if (this.connected_) {
            this.sendPut_(index);
        }
        else {
            this.log_('Buffering put: ' + pathString);
        }
    };
    PersistentConnection.prototype.sendPut_ = function (index) {
        var _this = this;
        var action = this.outstandingPuts_[index].action;
        var request = this.outstandingPuts_[index].request;
        var onComplete = this.outstandingPuts_[index].onComplete;
        this.outstandingPuts_[index].queued = this.connected_;
        this.sendRequest(action, request, function (message) {
            _this.log_(action + ' response', message);
            delete _this.outstandingPuts_[index];
            _this.outstandingPutCount_--;
            // Clean up array occasionally.
            if (_this.outstandingPutCount_ === 0) {
                _this.outstandingPuts_ = [];
            }
            if (onComplete)
                onComplete(message['s'], message['d']);
        });
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.reportStats = function (stats) {
        var _this = this;
        // If we're not connected, we just drop the stats.
        if (this.connected_) {
            var request = { /*counters*/ c: stats };
            this.log_('reportStats', request);
            this.sendRequest(/*stats*/ 's', request, function (result) {
                var status = result['s'];
                if (status !== 'ok') {
                    var errorReason = result['d'];
                    _this.log_('reportStats', 'Error sending stats: ' + errorReason);
                }
            });
        }
    };
    /**
     * @param {*} message
     * @private
     */
    PersistentConnection.prototype.onDataMessage_ = function (message) {
        if ('r' in message) {
            // this is a response
            this.log_('from server: ' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["j" /* stringify */])(message));
            var reqNum = message['r'];
            var onResponse = this.requestCBHash_[reqNum];
            if (onResponse) {
                delete this.requestCBHash_[reqNum];
                onResponse(message['b']);
            }
        }
        else if ('error' in message) {
            throw 'A server-side error has occurred: ' + message['error'];
        }
        else if ('a' in message) {
            // a and b are action and body, respectively
            this.onDataPush_(message['a'], message['b']);
        }
    };
    PersistentConnection.prototype.onDataPush_ = function (action, body) {
        this.log_('handleServerMessage', action, body);
        if (action === 'd')
            this.onDataUpdate_(body['p'], body['d'], 
            /*isMerge*/ false, body['t']);
        else if (action === 'm')
            this.onDataUpdate_(body['p'], body['d'], 
            /*isMerge=*/ true, body['t']);
        else if (action === 'c')
            this.onListenRevoked_(body['p'], body['q']);
        else if (action === 'ac')
            this.onAuthRevoked_(body['s'], body['d']);
        else if (action === 'sd')
            this.onSecurityDebugPacket_(body);
        else
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_util__["e" /* error */])('Unrecognized action received from server: ' +
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["j" /* stringify */])(action) +
                '\nAre you using the latest client?');
    };
    PersistentConnection.prototype.onReady_ = function (timestamp, sessionId) {
        this.log_('connection ready');
        this.connected_ = true;
        this.lastConnectionEstablishedTime_ = new Date().getTime();
        this.handleTimestamp_(timestamp);
        this.lastSessionId = sessionId;
        if (this.firstConnection_) {
            this.sendConnectStats_();
        }
        this.restoreState_();
        this.firstConnection_ = false;
        this.onConnectStatus_(true);
    };
    PersistentConnection.prototype.scheduleConnect_ = function (timeout) {
        var _this = this;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["g" /* assert */])(!this.realtime_, "Scheduling a connect when we're already connected/ing?");
        if (this.establishConnectionTimer_) {
            clearTimeout(this.establishConnectionTimer_);
        }
        // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating "Security Error" in
        // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).
        this.establishConnectionTimer_ = setTimeout(function () {
            _this.establishConnectionTimer_ = null;
            _this.establishConnection_();
        }, Math.floor(timeout));
    };
    /**
     * @param {boolean} visible
     * @private
     */
    PersistentConnection.prototype.onVisible_ = function (visible) {
        // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.
        if (visible &&
            !this.visible_ &&
            this.reconnectDelay_ === this.maxReconnectDelay_) {
            this.log_('Window became visible.  Reducing delay.');
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) {
                this.scheduleConnect_(0);
            }
        }
        this.visible_ = visible;
    };
    PersistentConnection.prototype.onOnline_ = function (online) {
        if (online) {
            this.log_('Browser went online.');
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) {
                this.scheduleConnect_(0);
            }
        }
        else {
            this.log_('Browser went offline.  Killing connection.');
            if (this.realtime_) {
                this.realtime_.close();
            }
        }
    };
    PersistentConnection.prototype.onRealtimeDisconnect_ = function () {
        this.log_('data client disconnected');
        this.connected_ = false;
        this.realtime_ = null;
        // Since we don't know if our sent transactions succeeded or not, we need to cancel them.
        this.cancelSentTransactions_();
        // Clear out the pending requests.
        this.requestCBHash_ = {};
        if (this.shouldReconnect_()) {
            if (!this.visible_) {
                this.log_("Window isn't visible.  Delaying reconnect.");
                this.reconnectDelay_ = this.maxReconnectDelay_;
                this.lastConnectionAttemptTime_ = new Date().getTime();
            }
            else if (this.lastConnectionEstablishedTime_) {
                // If we've been connected long enough, reset reconnect delay to minimum.
                var timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;
                if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT)
                    this.reconnectDelay_ = RECONNECT_MIN_DELAY;
                this.lastConnectionEstablishedTime_ = null;
            }
            var timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;
            var reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);
            reconnectDelay = Math.random() * reconnectDelay;
            this.log_('Trying to reconnect in ' + reconnectDelay + 'ms');
            this.scheduleConnect_(reconnectDelay);
            // Adjust reconnect delay for next time.
            this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);
        }
        this.onConnectStatus_(false);
    };
    PersistentConnection.prototype.establishConnection_ = function () {
        if (this.shouldReconnect_()) {
            this.log_('Making a connection attempt');
            this.lastConnectionAttemptTime_ = new Date().getTime();
            this.lastConnectionEstablishedTime_ = null;
            var onDataMessage_1 = this.onDataMessage_.bind(this);
            var onReady_1 = this.onReady_.bind(this);
            var onDisconnect_1 = this.onRealtimeDisconnect_.bind(this);
            var connId_1 = this.id + ':' + PersistentConnection.nextConnectionId_++;
            var self_1 = this;
            var lastSessionId_1 = this.lastSessionId;
            var canceled_1 = false;
            var connection_1 = null;
            var closeFn_1 = function () {
                if (connection_1) {
                    connection_1.close();
                }
                else {
                    canceled_1 = true;
                    onDisconnect_1();
                }
            };
            var sendRequestFn = function (msg) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["g" /* assert */])(connection_1, "sendRequest call when we're not connected not allowed.");
                connection_1.sendRequest(msg);
            };
            this.realtime_ = {
                close: closeFn_1,
                sendRequest: sendRequestFn
            };
            var forceRefresh = this.forceTokenRefresh_;
            this.forceTokenRefresh_ = false;
            // First fetch auth token, and establish connection after fetching the token was successful
            this.authTokenProvider_
                .getToken(forceRefresh)
                .then(function (result) {
                if (!canceled_1) {
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_util__["m" /* log */])('getToken() completed. Creating connection.');
                    self_1.authToken_ = result && result.accessToken;
                    connection_1 = new __WEBPACK_IMPORTED_MODULE_6__realtime_Connection__["a" /* Connection */](connId_1, self_1.repoInfo_, onDataMessage_1, onReady_1, onDisconnect_1, 
                    /* onKill= */ function (reason) {
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_util__["f" /* warn */])(reason + ' (' + self_1.repoInfo_.toString() + ')');
                        self_1.interrupt(SERVER_KILL_INTERRUPT_REASON);
                    }, lastSessionId_1);
                }
                else {
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_util__["m" /* log */])('getToken() completed but was canceled');
                }
            })
                .then(null, function (error) {
                self_1.log_('Failed to get token: ' + error);
                if (!canceled_1) {
                    if (__WEBPACK_IMPORTED_MODULE_1__firebase_util__["o" /* CONSTANTS */].NODE_ADMIN) {
                        // This may be a critical error for the Admin Node.js SDK, so log a warning.
                        // But getToken() may also just have temporarily failed, so we still want to
                        // continue retrying.
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_util__["f" /* warn */])(error);
                    }
                    closeFn_1();
                }
            });
        }
    };
    /**
     * @param {string} reason
     */
    PersistentConnection.prototype.interrupt = function (reason) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_util__["m" /* log */])('Interrupting connection for reason: ' + reason);
        this.interruptReasons_[reason] = true;
        if (this.realtime_) {
            this.realtime_.close();
        }
        else {
            if (this.establishConnectionTimer_) {
                clearTimeout(this.establishConnectionTimer_);
                this.establishConnectionTimer_ = null;
            }
            if (this.connected_) {
                this.onRealtimeDisconnect_();
            }
        }
    };
    /**
     * @param {string} reason
     */
    PersistentConnection.prototype.resume = function (reason) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_util__["m" /* log */])('Resuming connection for reason: ' + reason);
        delete this.interruptReasons_[reason];
        if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["q" /* isEmpty */])(this.interruptReasons_)) {
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) {
                this.scheduleConnect_(0);
            }
        }
    };
    PersistentConnection.prototype.handleTimestamp_ = function (timestamp) {
        var delta = timestamp - new Date().getTime();
        this.onServerInfoUpdate_({ serverTimeOffset: delta });
    };
    PersistentConnection.prototype.cancelSentTransactions_ = function () {
        for (var i = 0; i < this.outstandingPuts_.length; i++) {
            var put = this.outstandingPuts_[i];
            if (put && /*hash*/ 'h' in put.request && put.queued) {
                if (put.onComplete)
                    put.onComplete('disconnect');
                delete this.outstandingPuts_[i];
                this.outstandingPutCount_--;
            }
        }
        // Clean up array occasionally.
        if (this.outstandingPutCount_ === 0)
            this.outstandingPuts_ = [];
    };
    /**
     * @param {!string} pathString
     * @param {Array.<*>=} query
     * @private
     */
    PersistentConnection.prototype.onListenRevoked_ = function (pathString, query) {
        // Remove the listen and manufacture a "permission_denied" error for the failed listen.
        var queryId;
        if (!query) {
            queryId = 'default';
        }
        else {
            queryId = query.map(function (q) { return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_util__["o" /* ObjectToUniqueKey */])(q); }).join('$');
        }
        var listen = this.removeListen_(pathString, queryId);
        if (listen && listen.onComplete)
            listen.onComplete('permission_denied');
    };
    /**
     * @param {!string} pathString
     * @param {!string} queryId
     * @return {{queries:Array.<Query>, onComplete:function(string)}}
     * @private
     */
    PersistentConnection.prototype.removeListen_ = function (pathString, queryId) {
        var normalizedPathString = new __WEBPACK_IMPORTED_MODULE_3__util_Path__["a" /* Path */](pathString).toString(); // normalize path.
        var listen;
        if (this.listens_[normalizedPathString] !== undefined) {
            listen = this.listens_[normalizedPathString][queryId];
            delete this.listens_[normalizedPathString][queryId];
            if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["r" /* getCount */])(this.listens_[normalizedPathString]) === 0) {
                delete this.listens_[normalizedPathString];
            }
        }
        else {
            // all listens for this path has already been removed
            listen = undefined;
        }
        return listen;
    };
    PersistentConnection.prototype.onAuthRevoked_ = function (statusCode, explanation) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_util__["m" /* log */])('Auth token revoked: ' + statusCode + '/' + explanation);
        this.authToken_ = null;
        this.forceTokenRefresh_ = true;
        this.realtime_.close();
        if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {
            // We'll wait a couple times before logging the warning / increasing the
            // retry period since oauth tokens will report as "invalid" if they're
            // just expired. Plus there may be transient issues that resolve themselves.
            this.invalidAuthTokenCount_++;
            if (this.invalidAuthTokenCount_ >= INVALID_AUTH_TOKEN_THRESHOLD) {
                // Set a long reconnect delay because recovery is unlikely
                this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
                // Notify the auth token provider that the token is invalid, which will log
                // a warning
                this.authTokenProvider_.notifyForInvalidToken();
            }
        }
    };
    PersistentConnection.prototype.onSecurityDebugPacket_ = function (body) {
        if (this.securityDebugCallback_) {
            this.securityDebugCallback_(body);
        }
        else {
            if ('msg' in body && typeof console !== 'undefined') {
                console.log('FIREBASE: ' + body['msg'].replace('\n', '\nFIREBASE: '));
            }
        }
    };
    PersistentConnection.prototype.restoreState_ = function () {
        var _this = this;
        //Re-authenticate ourselves if we have a credential stored.
        this.tryAuth();
        // Puts depend on having received the corresponding data update from the server before they complete, so we must
        // make sure to send listens before puts.
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["h" /* forEach */])(this.listens_, function (pathString, queries) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["h" /* forEach */])(queries, function (key, listenSpec) {
                _this.sendListen_(listenSpec);
            });
        });
        for (var i = 0; i < this.outstandingPuts_.length; i++) {
            if (this.outstandingPuts_[i])
                this.sendPut_(i);
        }
        while (this.onDisconnectRequestQueue_.length) {
            var request = this.onDisconnectRequestQueue_.shift();
            this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);
        }
    };
    /**
     * Sends client stats for first connection
     * @private
     */
    PersistentConnection.prototype.sendConnectStats_ = function () {
        var stats = {};
        var clientName = 'js';
        if (__WEBPACK_IMPORTED_MODULE_1__firebase_util__["o" /* CONSTANTS */].NODE_ADMIN) {
            clientName = 'admin_node';
        }
        else if (__WEBPACK_IMPORTED_MODULE_1__firebase_util__["o" /* CONSTANTS */].NODE_CLIENT) {
            clientName = 'node';
        }
        stats['sdk.' + clientName + '.' + __WEBPACK_IMPORTED_MODULE_0__firebase_app__["default"].SDK_VERSION.replace(/\./g, '-')] = 1;
        if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["v" /* isMobileCordova */])()) {
            stats['framework.cordova'] = 1;
        }
        else if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["w" /* isReactNative */])()) {
            stats['framework.reactnative'] = 1;
        }
        this.reportStats(stats);
    };
    /**
     * @return {boolean}
     * @private
     */
    PersistentConnection.prototype.shouldReconnect_ = function () {
        var online = __WEBPACK_IMPORTED_MODULE_5__util_OnlineMonitor__["a" /* OnlineMonitor */].getInstance().currentlyOnline();
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["q" /* isEmpty */])(this.interruptReasons_) && online;
    };
    /**
     * @private
     */
    PersistentConnection.nextPersistentConnectionId_ = 0;
    /**
     * Counter for number of connections created. Mainly used for tagging in the logs
     * @type {number}
     * @private
     */
    PersistentConnection.nextConnectionId_ = 0;
    return PersistentConnection;
}(__WEBPACK_IMPORTED_MODULE_7__ServerActions__["a" /* ServerActions */]));




/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RepoInfo; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__storage_storage__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__realtime_Constants__ = __webpack_require__(24);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * A class that holds metadata about a Repo object
 *
 * @constructor
 */
var RepoInfo = /** @class */ (function () {
    /**
     * @param {string} host Hostname portion of the url for the repo
     * @param {boolean} secure Whether or not this repo is accessed over ssl
     * @param {string} namespace The namespace represented by the repo
     * @param {boolean} webSocketOnly Whether to prefer websockets over all other transports (used by Nest).
     * @param {string=} persistenceKey Override the default session persistence storage key
     */
    function RepoInfo(host, secure, namespace, webSocketOnly, persistenceKey) {
        if (persistenceKey === void 0) { persistenceKey = ''; }
        this.secure = secure;
        this.namespace = namespace;
        this.webSocketOnly = webSocketOnly;
        this.persistenceKey = persistenceKey;
        this.host = host.toLowerCase();
        this.domain = this.host.substr(this.host.indexOf('.') + 1);
        this.internalHost = __WEBPACK_IMPORTED_MODULE_1__storage_storage__["a" /* PersistentStorage */].get('host:' + host) || this.host;
    }
    RepoInfo.prototype.needsQueryParam = function () {
        return this.host !== this.internalHost;
    };
    RepoInfo.prototype.isCacheableHost = function () {
        return this.internalHost.substr(0, 2) === 's-';
    };
    RepoInfo.prototype.isDemoHost = function () {
        return this.domain === 'firebaseio-demo.com';
    };
    RepoInfo.prototype.isCustomHost = function () {
        return (this.domain !== 'firebaseio.com' && this.domain !== 'firebaseio-demo.com');
    };
    RepoInfo.prototype.updateHost = function (newHost) {
        if (newHost !== this.internalHost) {
            this.internalHost = newHost;
            if (this.isCacheableHost()) {
                __WEBPACK_IMPORTED_MODULE_1__storage_storage__["a" /* PersistentStorage */].set('host:' + this.host, this.internalHost);
            }
        }
    };
    /**
     * Returns the websocket URL for this repo
     * @param {string} type of connection
     * @param {Object} params list
     * @return {string} The URL for this repo
     */
    RepoInfo.prototype.connectionURL = function (type, params) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(typeof type === 'string', 'typeof type must == string');
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(typeof params === 'object', 'typeof params must == object');
        var connURL;
        if (type === __WEBPACK_IMPORTED_MODULE_2__realtime_Constants__["a" /* WEBSOCKET */]) {
            connURL =
                (this.secure ? 'wss://' : 'ws://') + this.internalHost + '/.ws?';
        }
        else if (type === __WEBPACK_IMPORTED_MODULE_2__realtime_Constants__["b" /* LONG_POLLING */]) {
            connURL =
                (this.secure ? 'https://' : 'http://') + this.internalHost + '/.lp?';
        }
        else {
            throw new Error('Unknown connection type: ' + type);
        }
        if (this.needsQueryParam()) {
            params['ns'] = this.namespace;
        }
        var pairs = [];
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["h" /* forEach */])(params, function (key, value) {
            pairs.push(key + '=' + value);
        });
        return connURL + pairs.join('&');
    };
    /** @return {string} */
    RepoInfo.prototype.toString = function () {
        var str = this.toURLString();
        if (this.persistenceKey) {
            str += '<' + this.persistenceKey + '>';
        }
        return str;
    };
    /** @return {string} */
    RepoInfo.prototype.toURLString = function () {
        return (this.secure ? 'https://' : 'http://') + this.host;
    };
    return RepoInfo;
}());




/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ServerActions; });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Interface defining the set of actions that can be performed against the Firebase server
 * (basically corresponds to our wire protocol).
 *
 * @interface
 */
var ServerActions = /** @class */ (function () {
    function ServerActions() {
    }
    /**
     * @param {string} pathString
     * @param {*} data
     * @param {function(string, string)=} onComplete
     * @param {string=} hash
     */
    ServerActions.prototype.put = function (pathString, data, onComplete, hash) { };
    /**
     * @param {string} pathString
     * @param {*} data
     * @param {function(string, ?string)} onComplete
     * @param {string=} hash
     */
    ServerActions.prototype.merge = function (pathString, data, onComplete, hash) { };
    /**
     * Refreshes the auth token for the current connection.
     * @param {string} token The authentication token
     */
    ServerActions.prototype.refreshAuthToken = function (token) { };
    /**
     * @param {string} pathString
     * @param {*} data
     * @param {function(string, string)=} onComplete
     */
    ServerActions.prototype.onDisconnectPut = function (pathString, data, onComplete) { };
    /**
     * @param {string} pathString
     * @param {*} data
     * @param {function(string, string)=} onComplete
     */
    ServerActions.prototype.onDisconnectMerge = function (pathString, data, onComplete) { };
    /**
     * @param {string} pathString
     * @param {function(string, string)=} onComplete
     */
    ServerActions.prototype.onDisconnectCancel = function (pathString, onComplete) { };
    /**
     * @param {Object.<string, *>} stats
     */
    ServerActions.prototype.reportStats = function (stats) { };
    return ServerActions;
}());




/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SparseSnapshotTree; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__snap_indexes_PriorityIndex__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_CountedSet__ = __webpack_require__(51);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Helper class to store a sparse set of snapshots.
 *
 * @constructor
 */
var SparseSnapshotTree = /** @class */ (function () {
    function SparseSnapshotTree() {
        /**
         * @private
         * @type {Node}
         */
        this.value_ = null;
        /**
         * @private
         * @type {CountedSet}
         */
        this.children_ = null;
    }
    /**
     * Gets the node stored at the given path if one exists.
     *
     * @param {!Path} path Path to look up snapshot for.
     * @return {?Node} The retrieved node, or null.
     */
    SparseSnapshotTree.prototype.find = function (path) {
        if (this.value_ != null) {
            return this.value_.getChild(path);
        }
        else if (!path.isEmpty() && this.children_ != null) {
            var childKey = path.getFront();
            path = path.popFront();
            if (this.children_.contains(childKey)) {
                var childTree = this.children_.get(childKey);
                return childTree.find(path);
            }
            else {
                return null;
            }
        }
        else {
            return null;
        }
    };
    /**
     * Stores the given node at the specified path. If there is already a node
     * at a shallower path, it merges the new data into that snapshot node.
     *
     * @param {!Path} path Path to look up snapshot for.
     * @param {!Node} data The new data, or null.
     */
    SparseSnapshotTree.prototype.remember = function (path, data) {
        if (path.isEmpty()) {
            this.value_ = data;
            this.children_ = null;
        }
        else if (this.value_ !== null) {
            this.value_ = this.value_.updateChild(path, data);
        }
        else {
            if (this.children_ == null) {
                this.children_ = new __WEBPACK_IMPORTED_MODULE_2__util_CountedSet__["a" /* CountedSet */]();
            }
            var childKey = path.getFront();
            if (!this.children_.contains(childKey)) {
                this.children_.add(childKey, new SparseSnapshotTree());
            }
            var child = this.children_.get(childKey);
            path = path.popFront();
            child.remember(path, data);
        }
    };
    /**
     * Purge the data at path from the cache.
     *
     * @param {!Path} path Path to look up snapshot for.
     * @return {boolean} True if this node should now be removed.
     */
    SparseSnapshotTree.prototype.forget = function (path) {
        if (path.isEmpty()) {
            this.value_ = null;
            this.children_ = null;
            return true;
        }
        else {
            if (this.value_ !== null) {
                if (this.value_.isLeafNode()) {
                    // We're trying to forget a node that doesn't exist
                    return false;
                }
                else {
                    var value = this.value_;
                    this.value_ = null;
                    var self_1 = this;
                    value.forEachChild(__WEBPACK_IMPORTED_MODULE_1__snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */], function (key, tree) {
                        self_1.remember(new __WEBPACK_IMPORTED_MODULE_0__util_Path__["a" /* Path */](key), tree);
                    });
                    return this.forget(path);
                }
            }
            else if (this.children_ !== null) {
                var childKey = path.getFront();
                path = path.popFront();
                if (this.children_.contains(childKey)) {
                    var safeToRemove = this.children_.get(childKey).forget(path);
                    if (safeToRemove) {
                        this.children_.remove(childKey);
                    }
                }
                if (this.children_.isEmpty()) {
                    this.children_ = null;
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return true;
            }
        }
    };
    /**
     * Recursively iterates through all of the stored tree and calls the
     * callback on each one.
     *
     * @param {!Path} prefixPath Path to look up node for.
     * @param {!Function} func The function to invoke for each tree.
     */
    SparseSnapshotTree.prototype.forEachTree = function (prefixPath, func) {
        if (this.value_ !== null) {
            func(prefixPath, this.value_);
        }
        else {
            this.forEachChild(function (key, tree) {
                var path = new __WEBPACK_IMPORTED_MODULE_0__util_Path__["a" /* Path */](prefixPath.toString() + '/' + key);
                tree.forEachTree(path, func);
            });
        }
    };
    /**
     * Iterates through each immediate child and triggers the callback.
     *
     * @param {!Function} func The function to invoke for each child.
     */
    SparseSnapshotTree.prototype.forEachChild = function (func) {
        if (this.children_ !== null) {
            this.children_.each(function (key, tree) {
                func(key, tree);
            });
        }
    };
    return SparseSnapshotTree;
}());




/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SyncPoint; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__view_CacheNode__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__snap_ChildrenNode__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__view_ViewCache__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__view_View__ = __webpack_require__(118);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






var __referenceConstructor;
/**
 * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to
 * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes
 * and user writes (set, transaction, update).
 *
 * It's responsible for:
 *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).
 *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,
 *    applyUserOverwrite, etc.)
 */
var SyncPoint = /** @class */ (function () {
    function SyncPoint() {
        /**
         * The Views being tracked at this location in the tree, stored as a map where the key is a
         * queryId and the value is the View for that query.
         *
         * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).
         *
         * @type {!Object.<!string, !View>}
         * @private
         */
        this.views_ = {};
    }
    Object.defineProperty(SyncPoint, "__referenceConstructor", {
        get: function () {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["g" /* assert */])(__referenceConstructor, 'Reference.ts has not been loaded');
            return __referenceConstructor;
        },
        set: function (val) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["g" /* assert */])(!__referenceConstructor, '__referenceConstructor has already been defined');
            __referenceConstructor = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {boolean}
     */
    SyncPoint.prototype.isEmpty = function () {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["q" /* isEmpty */])(this.views_);
    };
    /**
     *
     * @param {!Operation} operation
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} optCompleteServerCache
     * @return {!Array.<!Event>}
     */
    SyncPoint.prototype.applyOperation = function (operation, writesCache, optCompleteServerCache) {
        var queryId = operation.source.queryId;
        if (queryId !== null) {
            var view = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["s" /* safeGet */])(this.views_, queryId);
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["g" /* assert */])(view != null, 'SyncTree gave us an op for an invalid query.');
            return view.applyOperation(operation, writesCache, optCompleteServerCache);
        }
        else {
            var events_1 = [];
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["h" /* forEach */])(this.views_, function (key, view) {
                events_1 = events_1.concat(view.applyOperation(operation, writesCache, optCompleteServerCache));
            });
            return events_1;
        }
    };
    /**
     * Add an event callback for the specified query.
     *
     * @param {!Query} query
     * @param {!EventRegistration} eventRegistration
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} serverCache Complete server cache, if we have it.
     * @param {boolean} serverCacheComplete
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncPoint.prototype.addEventRegistration = function (query, eventRegistration, writesCache, serverCache, serverCacheComplete) {
        var queryId = query.queryIdentifier();
        var view = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["s" /* safeGet */])(this.views_, queryId);
        if (!view) {
            // TODO: make writesCache take flag for complete server node
            var eventCache = writesCache.calcCompleteEventCache(serverCacheComplete ? serverCache : null);
            var eventCacheComplete = false;
            if (eventCache) {
                eventCacheComplete = true;
            }
            else if (serverCache instanceof __WEBPACK_IMPORTED_MODULE_1__snap_ChildrenNode__["a" /* ChildrenNode */]) {
                eventCache = writesCache.calcCompleteEventChildren(serverCache);
                eventCacheComplete = false;
            }
            else {
                eventCache = __WEBPACK_IMPORTED_MODULE_1__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE;
                eventCacheComplete = false;
            }
            var viewCache = new __WEBPACK_IMPORTED_MODULE_3__view_ViewCache__["a" /* ViewCache */](new __WEBPACK_IMPORTED_MODULE_0__view_CacheNode__["a" /* CacheNode */](
            /** @type {!Node} */ (eventCache), eventCacheComplete, false), new __WEBPACK_IMPORTED_MODULE_0__view_CacheNode__["a" /* CacheNode */](
            /** @type {!Node} */ (serverCache), serverCacheComplete, false));
            view = new __WEBPACK_IMPORTED_MODULE_4__view_View__["a" /* View */](query, viewCache);
            this.views_[queryId] = view;
        }
        // This is guaranteed to exist now, we just created anything that was missing
        view.addEventRegistration(eventRegistration);
        return view.getInitialEvents(eventRegistration);
    };
    /**
     * Remove event callback(s).  Return cancelEvents if a cancelError is specified.
     *
     * If query is the default query, we'll check all views for the specified eventRegistration.
     * If eventRegistration is null, we'll remove all callbacks for the specified view(s).
     *
     * @param {!Query} query
     * @param {?EventRegistration} eventRegistration If null, remove all callbacks.
     * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.
     * @return {{removed:!Array.<!Query>, events:!Array.<!Event>}} removed queries and any cancel events
     */
    SyncPoint.prototype.removeEventRegistration = function (query, eventRegistration, cancelError) {
        var queryId = query.queryIdentifier();
        var removed = [];
        var cancelEvents = [];
        var hadCompleteView = this.hasCompleteView();
        if (queryId === 'default') {
            // When you do ref.off(...), we search all views for the registration to remove.
            var self_1 = this;
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["h" /* forEach */])(this.views_, function (viewQueryId, view) {
                cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));
                if (view.isEmpty()) {
                    delete self_1.views_[viewQueryId];
                    // We'll deal with complete views later.
                    if (!view
                        .getQuery()
                        .getQueryParams()
                        .loadsAllData()) {
                        removed.push(view.getQuery());
                    }
                }
            });
        }
        else {
            // remove the callback from the specific view.
            var view = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["s" /* safeGet */])(this.views_, queryId);
            if (view) {
                cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));
                if (view.isEmpty()) {
                    delete this.views_[queryId];
                    // We'll deal with complete views later.
                    if (!view
                        .getQuery()
                        .getQueryParams()
                        .loadsAllData()) {
                        removed.push(view.getQuery());
                    }
                }
            }
        }
        if (hadCompleteView && !this.hasCompleteView()) {
            // We removed our last complete view.
            removed.push(new SyncPoint.__referenceConstructor(query.repo, query.path));
        }
        return { removed: removed, events: cancelEvents };
    };
    /**
     * @return {!Array.<!View>}
     */
    SyncPoint.prototype.getQueryViews = function () {
        var _this = this;
        var values = Object.keys(this.views_).map(function (key) { return _this.views_[key]; });
        return values.filter(function (view) {
            return !view
                .getQuery()
                .getQueryParams()
                .loadsAllData();
        });
    };
    /**
     *
     * @param {!Path} path The path to the desired complete snapshot
     * @return {?Node} A complete cache, if it exists
     */
    SyncPoint.prototype.getCompleteServerCache = function (path) {
        var serverCache = null;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["h" /* forEach */])(this.views_, function (key, view) {
            serverCache = serverCache || view.getCompleteServerCache(path);
        });
        return serverCache;
    };
    /**
     * @param {!Query} query
     * @return {?View}
     */
    SyncPoint.prototype.viewForQuery = function (query) {
        var params = query.getQueryParams();
        if (params.loadsAllData()) {
            return this.getCompleteView();
        }
        else {
            var queryId = query.queryIdentifier();
            return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["s" /* safeGet */])(this.views_, queryId);
        }
    };
    /**
     * @param {!Query} query
     * @return {boolean}
     */
    SyncPoint.prototype.viewExistsForQuery = function (query) {
        return this.viewForQuery(query) != null;
    };
    /**
     * @return {boolean}
     */
    SyncPoint.prototype.hasCompleteView = function () {
        return this.getCompleteView() != null;
    };
    /**
     * @return {?View}
     */
    SyncPoint.prototype.getCompleteView = function () {
        var completeView = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["D" /* findValue */])(this.views_, function (view) {
            return view
                .getQuery()
                .getQueryParams()
                .loadsAllData();
        });
        return completeView || null;
    };
    return SyncPoint;
}());




/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Overwrite; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Operation__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_Path__ = __webpack_require__(2);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {!OperationSource} source
 * @param {!Path} path
 * @param {!Node} snap
 * @constructor
 * @implements {Operation}
 */
var Overwrite = /** @class */ (function () {
    function Overwrite(source, path, snap) {
        this.source = source;
        this.path = path;
        this.snap = snap;
        /** @inheritDoc */
        this.type = __WEBPACK_IMPORTED_MODULE_0__Operation__["b" /* OperationType */].OVERWRITE;
    }
    Overwrite.prototype.operationForChild = function (childName) {
        if (this.path.isEmpty()) {
            return new Overwrite(this.source, __WEBPACK_IMPORTED_MODULE_1__util_Path__["a" /* Path */].Empty, this.snap.getImmediateChild(childName));
        }
        else {
            return new Overwrite(this.source, this.path.popFront(), this.snap);
        }
    };
    return Overwrite;
}());




/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IndexMap; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__childSet__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Node__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__indexes_PriorityIndex__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__indexes_KeyIndex__ = __webpack_require__(15);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






var _defaultIndexMap;
var fallbackObject = {};
/**
 *
 * @param {Object.<string, FallbackType|SortedMap.<NamedNode, Node>>} indexes
 * @param {Object.<string, Index>} indexSet
 * @constructor
 */
var IndexMap = /** @class */ (function () {
    function IndexMap(indexes_, indexSet_) {
        this.indexes_ = indexes_;
        this.indexSet_ = indexSet_;
    }
    Object.defineProperty(IndexMap, "Default", {
        /**
         * The default IndexMap for nodes without a priority
         * @type {!IndexMap}
         * @const
         */
        get: function () {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(fallbackObject && __WEBPACK_IMPORTED_MODULE_3__indexes_PriorityIndex__["a" /* PRIORITY_INDEX */], 'ChildrenNode.ts has not been loaded');
            _defaultIndexMap =
                _defaultIndexMap ||
                    new IndexMap({ '.priority': fallbackObject }, { '.priority': __WEBPACK_IMPORTED_MODULE_3__indexes_PriorityIndex__["a" /* PRIORITY_INDEX */] });
            return _defaultIndexMap;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * @param {!string} indexKey
     * @return {?SortedMap.<NamedNode, Node>}
     */
    IndexMap.prototype.get = function (indexKey) {
        var sortedMap = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["s" /* safeGet */])(this.indexes_, indexKey);
        if (!sortedMap)
            throw new Error('No index defined for ' + indexKey);
        if (sortedMap === fallbackObject) {
            // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the
            // regular child map
            return null;
        }
        else {
            return sortedMap;
        }
    };
    /**
     * @param {!Index} indexDefinition
     * @return {boolean}
     */
    IndexMap.prototype.hasIndex = function (indexDefinition) {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["i" /* contains */])(this.indexSet_, indexDefinition.toString());
    };
    /**
     * @param {!Index} indexDefinition
     * @param {!SortedMap.<string, !Node>} existingChildren
     * @return {!IndexMap}
     */
    IndexMap.prototype.addIndex = function (indexDefinition, existingChildren) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(indexDefinition !== __WEBPACK_IMPORTED_MODULE_4__indexes_KeyIndex__["a" /* KEY_INDEX */], "KeyIndex always exists and isn't meant to be added to the IndexMap.");
        var childList = [];
        var sawIndexedValue = false;
        var iter = existingChildren.getIterator(__WEBPACK_IMPORTED_MODULE_2__Node__["a" /* NamedNode */].Wrap);
        var next = iter.getNext();
        while (next) {
            sawIndexedValue =
                sawIndexedValue || indexDefinition.isDefinedOn(next.node);
            childList.push(next);
            next = iter.getNext();
        }
        var newIndex;
        if (sawIndexedValue) {
            newIndex = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__childSet__["a" /* buildChildSet */])(childList, indexDefinition.getCompare());
        }
        else {
            newIndex = fallbackObject;
        }
        var indexName = indexDefinition.toString();
        var newIndexSet = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["B" /* clone */])(this.indexSet_);
        newIndexSet[indexName] = indexDefinition;
        var newIndexes = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["B" /* clone */])(this.indexes_);
        newIndexes[indexName] = newIndex;
        return new IndexMap(newIndexes, newIndexSet);
    };
    /**
     * Ensure that this node is properly tracked in any indexes that we're maintaining
     * @param {!NamedNode} namedNode
     * @param {!SortedMap.<string, !Node>} existingChildren
     * @return {!IndexMap}
     */
    IndexMap.prototype.addToIndexes = function (namedNode, existingChildren) {
        var _this = this;
        var newIndexes = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["A" /* map */])(this.indexes_, function (indexedChildren, indexName) {
            var index = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["s" /* safeGet */])(_this.indexSet_, indexName);
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(index, 'Missing index implementation for ' + indexName);
            if (indexedChildren === fallbackObject) {
                // Check to see if we need to index everything
                if (index.isDefinedOn(namedNode.node)) {
                    // We need to build this index
                    var childList = [];
                    var iter = existingChildren.getIterator(__WEBPACK_IMPORTED_MODULE_2__Node__["a" /* NamedNode */].Wrap);
                    var next = iter.getNext();
                    while (next) {
                        if (next.name != namedNode.name) {
                            childList.push(next);
                        }
                        next = iter.getNext();
                    }
                    childList.push(namedNode);
                    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__childSet__["a" /* buildChildSet */])(childList, index.getCompare());
                }
                else {
                    // No change, this remains a fallback
                    return fallbackObject;
                }
            }
            else {
                var existingSnap = existingChildren.get(namedNode.name);
                var newChildren = indexedChildren;
                if (existingSnap) {
                    newChildren = newChildren.remove(new __WEBPACK_IMPORTED_MODULE_2__Node__["a" /* NamedNode */](namedNode.name, existingSnap));
                }
                return newChildren.insert(namedNode, namedNode.node);
            }
        });
        return new IndexMap(newIndexes, this.indexSet_);
    };
    /**
     * Create a new IndexMap instance with the given value removed
     * @param {!NamedNode} namedNode
     * @param {!SortedMap.<string, !Node>} existingChildren
     * @return {!IndexMap}
     */
    IndexMap.prototype.removeFromIndexes = function (namedNode, existingChildren) {
        var newIndexes = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["A" /* map */])(this.indexes_, function (indexedChildren) {
            if (indexedChildren === fallbackObject) {
                // This is the fallback. Just return it, nothing to do in this case
                return indexedChildren;
            }
            else {
                var existingSnap = existingChildren.get(namedNode.name);
                if (existingSnap) {
                    return indexedChildren.remove(new __WEBPACK_IMPORTED_MODULE_2__Node__["a" /* NamedNode */](namedNode.name, existingSnap));
                }
                else {
                    // No record of this child
                    return indexedChildren;
                }
            }
        });
        return new IndexMap(newIndexes, this.indexSet_);
    };
    return IndexMap;
}());




/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return buildChildSet; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_SortedMap__ = __webpack_require__(22);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var LOG_2 = Math.log(2);
/**
 * @constructor
 */
var Base12Num = /** @class */ (function () {
    /**
     * @param {number} length
     */
    function Base12Num(length) {
        var logBase2 = function (num) {
            return parseInt((Math.log(num) / LOG_2), 10);
        };
        var bitMask = function (bits) { return parseInt(Array(bits + 1).join('1'), 2); };
        this.count = logBase2(length + 1);
        this.current_ = this.count - 1;
        var mask = bitMask(this.count);
        this.bits_ = (length + 1) & mask;
    }
    /**
     * @return {boolean}
     */
    Base12Num.prototype.nextBitIsOne = function () {
        //noinspection JSBitwiseOperatorUsage
        var result = !(this.bits_ & (0x1 << this.current_));
        this.current_--;
        return result;
    };
    return Base12Num;
}());
/**
 * Takes a list of child nodes and constructs a SortedSet using the given comparison
 * function
 *
 * Uses the algorithm described in the paper linked here:
 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458
 *
 * @template K, V
 * @param {Array.<!NamedNode>} childList Unsorted list of children
 * @param {function(!NamedNode, !NamedNode):number} cmp The comparison method to be used
 * @param {(function(NamedNode):K)=} keyFn An optional function to extract K from a node wrapper, if K's
 *                                                        type is not NamedNode
 * @param {(function(K, K):number)=} mapSortFn An optional override for comparator used by the generated sorted map
 * @return {SortedMap.<K, V>}
 */
var buildChildSet = function (childList, cmp, keyFn, mapSortFn) {
    childList.sort(cmp);
    var buildBalancedTree = function (low, high) {
        var length = high - low;
        var namedNode;
        var key;
        if (length == 0) {
            return null;
        }
        else if (length == 1) {
            namedNode = childList[low];
            key = keyFn ? keyFn(namedNode) : namedNode;
            return new __WEBPACK_IMPORTED_MODULE_0__util_SortedMap__["a" /* LLRBNode */](key, namedNode.node, __WEBPACK_IMPORTED_MODULE_0__util_SortedMap__["a" /* LLRBNode */].BLACK, null, null);
        }
        else {
            var middle = parseInt((length / 2), 10) + low;
            var left = buildBalancedTree(low, middle);
            var right = buildBalancedTree(middle + 1, high);
            namedNode = childList[middle];
            key = keyFn ? keyFn(namedNode) : namedNode;
            return new __WEBPACK_IMPORTED_MODULE_0__util_SortedMap__["a" /* LLRBNode */](key, namedNode.node, __WEBPACK_IMPORTED_MODULE_0__util_SortedMap__["a" /* LLRBNode */].BLACK, left, right);
        }
    };
    var buildFrom12Array = function (base12) {
        var node = null;
        var root = null;
        var index = childList.length;
        var buildPennant = function (chunkSize, color) {
            var low = index - chunkSize;
            var high = index;
            index -= chunkSize;
            var childTree = buildBalancedTree(low + 1, high);
            var namedNode = childList[low];
            var key = keyFn ? keyFn(namedNode) : namedNode;
            attachPennant(new __WEBPACK_IMPORTED_MODULE_0__util_SortedMap__["a" /* LLRBNode */](key, namedNode.node, color, null, childTree));
        };
        var attachPennant = function (pennant) {
            if (node) {
                node.left = pennant;
                node = pennant;
            }
            else {
                root = pennant;
                node = pennant;
            }
        };
        for (var i = 0; i < base12.count; ++i) {
            var isOne = base12.nextBitIsOne();
            // The number of nodes taken in each slice is 2^(arr.length - (i + 1))
            var chunkSize = Math.pow(2, base12.count - (i + 1));
            if (isOne) {
                buildPennant(chunkSize, __WEBPACK_IMPORTED_MODULE_0__util_SortedMap__["a" /* LLRBNode */].BLACK);
            }
            else {
                // current == 2
                buildPennant(chunkSize, __WEBPACK_IMPORTED_MODULE_0__util_SortedMap__["a" /* LLRBNode */].BLACK);
                buildPennant(chunkSize, __WEBPACK_IMPORTED_MODULE_0__util_SortedMap__["a" /* LLRBNode */].RED);
            }
        }
        return root;
    };
    var base12 = new Base12Num(childList.length);
    var root = buildFrom12Array(base12);
    return new __WEBPACK_IMPORTED_MODULE_0__util_SortedMap__["b" /* SortedMap */](mapSortFn || cmp, root);
};



/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = NAME_ONLY_COMPARATOR;
/* harmony export (immutable) */ __webpack_exports__["b"] = NAME_COMPARATOR;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_util__ = __webpack_require__(1);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function NAME_ONLY_COMPARATOR(left, right) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util_util__["p" /* nameCompare */])(left.name, right.name);
}
function NAME_COMPARATOR(left, right) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util_util__["p" /* nameCompare */])(left, right);
}



/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PathIndex; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Index__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ChildrenNode__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Node__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__nodeFromJSON__ = __webpack_require__(16);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






/**
 * @param {!Path} indexPath
 * @constructor
 * @extends {Index}
 */
var PathIndex = /** @class */ (function (_super) {
    __extends(PathIndex, _super);
    function PathIndex(indexPath_) {
        var _this = _super.call(this) || this;
        _this.indexPath_ = indexPath_;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(!indexPath_.isEmpty() && indexPath_.getFront() !== '.priority', "Can't create PathIndex with empty path or .priority key");
        return _this;
    }
    /**
     * @param {!Node} snap
     * @return {!Node}
     * @protected
     */
    PathIndex.prototype.extractChild = function (snap) {
        return snap.getChild(this.indexPath_);
    };
    /**
     * @inheritDoc
     */
    PathIndex.prototype.isDefinedOn = function (node) {
        return !node.getChild(this.indexPath_).isEmpty();
    };
    /**
     * @inheritDoc
     */
    PathIndex.prototype.compare = function (a, b) {
        var aChild = this.extractChild(a.node);
        var bChild = this.extractChild(b.node);
        var indexCmp = aChild.compareTo(bChild);
        if (indexCmp === 0) {
            return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_util__["p" /* nameCompare */])(a.name, b.name);
        }
        else {
            return indexCmp;
        }
    };
    /**
     * @inheritDoc
     */
    PathIndex.prototype.makePost = function (indexValue, name) {
        var valueNode = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__nodeFromJSON__["a" /* nodeFromJSON */])(indexValue);
        var node = __WEBPACK_IMPORTED_MODULE_3__ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE.updateChild(this.indexPath_, valueNode);
        return new __WEBPACK_IMPORTED_MODULE_4__Node__["a" /* NamedNode */](name, node);
    };
    /**
     * @inheritDoc
     */
    PathIndex.prototype.maxPost = function () {
        var node = __WEBPACK_IMPORTED_MODULE_3__ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE.updateChild(this.indexPath_, __WEBPACK_IMPORTED_MODULE_3__ChildrenNode__["b" /* MAX_NODE */]);
        return new __WEBPACK_IMPORTED_MODULE_4__Node__["a" /* NamedNode */](__WEBPACK_IMPORTED_MODULE_1__util_util__["u" /* MAX_NAME */], node);
    };
    /**
     * @inheritDoc
     */
    PathIndex.prototype.toString = function () {
        return this.indexPath_.slice().join('/');
    };
    return PathIndex;
}(__WEBPACK_IMPORTED_MODULE_2__Index__["a" /* Index */]));




/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ValueIndex */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return VALUE_INDEX; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Index__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Node__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__nodeFromJSON__ = __webpack_require__(16);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




/**
 * @constructor
 * @extends {Index}
 * @private
 */
var ValueIndex = /** @class */ (function (_super) {
    __extends(ValueIndex, _super);
    function ValueIndex() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @inheritDoc
     */
    ValueIndex.prototype.compare = function (a, b) {
        var indexCmp = a.node.compareTo(b.node);
        if (indexCmp === 0) {
            return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_util__["p" /* nameCompare */])(a.name, b.name);
        }
        else {
            return indexCmp;
        }
    };
    /**
     * @inheritDoc
     */
    ValueIndex.prototype.isDefinedOn = function (node) {
        return true;
    };
    /**
     * @inheritDoc
     */
    ValueIndex.prototype.indexedValueChanged = function (oldNode, newNode) {
        return !oldNode.equals(newNode);
    };
    /**
     * @inheritDoc
     */
    ValueIndex.prototype.minPost = function () {
        return __WEBPACK_IMPORTED_MODULE_1__Node__["a" /* NamedNode */].MIN;
    };
    /**
     * @inheritDoc
     */
    ValueIndex.prototype.maxPost = function () {
        return __WEBPACK_IMPORTED_MODULE_1__Node__["a" /* NamedNode */].MAX;
    };
    /**
     * @param {*} indexValue
     * @param {string} name
     * @return {!NamedNode}
     */
    ValueIndex.prototype.makePost = function (indexValue, name) {
        var valueNode = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__nodeFromJSON__["a" /* nodeFromJSON */])(indexValue);
        return new __WEBPACK_IMPORTED_MODULE_1__Node__["a" /* NamedNode */](name, valueNode);
    };
    /**
     * @return {!string} String representation for inclusion in a query spec
     */
    ValueIndex.prototype.toString = function () {
        return '.value';
    };
    return ValueIndex;
}(__WEBPACK_IMPORTED_MODULE_0__Index__["a" /* Index */]));

var VALUE_INDEX = new ValueIndex();



/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = setMaxNode;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return priorityHashText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return validatePriorityNode; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_util__ = __webpack_require__(1);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var MAX_NODE;
function setMaxNode(val) {
    MAX_NODE = val;
}
/**
 * @param {(!string|!number)} priority
 * @return {!string}
 */
var priorityHashText = function (priority) {
    if (typeof priority === 'number')
        return 'number:' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_util__["w" /* doubleToIEEE754String */])(priority);
    else
        return 'string:' + priority;
};
/**
 * Validates that a priority snapshot Node is valid.
 *
 * @param {!Node} priorityNode
 */
var validatePriorityNode = function (priorityNode) {
    if (priorityNode.isLeafNode()) {
        var val = priorityNode.val();
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(typeof val === 'string' ||
            typeof val === 'number' ||
            (typeof val === 'object' && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["i" /* contains */])(val, '.sv')), 'Priority must be a string or number.');
    }
    else {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(priorityNode === MAX_NODE || priorityNode.isEmpty(), 'priority of unexpected type.');
    }
    // Don't call getPriority() on MAX_NODE to avoid hitting assertion.
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(priorityNode === MAX_NODE || priorityNode.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.");
};



/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return StatsListener; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the delta from the previous call to get stats.
 *
 * @param collection_ The collection to "listen" to.
 * @constructor
 */
var StatsListener = /** @class */ (function () {
    function StatsListener(collection_) {
        this.collection_ = collection_;
        this.last_ = null;
    }
    StatsListener.prototype.get = function () {
        var newStats = this.collection_.get();
        var delta = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["B" /* clone */])(newStats);
        if (this.last_) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["h" /* forEach */])(this.last_, function (stat, value) {
                delta[stat] = delta[stat] - value;
            });
        }
        this.last_ = newStats;
        return delta;
    };
    return StatsListener;
}());




/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CountedSet; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Implements a set with a count of elements.
 *
 * @template K, V
 */
var CountedSet = /** @class */ (function () {
    function CountedSet() {
        this.set = {};
    }
    /**
     * @param {!K} item
     * @param {V} val
     */
    CountedSet.prototype.add = function (item, val) {
        this.set[item] = val !== null ? val : true;
    };
    /**
     * @param {!K} key
     * @return {boolean}
     */
    CountedSet.prototype.contains = function (key) {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["i" /* contains */])(this.set, key);
    };
    /**
     * @param {!K} item
     * @return {V}
     */
    CountedSet.prototype.get = function (item) {
        return this.contains(item) ? this.set[item] : undefined;
    };
    /**
     * @param {!K} item
     */
    CountedSet.prototype.remove = function (item) {
        delete this.set[item];
    };
    /**
     * Deletes everything in the set
     */
    CountedSet.prototype.clear = function () {
        this.set = {};
    };
    /**
     * True if there's nothing in the set
     * @return {boolean}
     */
    CountedSet.prototype.isEmpty = function () {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["q" /* isEmpty */])(this.set);
    };
    /**
     * @return {number} The number of items in the set
     */
    CountedSet.prototype.count = function () {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["r" /* getCount */])(this.set);
    };
    /**
     * Run a function on each k,v pair in the set
     * @param {function(K, V)} fn
     */
    CountedSet.prototype.each = function (fn) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["h" /* forEach */])(this.set, function (k, v) { return fn(k, v); });
    };
    /**
     * Mostly for debugging
     * @return {Array.<K>} The keys present in this CountedSet
     */
    CountedSet.prototype.keys = function () {
        var keys = [];
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["h" /* forEach */])(this.set, function (k) {
            keys.push(k);
        });
        return keys;
    };
    return CountedSet;
}());




/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EventEmitter; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Base class to be used if you want to emit events. Call the constructor with
 * the set of allowed event names.
 */
var EventEmitter = /** @class */ (function () {
    /**
     * @param {!Array.<string>} allowedEvents_
     */
    function EventEmitter(allowedEvents_) {
        this.allowedEvents_ = allowedEvents_;
        this.listeners_ = {};
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, 'Requires a non-empty array');
    }
    /**
     * To be called by derived classes to trigger events.
     * @param {!string} eventType
     * @param {...*} var_args
     */
    EventEmitter.prototype.trigger = function (eventType) {
        var var_args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            var_args[_i - 1] = arguments[_i];
        }
        if (Array.isArray(this.listeners_[eventType])) {
            // Clone the list, since callbacks could add/remove listeners.
            var listeners = this.listeners_[eventType].slice();
            for (var i = 0; i < listeners.length; i++) {
                listeners[i].callback.apply(listeners[i].context, var_args);
            }
        }
    };
    EventEmitter.prototype.on = function (eventType, callback, context) {
        this.validateEventType_(eventType);
        this.listeners_[eventType] = this.listeners_[eventType] || [];
        this.listeners_[eventType].push({ callback: callback, context: context });
        var eventData = this.getInitialEvent(eventType);
        if (eventData) {
            callback.apply(context, eventData);
        }
    };
    EventEmitter.prototype.off = function (eventType, callback, context) {
        this.validateEventType_(eventType);
        var listeners = this.listeners_[eventType] || [];
        for (var i = 0; i < listeners.length; i++) {
            if (listeners[i].callback === callback &&
                (!context || context === listeners[i].context)) {
                listeners.splice(i, 1);
                return;
            }
        }
    };
    EventEmitter.prototype.validateEventType_ = function (eventType) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(this.allowedEvents_.find(function (et) {
            return et === eventType;
        }), 'Unknown event: ' + eventType);
    };
    return EventEmitter;
}());




/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return generateWithValues; });
/* unused harmony export resolveDeferredValue */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return resolveDeferredValueTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return resolveDeferredValueSnapshot; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__SparseSnapshotTree__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__snap_LeafNode__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__snap_nodeFromJSON__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__snap_indexes_PriorityIndex__ = __webpack_require__(4);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Generate placeholders for deferred values.
 * @param {?Object} values
 * @return {!Object}
 */
var generateWithValues = function (values) {
    values = values || {};
    values['timestamp'] = values['timestamp'] || new Date().getTime();
    return values;
};
/**
 * Value to use when firing local events. When writing server values, fire
 * local events with an approximate value, otherwise return value as-is.
 * @param {(Object|string|number|boolean)} value
 * @param {!Object} serverValues
 * @return {!(string|number|boolean)}
 */
var resolveDeferredValue = function (value, serverValues) {
    if (!value || typeof value !== 'object') {
        return value;
    }
    else {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])('.sv' in value, 'Unexpected leaf node or priority contents');
        return serverValues[value['.sv']];
    }
};
/**
 * Recursively replace all deferred values and priorities in the tree with the
 * specified generated replacement values.
 * @param {!SparseSnapshotTree} tree
 * @param {!Object} serverValues
 * @return {!SparseSnapshotTree}
 */
var resolveDeferredValueTree = function (tree, serverValues) {
    var resolvedTree = new __WEBPACK_IMPORTED_MODULE_2__SparseSnapshotTree__["a" /* SparseSnapshotTree */]();
    tree.forEachTree(new __WEBPACK_IMPORTED_MODULE_1__Path__["a" /* Path */](''), function (path, node) {
        resolvedTree.remember(path, resolveDeferredValueSnapshot(node, serverValues));
    });
    return resolvedTree;
};
/**
 * Recursively replace all deferred values and priorities in the node with the
 * specified generated replacement values.  If there are no server values in the node,
 * it'll be returned as-is.
 * @param {!Node} node
 * @param {!Object} serverValues
 * @return {!Node}
 */
var resolveDeferredValueSnapshot = function (node, serverValues) {
    var rawPri = node.getPriority().val();
    var priority = resolveDeferredValue(rawPri, serverValues);
    var newNode;
    if (node.isLeafNode()) {
        var leafNode = node;
        var value = resolveDeferredValue(leafNode.getValue(), serverValues);
        if (value !== leafNode.getValue() ||
            priority !== leafNode.getPriority().val()) {
            return new __WEBPACK_IMPORTED_MODULE_3__snap_LeafNode__["a" /* LeafNode */](value, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__snap_nodeFromJSON__["a" /* nodeFromJSON */])(priority));
        }
        else {
            return node;
        }
    }
    else {
        var childrenNode = node;
        newNode = childrenNode;
        if (priority !== childrenNode.getPriority().val()) {
            newNode = newNode.updatePriority(new __WEBPACK_IMPORTED_MODULE_3__snap_LeafNode__["a" /* LeafNode */](priority));
        }
        childrenNode.forEachChild(__WEBPACK_IMPORTED_MODULE_5__snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */], function (childName, childNode) {
            var newChildNode = resolveDeferredValueSnapshot(childNode, serverValues);
            if (newChildNode !== childNode) {
                newNode = newNode.updateImmediateChild(childName, newChildNode);
            }
        });
        return newNode;
    }
};



/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return parseRepoInfo; });
/* unused harmony export parseURL */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__RepoInfo__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util__ = __webpack_require__(1);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {!string} pathString
 * @return {string}
 */
function decodePath(pathString) {
    var pathStringDecoded = '';
    var pieces = pathString.split('/');
    for (var i = 0; i < pieces.length; i++) {
        if (pieces[i].length > 0) {
            var piece = pieces[i];
            try {
                piece = decodeURIComponent(piece.replace(/\+/g, ' '));
            }
            catch (e) { }
            pathStringDecoded += '/' + piece;
        }
    }
    return pathStringDecoded;
}
/**
 *
 * @param {!string} dataURL
 * @return {{repoInfo: !RepoInfo, path: !Path}}
 */
var parseRepoInfo = function (dataURL) {
    var parsedUrl = parseURL(dataURL), namespace = parsedUrl.subdomain;
    if (parsedUrl.domain === 'firebase') {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["q" /* fatal */])(parsedUrl.host +
            ' is no longer supported. ' +
            'Please use <YOUR FIREBASE>.firebaseio.com instead');
    }
    // Catch common error of uninitialized namespace value.
    if (!namespace || namespace == 'undefined') {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["q" /* fatal */])('Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com');
    }
    if (!parsedUrl.secure) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__["s" /* warnIfPageIsSecure */])();
    }
    var webSocketOnly = parsedUrl.scheme === 'ws' || parsedUrl.scheme === 'wss';
    return {
        repoInfo: new __WEBPACK_IMPORTED_MODULE_1__RepoInfo__["a" /* RepoInfo */](parsedUrl.host, parsedUrl.secure, namespace, webSocketOnly),
        path: new __WEBPACK_IMPORTED_MODULE_0__Path__["a" /* Path */](parsedUrl.pathString)
    };
};
/**
 *
 * @param {!string} dataURL
 * @return {{host: string, port: number, domain: string, subdomain: string, secure: boolean, scheme: string, pathString: string}}
 */
var parseURL = function (dataURL) {
    // Default to empty strings in the event of a malformed string.
    var host = '', domain = '', subdomain = '', pathString = '';
    // Always default to SSL, unless otherwise specified.
    var secure = true, scheme = 'https', port = 443;
    // Don't do any validation here. The caller is responsible for validating the result of parsing.
    if (typeof dataURL === 'string') {
        // Parse scheme.
        var colonInd = dataURL.indexOf('//');
        if (colonInd >= 0) {
            scheme = dataURL.substring(0, colonInd - 1);
            dataURL = dataURL.substring(colonInd + 2);
        }
        // Parse host and path.
        var slashInd = dataURL.indexOf('/');
        if (slashInd === -1) {
            slashInd = dataURL.length;
        }
        host = dataURL.substring(0, slashInd);
        pathString = decodePath(dataURL.substring(slashInd));
        var parts = host.split('.');
        if (parts.length === 3) {
            // Normalize namespaces to lowercase to share storage / connection.
            domain = parts[1];
            subdomain = parts[0].toLowerCase();
        }
        else if (parts.length === 2) {
            domain = parts[0];
        }
        // If we have a port, use scheme for determining if it's secure.
        colonInd = host.indexOf(':');
        if (colonInd >= 0) {
            secure = scheme === 'https' || scheme === 'wss';
            port = parseInt(host.substring(colonInd + 1), 10);
        }
    }
    return {
        host: host,
        port: port,
        domain: domain,
        subdomain: subdomain,
        secure: secure,
        scheme: scheme,
        pathString: pathString
    };
};



/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ViewCache; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__snap_ChildrenNode__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__CacheNode__ = __webpack_require__(23);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Stores the data we have cached for a view.
 *
 * serverSnap is the cached server data, eventSnap is the cached event data (server data plus any local writes).
 *
 * @constructor
 */
var ViewCache = /** @class */ (function () {
    /**
     *
     * @param {!CacheNode} eventCache_
     * @param {!CacheNode} serverCache_
     */
    function ViewCache(eventCache_, serverCache_) {
        this.eventCache_ = eventCache_;
        this.serverCache_ = serverCache_;
    }
    /**
     * @param {!Node} eventSnap
     * @param {boolean} complete
     * @param {boolean} filtered
     * @return {!ViewCache}
     */
    ViewCache.prototype.updateEventSnap = function (eventSnap, complete, filtered) {
        return new ViewCache(new __WEBPACK_IMPORTED_MODULE_1__CacheNode__["a" /* CacheNode */](eventSnap, complete, filtered), this.serverCache_);
    };
    /**
     * @param {!Node} serverSnap
     * @param {boolean} complete
     * @param {boolean} filtered
     * @return {!ViewCache}
     */
    ViewCache.prototype.updateServerSnap = function (serverSnap, complete, filtered) {
        return new ViewCache(this.eventCache_, new __WEBPACK_IMPORTED_MODULE_1__CacheNode__["a" /* CacheNode */](serverSnap, complete, filtered));
    };
    /**
     * @return {!CacheNode}
     */
    ViewCache.prototype.getEventCache = function () {
        return this.eventCache_;
    };
    /**
     * @return {?Node}
     */
    ViewCache.prototype.getCompleteEventSnap = function () {
        return this.eventCache_.isFullyInitialized()
            ? this.eventCache_.getNode()
            : null;
    };
    /**
     * @return {!CacheNode}
     */
    ViewCache.prototype.getServerCache = function () {
        return this.serverCache_;
    };
    /**
     * @return {?Node}
     */
    ViewCache.prototype.getCompleteServerSnap = function () {
        return this.serverCache_.isFullyInitialized()
            ? this.serverCache_.getNode()
            : null;
    };
    /**
     * @const
     * @type {ViewCache}
     */
    ViewCache.Empty = new ViewCache(new __WEBPACK_IMPORTED_MODULE_1__CacheNode__["a" /* CacheNode */](__WEBPACK_IMPORTED_MODULE_0__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE, 
    /*fullyInitialized=*/ false, 
    /*filtered=*/ false), new __WEBPACK_IMPORTED_MODULE_1__CacheNode__["a" /* CacheNode */](__WEBPACK_IMPORTED_MODULE_0__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE, 
    /*fullyInitialized=*/ false, 
    /*filtered=*/ false));
    return ViewCache;
}());




/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RangedFilter; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__IndexedFilter__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__snap_indexes_PriorityIndex__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_snap_Node__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__snap_ChildrenNode__ = __webpack_require__(6);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node
 *
 * @constructor
 * @implements {NodeFilter}
 */
var RangedFilter = /** @class */ (function () {
    /**
     * @param {!QueryParams} params
     */
    function RangedFilter(params) {
        this.indexedFilter_ = new __WEBPACK_IMPORTED_MODULE_0__IndexedFilter__["a" /* IndexedFilter */](params.getIndex());
        this.index_ = params.getIndex();
        this.startPost_ = RangedFilter.getStartPost_(params);
        this.endPost_ = RangedFilter.getEndPost_(params);
    }
    /**
     * @return {!NamedNode}
     */
    RangedFilter.prototype.getStartPost = function () {
        return this.startPost_;
    };
    /**
     * @return {!NamedNode}
     */
    RangedFilter.prototype.getEndPost = function () {
        return this.endPost_;
    };
    /**
     * @param {!NamedNode} node
     * @return {boolean}
     */
    RangedFilter.prototype.matches = function (node) {
        return (this.index_.compare(this.getStartPost(), node) <= 0 &&
            this.index_.compare(node, this.getEndPost()) <= 0);
    };
    /**
     * @inheritDoc
     */
    RangedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        if (!this.matches(new __WEBPACK_IMPORTED_MODULE_2__core_snap_Node__["a" /* NamedNode */](key, newChild))) {
            newChild = __WEBPACK_IMPORTED_MODULE_3__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE;
        }
        return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
    };
    /**
     * @inheritDoc
     */
    RangedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {
        if (newSnap.isLeafNode()) {
            // Make sure we have a children node with the correct index, not a leaf node;
            newSnap = __WEBPACK_IMPORTED_MODULE_3__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE;
        }
        var filtered = newSnap.withIndex(this.index_);
        // Don't support priorities on queries
        filtered = filtered.updatePriority(__WEBPACK_IMPORTED_MODULE_3__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE);
        var self = this;
        newSnap.forEachChild(__WEBPACK_IMPORTED_MODULE_1__snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */], function (key, childNode) {
            if (!self.matches(new __WEBPACK_IMPORTED_MODULE_2__core_snap_Node__["a" /* NamedNode */](key, childNode))) {
                filtered = filtered.updateImmediateChild(key, __WEBPACK_IMPORTED_MODULE_3__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE);
            }
        });
        return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);
    };
    /**
     * @inheritDoc
     */
    RangedFilter.prototype.updatePriority = function (oldSnap, newPriority) {
        // Don't support priorities on queries
        return oldSnap;
    };
    /**
     * @inheritDoc
     */
    RangedFilter.prototype.filtersNodes = function () {
        return true;
    };
    /**
     * @inheritDoc
     */
    RangedFilter.prototype.getIndexedFilter = function () {
        return this.indexedFilter_;
    };
    /**
     * @inheritDoc
     */
    RangedFilter.prototype.getIndex = function () {
        return this.index_;
    };
    /**
     * @param {!QueryParams} params
     * @return {!NamedNode}
     * @private
     */
    RangedFilter.getStartPost_ = function (params) {
        if (params.hasStart()) {
            var startName = params.getIndexStartName();
            return params.getIndex().makePost(params.getIndexStartValue(), startName);
        }
        else {
            return params.getIndex().minPost();
        }
    };
    /**
     * @param {!QueryParams} params
     * @return {!NamedNode}
     * @private
     */
    RangedFilter.getEndPost_ = function (params) {
        if (params.hasEnd()) {
            var endName = params.getIndexEndName();
            return params.getIndex().makePost(params.getIndexEndValue(), endName);
        }
        else {
            return params.getIndex().maxPost();
        }
    };
    return RangedFilter;
}());




/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export FIREBASE_LONGPOLL_START_PARAM */
/* unused harmony export FIREBASE_LONGPOLL_CLOSE_COMMAND */
/* unused harmony export FIREBASE_LONGPOLL_COMMAND_CB_NAME */
/* unused harmony export FIREBASE_LONGPOLL_DATA_CB_NAME */
/* unused harmony export FIREBASE_LONGPOLL_ID_PARAM */
/* unused harmony export FIREBASE_LONGPOLL_PW_PARAM */
/* unused harmony export FIREBASE_LONGPOLL_SERIAL_PARAM */
/* unused harmony export FIREBASE_LONGPOLL_CALLBACK_ID_PARAM */
/* unused harmony export FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM */
/* unused harmony export FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET */
/* unused harmony export FIREBASE_LONGPOLL_DATA_PARAM */
/* unused harmony export FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM */
/* unused harmony export FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BrowserPollConnection; });
/* unused harmony export FirebaseIFrameScriptHolder */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_util_CountedSet__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_stats_StatsManager__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polling_PacketReceiver__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Constants__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







// URL query parameters associated with longpolling
var FIREBASE_LONGPOLL_START_PARAM = 'start';
var FIREBASE_LONGPOLL_CLOSE_COMMAND = 'close';
var FIREBASE_LONGPOLL_COMMAND_CB_NAME = 'pLPCommand';
var FIREBASE_LONGPOLL_DATA_CB_NAME = 'pRTLPCB';
var FIREBASE_LONGPOLL_ID_PARAM = 'id';
var FIREBASE_LONGPOLL_PW_PARAM = 'pw';
var FIREBASE_LONGPOLL_SERIAL_PARAM = 'ser';
var FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = 'cb';
var FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = 'seg';
var FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = 'ts';
var FIREBASE_LONGPOLL_DATA_PARAM = 'd';
var FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM = 'disconn';
var FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = 'dframe';
//Data size constants.
//TODO: Perf: the maximum length actually differs from browser to browser.
// We should check what browser we're on and set accordingly.
var MAX_URL_DATA_SIZE = 1870;
var SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=
var MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;
/**
 * Keepalive period
 * send a fresh request at minimum every 25 seconds. Opera has a maximum request
 * length of 30 seconds that we can't exceed.
 * @const
 * @type {number}
 */
var KEEPALIVE_REQUEST_INTERVAL = 25000;
/**
 * How long to wait before aborting a long-polling connection attempt.
 * @const
 * @type {number}
 */
var LP_CONNECT_TIMEOUT = 30000;
/**
 * This class manages a single long-polling connection.
 *
 * @constructor
 * @implements {Transport}
 */
var BrowserPollConnection = /** @class */ (function () {
    /**
     * @param {string} connId An identifier for this connection, used for logging
     * @param {RepoInfo} repoInfo The info for the endpoint to send data to.
     * @param {string=} transportSessionId Optional transportSessionid if we are reconnecting for an existing
     *                                         transport session
     * @param {string=}  lastSessionId Optional lastSessionId if the PersistentConnection has already created a
     *                                     connection previously
     */
    function BrowserPollConnection(connId, repoInfo, transportSessionId, lastSessionId) {
        this.connId = connId;
        this.repoInfo = repoInfo;
        this.transportSessionId = transportSessionId;
        this.lastSessionId = lastSessionId;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.everConnected_ = false;
        this.log_ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["b" /* logWrapper */])(connId);
        this.stats_ = __WEBPACK_IMPORTED_MODULE_2__core_stats_StatsManager__["a" /* StatsManager */].getCollection(repoInfo);
        this.urlFn = function (params) {
            return repoInfo.connectionURL(__WEBPACK_IMPORTED_MODULE_4__Constants__["b" /* LONG_POLLING */], params);
        };
    }
    /**
     *
     * @param {function(Object)} onMessage Callback when messages arrive
     * @param {function()} onDisconnect Callback with connection lost.
     */
    BrowserPollConnection.prototype.open = function (onMessage, onDisconnect) {
        var _this = this;
        this.curSegmentNum = 0;
        this.onDisconnect_ = onDisconnect;
        this.myPacketOrderer = new __WEBPACK_IMPORTED_MODULE_3__polling_PacketReceiver__["a" /* PacketReceiver */](onMessage);
        this.isClosed_ = false;
        this.connectTimeoutTimer_ = setTimeout(function () {
            _this.log_('Timed out trying to connect.');
            // Make sure we clear the host cache
            _this.onClosed_();
            _this.connectTimeoutTimer_ = null;
        }, Math.floor(LP_CONNECT_TIMEOUT));
        // Ensure we delay the creation of the iframe until the DOM is loaded.
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["i" /* executeWhenDOMReady */])(function () {
            if (_this.isClosed_)
                return;
            //Set up a callback that gets triggered once a connection is set up.
            _this.scriptTagHolder = new FirebaseIFrameScriptHolder(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var command = args[0], arg1 = args[1], arg2 = args[2], arg3 = args[3], arg4 = args[4];
                _this.incrementIncomingBytes_(args);
                if (!_this.scriptTagHolder)
                    return; // we closed the connection.
                if (_this.connectTimeoutTimer_) {
                    clearTimeout(_this.connectTimeoutTimer_);
                    _this.connectTimeoutTimer_ = null;
                }
                _this.everConnected_ = true;
                if (command == FIREBASE_LONGPOLL_START_PARAM) {
                    _this.id = arg1;
                    _this.password = arg2;
                }
                else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {
                    // Don't clear the host cache. We got a response from the server, so we know it's reachable
                    if (arg1) {
                        // We aren't expecting any more data (other than what the server's already in the process of sending us
                        // through our already open polls), so don't send any more.
                        _this.scriptTagHolder.sendNewPolls = false;
                        // arg1 in this case is the last response number sent by the server. We should try to receive
                        // all of the responses up to this one before closing
                        _this.myPacketOrderer.closeAfter(arg1, function () {
                            _this.onClosed_();
                        });
                    }
                    else {
                        _this.onClosed_();
                    }
                }
                else {
                    throw new Error('Unrecognized command received: ' + command);
                }
            }, function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var pN = args[0], data = args[1];
                _this.incrementIncomingBytes_(args);
                _this.myPacketOrderer.handleResponse(pN, data);
            }, function () {
                _this.onClosed_();
            }, _this.urlFn);
            //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results
            //from cache.
            var urlParams = {};
            urlParams[FIREBASE_LONGPOLL_START_PARAM] = 't';
            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 100000000);
            if (_this.scriptTagHolder.uniqueCallbackIdentifier)
                urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] = _this.scriptTagHolder.uniqueCallbackIdentifier;
            urlParams[__WEBPACK_IMPORTED_MODULE_4__Constants__["d" /* VERSION_PARAM */]] = __WEBPACK_IMPORTED_MODULE_4__Constants__["c" /* PROTOCOL_VERSION */];
            if (_this.transportSessionId) {
                urlParams[__WEBPACK_IMPORTED_MODULE_4__Constants__["h" /* TRANSPORT_SESSION_PARAM */]] = _this.transportSessionId;
            }
            if (_this.lastSessionId) {
                urlParams[__WEBPACK_IMPORTED_MODULE_4__Constants__["i" /* LAST_SESSION_PARAM */]] = _this.lastSessionId;
            }
            if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__firebase_util__["f" /* isNodeSdk */])() &&
                typeof location !== 'undefined' &&
                location.href &&
                location.href.indexOf(__WEBPACK_IMPORTED_MODULE_4__Constants__["e" /* FORGE_DOMAIN */]) !== -1) {
                urlParams[__WEBPACK_IMPORTED_MODULE_4__Constants__["f" /* REFERER_PARAM */]] = __WEBPACK_IMPORTED_MODULE_4__Constants__["g" /* FORGE_REF */];
            }
            var connectURL = _this.urlFn(urlParams);
            _this.log_('Connecting via long-poll to ' + connectURL);
            _this.scriptTagHolder.addTag(connectURL, function () {
                /* do nothing */
            });
        });
    };
    /**
     * Call this when a handshake has completed successfully and we want to consider the connection established
     */
    BrowserPollConnection.prototype.start = function () {
        this.scriptTagHolder.startLongPoll(this.id, this.password);
        this.addDisconnectPingFrame(this.id, this.password);
    };
    /**
     * Forces long polling to be considered as a potential transport
     */
    BrowserPollConnection.forceAllow = function () {
        BrowserPollConnection.forceAllow_ = true;
    };
    /**
     * Forces longpolling to not be considered as a potential transport
     */
    BrowserPollConnection.forceDisallow = function () {
        BrowserPollConnection.forceDisallow_ = true;
    };
    // Static method, use string literal so it can be accessed in a generic way
    BrowserPollConnection.isAvailable = function () {
        // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in
        // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).
        return (BrowserPollConnection.forceAllow_ ||
            (!BrowserPollConnection.forceDisallow_ &&
                typeof document !== 'undefined' &&
                document.createElement != null &&
                !__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["j" /* isChromeExtensionContentScript */])() &&
                !__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["k" /* isWindowsStoreApp */])() &&
                !__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__firebase_util__["f" /* isNodeSdk */])()));
    };
    /**
     * No-op for polling
     */
    BrowserPollConnection.prototype.markConnectionHealthy = function () { };
    /**
     * Stops polling and cleans up the iframe
     * @private
     */
    BrowserPollConnection.prototype.shutdown_ = function () {
        this.isClosed_ = true;
        if (this.scriptTagHolder) {
            this.scriptTagHolder.close();
            this.scriptTagHolder = null;
        }
        //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.
        if (this.myDisconnFrame) {
            document.body.removeChild(this.myDisconnFrame);
            this.myDisconnFrame = null;
        }
        if (this.connectTimeoutTimer_) {
            clearTimeout(this.connectTimeoutTimer_);
            this.connectTimeoutTimer_ = null;
        }
    };
    /**
     * Triggered when this transport is closed
     * @private
     */
    BrowserPollConnection.prototype.onClosed_ = function () {
        if (!this.isClosed_) {
            this.log_('Longpoll is closing itself');
            this.shutdown_();
            if (this.onDisconnect_) {
                this.onDisconnect_(this.everConnected_);
                this.onDisconnect_ = null;
            }
        }
    };
    /**
     * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server
     * that we've left.
     */
    BrowserPollConnection.prototype.close = function () {
        if (!this.isClosed_) {
            this.log_('Longpoll is being closed.');
            this.shutdown_();
        }
    };
    /**
     * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then
     * broken into chunks (since URLs have a small maximum length).
     * @param {!Object} data The JSON data to transmit.
     */
    BrowserPollConnection.prototype.send = function (data) {
        var dataStr = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__firebase_util__["j" /* stringify */])(data);
        this.bytesSent += dataStr.length;
        this.stats_.incrementCounter('bytes_sent', dataStr.length);
        //first, lets get the base64-encoded data
        var base64data = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__firebase_util__["p" /* base64Encode */])(dataStr);
        //We can only fit a certain amount in each URL, so we need to split this request
        //up into multiple pieces if it doesn't fit in one request.
        var dataSegs = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["h" /* splitStringBySize */])(base64data, MAX_PAYLOAD_SIZE);
        //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number
        //of segments so that we can reassemble the packet on the server.
        for (var i = 0; i < dataSegs.length; i++) {
            this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);
            this.curSegmentNum++;
        }
    };
    /**
     * This is how we notify the server that we're leaving.
     * We aren't able to send requests with DHTML on a window close event, but we can
     * trigger XHR requests in some browsers (everything but Opera basically).
     * @param {!string} id
     * @param {!string} pw
     */
    BrowserPollConnection.prototype.addDisconnectPingFrame = function (id, pw) {
        if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__firebase_util__["f" /* isNodeSdk */])())
            return;
        this.myDisconnFrame = document.createElement('iframe');
        var urlParams = {};
        urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = 't';
        urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;
        urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;
        this.myDisconnFrame.src = this.urlFn(urlParams);
        this.myDisconnFrame.style.display = 'none';
        document.body.appendChild(this.myDisconnFrame);
    };
    /**
     * Used to track the bytes received by this client
     * @param {*} args
     * @private
     */
    BrowserPollConnection.prototype.incrementIncomingBytes_ = function (args) {
        // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.
        var bytesReceived = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__firebase_util__["j" /* stringify */])(args).length;
        this.bytesReceived += bytesReceived;
        this.stats_.incrementCounter('bytes_received', bytesReceived);
    };
    return BrowserPollConnection;
}());

/*********************************************************************************************
 * A wrapper around an iframe that is used as a long-polling script holder.
 * @constructor
 *********************************************************************************************/
var FirebaseIFrameScriptHolder = /** @class */ (function () {
    /**
     * @param commandCB - The callback to be called when control commands are recevied from the server.
     * @param onMessageCB - The callback to be triggered when responses arrive from the server.
     * @param onDisconnect - The callback to be triggered when this tag holder is closed
     * @param urlFn - A function that provides the URL of the endpoint to send data to.
     */
    function FirebaseIFrameScriptHolder(commandCB, onMessageCB, onDisconnect, urlFn) {
        this.onDisconnect = onDisconnect;
        this.urlFn = urlFn;
        //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause
        //problems in some browsers.
        /**
         * @type {CountedSet.<number, number>}
         */
        this.outstandingRequests = new __WEBPACK_IMPORTED_MODULE_1__core_util_CountedSet__["a" /* CountedSet */]();
        //A queue of the pending segments waiting for transmission to the server.
        this.pendingSegs = [];
        //A serial number. We use this for two things:
        // 1) A way to ensure the browser doesn't cache responses to polls
        // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The
        //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute
        //    JSONP code in the order it was added to the iframe.
        this.currentSerial = Math.floor(Math.random() * 100000000);
        // This gets set to false when we're "closing down" the connection (e.g. we're switching transports but there's still
        // incoming data from the server that we're waiting for).
        this.sendNewPolls = true;
        if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__firebase_util__["f" /* isNodeSdk */])()) {
            //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the
            //iframes where we put the long-polling script tags. We have two callbacks:
            //   1) Command Callback - Triggered for control issues, like starting a connection.
            //   2) Message Callback - Triggered when new data arrives.
            this.uniqueCallbackIdentifier = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["l" /* LUIDGenerator */])();
            window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;
            window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] = onMessageCB;
            //Create an iframe for us to add script tags to.
            this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();
            // Set the iframe's contents.
            var script = '';
            // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient
            // for ie9, but ie8 needs to do it again in the document itself.
            if (this.myIFrame.src &&
                this.myIFrame.src.substr(0, 'javascript:'.length) === 'javascript:') {
                var currentDomain = document.domain;
                script = '<script>document.domain="' + currentDomain + '";</script>';
            }
            var iframeContents = '<html><body>' + script + '</body></html>';
            try {
                this.myIFrame.doc.open();
                this.myIFrame.doc.write(iframeContents);
                this.myIFrame.doc.close();
            }
            catch (e) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["m" /* log */])('frame writing exception');
                if (e.stack) {
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["m" /* log */])(e.stack);
                }
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["m" /* log */])(e);
            }
        }
        else {
            this.commandCB = commandCB;
            this.onMessageCB = onMessageCB;
        }
    }
    /**
     * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can
     * actually use.
     * @private
     * @return {Element}
     */
    FirebaseIFrameScriptHolder.createIFrame_ = function () {
        var iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        // This is necessary in order to initialize the document inside the iframe
        if (document.body) {
            document.body.appendChild(iframe);
            try {
                // If document.domain has been modified in IE, this will throw an error, and we need to set the
                // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute
                // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.
                var a = iframe.contentWindow.document;
                if (!a) {
                    // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["m" /* log */])('No IE domain setting required');
                }
            }
            catch (e) {
                var domain = document.domain;
                iframe.src =
                    "javascript:void((function(){document.open();document.domain='" +
                        domain +
                        "';document.close();})())";
            }
        }
        else {
            // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this
            // never gets hit.
            throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';
        }
        // Get the document of the iframe in a browser-specific way.
        if (iframe.contentDocument) {
            iframe.doc = iframe.contentDocument; // Firefox, Opera, Safari
        }
        else if (iframe.contentWindow) {
            iframe.doc = iframe.contentWindow.document; // Internet Explorer
        }
        else if (iframe.document) {
            iframe.doc = iframe.document; //others?
        }
        return iframe;
    };
    /**
     * Cancel all outstanding queries and remove the frame.
     */
    FirebaseIFrameScriptHolder.prototype.close = function () {
        var _this = this;
        //Mark this iframe as dead, so no new requests are sent.
        this.alive = false;
        if (this.myIFrame) {
            //We have to actually remove all of the html inside this iframe before removing it from the
            //window, or IE will continue loading and executing the script tags we've already added, which
            //can lead to some errors being thrown. Setting innerHTML seems to be the easiest way to do this.
            this.myIFrame.doc.body.innerHTML = '';
            setTimeout(function () {
                if (_this.myIFrame !== null) {
                    document.body.removeChild(_this.myIFrame);
                    _this.myIFrame = null;
                }
            }, Math.floor(0));
        }
        if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__firebase_util__["f" /* isNodeSdk */])() && this.myID) {
            var urlParams = {};
            urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM] = 't';
            urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;
            urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;
            var theURL = this.urlFn(urlParams);
            FirebaseIFrameScriptHolder.nodeRestRequest(theURL);
        }
        // Protect from being called recursively.
        var onDisconnect = this.onDisconnect;
        if (onDisconnect) {
            this.onDisconnect = null;
            onDisconnect();
        }
    };
    /**
     * Actually start the long-polling session by adding the first script tag(s) to the iframe.
     * @param {!string} id - The ID of this connection
     * @param {!string} pw - The password for this connection
     */
    FirebaseIFrameScriptHolder.prototype.startLongPoll = function (id, pw) {
        this.myID = id;
        this.myPW = pw;
        this.alive = true;
        //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.
        while (this.newRequest_()) { }
    };
    /**
     * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't
     * too many outstanding requests and we are still alive.
     *
     * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if
     * needed.
     */
    FirebaseIFrameScriptHolder.prototype.newRequest_ = function () {
        // We keep one outstanding request open all the time to receive data, but if we need to send data
        // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically
        // close the old request.
        if (this.alive &&
            this.sendNewPolls &&
            this.outstandingRequests.count() < (this.pendingSegs.length > 0 ? 2 : 1)) {
            //construct our url
            this.currentSerial++;
            var urlParams = {};
            urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;
            urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;
            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;
            var theURL = this.urlFn(urlParams);
            //Now add as much data as we can.
            var curDataString = '';
            var i = 0;
            while (this.pendingSegs.length > 0) {
                //first, lets see if the next segment will fit.
                var nextSeg = this.pendingSegs[0];
                if (nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <=
                    MAX_URL_DATA_SIZE) {
                    //great, the segment will fit. Lets append it.
                    var theSeg = this.pendingSegs.shift();
                    curDataString =
                        curDataString +
                            '&' +
                            FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM +
                            i +
                            '=' +
                            theSeg.seg +
                            '&' +
                            FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET +
                            i +
                            '=' +
                            theSeg.ts +
                            '&' +
                            FIREBASE_LONGPOLL_DATA_PARAM +
                            i +
                            '=' +
                            theSeg.d;
                    i++;
                }
                else {
                    break;
                }
            }
            theURL = theURL + curDataString;
            this.addLongPollTag_(theURL, this.currentSerial);
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Queue a packet for transmission to the server.
     * @param segnum - A sequential id for this packet segment used for reassembly
     * @param totalsegs - The total number of segments in this packet
     * @param data - The data for this segment.
     */
    FirebaseIFrameScriptHolder.prototype.enqueueSegment = function (segnum, totalsegs, data) {
        //add this to the queue of segments to send.
        this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });
        //send the data immediately if there isn't already data being transmitted, unless
        //startLongPoll hasn't been called yet.
        if (this.alive) {
            this.newRequest_();
        }
    };
    /**
     * Add a script tag for a regular long-poll request.
     * @param {!string} url - The URL of the script tag.
     * @param {!number} serial - The serial number of the request.
     * @private
     */
    FirebaseIFrameScriptHolder.prototype.addLongPollTag_ = function (url, serial) {
        var _this = this;
        //remember that we sent this request.
        this.outstandingRequests.add(serial, 1);
        var doNewRequest = function () {
            _this.outstandingRequests.remove(serial);
            _this.newRequest_();
        };
        // If this request doesn't return on its own accord (by the server sending us some data), we'll
        // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.
        var keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));
        var readyStateCB = function () {
            // Request completed.  Cancel the keepalive.
            clearTimeout(keepaliveTimeout);
            // Trigger a new request so we can continue receiving data.
            doNewRequest();
        };
        this.addTag(url, readyStateCB);
    };
    /**
     * Add an arbitrary script tag to the iframe.
     * @param {!string} url - The URL for the script tag source.
     * @param {!function()} loadCB - A callback to be triggered once the script has loaded.
     */
    FirebaseIFrameScriptHolder.prototype.addTag = function (url, loadCB) {
        var _this = this;
        if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__firebase_util__["f" /* isNodeSdk */])()) {
            this.doNodeLongPoll(url, loadCB);
        }
        else {
            setTimeout(function () {
                try {
                    // if we're already closed, don't add this poll
                    if (!_this.sendNewPolls)
                        return;
                    var newScript_1 = _this.myIFrame.doc.createElement('script');
                    newScript_1.type = 'text/javascript';
                    newScript_1.async = true;
                    newScript_1.src = url;
                    newScript_1.onload = newScript_1.onreadystatechange = function () {
                        var rstate = newScript_1.readyState;
                        if (!rstate || rstate === 'loaded' || rstate === 'complete') {
                            newScript_1.onload = newScript_1.onreadystatechange = null;
                            if (newScript_1.parentNode) {
                                newScript_1.parentNode.removeChild(newScript_1);
                            }
                            loadCB();
                        }
                    };
                    newScript_1.onerror = function () {
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["m" /* log */])('Long-poll script failed to load: ' + url);
                        _this.sendNewPolls = false;
                        _this.close();
                    };
                    _this.myIFrame.doc.body.appendChild(newScript_1);
                }
                catch (e) {
                    // TODO: we should make this error visible somehow
                }
            }, Math.floor(1));
        }
    };
    return FirebaseIFrameScriptHolder;
}());




/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Connection; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_storage_storage__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Constants__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__TransportManager__ = __webpack_require__(121);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




// Abort upgrade attempt if it takes longer than 60s.
var UPGRADE_TIMEOUT = 60000;
// For some transports (WebSockets), we need to "validate" the transport by exchanging a few requests and responses.
// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.
var DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;
// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)
// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout
// but we've sent/received enough bytes, we don't cancel the connection.
var BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;
var BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;
var MESSAGE_TYPE = 't';
var MESSAGE_DATA = 'd';
var CONTROL_SHUTDOWN = 's';
var CONTROL_RESET = 'r';
var CONTROL_ERROR = 'e';
var CONTROL_PONG = 'o';
var SWITCH_ACK = 'a';
var END_TRANSMISSION = 'n';
var PING = 'p';
var SERVER_HELLO = 'h';
/**
 * Creates a new real-time connection to the server using whichever method works
 * best in the current browser.
 *
 * @constructor
 */
var Connection = /** @class */ (function () {
    /**
     * @param {!string} id - an id for this connection
     * @param {!RepoInfo} repoInfo_ - the info for the endpoint to connect to
     * @param {function(Object)} onMessage_ - the callback to be triggered when a server-push message arrives
     * @param {function(number, string)} onReady_ - the callback to be triggered when this connection is ready to send messages.
     * @param {function()} onDisconnect_ - the callback to be triggered when a connection was lost
     * @param {function(string)} onKill_ - the callback to be triggered when this connection has permanently shut down.
     * @param {string=} lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server
     */
    function Connection(id, repoInfo_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {
        this.id = id;
        this.repoInfo_ = repoInfo_;
        this.onMessage_ = onMessage_;
        this.onReady_ = onReady_;
        this.onDisconnect_ = onDisconnect_;
        this.onKill_ = onKill_;
        this.lastSessionId = lastSessionId;
        this.connectionCount = 0;
        this.pendingDataMessages = [];
        this.state_ = 0 /* CONNECTING */;
        this.log_ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["b" /* logWrapper */])('c:' + this.id + ':');
        this.transportManager_ = new __WEBPACK_IMPORTED_MODULE_3__TransportManager__["a" /* TransportManager */](repoInfo_);
        this.log_('Connection created');
        this.start_();
    }
    /**
     * Starts a connection attempt
     * @private
     */
    Connection.prototype.start_ = function () {
        var _this = this;
        var conn = this.transportManager_.initialTransport();
        this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, undefined, this.lastSessionId);
        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we
        // can consider the transport healthy.
        this.primaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;
        var onMessageReceived = this.connReceiver_(this.conn_);
        var onConnectionLost = this.disconnReceiver_(this.conn_);
        this.tx_ = this.conn_;
        this.rx_ = this.conn_;
        this.secondaryConn_ = null;
        this.isHealthy_ = false;
        /*
         * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.
         * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.
         * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should
         * still have the context of your originating frame.
         */
        setTimeout(function () {
            // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it
            _this.conn_ && _this.conn_.open(onMessageReceived, onConnectionLost);
        }, Math.floor(0));
        var healthyTimeout_ms = conn['healthyTimeout'] || 0;
        if (healthyTimeout_ms > 0) {
            this.healthyTimeout_ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["c" /* setTimeoutNonBlocking */])(function () {
                _this.healthyTimeout_ = null;
                if (!_this.isHealthy_) {
                    if (_this.conn_ &&
                        _this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {
                        _this.log_('Connection exceeded healthy timeout but has received ' +
                            _this.conn_.bytesReceived +
                            ' bytes.  Marking connection healthy.');
                        _this.isHealthy_ = true;
                        _this.conn_.markConnectionHealthy();
                    }
                    else if (_this.conn_ &&
                        _this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {
                        _this.log_('Connection exceeded healthy timeout but has sent ' +
                            _this.conn_.bytesSent +
                            ' bytes.  Leaving connection alive.');
                        // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to
                        // the server.
                    }
                    else {
                        _this.log_('Closing unhealthy connection after timeout.');
                        _this.close();
                    }
                }
            }, Math.floor(healthyTimeout_ms));
        }
    };
    /**
     * @return {!string}
     * @private
     */
    Connection.prototype.nextTransportId_ = function () {
        return 'c:' + this.id + ':' + this.connectionCount++;
    };
    Connection.prototype.disconnReceiver_ = function (conn) {
        var _this = this;
        return function (everConnected) {
            if (conn === _this.conn_) {
                _this.onConnectionLost_(everConnected);
            }
            else if (conn === _this.secondaryConn_) {
                _this.log_('Secondary connection lost.');
                _this.onSecondaryConnectionLost_();
            }
            else {
                _this.log_('closing an old connection');
            }
        };
    };
    Connection.prototype.connReceiver_ = function (conn) {
        var _this = this;
        return function (message) {
            if (_this.state_ != 2 /* DISCONNECTED */) {
                if (conn === _this.rx_) {
                    _this.onPrimaryMessageReceived_(message);
                }
                else if (conn === _this.secondaryConn_) {
                    _this.onSecondaryMessageReceived_(message);
                }
                else {
                    _this.log_('message on old connection');
                }
            }
        };
    };
    /**
     *
     * @param {Object} dataMsg An arbitrary data message to be sent to the server
     */
    Connection.prototype.sendRequest = function (dataMsg) {
        // wrap in a data message envelope and send it on
        var msg = { t: 'd', d: dataMsg };
        this.sendData_(msg);
    };
    Connection.prototype.tryCleanupConnection = function () {
        if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {
            this.log_('cleaning up and promoting a connection: ' + this.secondaryConn_.connId);
            this.conn_ = this.secondaryConn_;
            this.secondaryConn_ = null;
            // the server will shutdown the old connection
        }
    };
    Connection.prototype.onSecondaryControl_ = function (controlData) {
        if (MESSAGE_TYPE in controlData) {
            var cmd = controlData[MESSAGE_TYPE];
            if (cmd === SWITCH_ACK) {
                this.upgradeIfSecondaryHealthy_();
            }
            else if (cmd === CONTROL_RESET) {
                // Most likely the session wasn't valid. Abandon the switch attempt
                this.log_('Got a reset on secondary, closing it');
                this.secondaryConn_.close();
                // If we were already using this connection for something, than we need to fully close
                if (this.tx_ === this.secondaryConn_ ||
                    this.rx_ === this.secondaryConn_) {
                    this.close();
                }
            }
            else if (cmd === CONTROL_PONG) {
                this.log_('got pong on secondary.');
                this.secondaryResponsesRequired_--;
                this.upgradeIfSecondaryHealthy_();
            }
        }
    };
    Connection.prototype.onSecondaryMessageReceived_ = function (parsedData) {
        var layer = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["d" /* requireKey */])('t', parsedData);
        var data = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["d" /* requireKey */])('d', parsedData);
        if (layer == 'c') {
            this.onSecondaryControl_(data);
        }
        else if (layer == 'd') {
            // got a data message, but we're still second connection. Need to buffer it up
            this.pendingDataMessages.push(data);
        }
        else {
            throw new Error('Unknown protocol layer: ' + layer);
        }
    };
    Connection.prototype.upgradeIfSecondaryHealthy_ = function () {
        if (this.secondaryResponsesRequired_ <= 0) {
            this.log_('Secondary connection is healthy.');
            this.isHealthy_ = true;
            this.secondaryConn_.markConnectionHealthy();
            this.proceedWithUpgrade_();
        }
        else {
            // Send a ping to make sure the connection is healthy.
            this.log_('sending ping on secondary.');
            this.secondaryConn_.send({ t: 'c', d: { t: PING, d: {} } });
        }
    };
    Connection.prototype.proceedWithUpgrade_ = function () {
        // tell this connection to consider itself open
        this.secondaryConn_.start();
        // send ack
        this.log_('sending client ack on secondary');
        this.secondaryConn_.send({ t: 'c', d: { t: SWITCH_ACK, d: {} } });
        // send end packet on primary transport, switch to sending on this one
        // can receive on this one, buffer responses until end received on primary transport
        this.log_('Ending transmission on primary');
        this.conn_.send({ t: 'c', d: { t: END_TRANSMISSION, d: {} } });
        this.tx_ = this.secondaryConn_;
        this.tryCleanupConnection();
    };
    Connection.prototype.onPrimaryMessageReceived_ = function (parsedData) {
        // Must refer to parsedData properties in quotes, so closure doesn't touch them.
        var layer = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["d" /* requireKey */])('t', parsedData);
        var data = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["d" /* requireKey */])('d', parsedData);
        if (layer == 'c') {
            this.onControl_(data);
        }
        else if (layer == 'd') {
            this.onDataMessage_(data);
        }
    };
    Connection.prototype.onDataMessage_ = function (message) {
        this.onPrimaryResponse_();
        // We don't do anything with data messages, just kick them up a level
        this.onMessage_(message);
    };
    Connection.prototype.onPrimaryResponse_ = function () {
        if (!this.isHealthy_) {
            this.primaryResponsesRequired_--;
            if (this.primaryResponsesRequired_ <= 0) {
                this.log_('Primary connection is healthy.');
                this.isHealthy_ = true;
                this.conn_.markConnectionHealthy();
            }
        }
    };
    Connection.prototype.onControl_ = function (controlData) {
        var cmd = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["d" /* requireKey */])(MESSAGE_TYPE, controlData);
        if (MESSAGE_DATA in controlData) {
            var payload = controlData[MESSAGE_DATA];
            if (cmd === SERVER_HELLO) {
                this.onHandshake_(payload);
            }
            else if (cmd === END_TRANSMISSION) {
                this.log_('recvd end transmission on primary');
                this.rx_ = this.secondaryConn_;
                for (var i = 0; i < this.pendingDataMessages.length; ++i) {
                    this.onDataMessage_(this.pendingDataMessages[i]);
                }
                this.pendingDataMessages = [];
                this.tryCleanupConnection();
            }
            else if (cmd === CONTROL_SHUTDOWN) {
                // This was previously the 'onKill' callback passed to the lower-level connection
                // payload in this case is the reason for the shutdown. Generally a human-readable error
                this.onConnectionShutdown_(payload);
            }
            else if (cmd === CONTROL_RESET) {
                // payload in this case is the host we should contact
                this.onReset_(payload);
            }
            else if (cmd === CONTROL_ERROR) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["e" /* error */])('Server Error: ' + payload);
            }
            else if (cmd === CONTROL_PONG) {
                this.log_('got pong on primary.');
                this.onPrimaryResponse_();
                this.sendPingOnPrimaryIfNecessary_();
            }
            else {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["e" /* error */])('Unknown control packet command: ' + cmd);
            }
        }
    };
    /**
     *
     * @param {Object} handshake The handshake data returned from the server
     * @private
     */
    Connection.prototype.onHandshake_ = function (handshake) {
        var timestamp = handshake.ts;
        var version = handshake.v;
        var host = handshake.h;
        this.sessionId = handshake.s;
        this.repoInfo_.updateHost(host);
        // if we've already closed the connection, then don't bother trying to progress further
        if (this.state_ == 0 /* CONNECTING */) {
            this.conn_.start();
            this.onConnectionEstablished_(this.conn_, timestamp);
            if (__WEBPACK_IMPORTED_MODULE_2__Constants__["c" /* PROTOCOL_VERSION */] !== version) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["f" /* warn */])('Protocol version mismatch detected');
            }
            // TODO: do we want to upgrade? when? maybe a delay?
            this.tryStartUpgrade_();
        }
    };
    Connection.prototype.tryStartUpgrade_ = function () {
        var conn = this.transportManager_.upgradeTransport();
        if (conn) {
            this.startUpgrade_(conn);
        }
    };
    Connection.prototype.startUpgrade_ = function (conn) {
        var _this = this;
        this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.sessionId);
        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we
        // can consider the transport healthy.
        this.secondaryResponsesRequired_ =
            conn['responsesRequiredToBeHealthy'] || 0;
        var onMessage = this.connReceiver_(this.secondaryConn_);
        var onDisconnect = this.disconnReceiver_(this.secondaryConn_);
        this.secondaryConn_.open(onMessage, onDisconnect);
        // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["c" /* setTimeoutNonBlocking */])(function () {
            if (_this.secondaryConn_) {
                _this.log_('Timed out trying to upgrade.');
                _this.secondaryConn_.close();
            }
        }, Math.floor(UPGRADE_TIMEOUT));
    };
    Connection.prototype.onReset_ = function (host) {
        this.log_('Reset packet received.  New host: ' + host);
        this.repoInfo_.updateHost(host);
        // TODO: if we're already "connected", we need to trigger a disconnect at the next layer up.
        // We don't currently support resets after the connection has already been established
        if (this.state_ === 1 /* CONNECTED */) {
            this.close();
        }
        else {
            // Close whatever connections we have open and start again.
            this.closeConnections_();
            this.start_();
        }
    };
    Connection.prototype.onConnectionEstablished_ = function (conn, timestamp) {
        var _this = this;
        this.log_('Realtime connection established.');
        this.conn_ = conn;
        this.state_ = 1 /* CONNECTED */;
        if (this.onReady_) {
            this.onReady_(timestamp, this.sessionId);
            this.onReady_ = null;
        }
        // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,
        // send some pings.
        if (this.primaryResponsesRequired_ === 0) {
            this.log_('Primary connection is healthy.');
            this.isHealthy_ = true;
        }
        else {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["c" /* setTimeoutNonBlocking */])(function () {
                _this.sendPingOnPrimaryIfNecessary_();
            }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));
        }
    };
    Connection.prototype.sendPingOnPrimaryIfNecessary_ = function () {
        // If the connection isn't considered healthy yet, we'll send a noop ping packet request.
        if (!this.isHealthy_ && this.state_ === 1 /* CONNECTED */) {
            this.log_('sending ping on primary.');
            this.sendData_({ t: 'c', d: { t: PING, d: {} } });
        }
    };
    Connection.prototype.onSecondaryConnectionLost_ = function () {
        var conn = this.secondaryConn_;
        this.secondaryConn_ = null;
        if (this.tx_ === conn || this.rx_ === conn) {
            // we are relying on this connection already in some capacity. Therefore, a failure is real
            this.close();
        }
    };
    /**
     *
     * @param {boolean} everConnected Whether or not the connection ever reached a server. Used to determine if
     * we should flush the host cache
     * @private
     */
    Connection.prototype.onConnectionLost_ = function (everConnected) {
        this.conn_ = null;
        // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting
        // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.
        if (!everConnected && this.state_ === 0 /* CONNECTING */) {
            this.log_('Realtime connection failed.');
            // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away
            if (this.repoInfo_.isCacheableHost()) {
                __WEBPACK_IMPORTED_MODULE_1__core_storage_storage__["a" /* PersistentStorage */].remove('host:' + this.repoInfo_.host);
                // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com
                this.repoInfo_.internalHost = this.repoInfo_.host;
            }
        }
        else if (this.state_ === 1 /* CONNECTED */) {
            this.log_('Realtime connection lost.');
        }
        this.close();
    };
    /**
     *
     * @param {string} reason
     * @private
     */
    Connection.prototype.onConnectionShutdown_ = function (reason) {
        this.log_('Connection shutdown command received. Shutting down...');
        if (this.onKill_) {
            this.onKill_(reason);
            this.onKill_ = null;
        }
        // We intentionally don't want to fire onDisconnect (kill is a different case),
        // so clear the callback.
        this.onDisconnect_ = null;
        this.close();
    };
    Connection.prototype.sendData_ = function (data) {
        if (this.state_ !== 1 /* CONNECTED */) {
            throw 'Connection is not connected';
        }
        else {
            this.tx_.send(data);
        }
    };
    /**
     * Cleans up this connection, calling the appropriate callbacks
     */
    Connection.prototype.close = function () {
        if (this.state_ !== 2 /* DISCONNECTED */) {
            this.log_('Closing realtime connection.');
            this.state_ = 2 /* DISCONNECTED */;
            this.closeConnections_();
            if (this.onDisconnect_) {
                this.onDisconnect_();
                this.onDisconnect_ = null;
            }
        }
    };
    /**
     *
     * @private
     */
    Connection.prototype.closeConnections_ = function () {
        this.log_('Shutting down all connections');
        if (this.conn_) {
            this.conn_.close();
            this.conn_ = null;
        }
        if (this.secondaryConn_) {
            this.secondaryConn_.close();
            this.secondaryConn_ = null;
        }
        if (this.healthyTimeout_) {
            clearTimeout(this.healthyTimeout_);
            this.healthyTimeout_ = null;
        }
    };
    return Connection;
}());




/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export setWebSocketImpl */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebSocketConnection; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_stats_StatsManager__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Constants__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_storage_storage__ = __webpack_require__(21);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









var WEBSOCKET_MAX_FRAME_SIZE = 16384;
var WEBSOCKET_KEEPALIVE_INTERVAL = 45000;
var WebSocketImpl = null;
if (typeof MozWebSocket !== 'undefined') {
    WebSocketImpl = MozWebSocket;
}
else if (typeof WebSocket !== 'undefined') {
    WebSocketImpl = WebSocket;
}
function setWebSocketImpl(impl) {
    WebSocketImpl = impl;
}
/**
 * Create a new websocket connection with the given callbacks.
 * @constructor
 * @implements {Transport}
 */
var WebSocketConnection = /** @class */ (function () {
    /**
     * @param {string} connId identifier for this transport
     * @param {RepoInfo} repoInfo The info for the websocket endpoint.
     * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport
     *                                         session
     * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection
     */
    function WebSocketConnection(connId, repoInfo, transportSessionId, lastSessionId) {
        this.connId = connId;
        this.keepaliveTimer = null;
        this.frames = null;
        this.totalFrames = 0;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.log_ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util_util__["b" /* logWrapper */])(this.connId);
        this.stats_ = __WEBPACK_IMPORTED_MODULE_3__core_stats_StatsManager__["a" /* StatsManager */].getCollection(repoInfo);
        this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId);
    }
    /**
     * @param {RepoInfo} repoInfo The info for the websocket endpoint.
     * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport
     *                                         session
     * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection
     * @return {string} connection url
     * @private
     */
    WebSocketConnection.connectionURL_ = function (repoInfo, transportSessionId, lastSessionId) {
        var urlParams = {};
        urlParams[__WEBPACK_IMPORTED_MODULE_4__Constants__["d" /* VERSION_PARAM */]] = __WEBPACK_IMPORTED_MODULE_4__Constants__["c" /* PROTOCOL_VERSION */];
        if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["f" /* isNodeSdk */])() &&
            typeof location !== 'undefined' &&
            location.href &&
            location.href.indexOf(__WEBPACK_IMPORTED_MODULE_4__Constants__["e" /* FORGE_DOMAIN */]) !== -1) {
            urlParams[__WEBPACK_IMPORTED_MODULE_4__Constants__["f" /* REFERER_PARAM */]] = __WEBPACK_IMPORTED_MODULE_4__Constants__["g" /* FORGE_REF */];
        }
        if (transportSessionId) {
            urlParams[__WEBPACK_IMPORTED_MODULE_4__Constants__["h" /* TRANSPORT_SESSION_PARAM */]] = transportSessionId;
        }
        if (lastSessionId) {
            urlParams[__WEBPACK_IMPORTED_MODULE_4__Constants__["i" /* LAST_SESSION_PARAM */]] = lastSessionId;
        }
        return repoInfo.connectionURL(__WEBPACK_IMPORTED_MODULE_4__Constants__["a" /* WEBSOCKET */], urlParams);
    };
    /**
     *
     * @param onMessage Callback when messages arrive
     * @param onDisconnect Callback with connection lost.
     */
    WebSocketConnection.prototype.open = function (onMessage, onDisconnect) {
        var _this = this;
        this.onDisconnect = onDisconnect;
        this.onMessage = onMessage;
        this.log_('Websocket connecting to ' + this.connURL);
        this.everConnected_ = false;
        // Assume failure until proven otherwise.
        __WEBPACK_IMPORTED_MODULE_5__core_storage_storage__["a" /* PersistentStorage */].set('previous_websocket_failure', true);
        try {
            if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["f" /* isNodeSdk */])()) {
                var device = __WEBPACK_IMPORTED_MODULE_1__firebase_util__["o" /* CONSTANTS */].NODE_ADMIN ? 'AdminNode' : 'Node';
                // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>
                var options = {
                    headers: {
                        'User-Agent': "Firebase/" + __WEBPACK_IMPORTED_MODULE_4__Constants__["c" /* PROTOCOL_VERSION */] + "/" + __WEBPACK_IMPORTED_MODULE_0__firebase_app__["default"].SDK_VERSION + "/" + process.platform + "/" + device
                    }
                };
                // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.
                var env = __webpack_require__.i({"NODE_ENV":"development"});
                var proxy = this.connURL.indexOf('wss://') == 0
                    ? env['HTTPS_PROXY'] || env['https_proxy']
                    : env['HTTP_PROXY'] || env['http_proxy'];
                if (proxy) {
                    options['proxy'] = { origin: proxy };
                }
                this.mySock = new WebSocketImpl(this.connURL, [], options);
            }
            else {
                this.mySock = new WebSocketImpl(this.connURL);
            }
        }
        catch (e) {
            this.log_('Error instantiating WebSocket.');
            var error = e.message || e.data;
            if (error) {
                this.log_(error);
            }
            this.onClosed_();
            return;
        }
        this.mySock.onopen = function () {
            _this.log_('Websocket connected.');
            _this.everConnected_ = true;
        };
        this.mySock.onclose = function () {
            _this.log_('Websocket connection was disconnected.');
            _this.mySock = null;
            _this.onClosed_();
        };
        this.mySock.onmessage = function (m) {
            _this.handleIncomingFrame(m);
        };
        this.mySock.onerror = function (e) {
            _this.log_('WebSocket error.  Closing connection.');
            var error = e.message || e.data;
            if (error) {
                _this.log_(error);
            }
            _this.onClosed_();
        };
    };
    /**
     * No-op for websockets, we don't need to do anything once the connection is confirmed as open
     */
    WebSocketConnection.prototype.start = function () { };
    WebSocketConnection.forceDisallow = function () {
        WebSocketConnection.forceDisallow_ = true;
    };
    WebSocketConnection.isAvailable = function () {
        var isOldAndroid = false;
        if (typeof navigator !== 'undefined' && navigator.userAgent) {
            var oldAndroidRegex = /Android ([0-9]{0,}\.[0-9]{0,})/;
            var oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);
            if (oldAndroidMatch && oldAndroidMatch.length > 1) {
                if (parseFloat(oldAndroidMatch[1]) < 4.4) {
                    isOldAndroid = true;
                }
            }
        }
        return (!isOldAndroid &&
            WebSocketImpl !== null &&
            !WebSocketConnection.forceDisallow_);
    };
    /**
     * Returns true if we previously failed to connect with this transport.
     * @return {boolean}
     */
    WebSocketConnection.previouslyFailed = function () {
        // If our persistent storage is actually only in-memory storage,
        // we default to assuming that it previously failed to be safe.
        return (__WEBPACK_IMPORTED_MODULE_5__core_storage_storage__["a" /* PersistentStorage */].isInMemoryStorage ||
            __WEBPACK_IMPORTED_MODULE_5__core_storage_storage__["a" /* PersistentStorage */].get('previous_websocket_failure') === true);
    };
    WebSocketConnection.prototype.markConnectionHealthy = function () {
        __WEBPACK_IMPORTED_MODULE_5__core_storage_storage__["a" /* PersistentStorage */].remove('previous_websocket_failure');
    };
    WebSocketConnection.prototype.appendFrame_ = function (data) {
        this.frames.push(data);
        if (this.frames.length == this.totalFrames) {
            var fullMess = this.frames.join('');
            this.frames = null;
            var jsonMess = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["k" /* jsonEval */])(fullMess);
            //handle the message
            this.onMessage(jsonMess);
        }
    };
    /**
     * @param {number} frameCount The number of frames we are expecting from the server
     * @private
     */
    WebSocketConnection.prototype.handleNewFrameCount_ = function (frameCount) {
        this.totalFrames = frameCount;
        this.frames = [];
    };
    /**
     * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1
     * @param {!String} data
     * @return {?String} Any remaining data to be process, or null if there is none
     * @private
     */
    WebSocketConnection.prototype.extractFrameCount_ = function (data) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["g" /* assert */])(this.frames === null, 'We already have a frame buffer');
        // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced
        // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508
        if (data.length <= 6) {
            var frameCount = Number(data);
            if (!isNaN(frameCount)) {
                this.handleNewFrameCount_(frameCount);
                return null;
            }
        }
        this.handleNewFrameCount_(1);
        return data;
    };
    /**
     * Process a websocket frame that has arrived from the server.
     * @param mess The frame data
     */
    WebSocketConnection.prototype.handleIncomingFrame = function (mess) {
        if (this.mySock === null)
            return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.
        var data = mess['data'];
        this.bytesReceived += data.length;
        this.stats_.incrementCounter('bytes_received', data.length);
        this.resetKeepAlive();
        if (this.frames !== null) {
            // we're buffering
            this.appendFrame_(data);
        }
        else {
            // try to parse out a frame count, otherwise, assume 1 and process it
            var remainingData = this.extractFrameCount_(data);
            if (remainingData !== null) {
                this.appendFrame_(remainingData);
            }
        }
    };
    /**
     * Send a message to the server
     * @param {Object} data The JSON object to transmit
     */
    WebSocketConnection.prototype.send = function (data) {
        this.resetKeepAlive();
        var dataStr = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["j" /* stringify */])(data);
        this.bytesSent += dataStr.length;
        this.stats_.incrementCounter('bytes_sent', dataStr.length);
        //We can only fit a certain amount in each websocket frame, so we need to split this request
        //up into multiple pieces if it doesn't fit in one request.
        var dataSegs = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util_util__["h" /* splitStringBySize */])(dataStr, WEBSOCKET_MAX_FRAME_SIZE);
        //Send the length header
        if (dataSegs.length > 1) {
            this.sendString_(String(dataSegs.length));
        }
        //Send the actual data in segments.
        for (var i = 0; i < dataSegs.length; i++) {
            this.sendString_(dataSegs[i]);
        }
    };
    WebSocketConnection.prototype.shutdown_ = function () {
        this.isClosed_ = true;
        if (this.keepaliveTimer) {
            clearInterval(this.keepaliveTimer);
            this.keepaliveTimer = null;
        }
        if (this.mySock) {
            this.mySock.close();
            this.mySock = null;
        }
    };
    WebSocketConnection.prototype.onClosed_ = function () {
        if (!this.isClosed_) {
            this.log_('WebSocket is closing itself');
            this.shutdown_();
            // since this is an internal close, trigger the close listener
            if (this.onDisconnect) {
                this.onDisconnect(this.everConnected_);
                this.onDisconnect = null;
            }
        }
    };
    /**
     * External-facing close handler.
     * Close the websocket and kill the connection.
     */
    WebSocketConnection.prototype.close = function () {
        if (!this.isClosed_) {
            this.log_('WebSocket is being closed');
            this.shutdown_();
        }
    };
    /**
     * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after
     * the last activity.
     */
    WebSocketConnection.prototype.resetKeepAlive = function () {
        var _this = this;
        clearInterval(this.keepaliveTimer);
        this.keepaliveTimer = setInterval(function () {
            //If there has been no websocket activity for a while, send a no-op
            if (_this.mySock) {
                _this.sendString_('0');
            }
            _this.resetKeepAlive();
        }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));
    };
    /**
     * Send a string over the websocket.
     *
     * @param {string} str String to send.
     * @private
     */
    WebSocketConnection.prototype.sendString_ = function (str) {
        // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()
        // calls for some unknown reason.  We treat these as an error and disconnect.
        // See https://app.asana.com/0/58926111402292/68021340250410
        try {
            this.mySock.send(str);
        }
        catch (e) {
            this.log_('Exception thrown from WebSocket.send():', e.message || e.data, 'Closing connection.');
            setTimeout(this.onClosed_.bind(this), 0);
        }
    };
    /**
     * Number of response before we consider the connection "healthy."
     * @type {number}
     */
    WebSocketConnection.responsesRequiredToBeHealthy = 2;
    /**
     * Time to wait for the connection te become healthy before giving up.
     * @type {number}
     */
    WebSocketConnection.healthyTimeout = 30000;
    return WebSocketConnection;
}());




/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return assert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return assertionError; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(30);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Throws an error if the provided assertion is falsy
 * @param {*} assertion The assertion to be tested for falsiness
 * @param {!string} message The message to display if the check fails
 */
var assert = function (assertion, message) {
    if (!assertion) {
        throw assertionError(message);
    }
};
/**
 * Returns an Error object suitable for throwing.
 * @param {string} message
 * @return {!Error}
 */
var assertionError = function (message) {
    return new Error('Firebase Database (' +
        __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* CONSTANTS */].SDK_VERSION +
        ') INTERNAL ASSERT FAILED: ' +
        message);
};



/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return base64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return base64Encode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return base64Decode; });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var stringToByteArray = function (str) {
    var output = [], p = 0;
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        while (c > 255) {
            output[p++] = c & 255;
            c >>= 8;
        }
        output[p++] = c;
    }
    return output;
};
/**
 * Turns an array of numbers into the string given by the concatenation of the
 * characters to which the numbers correspond.
 * @param {Array<number>} bytes Array of numbers representing characters.
 * @return {string} Stringification of the array.
 */
var byteArrayToString = function (bytes) {
    var CHUNK_SIZE = 8192;
    // Special-case the simple case for speed's sake.
    if (bytes.length < CHUNK_SIZE) {
        return String.fromCharCode.apply(null, bytes);
    }
    // The remaining logic splits conversion by chunks since
    // Function#apply() has a maximum parameter count.
    // See discussion: http://goo.gl/LrWmZ9
    var str = '';
    for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {
        var chunk = bytes.slice(i, i + CHUNK_SIZE);
        str += String.fromCharCode.apply(null, chunk);
    }
    return str;
};
// Static lookup maps, lazily populated by init_()
var base64 = {
    /**
     * Maps bytes to characters.
     * @type {Object}
     * @private
     */
    byteToCharMap_: null,
    /**
     * Maps characters to bytes.
     * @type {Object}
     * @private
     */
    charToByteMap_: null,
    /**
     * Maps bytes to websafe characters.
     * @type {Object}
     * @private
     */
    byteToCharMapWebSafe_: null,
    /**
     * Maps websafe characters to bytes.
     * @type {Object}
     * @private
     */
    charToByteMapWebSafe_: null,
    /**
     * Our default alphabet, shared between
     * ENCODED_VALS and ENCODED_VALS_WEBSAFE
     * @type {string}
     */
    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',
    /**
     * Our default alphabet. Value 64 (=) is special; it means "nothing."
     * @type {string}
     */
    get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + '+/=';
    },
    /**
     * Our websafe alphabet.
     * @type {string}
     */
    get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + '-_.';
    },
    /**
     * Whether this browser supports the atob and btoa functions. This extension
     * started at Mozilla but is now implemented by many browsers. We use the
     * ASSUME_* variables to avoid pulling in the full useragent detection library
     * but still allowing the standard per-browser compilations.
     *
     * @type {boolean}
     */
    HAS_NATIVE_SUPPORT: typeof atob === 'function',
    /**
     * Base64-encode an array of bytes.
     *
     * @param {Array<number>|Uint8Array} input An array of bytes (numbers with
     *     value in [0, 255]) to encode.
     * @param {boolean=} opt_webSafe Boolean indicating we should use the
     *     alternative alphabet.
     * @return {string} The base64 encoded string.
     */
    encodeByteArray: function (input, opt_webSafe) {
        if (!Array.isArray(input)) {
            throw Error('encodeByteArray takes an array as a parameter');
        }
        this.init_();
        var byteToCharMap = opt_webSafe
            ? this.byteToCharMapWebSafe_
            : this.byteToCharMap_;
        var output = [];
        for (var i = 0; i < input.length; i += 3) {
            var byte1 = input[i];
            var haveByte2 = i + 1 < input.length;
            var byte2 = haveByte2 ? input[i + 1] : 0;
            var haveByte3 = i + 2 < input.length;
            var byte3 = haveByte3 ? input[i + 2] : 0;
            var outByte1 = byte1 >> 2;
            var outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);
            var outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);
            var outByte4 = byte3 & 0x3f;
            if (!haveByte3) {
                outByte4 = 64;
                if (!haveByte2) {
                    outByte3 = 64;
                }
            }
            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join('');
    },
    /**
     * Base64-encode a string.
     *
     * @param {string} input A string to encode.
     * @param {boolean=} opt_webSafe If true, we should use the
     *     alternative alphabet.
     * @return {string} The base64 encoded string.
     */
    encodeString: function (input, opt_webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {
            return btoa(input);
        }
        return this.encodeByteArray(stringToByteArray(input), opt_webSafe);
    },
    /**
     * Base64-decode a string.
     *
     * @param {string} input to decode.
     * @param {boolean=} opt_webSafe True if we should use the
     *     alternative alphabet.
     * @return {string} string representing the decoded value.
     */
    decodeString: function (input, opt_webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {
            return atob(input);
        }
        return byteArrayToString(this.decodeStringToByteArray(input, opt_webSafe));
    },
    /**
     * Base64-decode a string.
     *
     * In base-64 decoding, groups of four characters are converted into three
     * bytes.  If the encoder did not apply padding, the input length may not
     * be a multiple of 4.
     *
     * In this case, the last group will have fewer than 4 characters, and
     * padding will be inferred.  If the group has one or two characters, it decodes
     * to one byte.  If the group has three characters, it decodes to two bytes.
     *
     * @param {string} input Input to decode.
     * @param {boolean=} opt_webSafe True if we should use the web-safe alphabet.
     * @return {!Array<number>} bytes representing the decoded value.
     */
    decodeStringToByteArray: function (input, opt_webSafe) {
        this.init_();
        var charToByteMap = opt_webSafe
            ? this.charToByteMapWebSafe_
            : this.charToByteMap_;
        var output = [];
        for (var i = 0; i < input.length;) {
            var byte1 = charToByteMap[input.charAt(i++)];
            var haveByte2 = i < input.length;
            var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
            ++i;
            var haveByte3 = i < input.length;
            var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            var haveByte4 = i < input.length;
            var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
                throw Error();
            }
            var outByte1 = (byte1 << 2) | (byte2 >> 4);
            output.push(outByte1);
            if (byte3 != 64) {
                var outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);
                output.push(outByte2);
                if (byte4 != 64) {
                    var outByte3 = ((byte3 << 6) & 0xc0) | byte4;
                    output.push(outByte3);
                }
            }
        }
        return output;
    },
    /**
     * Lazy static initialization function. Called before
     * accessing any of the static map variables.
     * @private
     */
    init_: function () {
        if (!this.byteToCharMap_) {
            this.byteToCharMap_ = {};
            this.charToByteMap_ = {};
            this.byteToCharMapWebSafe_ = {};
            this.charToByteMapWebSafe_ = {};
            // We want quick mappings back and forth, so we precompute two maps.
            for (var i = 0; i < this.ENCODED_VALS.length; i++) {
                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
                this.charToByteMap_[this.byteToCharMap_[i]] = i;
                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
                // Be forgiving when decoding and correctly decode both encodings.
                if (i >= this.ENCODED_VALS_BASE.length) {
                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
                }
            }
        }
    }
};
/**
 * URL-safe base64 encoding
 * @param {!string} str
 * @return {!string}
 */
var base64Encode = function (str) {
    var utf8Bytes = stringToByteArray(str);
    return base64.encodeByteArray(utf8Bytes, true);
};
/**
 * URL-safe base64 decoding
 *
 * NOTE: DO NOT use the global atob() function - it does NOT support the
 * base64Url variant encoding.
 *
 * @param {string} str To be decoded
 * @return {?string} Decoded result, if possible
 */
var base64Decode = function (str) {
    try {
        return base64.decodeString(str, true);
    }
    catch (e) {
        console.error('base64Decode failed: ', e);
    }
    return null;
};



/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = jsonEval;
/* harmony export (immutable) */ __webpack_exports__["b"] = stringify;
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Evaluates a JSON string into a javascript object.
 *
 * @param {string} str A string containing JSON.
 * @return {*} The javascript object representing the specified JSON.
 */
function jsonEval(str) {
    return JSON.parse(str);
}
/**
 * Returns JSON representing a javascript object.
 * @param {*} data Javascript object to be stringified.
 * @return {string} The JSON contents of the object.
 */
function stringify(data) {
    return JSON.stringify(data);
}



/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return contains; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return safeGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return forEach; });
/* unused harmony export extend */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return clone; });
/* unused harmony export isNonNullObject */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return findKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return findValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return getAnyKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return getValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return every; });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// See http://www.devthought.com/2012/01/18/an-object-is-not-a-hash/
var contains = function (obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
};
var safeGet = function (obj, key) {
    if (Object.prototype.hasOwnProperty.call(obj, key))
        return obj[key];
    // else return undefined.
};
/**
 * Enumerates the keys/values in an object, excluding keys defined on the prototype.
 *
 * @param {?Object.<K,V>} obj Object to enumerate.
 * @param {!function(K, V)} fn Function to call for each key and value.
 * @template K,V
 */
var forEach = function (obj, fn) {
    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn(key, obj[key]);
        }
    }
};
/**
 * Copies all the (own) properties from one object to another.
 * @param {!Object} objTo
 * @param {!Object} objFrom
 * @return {!Object} objTo
 */
var extend = function (objTo, objFrom) {
    forEach(objFrom, function (key, value) {
        objTo[key] = value;
    });
    return objTo;
};
/**
 * Returns a clone of the specified object.
 * @param {!Object} obj
 * @return {!Object} cloned obj.
 */
var clone = function (obj) {
    return extend({}, obj);
};
/**
 * Returns true if obj has typeof "object" and is not null.  Unlike goog.isObject(), does not return true
 * for functions.
 *
 * @param obj {*} A potential object.
 * @returns {boolean} True if it's an object.
 */
var isNonNullObject = function (obj) {
    return typeof obj === 'object' && obj !== null;
};
var isEmpty = function (obj) {
    for (var key in obj) {
        return false;
    }
    return true;
};
var getCount = function (obj) {
    var rv = 0;
    for (var key in obj) {
        rv++;
    }
    return rv;
};
var map = function (obj, f, opt_obj) {
    var res = {};
    for (var key in obj) {
        res[key] = f.call(opt_obj, obj[key], key, obj);
    }
    return res;
};
var findKey = function (obj, fn, opt_this) {
    for (var key in obj) {
        if (fn.call(opt_this, obj[key], key, obj)) {
            return key;
        }
    }
    return undefined;
};
var findValue = function (obj, fn, opt_this) {
    var key = findKey(obj, fn, opt_this);
    return key && obj[key];
};
var getAnyKey = function (obj) {
    for (var key in obj) {
        return key;
    }
};
var getValues = function (obj) {
    var res = [];
    var i = 0;
    for (var key in obj) {
        res[i++] = obj[key];
    }
    return res;
};
/**
 * Tests whether every key/value pair in an object pass the test implemented
 * by the provided function
 *
 * @param {?Object.<K,V>} obj Object to test.
 * @param {!function(K, V)} fn Function to call for each key and value.
 * @template K,V
 */
var every = function (obj, fn) {
    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            if (!fn(key, obj[key])) {
                return false;
            }
        }
    }
    return true;
};



/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export shuffled */
/* unused harmony export randomItem */
/* unused harmony export removeDuplicates */
/* unused harmony export addOnce */
/* unused harmony export next */
/* unused harmony export prev */
/* unused harmony export nextItem */
/* unused harmony export prevItem */
/* unused harmony export removeFirst */
/* unused harmony export removeAll */
/* unused harmony export contains */
/* unused harmony export wrapIndex */
/* unused harmony export firstItem */
/* unused harmony export lastItem */
/* harmony export (immutable) */ __webpack_exports__["a"] = lastIndex;
/* unused harmony export getIndexRange */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__maths__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__random__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Range__ = __webpack_require__(31);





function shuffled(a) {
  return __WEBPACK_IMPORTED_MODULE_1__random__["e" /* shuffle */](a);
}
function randomItem(a) {
  return __WEBPACK_IMPORTED_MODULE_1__random__["f" /* item */](a);
}

function removeDuplicates(a) {
  return Array.from(new Set(a));
}

function addOnce(a, item) {
  if (a.indexOf(item) == -1) {
    a.push(item);
  }
}

function next(i, a, clamp = false) {
  return __WEBPACK_IMPORTED_MODULE_0__maths__["i" /* nextWithin */](i, 0, a.length - 1, clamp);
}
function prev(i, a, clamp = false) {
  return __WEBPACK_IMPORTED_MODULE_0__maths__["j" /* prevWithin */](i, 0, a.length - 1, clamp);
}

function nextItem(item, a, clamp = false) {

  let i    = a.indexOf(item),
    iNext  = next(i, a, clamp);

  return a[iNext];

}
function prevItem(item, a, clamp = false) {

  let i    = a.indexOf(item),
    iPrev  = prev(i, a, clamp);

  return a[iPrev];

}

function removeFirst(a, item) {
  for (let i = 0; i < a.length; i++) {
    if (a[i] == item) {
      a.splice(i, 1);
      return;
    }
  }
}
function removeAll(a, item) {
  for (let i = 0; i < a.length; i++) {
    if (a[i] == item) {
      a.splice(i, 1);
      i--;
    }
  }
}

function contains(a, item) {
  return (a.indexOf(item) != -1);
}

function wrapIndex(i, a) {
  return __WEBPACK_IMPORTED_MODULE_0__maths__["g" /* wrap */](i, 0, a.length - 1);
}

function firstItem(a) {
  return a[0];
}
function lastItem(a) {
  return a[lastIndex(a)];
}

function lastIndex(a) {
  return a.length - 1;
}

function getIndexRange(a) {
  return new __WEBPACK_IMPORTED_MODULE_2__Range__(0, a.length - 1);
}


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export transformPt */
/* unused harmony export scalePt */
/* unused harmony export rotatePt */
/* unused harmony export ptAroundCircle */
/* harmony export (immutable) */ __webpack_exports__["a"] = dist;
/* unused harmony export distXY */
/* harmony export (immutable) */ __webpack_exports__["b"] = distSq;
/* unused harmony export distSqXY */
/* unused harmony export lerpPt */
/* unused harmony export degToRad */
/* unused harmony export radToDeg */
/* unused harmony export getRadFromPts */
/* unused harmony export getRadFromXY */
/* unused harmony export lerpRect */
/* unused harmony export getFillRect */
/* unused harmony export getFitRect */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__maths__ = __webpack_require__(17);



// Pts

function transformPt(pt, scaleX, scaleY, rads) {
  return rotatePt(scalePt(pt, scaleX, scaleY), rads);
}
function scalePt(pt, scaleX, scaleY) {

  return {
    x: pt.x * scaleX,
    y: pt.y * scaleY
  };

}
function rotatePt(pt, rads, origin) {

  let ox = (origin === undefined) ? 0 : origin.x,
      oy = (origin === undefined) ? 0 : origin.y;

  let dx = pt.x - ox,
      dy = pt.y - oy;

  let aSin = Math.sin(rads),
      aCos = Math.cos(rads);

  let x  = (aCos * dx) - (aSin * dy) + ox,
      y  = (aSin * dx) + (aCos * dy) + oy

  return { x, y };

}

function ptAroundCircle(rad, perc, origin = null) {

  let angle = (perc * __WEBPACK_IMPORTED_MODULE_0__maths__["a" /* TAO */]) - (Math.PI / 2),
      x     = (origin ? origin.x : 0) + (rad * Math.cos(angle)),
      y     = (origin ? origin.y : 0) + (rad * Math.sin(angle));

  return { x, y };

}

function dist(pt1, pt2) {
  return Math.sqrt(distSq(pt1, pt2));
}
function distXY(x1, y1, x2, y2) {
  return Math.sqrt(distSqXY(x1, y1, x2, y2));
}

function distSq(pt1, pt2) {
  return distSqXY(pt1.x, pt1.y, pt2.x, pt2.y);
}
function distSqXY(x1, y1, x2, y2) {
  return ((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1));
}

function lerpPt(p1, p2, val = 0.5) {
  return {
    x: __WEBPACK_IMPORTED_MODULE_0__maths__["b" /* lerp */](p1.x, p2.x, val),
    y: __WEBPACK_IMPORTED_MODULE_0__maths__["b" /* lerp */](p1.y, p2.y, val)
  };
}


// Trig

function degToRad(degs) {
  return degs * (__WEBPACK_IMPORTED_MODULE_0__maths__["a" /* TAO */] / 360);
}
function radToDeg(rads) {
  return rads * (360 / __WEBPACK_IMPORTED_MODULE_0__maths__["a" /* TAO */]);
}

function getRadFromPts(fromPt, toPt) {

  if (toPt === undefined) {
    toPt    = { x: fromPt.x, y: fromPt.y };
    fromPt  = { x: 0, y: 0 };
  }

  return Math.atan2(toPt.y - fromPt.y, toPt.x - fromPt.x);

}
function getRadFromXY(fromX, fromY, toX, toY) {

  if (toX === undefined || toY === undefined) {
    toX   = fromX;
    toY   = fromY;
    fromX = 0;
    fromY = 0;
  }

  return Math.atan2(toY - fromY, toX - fromX);

}


// Areas

function lerpRect(rectA, rectB, val = 0.5) {

  return {
    x:      __WEBPACK_IMPORTED_MODULE_0__maths__["b" /* lerp */](rectA.x,      rectB.x,      val),
    y:      __WEBPACK_IMPORTED_MODULE_0__maths__["b" /* lerp */](rectA.y,      rectB.y,      val),
    width:  __WEBPACK_IMPORTED_MODULE_0__maths__["b" /* lerp */](rectA.width,  rectB.width,  val),
    height: __WEBPACK_IMPORTED_MODULE_0__maths__["b" /* lerp */](rectA.height, rectB.height, val)
  };

}

function getFillRect(w, h, area) {

  const aw = area.width,
        ah = area.height,
        ax = area.x,
        ay = area.y,
        sw = ah * w / h,
        sh = aw * h / w,
        rw = (sw > aw) ? sw : aw,
        rh = (sw > aw) ? ah : sh,
        rx = Math.min(ax, Math.max(ax + aw - rw, ax + Math.round((aw - rw) / 2))),
        ry = Math.min(ay, Math.max(ay + ah - rh, ay + Math.round((ah - rh) / 2)));

  return {
    x: rx,
    y: ry,
    width: rw,
    height: rh
  };

}
function getFitRect(w, h, area) {

  const aw = area.width,
        ah = area.height,
        ax = area.x,
        ay = area.y,
        sw = ah * w / h,
        sh = aw * h / w,
        rw = (sw <= aw) ? sw : aw,
        rh = (sw <= aw) ? ah : sh,
        rx = ax + Math.round((aw - rw) / 2),
        ry = ay + Math.round((ah - rh) / 2);

  return {
    x: rx,
    y: ry,
    width: rw,
    height: rh
  };

}


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export getLatin */
/* unused harmony export trunc */
/* harmony export (immutable) */ __webpack_exports__["a"] = beginsWith;
/* unused harmony export endsWith */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__random__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__arrays__ = __webpack_require__(64);




const QUOTE_L    = "\u201C";
/* unused harmony export QUOTE_L */

const QUOTE_R    = "\u201D";
/* unused harmony export QUOTE_R */


function getLatin(wordCount = 1, punctuate = false) {

  const CHANCE_PERIOD = 0.1,
        CHANCE_COMMA  = 0.15;

  let sourceWords = [
    "a", "ac", "accumsan", "ad", "adipiscing", "aenean", "aliquam", "amet", "ante",
    "aptent", "arcu", "at", "auctor", "augue", "bibendum", "blandit", "class",
    "commodo", "congue", "consectetur", "consequat", "conubia", "convallis", "cras",
    "curabitur", "cursus", "dapibus", "diam", "dictum", "dignissim", "dolor",
    "donec", "dui", "duis", "egestas", "eget", "eleifend", "elementum", "elit",
    "enim", "erat", "eros", "est", "et", "etiam", "eu", "euismod", "fames",
    "faucibus", "felis", "fermentum", "feugiat", "fringilla", "fusce", "gravida",
    "habitant", "hendrerit", "himenaeos", "iaculis", "id", "imperdiet", "in",
    "inceptos", "integer", "interdum", "ipsum", "justo", "lacinia", "lacus",
    "laoreet", "lectus", "leo", "libero", "ligula", "litora", "lobortis", "lorem",
    "luctus", "maecenas", "magna", "malesuada", "massa", "mattis", "mauris",
    "metus", "mi", "mollis", "morbi", "nam", "nec", "neque", "netus", "nibh",
    "nisi", "nisl", "non", "nostra", "nulla", "nullam", "nunc", "odio", "orci",
    "ornare", "pellentesque", "per", "pharetra", "phasellus", "placerat",
    "porttitor", "posuere", "praesent", "pretium", "proin", "pulvinar", "purus",
    "quam", "quis", "quisque", "rhoncus", "risus", "rutrum", "sagittis", "sapien",
    "scelerisque", "sed", "sem", "semper", "senectus", "sit", "sociosqu",
    "suscipit", "suspendisse", "taciti", "tellus", "tempor", "tempus", "tincidunt",
    "torquent", "tortor", "tristique", "turpis", "ullamcorper", "ultrices",
    "ultricies", "urna", "ut", "varius", "vehicula", "vel", "velit", "venenatis",
    "vitae", "vivamus", "viverra", "volutpat", "vulputate"
  ];

  while(sourceWords.length < wordCount) {
    sourceWords = sourceWords.concat(sourceWords);
  }

  let isNewSentence = true,
      words         = __WEBPACK_IMPORTED_MODULE_0__random__["c" /* items */](sourceWords, wordCount),
      result        = "";

  for (let i = 0; i < words.length; i++) {

    let isLastWord  = (i === __WEBPACK_IMPORTED_MODULE_1__arrays__["a" /* lastIndex */](words)),
        nextWord    = words[i];

    if (isNewSentence) {
      result += nextWord.charAt(0).toUpperCase() + nextWord.substr(1);
      isNewSentence = false;

    } else {
      result += words[i];

    }

    if (punctuate) {

      if (isLastWord) {
        result += ".";

      } else if (__WEBPACK_IMPORTED_MODULE_0__random__["d" /* boolean */](CHANCE_PERIOD)) {
        result += ". ";
        isNewSentence = true;

      } else if (__WEBPACK_IMPORTED_MODULE_0__random__["d" /* boolean */](CHANCE_COMMA)) {
        result += ", ";

      } else {
        result += " ";
      }

    } else if (!isLastWord) {
      result += " ";
    }

  }

  return result;

}

function trunc(s, charCount, addElipsis = false) {
  if (!s) return "";
  if (s.length <= charCount) {
    return s;
  } else {
    if (addElipsis) {
      return s.substr(0, charCount - 3) + "...";
    } else {
      return s.substr(0, charCount);
    }
  }
}

function beginsWith(s, test) {
  return (s.substr(0, test.length) === test);
}

function endsWith(s, test) {
  return (s.substr(-test.length) === test);
}


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

__webpack_require__(87);


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = __webpack_require__(88);


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(81);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(141)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/lib/loader.js!./style.scss", function() {
			var newContent = require("!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/lib/loader.js!./style.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = ReactDOM;

/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_classnames__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_firebase_app__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_firebase_app___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_firebase_app__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__App__ = __webpack_require__(5);

// Imports








// Constants


// Component

class CustomizeCategoryForm extends __WEBPACK_IMPORTED_MODULE_0_react__["Component"] {

  // Constructor

  constructor() {

    super();

    this.handleInputChange = e => {

      this.setState({
        [e.currentTarget.name]: e.currentTarget.value
      });
    };

    this.handleSubmit = e => {

      e.preventDefault();

      if (this.validate()) {

        const category = {
          label: this.state.valLabel
        };

        this.categoriesRef.push(category, error => {

          if (!error) {
            this.clearInput();
          }
        });
      }
    };

    this.initState();
  }

  initState() {

    this.state = {
      valLabel: ''
    };
  }

  // Event handlers

  // Methods

  clearInput() {

    this.setState({
      valLabel: ''
    });
  }

  validate() {

    const hasLabel = this.state.valLabel && this.state.valLabel.length;

    return hasLabel;
  }

  // React

  componentDidMount() {

    const userId = __WEBPACK_IMPORTED_MODULE_2_firebase_app___default.a.auth().currentUser.uid;

    this.categoriesRef = __WEBPACK_IMPORTED_MODULE_2_firebase_app___default.a.database().ref(`categories/${userId}`);
  }

  render() {

    return __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
      'form',
      {
        className: 'category-input',
        onSubmit: this.handleSubmit },
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'h3',
        null,
        'Add Category'
      ),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'p',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'label',
          {
            htmlFor: 'category-input-label' },
          'Label'
        )
      ),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'p',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"]('input', {
          id: 'category-input-label',
          type: 'text',
          name: 'valLabel',
          value: this.state.valLabel,
          onChange: this.handleInputChange })
      ),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'p',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"]('input', {
          id: 'category-input-submit',
          type: 'submit',
          disabled: !this.validate() })
      )
    );
  }

}
/* harmony export (immutable) */ __webpack_exports__["a"] = CustomizeCategoryForm;


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_classnames__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__App__ = __webpack_require__(5);

// Imports






// Constants


// Component

class CustomizeTableCell extends __WEBPACK_IMPORTED_MODULE_0_react__["Component"] {

  // Constructor

  constructor() {

    super();

    this.handleInputFocus = e => {

      this.setState({
        editing: true
      });
    };

    this.handleInputBlur = e => {
      this.setState({
        editing: false
      });
    };

    this.handleWeightChange = e => {

      const actKey = this.props.actKey,
            valLinkKey = this.props.valLinkKey,
            weight = e.currentTarget.value;

      if (this.props.onWeightChange) {
        this.props.onWeightChange(actKey, valLinkKey, weight);
      }
    };

    this.initState();
  }

  initState() {

    this.state = {
      editing: false
    };
  }

  // Event handlers

  // React

  render() {

    const actKey = this.props.actKey,
          activity = this.props.activity,
          valLinkKey = this.props.valLinkKey,
          valLink = activity && activity.values ? activity.values[valLinkKey] : undefined,
          weight = valLink ? valLink.weight : 0;

    const classes = __WEBPACK_IMPORTED_MODULE_1_classnames__({
      ['weight-' + weight]: true,
      editing: this.state.editing
    });

    return __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
      'td',
      {
        className: classes },
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"]('input', {
        type: 'number',
        onFocus: this.handleInputFocus,
        onBlur: this.handleInputBlur,
        onChange: this.handleWeightChange,
        value: weight })
    );
  }

}
/* harmony export (immutable) */ __webpack_exports__["a"] = CustomizeTableCell;


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_classnames__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__App__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__CustomizeTable__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__CustomizeCategoryForm__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__CustomizeValueForm__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__CustomizeActivityForm__ = __webpack_require__(32);

// Imports










// Constants


// Component

class CustomizeView extends __WEBPACK_IMPORTED_MODULE_0_react__["Component"] {

  // Constructor

  constructor() {

    super();

    this.initState();
  }

  initState() {}

  // Event handlers


  // Methods


  // React

  render() {

    const classSection = __WEBPACK_IMPORTED_MODULE_1_classnames__({
      'customize': true
    });

    return __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
      'section',
      {
        className: classSection },
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'header',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'h2',
          null,
          'Customize'
        )
      ),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'article',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'h2',
          null,
          'Edit Activities'
        ),
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](__WEBPACK_IMPORTED_MODULE_3__CustomizeTable__["a" /* default */], null),
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'h2',
          null,
          'Add new'
        ),
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](__WEBPACK_IMPORTED_MODULE_4__CustomizeCategoryForm__["a" /* default */], null),
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](__WEBPACK_IMPORTED_MODULE_5__CustomizeValueForm__["a" /* default */], null),
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](__WEBPACK_IMPORTED_MODULE_6__CustomizeActivityForm__["a" /* default */], null)
      )
    );
  }

}
/* harmony export (immutable) */ __webpack_exports__["a"] = CustomizeView;


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_classnames__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__App__ = __webpack_require__(5);

// Imports






// Constants


// Component

class EvaluateView extends __WEBPACK_IMPORTED_MODULE_0_react__["Component"] {

  // Constructor

  constructor() {

    super();

    this.initState();
  }

  initState() {}

  // Event handlers


  // Methods


  // React

  render() {

    const classSection = __WEBPACK_IMPORTED_MODULE_1_classnames__({
      'evaluate': true
    });

    return __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
      'section',
      {
        className: classSection },
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'header',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'h2',
          null,
          'Evaluate'
        )
      ),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'article',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'h2',
          null,
          'To do.'
        )
      )
    );
  }

}
/* harmony export (immutable) */ __webpack_exports__["a"] = EvaluateView;


/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_classnames__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__App__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__CustomizeTable__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__CustomizeValueForm__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__CustomizeActivityForm__ = __webpack_require__(32);

// Imports









// Constants


// Component

class LoginView extends __WEBPACK_IMPORTED_MODULE_0_react__["Component"] {

  // Constructor

  constructor() {

    super();

    this.handleAnonymousLoginClick = () => {
      this.props.onAnonymousLoginClick();
    };

    this.handleGoogleLoginClick = () => {
      this.props.onGoogleLoginClick();
    };

    this.initState();
  }

  initState() {}

  // Event handlers

  // Methods


  // React

  render() {

    const classSection = __WEBPACK_IMPORTED_MODULE_1_classnames__({
      'login': true
    });

    return __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
      'section',
      {
        className: classSection },
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'div',
        { className: 'login-panel' },
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'h1',
          null,
          'Endeavors'
        ),
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'p',
          null,
          __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
            'button',
            {
              onClick: this.handleGoogleLoginClick },
            'Log in with Google'
          )
        ),
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'p',
          null,
          __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
            'button',
            {
              onClick: this.handleAnonymousLoginClick },
            'Log in Anonymously'
          )
        )
      )
    );
  }

}
/* harmony export (immutable) */ __webpack_exports__["a"] = LoginView;


/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_classnames__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__App__ = __webpack_require__(5);

// Imports






// Constants


// Component

class SettingsView extends __WEBPACK_IMPORTED_MODULE_0_react__["Component"] {

  // Constructor

  constructor() {

    super();

    this.initState();
  }

  initState() {}

  // Event handlers


  // Methods


  // React

  render() {

    const classSection = __WEBPACK_IMPORTED_MODULE_1_classnames__({
      'settings': true
    });

    return __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
      'section',
      {
        className: classSection },
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'header',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'h2',
          null,
          'Settings'
        )
      ),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'article',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'h2',
          null,
          'To do.'
        )
      )
    );
  }

}
/* harmony export (immutable) */ __webpack_exports__["a"] = SettingsView;


/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_classnames__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__App__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__SidebarItem__ = __webpack_require__(78);

// Imports







// Constants


// Component

class Sidebar extends __WEBPACK_IMPORTED_MODULE_0_react__["Component"] {

  // Constructor

  constructor() {

    super();

    this.handleItemSelect = itemClass => {

      this.props.onModeChange(itemClass);
    };

    this.initState();
  }

  initState() {}

  // Event handlers

  // Methods


  // React

  render() {

    return __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
      'aside',
      null,
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'ul',
        {
          className: 'main-nav' },
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](__WEBPACK_IMPORTED_MODULE_3__SidebarItem__["a" /* default */], {
          label: 'Track',
          className: 'track',
          icon: 'check_box',
          selected: this.props.mode === 'track',
          onSelect: this.handleItemSelect }),
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](__WEBPACK_IMPORTED_MODULE_3__SidebarItem__["a" /* default */], {
          label: 'Evaluate',
          className: 'evaluate',
          icon: 'timeline',
          selected: this.props.mode === 'evaluate',
          onSelect: this.handleItemSelect })
      ),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'ul',
        {
          className: 'sub-nav' },
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](__WEBPACK_IMPORTED_MODULE_3__SidebarItem__["a" /* default */], {
          label: 'Customize',
          className: 'customize',
          icon: 'fingerprint',
          selected: this.props.mode === 'customize',
          onSelect: this.handleItemSelect }),
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](__WEBPACK_IMPORTED_MODULE_3__SidebarItem__["a" /* default */], {
          label: 'Settings',
          className: 'settings',
          icon: 'settings_applications',
          selected: this.props.mode === 'settings',
          onSelect: this.handleItemSelect })
      )
    );
  }

}
/* harmony export (immutable) */ __webpack_exports__["a"] = Sidebar;


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_classnames__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__App__ = __webpack_require__(5);

// Imports






// Constants


// Component

class SidebarItem extends __WEBPACK_IMPORTED_MODULE_0_react__["Component"] {

  // Constructor

  constructor() {

    super();

    this.handleClick = e => {
      this.props.onSelect(this.props.className);
    };

    this.initState();
  }

  initState() {}

  // Event handlers

  // Methods


  // React

  render() {

    const classLi = __WEBPACK_IMPORTED_MODULE_1_classnames__({
      [this.props.className]: true,
      selected: this.props.selected
    });

    return __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
      'li',
      {
        className: classLi,
        onClick: this.handleClick },
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'p',
        {
          className: 'icon' },
        this.props.icon
      ),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'p',
        {
          className: 'label' },
        this.props.label
      )
    );
  }

}
/* harmony export (immutable) */ __webpack_exports__["a"] = SidebarItem;


/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_classnames___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_classnames__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__App__ = __webpack_require__(5);

// Imports






// Constants


// Component

class TrackView extends __WEBPACK_IMPORTED_MODULE_0_react__["Component"] {

  // Constructor

  constructor() {

    super();

    this.initState();
  }

  initState() {}

  // Event handlers


  // Methods


  // React

  render() {

    const classSection = __WEBPACK_IMPORTED_MODULE_1_classnames__({
      'track': true
    });

    return __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
      'section',
      {
        className: classSection },
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'header',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'h2',
          null,
          'Track'
        )
      ),
      __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
        'article',
        null,
        __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](
          'h2',
          null,
          'To do.'
        )
      )
    );
  }

}
/* harmony export (immutable) */ __webpack_exports__["a"] = TrackView;


/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_dom__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_dom___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react_dom__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_firebase_app__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_firebase_app___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_firebase_app__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_firebase_auth__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_firebase_auth___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_firebase_auth__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_firebase_database__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_firebase_database___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_firebase_database__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__styles_style_scss__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__styles_style_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__styles_style_scss__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_App__ = __webpack_require__(5);












const DEBUG_SIGN_OUT = false;

initFirebase();
initApp();

function initFirebase() {

  __WEBPACK_IMPORTED_MODULE_2_firebase_app___default.a.initializeApp({
    apiKey: "AIzaSyCfceUvLUQrPJTWx-OBN82FtEZe3DKEfNs",
    authDomain: "endeavorsssss.firebaseapp.com",
    databaseURL: "https://endeavorsssss.firebaseio.com",
    projectId: "endeavorsssss",
    storageBucket: "endeavorsssss.appspot.com",
    messagingSenderId: "589591316736"
  });
}

function initApp() {

  if (DEBUG_SIGN_OUT) {
    __WEBPACK_IMPORTED_MODULE_2_firebase_app___default.a.auth().setPersistence(__WEBPACK_IMPORTED_MODULE_2_firebase_app___default.a.auth.Auth.Persistence.NONE);
    __WEBPACK_IMPORTED_MODULE_2_firebase_app___default.a.auth().signOut();
    window.location = "https://mail.google.com/mail/u/0/?logout&hl=en";
    return;
  }

  const element = document.getElementById('app'),
        component = __WEBPACK_IMPORTED_MODULE_0_react__["createElement"](__WEBPACK_IMPORTED_MODULE_6__components_App__["a" /* default */]);

  __WEBPACK_IMPORTED_MODULE_1_react_dom__["render"](component, element);
}

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(138)(undefined);
// imports


// module
exports.push([module.i, "* {\n  box-sizing: border-box !important; }\n\nhtml,\nbody,\ndiv#app,\ndiv.wrap-all {\n  width: 100vw;\n  height: 100vh;\n  min-height: 100vh; }\n\n@font-face {\n  font-family: 'Material Icons';\n  font-style: normal;\n  font-weight: 400;\n  src: url(" + __webpack_require__(82) + ");\n  /* For IE6-8 */\n  src: local(\"Material Icons\"), local(\"MaterialIcons-Regular\"), url(" + __webpack_require__(85) + ") format(\"woff2\"), url(" + __webpack_require__(84) + ") format(\"woff\"), url(" + __webpack_require__(83) + ") format(\"truetype\"); }\n\n.icon {\n  font-family: 'Material Icons';\n  font-weight: normal;\n  font-style: normal;\n  font-size: 24px;\n  /* Preferred icon size */\n  display: inline-block;\n  line-height: 1;\n  text-transform: none;\n  letter-spacing: normal;\n  word-wrap: normal;\n  white-space: nowrap;\n  direction: ltr;\n  /* Support for all WebKit browsers. */\n  -webkit-font-smoothing: antialiased;\n  /* Support for Safari and Chrome. */\n  text-rendering: optimizeLegibility;\n  /* Support for Firefox. */\n  -moz-osx-font-smoothing: grayscale;\n  /* Support for IE. */\n  font-feature-settings: 'liga'; }\n\nsection.login, aside, main > section header {\n  -webkit-app-region: drag; }\n\nsection.login div.login-panel p button {\n  -webkit-app-region: no-drag; }\n\nsection.login :not(input):not(textarea), aside :not(input):not(textarea), main > section header :not(input):not(textarea), section.login :not(input):not(textarea)::after, aside :not(input):not(textarea)::after, main > section header :not(input):not(textarea)::after, section.login :not(input):not(textarea)::before, aside :not(input):not(textarea)::before, main > section header :not(input):not(textarea)::before {\n  -webkit-user-select: none;\n  user-select: none;\n  cursor: default; }\n\nsection.login input, aside input, main > section header input, section.login button, aside button, main > section header button, section.login textarea, aside textarea, main > section header textarea, section.login :focus, aside :focus, main > section header :focus {\n  outline: none; }\n\nbody {\n  font: 13px/17px -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n  background-color: white;\n  margin: 0px;\n  padding: 0px;\n  overflow: hidden; }\n\nsection.login {\n  background: #222;\n  width: 100%;\n  height: 100%; }\n  section.login div.login-panel {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%); }\n    section.login div.login-panel h1 {\n      text-align: center;\n      font-size: 16px;\n      text-transform: uppercase;\n      letter-spacing: 0.025em;\n      color: #fff;\n      margin-bottom: 35px; }\n    section.login div.login-panel p {\n      text-align: center;\n      margin: 0px 0px 15px 0px; }\n      section.login div.login-panel p button {\n        border: 1px solid #96f;\n        background: none;\n        border-radius: 8px;\n        padding: 15px 20px;\n        outline: none;\n        color: #96f;\n        font: 600 16px -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n        transition: border-color 0.1s, color 0.1s, background-color 0.1s; }\n        section.login div.login-panel p button:hover, section.login div.login-panel p button:active {\n          border-color: #96f;\n          background-color: #96f;\n          color: #222; }\n        section.login div.login-panel p button:active:hover {\n          opacity: 0.5; }\n\naside {\n  position: fixed;\n  top: 0px;\n  left: 0px;\n  width: 100px;\n  height: 100%;\n  background-color: #222; }\n  aside ul {\n    list-style: none;\n    margin: 0px;\n    padding: 0px;\n    position: absolute;\n    left: 50%;\n    transform: translate(-50%, 0px);\n    text-align: center;\n    width: calc(100% - 20px); }\n    aside ul.main-nav {\n      top: 85px; }\n    aside ul.sub-nav {\n      bottom: 10px; }\n    aside ul li {\n      margin-bottom: 10px;\n      border-radius: 5px;\n      padding: 10px 0px;\n      transition: background-color 0.1s; }\n      aside ul li p {\n        margin: 0px;\n        color: #555;\n        transition: color 0.1s, opacity 0.1s; }\n        aside ul li p.icon {\n          font-size: 48px; }\n        aside ul li p.label {\n          font-size: 10px;\n          text-transform: uppercase;\n          font-weight: bold; }\n      aside ul li:hover:not(.selected) {\n        background-color: #2f2f2f; }\n        aside ul li:hover:not(.selected).track p.icon {\n          color: #0cd; }\n        aside ul li:hover:not(.selected).evaluate p.icon {\n          color: #cf0; }\n        aside ul li:hover:not(.selected).customize p.icon {\n          color: #96f; }\n        aside ul li:hover:not(.selected).settings p.icon {\n          color: #f66; }\n        aside ul li:hover:not(.selected) p.label {\n          color: white; }\n      aside ul li:active:not(.selected) p {\n        opacity: 0.5;\n        transition: none; }\n      aside ul li.selected.track {\n        background-color: #0cd; }\n        aside ul li.selected.track p.label {\n          color: #1a4d51; }\n      aside ul li.selected.evaluate {\n        background-color: #cf0; }\n        aside ul li.selected.evaluate p.label {\n          color: #4d591a; }\n      aside ul li.selected.customize {\n        background-color: #96f; }\n        aside ul li.selected.customize p.label {\n          color: #403359; }\n      aside ul li.selected.settings {\n        background-color: #f66; }\n        aside ul li.selected.settings p.label {\n          color: #593333; }\n      aside ul li.selected p {\n        color: black; }\n\nmain {\n  position: absolute;\n  top: 0px;\n  left: 100px;\n  width: calc(100% - 100px);\n  height: 100%; }\n  main > section {\n    width: 100%;\n    height: 100%; }\n    main > section header {\n      height: 75px;\n      border-bottom: 1px solid #ddd;\n      position: relative; }\n      main > section header h2 {\n        position: absolute;\n        top: 50%;\n        left: 25px;\n        transform: translate(0px, -50%);\n        margin: 0px;\n        font-size: 14px;\n        text-transform: uppercase; }\n    main > section article {\n      width: 100%;\n      height: calc(100% - 75px);\n      overflow: scroll;\n      background: #f6f6f6;\n      padding: 25px; }\n\nsection.customize table.customize-table {\n  border-spacing: 0;\n  border-collapse: collapse;\n  margin-bottom: 25px; }\n  section.customize table.customize-table th,\n  section.customize table.customize-table td {\n    padding: 5px;\n    width: 125px; }\n    section.customize table.customize-table th:first-child,\n    section.customize table.customize-table td:first-child {\n      width: 200px; }\n    section.customize table.customize-table th:not(:first-child),\n    section.customize table.customize-table td:not(:first-child) {\n      border-left: 1px dotted #ddd; }\n    section.customize table.customize-table th a.remove-btn,\n    section.customize table.customize-table td a.remove-btn {\n      display: none; }\n    section.customize table.customize-table th:hover a.remove-btn,\n    section.customize table.customize-table td:hover a.remove-btn {\n      display: inline-block; }\n  section.customize table.customize-table thead tr:first-child th {\n    padding-bottom: 20px;\n    border: none;\n    font-weight: bold;\n    color: black; }\n  section.customize table.customize-table thead tr th {\n    color: #777;\n    position: relative;\n    font-weight: normal; }\n    section.customize table.customize-table thead tr th a.remove-btn {\n      background-color: #eee;\n      position: absolute;\n      right: 5px;\n      top: 5px;\n      color: #aaa;\n      border-color: #aaa; }\n  section.customize table.customize-table tbody th:first-child {\n    text-align: left;\n    font-weight: normal;\n    color: #777;\n    position: relative;\n    border-top: 1px dotted #ddd; }\n    section.customize table.customize-table tbody th:first-child a.remove-btn {\n      position: absolute;\n      right: 10px;\n      top: 50%;\n      transform: translate(0px, -50%); }\n  section.customize table.customize-table td {\n    text-align: center;\n    border-top: 1px dotted #ddd; }\n    section.customize table.customize-table td input {\n      border: none;\n      border-radius: 5px;\n      background-color: transparent;\n      text-align: center;\n      font: bold 13px/17px -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n      width: 100%;\n      height: 30px;\n      color: inherit;\n      -webkit-tap-highlight-color: transparent;\n      outline: none !important; }\n    section.customize table.customize-table td.editing input {\n      background-color: white;\n      color: #90f;\n      box-shadow: inset 0 0 0 3px #90f; }\n    section.customize table.customize-table td:not(.editing) input[type=number]::-webkit-inner-spin-button,\n    section.customize table.customize-table td:not(.editing) input[type=number]::-webkit-outer-spin-button {\n      -webkit-appearance: none;\n      margin: 0; }\n    section.customize table.customize-table td:not(.editing):hover.weight-0 input {\n      background-color: white; }\n    section.customize table.customize-table td:not(.editing).weight-0 input {\n      background-color: transparent;\n      color: transparent; }\n    section.customize table.customize-table td:not(.editing).weight-1 input {\n      background-color: rgba(153, 102, 255, 0.15);\n      color: rgba(37, 25, 62, 0.32); }\n    section.customize table.customize-table td:not(.editing).weight-2 input {\n      background-color: rgba(153, 102, 255, 0.5);\n      color: rgba(37, 25, 62, 0.32); }\n    section.customize table.customize-table td:not(.editing).weight-3 input {\n      background-color: #96f;\n      color: rgba(37, 25, 62, 0.32); }\n  section.customize table.customize-table a.remove-btn {\n    display: inline-block;\n    border: 1px solid #aaa;\n    background: transparent;\n    font-size: 15px;\n    border-radius: 100%;\n    color: #aaa;\n    width: 20px;\n    height: 20px;\n    text-align: center; }\n    section.customize table.customize-table a.remove-btn:hover {\n      border-color: #f66;\n      background-color: #f66;\n      color: white;\n      cursor: pointer; }\n\nsection.customize form {\n  vertical-align: top;\n  border: 1px solid #ccc;\n  border-radius: 5px;\n  display: inline-block;\n  padding: 10px;\n  margin-right: 15px; }\n  section.customize form h3 {\n    margin-top: 0px;\n    font-size: 13px;\n    color: #666; }\n  section.customize form label {\n    color: #999; }\n  section.customize form p {\n    margin: 5px 0; }\n  section.customize form input[type='text'] {\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n    font-size: 13px; }\n", ""]);

// exports


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "resources/fonts/MaterialIcons-Regular.eot";

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "resources/fonts/MaterialIcons-Regular.ttf";

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "resources/fonts/MaterialIcons-Regular.woff";

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "resources/fonts/MaterialIcons-Regular.woff2";

/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createFirebaseNamespace;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var contains = function (obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
};
var DEFAULT_ENTRY_NAME = '[DEFAULT]';
// An array to capture listeners before the true auth functions
// exist
var tokenListeners = [];
/**
 * Global context object for a collection of services using
 * a shared authentication state.
 */
var FirebaseAppImpl = /** @class */ (function () {
    function FirebaseAppImpl(options, name, firebase_) {
        this.firebase_ = firebase_;
        this.isDeleted_ = false;
        this.services_ = {};
        this.name_ = name;
        this.options_ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["a" /* deepCopy */])(options);
        this.INTERNAL = {
            getUid: function () { return null; },
            getToken: function () { return Promise.resolve(null); },
            addAuthTokenListener: function (callback) {
                tokenListeners.push(callback);
                // Make sure callback is called, asynchronously, in the absence of the auth module
                setTimeout(function () { return callback(null); }, 0);
            },
            removeAuthTokenListener: function (callback) {
                tokenListeners = tokenListeners.filter(function (listener) { return listener !== callback; });
            }
        };
    }
    Object.defineProperty(FirebaseAppImpl.prototype, "name", {
        get: function () {
            this.checkDestroyed_();
            return this.name_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirebaseAppImpl.prototype, "options", {
        get: function () {
            this.checkDestroyed_();
            return this.options_;
        },
        enumerable: true,
        configurable: true
    });
    FirebaseAppImpl.prototype.delete = function () {
        var _this = this;
        return new Promise(function (resolve) {
            _this.checkDestroyed_();
            resolve();
        })
            .then(function () {
            _this.firebase_.INTERNAL.removeApp(_this.name_);
            var services = [];
            Object.keys(_this.services_).forEach(function (serviceKey) {
                Object.keys(_this.services_[serviceKey]).forEach(function (instanceKey) {
                    services.push(_this.services_[serviceKey][instanceKey]);
                });
            });
            return Promise.all(services.map(function (service) {
                return service.INTERNAL.delete();
            }));
        })
            .then(function () {
            _this.isDeleted_ = true;
            _this.services_ = {};
        });
    };
    /**
     * Return a service instance associated with this app (creating it
     * on demand), identified by the passed instanceIdentifier.
     *
     * NOTE: Currently storage is the only one that is leveraging this
     * functionality. They invoke it by calling:
     *
     * ```javascript
     * firebase.app().storage('STORAGE BUCKET ID')
     * ```
     *
     * The service name is passed to this already
     * @internal
     */
    FirebaseAppImpl.prototype._getService = function (name, instanceIdentifier) {
        if (instanceIdentifier === void 0) { instanceIdentifier = DEFAULT_ENTRY_NAME; }
        this.checkDestroyed_();
        if (!this.services_[name]) {
            this.services_[name] = {};
        }
        if (!this.services_[name][instanceIdentifier]) {
            /**
             * If a custom instance has been defined (i.e. not '[DEFAULT]')
             * then we will pass that instance on, otherwise we pass `null`
             */
            var instanceSpecifier = instanceIdentifier !== DEFAULT_ENTRY_NAME
                ? instanceIdentifier
                : undefined;
            var service = this.firebase_.INTERNAL.factories[name](this, this.extendApp.bind(this), instanceSpecifier);
            this.services_[name][instanceIdentifier] = service;
        }
        return this.services_[name][instanceIdentifier];
    };
    /**
     * Callback function used to extend an App instance at the time
     * of service instance creation.
     */
    FirebaseAppImpl.prototype.extendApp = function (props) {
        var _this = this;
        // Copy the object onto the FirebaseAppImpl prototype
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["b" /* deepExtend */])(this, props);
        /**
         * If the app has overwritten the addAuthTokenListener stub, forward
         * the active token listeners on to the true fxn.
         *
         * TODO: This function is required due to our current module
         * structure. Once we are able to rely strictly upon a single module
         * implementation, this code should be refactored and Auth should
         * provide these stubs and the upgrade logic
         */
        if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {
            tokenListeners.forEach(function (listener) {
                _this.INTERNAL.addAuthTokenListener(listener);
            });
            tokenListeners = [];
        }
    };
    /**
     * This function will throw an Error if the App has already been deleted -
     * use before performing API actions on the App.
     */
    FirebaseAppImpl.prototype.checkDestroyed_ = function () {
        if (this.isDeleted_) {
            error('app-deleted', { name: this.name_ });
        }
    };
    return FirebaseAppImpl;
}());
// Prevent dead-code elimination of these methods w/o invalid property
// copying.
(FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options) ||
    FirebaseAppImpl.prototype.delete ||
    console.log('dc');
/**
 * Return a firebase namespace object.
 *
 * In production, this will be called exactly once and the result
 * assigned to the 'firebase' global.  It may be called multiple times
 * in unit tests.
 */
function createFirebaseNamespace() {
    var apps_ = {};
    var factories = {};
    var appHooks = {};
    // A namespace is a plain JavaScript Object.
    var namespace = {
        // Hack to prevent Babel from modifying the object returned
        // as the firebase namespace.
        __esModule: true,
        initializeApp: initializeApp,
        app: app,
        apps: null,
        Promise: Promise,
        SDK_VERSION: '4.5.2',
        INTERNAL: {
            registerService: registerService,
            createFirebaseNamespace: createFirebaseNamespace,
            extendNamespace: extendNamespace,
            createSubscribe: __WEBPACK_IMPORTED_MODULE_0__firebase_util__["c" /* createSubscribe */],
            ErrorFactory: __WEBPACK_IMPORTED_MODULE_0__firebase_util__["d" /* ErrorFactory */],
            removeApp: removeApp,
            factories: factories,
            useAsService: useAsService,
            Promise: Promise,
            deepExtend: __WEBPACK_IMPORTED_MODULE_0__firebase_util__["b" /* deepExtend */]
        }
    };
    // Inject a circular default export to allow Babel users who were previously
    // using:
    //
    //   import firebase from 'firebase';
    //   which becomes: var firebase = require('firebase').default;
    //
    // instead of
    //
    //   import * as firebase from 'firebase';
    //   which becomes: var firebase = require('firebase');
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["e" /* patchProperty */])(namespace, 'default', namespace);
    // firebase.apps is a read-only getter.
    Object.defineProperty(namespace, 'apps', {
        get: getApps
    });
    /**
     * Called by App.delete() - but before any services associated with the App
     * are deleted.
     */
    function removeApp(name) {
        var app = apps_[name];
        callAppHooks(app, 'delete');
        delete apps_[name];
    }
    /**
     * Get the App object for a given name (or DEFAULT).
     */
    function app(name) {
        name = name || DEFAULT_ENTRY_NAME;
        if (!contains(apps_, name)) {
            error('no-app', { name: name });
        }
        return apps_[name];
    }
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["e" /* patchProperty */])(app, 'App', FirebaseAppImpl);
    /**
     * Create a new App instance (name must be unique).
     */
    function initializeApp(options, name) {
        if (name === undefined) {
            name = DEFAULT_ENTRY_NAME;
        }
        else {
            if (typeof name !== 'string' || name === '') {
                error('bad-app-name', { name: name + '' });
            }
        }
        if (contains(apps_, name)) {
            error('duplicate-app', { name: name });
        }
        var app = new FirebaseAppImpl(options, name, namespace);
        apps_[name] = app;
        callAppHooks(app, 'create');
        return app;
    }
    /*
     * Return an array of all the non-deleted FirebaseApps.
     */
    function getApps() {
        // Make a copy so caller cannot mutate the apps list.
        return Object.keys(apps_).map(function (name) { return apps_[name]; });
    }
    /*
     * Register a Firebase Service.
     *
     * firebase.INTERNAL.registerService()
     *
     * TODO: Implement serviceProperties.
     */
    function registerService(name, createService, serviceProperties, appHook, allowMultipleInstances) {
        // Cannot re-register a service that already exists
        if (factories[name]) {
            error('duplicate-service', { name: name });
        }
        // Capture the service factory for later service instantiation
        factories[name] = createService;
        // Capture the appHook, if passed
        if (appHook) {
            appHooks[name] = appHook;
            // Run the **new** app hook on all existing apps
            getApps().forEach(function (app) {
                appHook('create', app);
            });
        }
        // The Service namespace is an accessor function ...
        var serviceNamespace = function (appArg) {
            if (appArg === void 0) { appArg = app(); }
            if (typeof appArg[name] !== 'function') {
                // Invalid argument.
                // This happens in the following case: firebase.storage('gs:/')
                error('invalid-app-argument', { name: name });
            }
            // Forward service instance lookup to the FirebaseApp.
            return appArg[name]();
        };
        // ... and a container for service-level properties.
        if (serviceProperties !== undefined) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["b" /* deepExtend */])(serviceNamespace, serviceProperties);
        }
        // Monkey-patch the serviceNamespace onto the firebase namespace
        namespace[name] = serviceNamespace;
        // Patch the FirebaseAppImpl prototype
        FirebaseAppImpl.prototype[name] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var serviceFxn = this._getService.bind(this, name);
            return serviceFxn.apply(this, allowMultipleInstances ? args : []);
        };
        return serviceNamespace;
    }
    /**
     * Patch the top-level firebase namespace with additional properties.
     *
     * firebase.INTERNAL.extendNamespace()
     */
    function extendNamespace(props) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["b" /* deepExtend */])(namespace, props);
    }
    function callAppHooks(app, eventName) {
        Object.keys(factories).forEach(function (serviceName) {
            // Ignore virtual services
            var factoryName = useAsService(app, serviceName);
            if (factoryName === null) {
                return;
            }
            if (appHooks[factoryName]) {
                appHooks[factoryName](eventName, app);
            }
        });
    }
    // Map the requested service to a registered service name
    // (used to map auth to serverAuth service when needed).
    function useAsService(app, name) {
        if (name === 'serverAuth') {
            return null;
        }
        var useService = name;
        var options = app.options;
        return useService;
    }
    return namespace;
}
function error(code, args) {
    throw appErrors.create(code, args);
}
// TypeScript does not support non-string indexes!
// let errors: {[code: AppError: string} = {
var errors = {
    'no-app': "No Firebase App '{$name}' has been created - " +
        'call Firebase App.initializeApp()',
    'bad-app-name': "Illegal App name: '{$name}",
    'duplicate-app': "Firebase App named '{$name}' already exists",
    'app-deleted': "Firebase App named '{$name}' already deleted",
    'duplicate-service': "Firebase service named '{$name}' already registered",
    'sa-not-supported': 'Initializing the Firebase SDK with a service ' +
        'account is only allowed in a Node.js environment. On client ' +
        'devices, you should instead initialize the SDK with an api key and ' +
        'auth domain',
    'invalid-app-argument': 'firebase.{$name}() takes either no argument or a ' +
        'Firebase App instance.'
};
var appErrors = new __WEBPACK_IMPORTED_MODULE_0__firebase_util__["d" /* ErrorFactory */]('app', 'Firebase', errors);




/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var firebase = __webpack_require__(14).default; (function(){/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(){var h,aa=aa||{},k=this,ba=function(a){return void 0!==a},m=function(a){return"string"==typeof a},ca=function(a){return"boolean"==typeof a},da=function(){},ea=function(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";
if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";else if("function"==b&&"undefined"==typeof a.call)return"object";return b},fa=function(a){return null===a},ha=function(a){return"array"==ea(a)},ia=function(a){var b=ea(a);return"array"==b||"object"==b&&"number"==typeof a.length},p=function(a){return"function"==ea(a)},q=function(a){var b=typeof a;return"object"==b&&null!=a||"function"==
b},ja=function(a,b,c){return a.call.apply(a.bind,arguments)},ka=function(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}},r=function(a,b,c){r=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?ja:ka;return r.apply(null,arguments)},la=function(a,b){var c=
Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}},ma=Date.now||function(){return+new Date},t=function(a,b){function c(){}c.prototype=b.prototype;a.Uc=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.Og=function(a,c,f){for(var d=Array(arguments.length-2),e=2;e<arguments.length;e++)d[e-2]=arguments[e];return b.prototype[c].apply(a,d)}};var u=function(a){if(Error.captureStackTrace)Error.captureStackTrace(this,u);else{var b=Error().stack;b&&(this.stack=b)}a&&(this.message=String(a))};t(u,Error);u.prototype.name="CustomError";var na=function(a,b){for(var c=a.split("%s"),d="",e=Array.prototype.slice.call(arguments,1);e.length&&1<c.length;)d+=c.shift()+e.shift();return d+c.join("%s")},oa=String.prototype.trim?function(a){return a.trim()}:function(a){return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},wa=function(a){if(!pa.test(a))return a;-1!=a.indexOf("&")&&(a=a.replace(qa,"&amp;"));-1!=a.indexOf("<")&&(a=a.replace(ra,"&lt;"));-1!=a.indexOf(">")&&(a=a.replace(sa,"&gt;"));-1!=a.indexOf('"')&&(a=a.replace(ta,"&quot;"));-1!=a.indexOf("'")&&
(a=a.replace(ua,"&#39;"));-1!=a.indexOf("\x00")&&(a=a.replace(va,"&#0;"));return a},qa=/&/g,ra=/</g,sa=/>/g,ta=/"/g,ua=/'/g,va=/\x00/g,pa=/[\x00&<>"']/,v=function(a,b){return-1!=a.indexOf(b)},xa=function(a,b){return a<b?-1:a>b?1:0};var ya=function(a,b){b.unshift(a);u.call(this,na.apply(null,b));b.shift()};t(ya,u);ya.prototype.name="AssertionError";
var za=function(a,b,c,d){var e="Assertion failed";if(c){e+=": "+c;var f=d}else a&&(e+=": "+a,f=b);throw new ya(""+e,f||[]);},w=function(a,b,c){a||za("",null,b,Array.prototype.slice.call(arguments,2));return a},Aa=function(a,b){throw new ya("Failure"+(a?": "+a:""),Array.prototype.slice.call(arguments,1));},Ba=function(a,b,c){"number"==typeof a||za("Expected number but got %s: %s.",[ea(a),a],b,Array.prototype.slice.call(arguments,2));return a},Ca=function(a,b,c){m(a)||za("Expected string but got %s: %s.",
[ea(a),a],b,Array.prototype.slice.call(arguments,2))},Da=function(a,b,c){p(a)||za("Expected function but got %s: %s.",[ea(a),a],b,Array.prototype.slice.call(arguments,2))};var Fa=function(){this.Tc="";this.kf=Ea};Fa.prototype.qb=!0;Fa.prototype.ob=function(){return this.Tc};Fa.prototype.toString=function(){return"Const{"+this.Tc+"}"};var Ga=function(a){if(a instanceof Fa&&a.constructor===Fa&&a.kf===Ea)return a.Tc;Aa("expected object of type Const, got '"+a+"'");return"type_error:Const"},Ea={},Ha=function(a){var b=new Fa;b.Tc=a;return b};Ha("");var Ja=function(){this.Lc="";this.lf=Ia};Ja.prototype.qb=!0;Ja.prototype.ob=function(){return this.Lc};Ja.prototype.toString=function(){return"TrustedResourceUrl{"+this.Lc+"}"};
var Ka=function(a){if(a instanceof Ja&&a.constructor===Ja&&a.lf===Ia)return a.Lc;Aa("expected object of type TrustedResourceUrl, got '"+a+"' of type "+ea(a));return"type_error:TrustedResourceUrl"},Oa=function(a,b){var c=Ga(a);if(!La.test(c))throw Error("Invalid TrustedResourceUrl format: "+c);a=c.replace(Ma,function(a,e){if(!Object.prototype.hasOwnProperty.call(b,e))throw Error('Found marker, "'+e+'", in format string, "'+c+'", but no valid label mapping found in args: '+JSON.stringify(b));a=b[e];
return a instanceof Fa?Ga(a):encodeURIComponent(String(a))});return Na(a)},Ma=/%{(\w+)}/g,La=/^(?:https:)?\/\/[0-9a-z.:[\]-]+\/|^\/[^\/\\]|^about:blank(#|$)/i,Ia={},Na=function(a){var b=new Ja;b.Lc=a;return b};var Pa=Array.prototype.indexOf?function(a,b,c){w(null!=a.length);return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(m(a))return m(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},x=Array.prototype.forEach?function(a,b,c){w(null!=a.length);Array.prototype.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=m(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)},Qa=function(a,b){for(var c=m(a)?
a.split(""):a,d=a.length-1;0<=d;--d)d in c&&b.call(void 0,c[d],d,a)},Ra=Array.prototype.map?function(a,b,c){w(null!=a.length);return Array.prototype.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=m(a)?a.split(""):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e},Sa=Array.prototype.some?function(a,b,c){w(null!=a.length);return Array.prototype.some.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=m(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return!0;return!1},
Ua=function(a){a:{var b=Ta;for(var c=a.length,d=m(a)?a.split(""):a,e=0;e<c;e++)if(e in d&&b.call(void 0,d[e],e,a)){b=e;break a}b=-1}return 0>b?null:m(a)?a.charAt(b):a[b]},Va=function(a,b){return 0<=Pa(a,b)},Xa=function(a,b){b=Pa(a,b);var c;(c=0<=b)&&Wa(a,b);return c},Wa=function(a,b){w(null!=a.length);return 1==Array.prototype.splice.call(a,b,1).length},Ya=function(a,b){var c=0;Qa(a,function(d,e){b.call(void 0,d,e,a)&&Wa(a,e)&&c++})},Za=function(a){return Array.prototype.concat.apply([],arguments)},
$a=function(a){var b=a.length;if(0<b){for(var c=Array(b),d=0;d<b;d++)c[d]=a[d];return c}return[]};var ab=function(a){return Ra(a,function(a){a=a.toString(16);return 1<a.length?a:"0"+a}).join("")};var bb;a:{var cb=k.navigator;if(cb){var db=cb.userAgent;if(db){bb=db;break a}}bb=""}var y=function(a){return v(bb,a)};var eb=function(a,b){for(var c in a)b.call(void 0,a[c],c,a)},fb=function(a,b){for(var c in a)if(b.call(void 0,a[c],c,a))return!0;return!1},gb=function(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b},hb=function(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b},ib=function(a){for(var b in a)return!1;return!0},jb=function(a,b){for(var c in a)if(!(c in b)||a[c]!==b[c])return!1;for(c in b)if(!(c in a))return!1;return!0},kb=function(a){var b={},c;for(c in a)b[c]=a[c];return b},lb="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "),
mb=function(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<lb.length;f++)c=lb[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};var nb=function(a){nb[" "](a);return a};nb[" "]=da;var pb=function(a,b){var c=ob;return Object.prototype.hasOwnProperty.call(c,a)?c[a]:c[a]=b(a)};var qb=y("Opera"),z=y("Trident")||y("MSIE"),rb=y("Edge"),sb=rb||z,tb=y("Gecko")&&!(v(bb.toLowerCase(),"webkit")&&!y("Edge"))&&!(y("Trident")||y("MSIE"))&&!y("Edge"),ub=v(bb.toLowerCase(),"webkit")&&!y("Edge"),vb=function(){var a=k.document;return a?a.documentMode:void 0},wb;
a:{var xb="",yb=function(){var a=bb;if(tb)return/rv:([^\);]+)(\)|;)/.exec(a);if(rb)return/Edge\/([\d\.]+)/.exec(a);if(z)return/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(ub)return/WebKit\/(\S+)/.exec(a);if(qb)return/(?:Version)[ \/]?(\S+)/.exec(a)}();yb&&(xb=yb?yb[1]:"");if(z){var Ab=vb();if(null!=Ab&&Ab>parseFloat(xb)){wb=String(Ab);break a}}wb=xb}
var Bb=wb,ob={},A=function(a){return pb(a,function(){for(var b=0,c=oa(String(Bb)).split("."),d=oa(String(a)).split("."),e=Math.max(c.length,d.length),f=0;0==b&&f<e;f++){var g=c[f]||"",l=d[f]||"";do{g=/(\d*)(\D*)(.*)/.exec(g)||["","","",""];l=/(\d*)(\D*)(.*)/.exec(l)||["","","",""];if(0==g[0].length&&0==l[0].length)break;b=xa(0==g[1].length?0:parseInt(g[1],10),0==l[1].length?0:parseInt(l[1],10))||xa(0==g[2].length,0==l[2].length)||xa(g[2],l[2]);g=g[3];l=l[3]}while(0==b)}return 0<=b})},Cb;var Db=k.document;
Cb=Db&&z?vb()||("CSS1Compat"==Db.compatMode?parseInt(Bb,10):5):void 0;var Eb=null,Fb=null,Hb=function(a){var b="";Gb(a,function(a){b+=String.fromCharCode(a)});return b},Gb=function(a,b){function c(b){for(;d<a.length;){var c=a.charAt(d++),e=Fb[c];if(null!=e)return e;if(!/^[\s\xa0]*$/.test(c))throw Error("Unknown base64 encoding at char: "+c);}return b}Ib();for(var d=0;;){var e=c(-1),f=c(0),g=c(64),l=c(64);if(64===l&&-1===e)break;b(e<<2|f>>4);64!=g&&(b(f<<4&240|g>>2),64!=l&&b(g<<6&192|l))}},Ib=function(){if(!Eb){Eb={};Fb={};for(var a=0;65>a;a++)Eb[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a),
Fb[Eb[a]]=a,62<=a&&(Fb["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt(a)]=a)}};var Jb=function(){this.Da=-1};var Mb=function(a,b){this.Da=-1;this.Da=64;this.qc=k.Uint8Array?new Uint8Array(this.Da):Array(this.Da);this.Xc=this.rb=0;this.l=[];this.bg=a;this.Fe=b;this.Cg=k.Int32Array?new Int32Array(64):Array(64);ba(Kb)||(Kb=k.Int32Array?new Int32Array(Lb):Lb);this.reset()},Kb;t(Mb,Jb);for(var Nb=[],Ob=0;63>Ob;Ob++)Nb[Ob]=0;var Pb=Za(128,Nb);Mb.prototype.reset=function(){this.Xc=this.rb=0;this.l=k.Int32Array?new Int32Array(this.Fe):$a(this.Fe)};
var Qb=function(a){var b=a.qc;w(b.length==a.Da);for(var c=a.Cg,d=0,e=0;e<b.length;)c[d++]=b[e]<<24|b[e+1]<<16|b[e+2]<<8|b[e+3],e=4*d;for(b=16;64>b;b++){e=c[b-15]|0;d=c[b-2]|0;var f=(c[b-16]|0)+((e>>>7|e<<25)^(e>>>18|e<<14)^e>>>3)|0,g=(c[b-7]|0)+((d>>>17|d<<15)^(d>>>19|d<<13)^d>>>10)|0;c[b]=f+g|0}d=a.l[0]|0;e=a.l[1]|0;var l=a.l[2]|0,n=a.l[3]|0,F=a.l[4]|0,zb=a.l[5]|0,ic=a.l[6]|0;f=a.l[7]|0;for(b=0;64>b;b++){var yi=((d>>>2|d<<30)^(d>>>13|d<<19)^(d>>>22|d<<10))+(d&e^d&l^e&l)|0;g=F&zb^~F&ic;f=f+((F>>>
6|F<<26)^(F>>>11|F<<21)^(F>>>25|F<<7))|0;g=g+(Kb[b]|0)|0;g=f+(g+(c[b]|0)|0)|0;f=ic;ic=zb;zb=F;F=n+g|0;n=l;l=e;e=d;d=g+yi|0}a.l[0]=a.l[0]+d|0;a.l[1]=a.l[1]+e|0;a.l[2]=a.l[2]+l|0;a.l[3]=a.l[3]+n|0;a.l[4]=a.l[4]+F|0;a.l[5]=a.l[5]+zb|0;a.l[6]=a.l[6]+ic|0;a.l[7]=a.l[7]+f|0};
Mb.prototype.update=function(a,b){ba(b)||(b=a.length);var c=0,d=this.rb;if(m(a))for(;c<b;)this.qc[d++]=a.charCodeAt(c++),d==this.Da&&(Qb(this),d=0);else if(ia(a))for(;c<b;){var e=a[c++];if(!("number"==typeof e&&0<=e&&255>=e&&e==(e|0)))throw Error("message must be a byte array");this.qc[d++]=e;d==this.Da&&(Qb(this),d=0)}else throw Error("message must be string or array");this.rb=d;this.Xc+=b};
Mb.prototype.digest=function(){var a=[],b=8*this.Xc;56>this.rb?this.update(Pb,56-this.rb):this.update(Pb,this.Da-(this.rb-56));for(var c=63;56<=c;c--)this.qc[c]=b&255,b/=256;Qb(this);for(c=b=0;c<this.bg;c++)for(var d=24;0<=d;d-=8)a[b++]=this.l[c]>>d&255;return a};
var Lb=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,
4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];var Sb=function(){Mb.call(this,8,Rb)};t(Sb,Mb);var Rb=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225];var Tb=Object.freeze||function(a){return a};var Ub=function(){this.Ma=this.Ma;this.Ic=this.Ic};Ub.prototype.Ma=!1;Ub.prototype.isDisposed=function(){return this.Ma};Ub.prototype.lb=function(){if(this.Ic)for(;this.Ic.length;)this.Ic.shift()()};var Vb=!z||9<=Number(Cb),Wb=z&&!A("9");!ub||A("528");tb&&A("1.9b")||z&&A("8")||qb&&A("9.5")||ub&&A("528");tb&&!A("8")||z&&A("9");var Xb=function(){if(!k.addEventListener||!Object.defineProperty)return!1;var a=!1,b=Object.defineProperty({},"passive",{get:function(){a=!0}});k.addEventListener("test",da,b);k.removeEventListener("test",da,b);return a}();var B=function(a,b){this.type=a;this.currentTarget=this.target=b;this.defaultPrevented=this.Wa=!1;this.Ue=!0};B.prototype.stopPropagation=function(){this.Wa=!0};B.prototype.preventDefault=function(){this.defaultPrevented=!0;this.Ue=!1};var Yb=function(a,b){B.call(this,a?a.type:"");this.relatedTarget=this.currentTarget=this.target=null;this.button=this.screenY=this.screenX=this.clientY=this.clientX=this.offsetY=this.offsetX=0;this.key="";this.charCode=this.keyCode=0;this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1;this.state=null;this.pointerId=0;this.pointerType="";this.R=null;a&&this.init(a,b)};t(Yb,B);var Zb=Tb({2:"touch",3:"pen",4:"mouse"});
Yb.prototype.init=function(a,b){var c=this.type=a.type,d=a.changedTouches?a.changedTouches[0]:null;this.target=a.target||a.srcElement;this.currentTarget=b;if(b=a.relatedTarget){if(tb){a:{try{nb(b.nodeName);var e=!0;break a}catch(f){}e=!1}e||(b=null)}}else"mouseover"==c?b=a.fromElement:"mouseout"==c&&(b=a.toElement);this.relatedTarget=b;null===d?(this.offsetX=ub||void 0!==a.offsetX?a.offsetX:a.layerX,this.offsetY=ub||void 0!==a.offsetY?a.offsetY:a.layerY,this.clientX=void 0!==a.clientX?a.clientX:a.pageX,
this.clientY=void 0!==a.clientY?a.clientY:a.pageY,this.screenX=a.screenX||0,this.screenY=a.screenY||0):(this.clientX=void 0!==d.clientX?d.clientX:d.pageX,this.clientY=void 0!==d.clientY?d.clientY:d.pageY,this.screenX=d.screenX||0,this.screenY=d.screenY||0);this.button=a.button;this.keyCode=a.keyCode||0;this.key=a.key||"";this.charCode=a.charCode||("keypress"==c?a.keyCode:0);this.ctrlKey=a.ctrlKey;this.altKey=a.altKey;this.shiftKey=a.shiftKey;this.metaKey=a.metaKey;this.pointerId=a.pointerId||0;this.pointerType=
m(a.pointerType)?a.pointerType:Zb[a.pointerType]||"";this.state=a.state;this.R=a;a.defaultPrevented&&this.preventDefault()};Yb.prototype.stopPropagation=function(){Yb.Uc.stopPropagation.call(this);this.R.stopPropagation?this.R.stopPropagation():this.R.cancelBubble=!0};Yb.prototype.preventDefault=function(){Yb.Uc.preventDefault.call(this);var a=this.R;if(a.preventDefault)a.preventDefault();else if(a.returnValue=!1,Wb)try{if(a.ctrlKey||112<=a.keyCode&&123>=a.keyCode)a.keyCode=-1}catch(b){}};
Yb.prototype.Hf=function(){return this.R};var $b="closure_listenable_"+(1E6*Math.random()|0),ac=0;var bc=function(a,b,c,d,e){this.listener=a;this.Mc=null;this.src=b;this.type=c;this.capture=!!d;this.vc=e;this.key=++ac;this.Bb=this.pc=!1},cc=function(a){a.Bb=!0;a.listener=null;a.Mc=null;a.src=null;a.vc=null};var dc=function(a){this.src=a;this.I={};this.jc=0};dc.prototype.add=function(a,b,c,d,e){var f=a.toString();a=this.I[f];a||(a=this.I[f]=[],this.jc++);var g=ec(a,b,d,e);-1<g?(b=a[g],c||(b.pc=!1)):(b=new bc(b,this.src,f,!!d,e),b.pc=c,a.push(b));return b};dc.prototype.remove=function(a,b,c,d){a=a.toString();if(!(a in this.I))return!1;var e=this.I[a];b=ec(e,b,c,d);return-1<b?(cc(e[b]),Wa(e,b),0==e.length&&(delete this.I[a],this.jc--),!0):!1};
var fc=function(a,b){var c=b.type;c in a.I&&Xa(a.I[c],b)&&(cc(b),0==a.I[c].length&&(delete a.I[c],a.jc--))};dc.prototype.td=function(a,b,c,d){a=this.I[a.toString()];var e=-1;a&&(e=ec(a,b,c,d));return-1<e?a[e]:null};dc.prototype.hasListener=function(a,b){var c=ba(a),d=c?a.toString():"",e=ba(b);return fb(this.I,function(a){for(var f=0;f<a.length;++f)if(!(c&&a[f].type!=d||e&&a[f].capture!=b))return!0;return!1})};
var ec=function(a,b,c,d){for(var e=0;e<a.length;++e){var f=a[e];if(!f.Bb&&f.listener==b&&f.capture==!!c&&f.vc==d)return e}return-1};var gc="closure_lm_"+(1E6*Math.random()|0),hc={},jc=0,lc=function(a,b,c,d,e){if(d&&d.once)kc(a,b,c,d,e);else if(ha(b))for(var f=0;f<b.length;f++)lc(a,b[f],c,d,e);else c=mc(c),a&&a[$b]?a.listen(b,c,q(d)?!!d.capture:!!d,e):nc(a,b,c,!1,d,e)},nc=function(a,b,c,d,e,f){if(!b)throw Error("Invalid event type");var g=q(e)?!!e.capture:!!e,l=oc(a);l||(a[gc]=l=new dc(a));c=l.add(b,c,d,g,f);if(!c.Mc){d=pc();c.Mc=d;d.src=a;d.listener=c;if(a.addEventListener)Xb||(e=g),void 0===e&&(e=!1),a.addEventListener(b.toString(),
d,e);else if(a.attachEvent)a.attachEvent(qc(b.toString()),d);else throw Error("addEventListener and attachEvent are unavailable.");jc++}},pc=function(){var a=rc,b=Vb?function(c){return a.call(b.src,b.listener,c)}:function(c){c=a.call(b.src,b.listener,c);if(!c)return c};return b},kc=function(a,b,c,d,e){if(ha(b))for(var f=0;f<b.length;f++)kc(a,b[f],c,d,e);else c=mc(c),a&&a[$b]?sc(a,b,c,q(d)?!!d.capture:!!d,e):nc(a,b,c,!0,d,e)},tc=function(a,b,c,d,e){if(ha(b))for(var f=0;f<b.length;f++)tc(a,b[f],c,d,
e);else d=q(d)?!!d.capture:!!d,c=mc(c),a&&a[$b]?a.ga.remove(String(b),c,d,e):a&&(a=oc(a))&&(b=a.td(b,c,d,e))&&uc(b)},uc=function(a){if("number"!=typeof a&&a&&!a.Bb){var b=a.src;if(b&&b[$b])fc(b.ga,a);else{var c=a.type,d=a.Mc;b.removeEventListener?b.removeEventListener(c,d,a.capture):b.detachEvent&&b.detachEvent(qc(c),d);jc--;(c=oc(b))?(fc(c,a),0==c.jc&&(c.src=null,b[gc]=null)):cc(a)}}},qc=function(a){return a in hc?hc[a]:hc[a]="on"+a},wc=function(a,b,c,d){var e=!0;if(a=oc(a))if(b=a.I[b.toString()])for(b=
b.concat(),a=0;a<b.length;a++){var f=b[a];f&&f.capture==c&&!f.Bb&&(f=vc(f,d),e=e&&!1!==f)}return e},vc=function(a,b){var c=a.listener,d=a.vc||a.src;a.pc&&uc(a);return c.call(d,b)},rc=function(a,b){if(a.Bb)return!0;if(!Vb){if(!b)a:{b=["window","event"];for(var c=k,d=0;d<b.length;d++)if(c=c[b[d]],null==c){b=null;break a}b=c}d=b;b=new Yb(d,this);c=!0;if(!(0>d.keyCode||void 0!=d.returnValue)){a:{var e=!1;if(0==d.keyCode)try{d.keyCode=-1;break a}catch(g){e=!0}if(e||void 0==d.returnValue)d.returnValue=
!0}d=[];for(e=b.currentTarget;e;e=e.parentNode)d.push(e);a=a.type;for(e=d.length-1;!b.Wa&&0<=e;e--){b.currentTarget=d[e];var f=wc(d[e],a,!0,b);c=c&&f}for(e=0;!b.Wa&&e<d.length;e++)b.currentTarget=d[e],f=wc(d[e],a,!1,b),c=c&&f}return c}return vc(a,new Yb(b,this))},oc=function(a){a=a[gc];return a instanceof dc?a:null},xc="__closure_events_fn_"+(1E9*Math.random()>>>0),mc=function(a){w(a,"Listener can not be null.");if(p(a))return a;w(a.handleEvent,"An object listener must have handleEvent method.");
a[xc]||(a[xc]=function(b){return a.handleEvent(b)});return a[xc]};var yc=/^[+a-zA-Z0-9_.!#$%&'*\/=?^`{|}~-]+@([a-zA-Z0-9-]+\.)+[a-zA-Z0-9]{2,63}$/;var Ac=function(){this.xa="";this.jf=zc};Ac.prototype.qb=!0;Ac.prototype.ob=function(){return this.xa};Ac.prototype.toString=function(){return"SafeUrl{"+this.xa+"}"};
var Bc=function(a){if(a instanceof Ac&&a.constructor===Ac&&a.jf===zc)return a.xa;Aa("expected object of type SafeUrl, got '"+a+"' of type "+ea(a));return"type_error:SafeUrl"},Cc=/^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i,Ec=function(a){if(a instanceof Ac)return a;a=a.qb?a.ob():String(a);Cc.test(a)||(a="about:invalid#zClosurez");return Dc(a)},zc={},Dc=function(a){var b=new Ac;b.xa=a;return b};Dc("about:blank");var Hc=function(a){var b=[];Fc(new Gc,a,b);return b.join("")},Gc=function(){this.Nc=void 0},Fc=function(a,b,c){if(null==b)c.push("null");else{if("object"==typeof b){if(ha(b)){var d=b;b=d.length;c.push("[");for(var e="",f=0;f<b;f++)c.push(e),e=d[f],Fc(a,a.Nc?a.Nc.call(d,String(f),e):e,c),e=",";c.push("]");return}if(b instanceof String||b instanceof Number||b instanceof Boolean)b=b.valueOf();else{c.push("{");f="";for(d in b)Object.prototype.hasOwnProperty.call(b,d)&&(e=b[d],"function"!=typeof e&&(c.push(f),
Ic(d,c),c.push(":"),Fc(a,a.Nc?a.Nc.call(b,d,e):e,c),f=","));c.push("}");return}}switch(typeof b){case "string":Ic(b,c);break;case "number":c.push(isFinite(b)&&!isNaN(b)?String(b):"null");break;case "boolean":c.push(String(b));break;case "function":c.push("null");break;default:throw Error("Unknown type: "+typeof b);}}},Jc={'"':'\\"',"\\":"\\\\","/":"\\/","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\u000b"},Kc=/\uffff/.test("\uffff")?/[\\"\x00-\x1f\x7f-\uffff]/g:/[\\"\x00-\x1f\x7f-\xff]/g,
Ic=function(a,b){b.push('"',a.replace(Kc,function(a){var b=Jc[a];b||(b="\\u"+(a.charCodeAt(0)|65536).toString(16).substr(1),Jc[a]=b);return b}),'"')};var Lc=function(){};Lc.prototype.je=null;var Mc=function(a){return a.je||(a.je=a.Cd())};var Nc,Oc=function(){};t(Oc,Lc);Oc.prototype.rc=function(){var a=Pc(this);return a?new ActiveXObject(a):new XMLHttpRequest};Oc.prototype.Cd=function(){var a={};Pc(this)&&(a[0]=!0,a[1]=!0);return a};
var Pc=function(a){if(!a.Ee&&"undefined"==typeof XMLHttpRequest&&"undefined"!=typeof ActiveXObject){for(var b=["MSXML2.XMLHTTP.6.0","MSXML2.XMLHTTP.3.0","MSXML2.XMLHTTP","Microsoft.XMLHTTP"],c=0;c<b.length;c++){var d=b[c];try{return new ActiveXObject(d),a.Ee=d}catch(e){}}throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");}return a.Ee};Nc=new Oc;var Qc=function(){};t(Qc,Lc);Qc.prototype.rc=function(){var a=new XMLHttpRequest;if("withCredentials"in a)return a;if("undefined"!=typeof XDomainRequest)return new Rc;throw Error("Unsupported browser");};Qc.prototype.Cd=function(){return{}};
var Rc=function(){this.oa=new XDomainRequest;this.readyState=0;this.onreadystatechange=null;this.responseText="";this.status=-1;this.statusText=this.responseXML=null;this.oa.onload=r(this.Lf,this);this.oa.onerror=r(this.ze,this);this.oa.onprogress=r(this.Mf,this);this.oa.ontimeout=r(this.Nf,this)};h=Rc.prototype;h.open=function(a,b,c){if(null!=c&&!c)throw Error("Only async requests are supported.");this.oa.open(a,b)};
h.send=function(a){if(a)if("string"==typeof a)this.oa.send(a);else throw Error("Only string data is supported");else this.oa.send()};h.abort=function(){this.oa.abort()};h.setRequestHeader=function(){};h.getResponseHeader=function(a){return"content-type"==a.toLowerCase()?this.oa.contentType:""};h.Lf=function(){this.status=200;this.responseText=this.oa.responseText;Sc(this,4)};h.ze=function(){this.status=500;this.responseText="";Sc(this,4)};h.Nf=function(){this.ze()};
h.Mf=function(){this.status=200;Sc(this,1)};var Sc=function(a,b){a.readyState=b;if(a.onreadystatechange)a.onreadystatechange()};Rc.prototype.getAllResponseHeaders=function(){return"content-type: "+this.oa.contentType};var Tc=function(a,b,c){this.Yf=c;this.wf=a;this.lg=b;this.Hc=0;this.wc=null};Tc.prototype.get=function(){if(0<this.Hc){this.Hc--;var a=this.wc;this.wc=a.next;a.next=null}else a=this.wf();return a};Tc.prototype.put=function(a){this.lg(a);this.Hc<this.Yf&&(this.Hc++,a.next=this.wc,this.wc=a)};var Uc=function(a){k.setTimeout(function(){throw a;},0)},Vc,Wc=function(){var a=k.MessageChannel;"undefined"===typeof a&&"undefined"!==typeof window&&window.postMessage&&window.addEventListener&&!y("Presto")&&(a=function(){var a=document.createElement("IFRAME");a.style.display="none";a.src="";document.documentElement.appendChild(a);var b=a.contentWindow;a=b.document;a.open();a.write("");a.close();var c="callImmediate"+Math.random(),d="file:"==b.location.protocol?"*":b.location.protocol+"//"+b.location.host;
a=r(function(a){if(("*"==d||a.origin==d)&&a.data==c)this.port1.onmessage()},this);b.addEventListener("message",a,!1);this.port1={};this.port2={postMessage:function(){b.postMessage(c,d)}}});if("undefined"!==typeof a&&!y("Trident")&&!y("MSIE")){var b=new a,c={},d=c;b.port1.onmessage=function(){if(ba(c.next)){c=c.next;var a=c.me;c.me=null;a()}};return function(a){d.next={me:a};d=d.next;b.port2.postMessage(0)}}return"undefined"!==typeof document&&"onreadystatechange"in document.createElement("SCRIPT")?
function(a){var b=document.createElement("SCRIPT");b.onreadystatechange=function(){b.onreadystatechange=null;b.parentNode.removeChild(b);b=null;a();a=null};document.documentElement.appendChild(b)}:function(a){k.setTimeout(a,0)}};var Xc=function(){this.bd=this.hb=null},Zc=new Tc(function(){return new Yc},function(a){a.reset()},100);Xc.prototype.add=function(a,b){var c=Zc.get();c.set(a,b);this.bd?this.bd.next=c:(w(!this.hb),this.hb=c);this.bd=c};Xc.prototype.remove=function(){var a=null;this.hb&&(a=this.hb,this.hb=this.hb.next,this.hb||(this.bd=null),a.next=null);return a};var Yc=function(){this.next=this.scope=this.rd=null};Yc.prototype.set=function(a,b){this.rd=a;this.scope=b;this.next=null};
Yc.prototype.reset=function(){this.next=this.scope=this.rd=null};var dd=function(a,b){$c||ad();bd||($c(),bd=!0);cd.add(a,b)},$c,ad=function(){if(-1!=String(k.Promise).indexOf("[native code]")){var a=k.Promise.resolve(void 0);$c=function(){a.then(ed)}}else $c=function(){var a=ed;!p(k.setImmediate)||k.Window&&k.Window.prototype&&!y("Edge")&&k.Window.prototype.setImmediate==k.setImmediate?(Vc||(Vc=Wc()),Vc(a)):k.setImmediate(a)}},bd=!1,cd=new Xc,ed=function(){for(var a;a=cd.remove();){try{a.rd.call(a.scope)}catch(b){Uc(b)}Zc.put(a)}bd=!1};var fd=function(a,b){var c=(c=a&&a.ownerDocument)&&(c.defaultView||c.parentWindow)||k;"undefined"!=typeof c[b]&&"undefined"!=typeof c.Location&&"undefined"!=typeof c.Element&&(c=a&&(a instanceof c[b]||!(a instanceof c.Location||a instanceof c.Element)),a=q(a)?a.constructor.displayName||a.constructor.name||Object.prototype.toString.call(a):void 0===a?"undefined":null===a?"null":typeof a,w(c,"Argument is not a %s (or a non-Element, non-Location mock); got: %s",b,a))};var gd=!z||9<=Number(Cb);!tb&&!z||z&&9<=Number(Cb)||tb&&A("1.9.1");z&&A("9");var id=function(){this.xa="";this.hf=hd};id.prototype.qb=!0;id.prototype.ob=function(){return this.xa};id.prototype.toString=function(){return"SafeHtml{"+this.xa+"}"};var jd=function(a){if(a instanceof id&&a.constructor===id&&a.hf===hd)return a.xa;Aa("expected object of type SafeHtml, got '"+a+"' of type "+ea(a));return"type_error:SafeHtml"},hd={};id.prototype.Tf=function(a){this.xa=a;return this};var kd=function(a,b){fd(a,"HTMLScriptElement");a.src=Ka(b)};var ld=function(a){var b=document;return m(a)?b.getElementById(a):a},nd=function(a,b){eb(b,function(b,d){b&&b.qb&&(b=b.ob());"style"==d?a.style.cssText=b:"class"==d?a.className=b:"for"==d?a.htmlFor=b:md.hasOwnProperty(d)?a.setAttribute(md[d],b):0==d.lastIndexOf("aria-",0)||0==d.lastIndexOf("data-",0)?a.setAttribute(d,b):a[d]=b})},md={cellpadding:"cellPadding",cellspacing:"cellSpacing",colspan:"colSpan",frameborder:"frameBorder",height:"height",maxlength:"maxLength",nonce:"nonce",role:"role",rowspan:"rowSpan",
type:"type",usemap:"useMap",valign:"vAlign",width:"width"},pd=function(a,b,c){var d=arguments,e=document,f=String(d[0]),g=d[1];if(!gd&&g&&(g.name||g.type)){f=["<",f];g.name&&f.push(' name="',wa(g.name),'"');if(g.type){f.push(' type="',wa(g.type),'"');var l={};mb(l,g);delete l.type;g=l}f.push(">");f=f.join("")}f=e.createElement(f);g&&(m(g)?f.className=g:ha(g)?f.className=g.join(" "):nd(f,g));2<d.length&&od(e,f,d);return f},od=function(a,b,c){function d(c){c&&b.appendChild(m(c)?a.createTextNode(c):
c)}for(var e=2;e<c.length;e++){var f=c[e];!ia(f)||q(f)&&0<f.nodeType?d(f):x(qd(f)?$a(f):f,d)}},qd=function(a){if(a&&"number"==typeof a.length){if(q(a))return"function"==typeof a.item||"string"==typeof a.item;if(p(a))return"function"==typeof a.item}return!1};var rd=function(a){a.prototype.then=a.prototype.then;a.prototype.$goog_Thenable=!0},sd=function(a){if(!a)return!1;try{return!!a.$goog_Thenable}catch(b){return!1}};var C=function(a,b){this.aa=0;this.za=void 0;this.kb=this.ua=this.w=null;this.uc=this.pd=!1;if(a!=da)try{var c=this;a.call(b,function(a){td(c,2,a)},function(a){if(!(a instanceof ud))try{if(a instanceof Error)throw a;throw Error("Promise rejected.");}catch(e){}td(c,3,a)})}catch(d){td(this,3,d)}},vd=function(){this.next=this.context=this.tb=this.Ua=this.child=null;this.Hb=!1};vd.prototype.reset=function(){this.context=this.tb=this.Ua=this.child=null;this.Hb=!1};
var wd=new Tc(function(){return new vd},function(a){a.reset()},100),xd=function(a,b,c){var d=wd.get();d.Ua=a;d.tb=b;d.context=c;return d},D=function(a){if(a instanceof C)return a;var b=new C(da);td(b,2,a);return b},E=function(a){return new C(function(b,c){c(a)})},zd=function(a,b,c){yd(a,b,c,null)||dd(la(b,a))},Ad=function(a){return new C(function(b,c){var d=a.length,e=[];if(d)for(var f=function(a,c){d--;e[a]=c;0==d&&b(e)},g=function(a){c(a)},l=0,n;l<a.length;l++)n=a[l],zd(n,la(f,l),g);else b(e)})},
Bd=function(a){return new C(function(b){var c=a.length,d=[];if(c)for(var e=function(a,e,f){c--;d[a]=e?{Gf:!0,value:f}:{Gf:!1,reason:f};0==c&&b(d)},f=0,g;f<a.length;f++)g=a[f],zd(g,la(e,f,!0),la(e,f,!1));else b(d)})};C.prototype.then=function(a,b,c){null!=a&&Da(a,"opt_onFulfilled should be a function.");null!=b&&Da(b,"opt_onRejected should be a function. Did you pass opt_context as the second argument instead of the third?");return Cd(this,p(a)?a:null,p(b)?b:null,c)};rd(C);
var Ed=function(a,b){b=xd(b,b,void 0);b.Hb=!0;Dd(a,b);return a};C.prototype.g=function(a,b){return Cd(this,null,a,b)};C.prototype.cancel=function(a){0==this.aa&&dd(function(){var b=new ud(a);Fd(this,b)},this)};
var Fd=function(a,b){if(0==a.aa)if(a.w){var c=a.w;if(c.ua){for(var d=0,e=null,f=null,g=c.ua;g&&(g.Hb||(d++,g.child==a&&(e=g),!(e&&1<d)));g=g.next)e||(f=g);e&&(0==c.aa&&1==d?Fd(c,b):(f?(d=f,w(c.ua),w(null!=d),d.next==c.kb&&(c.kb=d),d.next=d.next.next):Gd(c),Hd(c,e,3,b)))}a.w=null}else td(a,3,b)},Dd=function(a,b){a.ua||2!=a.aa&&3!=a.aa||Id(a);w(null!=b.Ua);a.kb?a.kb.next=b:a.ua=b;a.kb=b},Cd=function(a,b,c,d){var e=xd(null,null,null);e.child=new C(function(a,g){e.Ua=b?function(c){try{var e=b.call(d,
c);a(e)}catch(F){g(F)}}:a;e.tb=c?function(b){try{var e=c.call(d,b);!ba(e)&&b instanceof ud?g(b):a(e)}catch(F){g(F)}}:g});e.child.w=a;Dd(a,e);return e.child};C.prototype.zg=function(a){w(1==this.aa);this.aa=0;td(this,2,a)};C.prototype.Ag=function(a){w(1==this.aa);this.aa=0;td(this,3,a)};
var td=function(a,b,c){0==a.aa&&(a===c&&(b=3,c=new TypeError("Promise cannot resolve to itself")),a.aa=1,yd(c,a.zg,a.Ag,a)||(a.za=c,a.aa=b,a.w=null,Id(a),3!=b||c instanceof ud||Jd(a,c)))},yd=function(a,b,c,d){if(a instanceof C)return null!=b&&Da(b,"opt_onFulfilled should be a function."),null!=c&&Da(c,"opt_onRejected should be a function. Did you pass opt_context as the second argument instead of the third?"),Dd(a,xd(b||da,c||null,d)),!0;if(sd(a))return a.then(b,c,d),!0;if(q(a))try{var e=a.then;if(p(e))return Kd(a,
e,b,c,d),!0}catch(f){return c.call(d,f),!0}return!1},Kd=function(a,b,c,d,e){var f=!1,g=function(a){f||(f=!0,c.call(e,a))},l=function(a){f||(f=!0,d.call(e,a))};try{b.call(a,g,l)}catch(n){l(n)}},Id=function(a){a.pd||(a.pd=!0,dd(a.Bf,a))},Gd=function(a){var b=null;a.ua&&(b=a.ua,a.ua=b.next,b.next=null);a.ua||(a.kb=null);null!=b&&w(null!=b.Ua);return b};C.prototype.Bf=function(){for(var a;a=Gd(this);)Hd(this,a,this.aa,this.za);this.pd=!1};
var Hd=function(a,b,c,d){if(3==c&&b.tb&&!b.Hb)for(;a&&a.uc;a=a.w)a.uc=!1;if(b.child)b.child.w=null,Ld(b,c,d);else try{b.Hb?b.Ua.call(b.context):Ld(b,c,d)}catch(e){Md.call(null,e)}wd.put(b)},Ld=function(a,b,c){2==b?a.Ua.call(a.context,c):a.tb&&a.tb.call(a.context,c)},Jd=function(a,b){a.uc=!0;dd(function(){a.uc&&Md.call(null,b)})},Md=Uc,ud=function(a){u.call(this,a)};t(ud,u);ud.prototype.name="cancel";/*
 Portions of this code are from MochiKit, received by
 The Closure Authors under the MIT license. All other code is Copyright
 2005-2009 The Closure Authors. All Rights Reserved.
*/
var Nd=function(a,b){this.Qc=[];this.Ne=a;this.re=b||null;this.Pb=this.nb=!1;this.za=void 0;this.be=this.he=this.fd=!1;this.Yc=0;this.w=null;this.gd=0};Nd.prototype.cancel=function(a){if(this.nb)this.za instanceof Nd&&this.za.cancel();else{if(this.w){var b=this.w;delete this.w;a?b.cancel(a):(b.gd--,0>=b.gd&&b.cancel())}this.Ne?this.Ne.call(this.re,this):this.be=!0;this.nb||Od(this,new Pd)}};Nd.prototype.oe=function(a,b){this.fd=!1;Qd(this,a,b)};
var Qd=function(a,b,c){a.nb=!0;a.za=c;a.Pb=!b;Rd(a)},Td=function(a){if(a.nb){if(!a.be)throw new Sd;a.be=!1}};Nd.prototype.callback=function(a){Td(this);Ud(a);Qd(this,!0,a)};var Od=function(a,b){Td(a);Ud(b);Qd(a,!1,b)},Ud=function(a){w(!(a instanceof Nd),"An execution sequence may not be initiated with a blocking Deferred.")},Wd=function(a,b){Vd(a,null,b,void 0)},Vd=function(a,b,c,d){w(!a.he,"Blocking Deferreds can not be re-used");a.Qc.push([b,c,d]);a.nb&&Rd(a)};
Nd.prototype.then=function(a,b,c){var d,e,f=new C(function(a,b){d=a;e=b});Vd(this,d,function(a){a instanceof Pd?f.cancel():e(a)});return f.then(a,b,c)};rd(Nd);
var Xd=function(a){return Sa(a.Qc,function(a){return p(a[1])})},Rd=function(a){if(a.Yc&&a.nb&&Xd(a)){var b=a.Yc,c=Yd[b];c&&(k.clearTimeout(c.Qb),delete Yd[b]);a.Yc=0}a.w&&(a.w.gd--,delete a.w);b=a.za;for(var d=c=!1;a.Qc.length&&!a.fd;){var e=a.Qc.shift(),f=e[0],g=e[1];e=e[2];if(f=a.Pb?g:f)try{var l=f.call(e||a.re,b);ba(l)&&(a.Pb=a.Pb&&(l==b||l instanceof Error),a.za=b=l);if(sd(b)||"function"===typeof k.Promise&&b instanceof k.Promise)d=!0,a.fd=!0}catch(n){b=n,a.Pb=!0,Xd(a)||(c=!0)}}a.za=b;d&&(l=r(a.oe,
a,!0),d=r(a.oe,a,!1),b instanceof Nd?(Vd(b,l,d),b.he=!0):b.then(l,d));c&&(b=new Zd(b),Yd[b.Qb]=b,a.Yc=b.Qb)},Sd=function(){u.call(this)};t(Sd,u);Sd.prototype.message="Deferred has already fired";Sd.prototype.name="AlreadyCalledError";var Pd=function(){u.call(this)};t(Pd,u);Pd.prototype.message="Deferred was canceled";Pd.prototype.name="CanceledError";var Zd=function(a){this.Qb=k.setTimeout(r(this.yg,this),0);this.ba=a};
Zd.prototype.yg=function(){w(Yd[this.Qb],"Cannot throw an error that is not scheduled.");delete Yd[this.Qb];throw this.ba;};var Yd={};var de=function(a){var b={},c=b.document||document,d=Ka(a),e=document.createElement("SCRIPT"),f={We:e,ic:void 0},g=new Nd($d,f),l=null,n=null!=b.timeout?b.timeout:5E3;0<n&&(l=window.setTimeout(function(){ae(e,!0);Od(g,new be(1,"Timeout reached for loading script "+d))},n),f.ic=l);e.onload=e.onreadystatechange=function(){e.readyState&&"loaded"!=e.readyState&&"complete"!=e.readyState||(ae(e,b.Pg||!1,l),g.callback(null))};e.onerror=function(){ae(e,!0,l);Od(g,new be(0,"Error while loading script "+d))};
f=b.attributes||{};mb(f,{type:"text/javascript",charset:"UTF-8"});nd(e,f);kd(e,a);ce(c).appendChild(e);return g},ce=function(a){var b;return(b=(a||document).getElementsByTagName("HEAD"))&&0!=b.length?b[0]:a.documentElement},$d=function(){if(this&&this.We){var a=this.We;a&&"SCRIPT"==a.tagName&&ae(a,!0,this.ic)}},ae=function(a,b,c){null!=c&&k.clearTimeout(c);a.onload=da;a.onerror=da;a.onreadystatechange=da;b&&window.setTimeout(function(){a&&a.parentNode&&a.parentNode.removeChild(a)},0)},be=function(a,
b){var c="Jsloader error (code #"+a+")";b&&(c+=": "+b);u.call(this,c);this.code=a};t(be,u);var ee=function(a,b,c,d,e){this.reset(a,b,c,d,e)};ee.prototype.te=null;var fe=0;ee.prototype.reset=function(a,b,c,d,e){"number"==typeof e||fe++;d||ma();this.Vb=a;delete this.te};ee.prototype.Xe=function(a){this.Vb=a};var ge=function(a){this.Le=a;this.Ae=this.kd=this.Vb=this.w=null},he=function(a,b){this.name=a;this.value=b};he.prototype.toString=function(){return this.name};var ie=new he("SEVERE",1E3),je=new he("INFO",800),ke=new he("CONFIG",700),le=new he("FINE",500);ge.prototype.getName=function(){return this.Le};ge.prototype.getParent=function(){return this.w};ge.prototype.Xe=function(a){this.Vb=a};var me=function(a){if(a.Vb)return a.Vb;if(a.w)return me(a.w);Aa("Root logger has no level set.");return null};
ge.prototype.log=function(a,b,c){if(a.value>=me(this).value)for(p(b)&&(b=b()),a=new ee(a,String(b),this.Le),c&&(a.te=c),c=this;c;){var d=c,e=a;if(d.Ae)for(var f=0;b=d.Ae[f];f++)b(e);c=c.getParent()}};ge.prototype.info=function(a,b){this.log(je,a,b)};ge.prototype.config=function(a,b){this.log(ke,a,b)};
var ne={},oe=null,pe=function(a){oe||(oe=new ge(""),ne[""]=oe,oe.Xe(ke));var b;if(!(b=ne[a])){b=new ge(a);var c=a.lastIndexOf("."),d=a.substr(c+1);c=pe(a.substr(0,c));c.kd||(c.kd={});c.kd[d]=b;b.w=c;ne[a]=b}return b};var G=function(){Ub.call(this);this.ga=new dc(this);this.nf=this;this.Kd=null};t(G,Ub);G.prototype[$b]=!0;h=G.prototype;h.addEventListener=function(a,b,c,d){lc(this,a,b,c,d)};h.removeEventListener=function(a,b,c,d){tc(this,a,b,c,d)};
h.dispatchEvent=function(a){qe(this);var b=this.Kd;if(b){var c=[];for(var d=1;b;b=b.Kd)c.push(b),w(1E3>++d,"infinite loop")}b=this.nf;d=a.type||a;if(m(a))a=new B(a,b);else if(a instanceof B)a.target=a.target||b;else{var e=a;a=new B(d,b);mb(a,e)}e=!0;if(c)for(var f=c.length-1;!a.Wa&&0<=f;f--){var g=a.currentTarget=c[f];e=re(g,d,!0,a)&&e}a.Wa||(g=a.currentTarget=b,e=re(g,d,!0,a)&&e,a.Wa||(e=re(g,d,!1,a)&&e));if(c)for(f=0;!a.Wa&&f<c.length;f++)g=a.currentTarget=c[f],e=re(g,d,!1,a)&&e;return e};
h.lb=function(){G.Uc.lb.call(this);if(this.ga){var a=this.ga,b=0,c;for(c in a.I){for(var d=a.I[c],e=0;e<d.length;e++)++b,cc(d[e]);delete a.I[c];a.jc--}}this.Kd=null};h.listen=function(a,b,c,d){qe(this);return this.ga.add(String(a),b,!1,c,d)};
var sc=function(a,b,c,d,e){a.ga.add(String(b),c,!0,d,e)},re=function(a,b,c,d){b=a.ga.I[String(b)];if(!b)return!0;b=b.concat();for(var e=!0,f=0;f<b.length;++f){var g=b[f];if(g&&!g.Bb&&g.capture==c){var l=g.listener,n=g.vc||g.src;g.pc&&fc(a.ga,g);e=!1!==l.call(n,d)&&e}}return e&&0!=d.Ue};G.prototype.td=function(a,b,c,d){return this.ga.td(String(a),b,c,d)};G.prototype.hasListener=function(a,b){return this.ga.hasListener(ba(a)?String(a):void 0,b)};var qe=function(a){w(a.ga,"Event target is not initialized. Did you call the superclass (goog.events.EventTarget) constructor?")};var se="StopIteration"in k?k.StopIteration:{message:"StopIteration",stack:""},te=function(){};te.prototype.next=function(){throw se;};te.prototype.mf=function(){return this};var H=function(a,b){a&&a.log(le,b,void 0)};var ue=function(a,b){this.ja={};this.C=[];this.gb=this.u=0;var c=arguments.length;if(1<c){if(c%2)throw Error("Uneven number of arguments");for(var d=0;d<c;d+=2)this.set(arguments[d],arguments[d+1])}else a&&this.addAll(a)};h=ue.prototype;h.ha=function(){ve(this);for(var a=[],b=0;b<this.C.length;b++)a.push(this.ja[this.C[b]]);return a};h.va=function(){ve(this);return this.C.concat()};h.Jb=function(a){return we(this.ja,a)};h.clear=function(){this.ja={};this.gb=this.u=this.C.length=0};
h.remove=function(a){return we(this.ja,a)?(delete this.ja[a],this.u--,this.gb++,this.C.length>2*this.u&&ve(this),!0):!1};var ve=function(a){if(a.u!=a.C.length){for(var b=0,c=0;b<a.C.length;){var d=a.C[b];we(a.ja,d)&&(a.C[c++]=d);b++}a.C.length=c}if(a.u!=a.C.length){var e={};for(c=b=0;b<a.C.length;)d=a.C[b],we(e,d)||(a.C[c++]=d,e[d]=1),b++;a.C.length=c}};h=ue.prototype;h.get=function(a,b){return we(this.ja,a)?this.ja[a]:b};
h.set=function(a,b){we(this.ja,a)||(this.u++,this.C.push(a),this.gb++);this.ja[a]=b};h.addAll=function(a){if(a instanceof ue){var b=a.va();a=a.ha()}else b=hb(a),a=gb(a);for(var c=0;c<b.length;c++)this.set(b[c],a[c])};h.forEach=function(a,b){for(var c=this.va(),d=0;d<c.length;d++){var e=c[d],f=this.get(e);a.call(b,f,e,this)}};h.clone=function(){return new ue(this)};
h.mf=function(a){ve(this);var b=0,c=this.gb,d=this,e=new te;e.next=function(){if(c!=d.gb)throw Error("The map has changed since the iterator was created");if(b>=d.C.length)throw se;var e=d.C[b++];return a?e:d.ja[e]};return e};var we=function(a,b){return Object.prototype.hasOwnProperty.call(a,b)};var xe=function(a){if(a.ha&&"function"==typeof a.ha)return a.ha();if(m(a))return a.split("");if(ia(a)){for(var b=[],c=a.length,d=0;d<c;d++)b.push(a[d]);return b}return gb(a)},ye=function(a){if(a.va&&"function"==typeof a.va)return a.va();if(!a.ha||"function"!=typeof a.ha){if(ia(a)||m(a)){var b=[];a=a.length;for(var c=0;c<a;c++)b.push(c);return b}return hb(a)}},ze=function(a,b,c){if(a.forEach&&"function"==typeof a.forEach)a.forEach(b,c);else if(ia(a)||m(a))x(a,b,c);else for(var d=ye(a),e=xe(a),f=e.length,
g=0;g<f;g++)b.call(c,e[g],d&&d[g],a)};var Ae=function(a,b,c){if(p(a))c&&(a=r(a,c));else if(a&&"function"==typeof a.handleEvent)a=r(a.handleEvent,a);else throw Error("Invalid listener argument");return 2147483647<Number(b)?-1:k.setTimeout(a,b||0)},Be=function(a){var b=null;return(new C(function(c,d){b=Ae(function(){c(void 0)},a);-1==b&&d(Error("Failed to schedule timer."))})).g(function(a){k.clearTimeout(b);throw a;})};var Ce=/^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/,De=function(a,b){if(a){a=a.split("&");for(var c=0;c<a.length;c++){var d=a[c].indexOf("="),e=null;if(0<=d){var f=a[c].substring(0,d);e=a[c].substring(d+1)}else f=a[c];b(f,e?decodeURIComponent(e.replace(/\+/g," ")):"")}}};var I=function(a){G.call(this);this.headers=new ue;this.dd=a||null;this.Ca=!1;this.cd=this.b=null;this.Ub=this.Ke=this.Ec="";this.Qa=this.zd=this.zc=this.od=!1;this.Db=0;this.Vc=null;this.Oc="";this.Zc=this.hg=this.gf=!1};t(I,G);var Ee=I.prototype,Fe=pe("goog.net.XhrIo");Ee.T=Fe;var Ge=/^https?$/i,He=["POST","PUT"];
I.prototype.send=function(a,b,c,d){if(this.b)throw Error("[goog.net.XhrIo] Object is active with another request="+this.Ec+"; newUri="+a);b=b?b.toUpperCase():"GET";this.Ec=a;this.Ub="";this.Ke=b;this.od=!1;this.Ca=!0;this.b=this.dd?this.dd.rc():Nc.rc();this.cd=this.dd?Mc(this.dd):Mc(Nc);this.b.onreadystatechange=r(this.Re,this);this.hg&&"onprogress"in this.b&&(this.b.onprogress=r(function(a){this.Qe(a,!0)},this),this.b.upload&&(this.b.upload.onprogress=r(this.Qe,this)));try{H(this.T,Ie(this,"Opening Xhr")),
this.zd=!0,this.b.open(b,String(a),!0),this.zd=!1}catch(f){H(this.T,Ie(this,"Error opening Xhr: "+f.message));this.ba(5,f);return}a=c||"";var e=this.headers.clone();d&&ze(d,function(a,b){e.set(b,a)});d=Ua(e.va());c=k.FormData&&a instanceof k.FormData;!Va(He,b)||d||c||e.set("Content-Type","application/x-www-form-urlencoded;charset=utf-8");e.forEach(function(a,b){this.b.setRequestHeader(b,a)},this);this.Oc&&(this.b.responseType=this.Oc);"withCredentials"in this.b&&this.b.withCredentials!==this.gf&&
(this.b.withCredentials=this.gf);try{Je(this),0<this.Db&&(this.Zc=Ke(this.b),H(this.T,Ie(this,"Will abort after "+this.Db+"ms if incomplete, xhr2 "+this.Zc)),this.Zc?(this.b.timeout=this.Db,this.b.ontimeout=r(this.ic,this)):this.Vc=Ae(this.ic,this.Db,this)),H(this.T,Ie(this,"Sending request")),this.zc=!0,this.b.send(a),this.zc=!1}catch(f){H(this.T,Ie(this,"Send error: "+f.message)),this.ba(5,f)}};
var Ke=function(a){return z&&A(9)&&"number"==typeof a.timeout&&ba(a.ontimeout)},Ta=function(a){return"content-type"==a.toLowerCase()};I.prototype.ic=function(){"undefined"!=typeof aa&&this.b&&(this.Ub="Timed out after "+this.Db+"ms, aborting",H(this.T,Ie(this,this.Ub)),this.dispatchEvent("timeout"),this.abort(8))};I.prototype.ba=function(a,b){this.Ca=!1;this.b&&(this.Qa=!0,this.b.abort(),this.Qa=!1);this.Ub=b;Le(this);Me(this)};var Le=function(a){a.od||(a.od=!0,a.dispatchEvent("complete"),a.dispatchEvent("error"))};
I.prototype.abort=function(){this.b&&this.Ca&&(H(this.T,Ie(this,"Aborting")),this.Ca=!1,this.Qa=!0,this.b.abort(),this.Qa=!1,this.dispatchEvent("complete"),this.dispatchEvent("abort"),Me(this))};I.prototype.lb=function(){this.b&&(this.Ca&&(this.Ca=!1,this.Qa=!0,this.b.abort(),this.Qa=!1),Me(this,!0));I.Uc.lb.call(this)};I.prototype.Re=function(){this.isDisposed()||(this.zd||this.zc||this.Qa?Ne(this):this.dg())};I.prototype.dg=function(){Ne(this)};
var Ne=function(a){if(a.Ca&&"undefined"!=typeof aa)if(a.cd[1]&&4==Oe(a)&&2==Pe(a))H(a.T,Ie(a,"Local request error detected and ignored"));else if(a.zc&&4==Oe(a))Ae(a.Re,0,a);else if(a.dispatchEvent("readystatechange"),4==Oe(a)){H(a.T,Ie(a,"Request complete"));a.Ca=!1;try{var b=Pe(a);a:switch(b){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:var c=!0;break a;default:c=!1}var d;if(!(d=c)){var e;if(e=0===b){var f=String(a.Ec).match(Ce)[1]||null;if(!f&&k.self&&k.self.location){var g=
k.self.location.protocol;f=g.substr(0,g.length-1)}e=!Ge.test(f?f.toLowerCase():"")}d=e}if(d)a.dispatchEvent("complete"),a.dispatchEvent("success");else{try{var l=2<Oe(a)?a.b.statusText:""}catch(n){H(a.T,"Can not get status: "+n.message),l=""}a.Ub=l+" ["+Pe(a)+"]";Le(a)}}finally{Me(a)}}};I.prototype.Qe=function(a,b){w("progress"===a.type,"goog.net.EventType.PROGRESS is of the same type as raw XHR progress.");this.dispatchEvent(Qe(a,"progress"));this.dispatchEvent(Qe(a,b?"downloadprogress":"uploadprogress"))};
var Qe=function(a,b){return{type:b,lengthComputable:a.lengthComputable,loaded:a.loaded,total:a.total}},Me=function(a,b){if(a.b){Je(a);var c=a.b,d=a.cd[0]?da:null;a.b=null;a.cd=null;b||a.dispatchEvent("ready");try{c.onreadystatechange=d}catch(e){(a=a.T)&&a.log(ie,"Problem encountered resetting onreadystatechange: "+e.message,void 0)}}},Je=function(a){a.b&&a.Zc&&(a.b.ontimeout=null);a.Vc&&(k.clearTimeout(a.Vc),a.Vc=null)},Oe=function(a){return a.b?a.b.readyState:0},Pe=function(a){try{return 2<Oe(a)?
a.b.status:-1}catch(b){return-1}},Re=function(a){try{return a.b?a.b.responseText:""}catch(b){return H(a.T,"Can not get responseText: "+b.message),""}};
I.prototype.getResponse=function(){try{if(!this.b)return null;if("response"in this.b)return this.b.response;switch(this.Oc){case "":case "text":return this.b.responseText;case "arraybuffer":if("mozResponseArrayBuffer"in this.b)return this.b.mozResponseArrayBuffer}var a=this.T;a&&a.log(ie,"Response type "+this.Oc+" is not supported on this browser",void 0);return null}catch(b){return H(this.T,"Can not get response: "+b.message),null}};
I.prototype.getResponseHeader=function(a){if(this.b&&4==Oe(this))return a=this.b.getResponseHeader(a),null===a?void 0:a};I.prototype.getAllResponseHeaders=function(){return this.b&&4==Oe(this)?this.b.getAllResponseHeaders():""};var Ie=function(a,b){return b+" ["+a.Ke+" "+a.Ec+" "+Pe(a)+"]"};var Se=function(a,b){this.pa=this.eb=this.qa="";this.vb=null;this.Pa=this.Ga="";this.da=this.Xf=!1;if(a instanceof Se){this.da=ba(b)?b:a.da;Te(this,a.qa);var c=a.eb;J(this);this.eb=c;Ue(this,a.pa);Ve(this,a.vb);We(this,a.Ga);Xe(this,a.ea.clone());a=a.Pa;J(this);this.Pa=a}else a&&(c=String(a).match(Ce))?(this.da=!!b,Te(this,c[1]||"",!0),a=c[2]||"",J(this),this.eb=Ye(a),Ue(this,c[3]||"",!0),Ve(this,c[4]),We(this,c[5]||"",!0),Xe(this,c[6]||"",!0),a=c[7]||"",J(this),this.Pa=Ye(a)):(this.da=!!b,this.ea=
new Ze(null,0,this.da))};Se.prototype.toString=function(){var a=[],b=this.qa;b&&a.push($e(b,af,!0),":");var c=this.pa;if(c||"file"==b)a.push("//"),(b=this.eb)&&a.push($e(b,af,!0),"@"),a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g,"%$1")),c=this.vb,null!=c&&a.push(":",String(c));if(c=this.Ga)this.pa&&"/"!=c.charAt(0)&&a.push("/"),a.push($e(c,"/"==c.charAt(0)?bf:cf,!0));(c=this.ea.toString())&&a.push("?",c);(c=this.Pa)&&a.push("#",$e(c,df));return a.join("")};
Se.prototype.resolve=function(a){var b=this.clone(),c=!!a.qa;c?Te(b,a.qa):c=!!a.eb;if(c){var d=a.eb;J(b);b.eb=d}else c=!!a.pa;c?Ue(b,a.pa):c=null!=a.vb;d=a.Ga;if(c)Ve(b,a.vb);else if(c=!!a.Ga){if("/"!=d.charAt(0))if(this.pa&&!this.Ga)d="/"+d;else{var e=b.Ga.lastIndexOf("/");-1!=e&&(d=b.Ga.substr(0,e+1)+d)}e=d;if(".."==e||"."==e)d="";else if(v(e,"./")||v(e,"/.")){d=0==e.lastIndexOf("/",0);e=e.split("/");for(var f=[],g=0;g<e.length;){var l=e[g++];"."==l?d&&g==e.length&&f.push(""):".."==l?((1<f.length||
1==f.length&&""!=f[0])&&f.pop(),d&&g==e.length&&f.push("")):(f.push(l),d=!0)}d=f.join("/")}else d=e}c?We(b,d):c=""!==a.ea.toString();c?Xe(b,a.ea.clone()):c=!!a.Pa;c&&(a=a.Pa,J(b),b.Pa=a);return b};Se.prototype.clone=function(){return new Se(this)};
var Te=function(a,b,c){J(a);a.qa=c?Ye(b,!0):b;a.qa&&(a.qa=a.qa.replace(/:$/,""))},Ue=function(a,b,c){J(a);a.pa=c?Ye(b,!0):b},Ve=function(a,b){J(a);if(b){b=Number(b);if(isNaN(b)||0>b)throw Error("Bad port number "+b);a.vb=b}else a.vb=null},We=function(a,b,c){J(a);a.Ga=c?Ye(b,!0):b},Xe=function(a,b,c){J(a);b instanceof Ze?(a.ea=b,a.ea.$d(a.da)):(c||(b=$e(b,ef)),a.ea=new Ze(b,0,a.da))},K=function(a,b,c){J(a);a.ea.set(b,c)},ff=function(a,b){return a.ea.get(b)};
Se.prototype.removeParameter=function(a){J(this);this.ea.remove(a);return this};var J=function(a){if(a.Xf)throw Error("Tried to modify a read-only Uri");};Se.prototype.$d=function(a){this.da=a;this.ea&&this.ea.$d(a);return this};
var gf=function(a){return a instanceof Se?a.clone():new Se(a,void 0)},hf=function(a,b){var c=new Se(null,void 0);Te(c,"https");a&&Ue(c,a);b&&We(c,b);return c},Ye=function(a,b){return a?b?decodeURI(a.replace(/%25/g,"%2525")):decodeURIComponent(a):""},$e=function(a,b,c){return m(a)?(a=encodeURI(a).replace(b,jf),c&&(a=a.replace(/%25([0-9a-fA-F]{2})/g,"%$1")),a):null},jf=function(a){a=a.charCodeAt(0);return"%"+(a>>4&15).toString(16)+(a&15).toString(16)},af=/[#\/\?@]/g,cf=/[#\?:]/g,bf=/[#\?]/g,ef=/[#\?@]/g,
df=/#/g,Ze=function(a,b,c){this.u=this.s=null;this.X=a||null;this.da=!!c},kf=function(a){a.s||(a.s=new ue,a.u=0,a.X&&De(a.X,function(b,c){a.add(decodeURIComponent(b.replace(/\+/g," ")),c)}))},mf=function(a){var b=ye(a);if("undefined"==typeof b)throw Error("Keys are undefined");var c=new Ze(null,0,void 0);a=xe(a);for(var d=0;d<b.length;d++){var e=b[d],f=a[d];ha(f)?lf(c,e,f):c.add(e,f)}return c};h=Ze.prototype;
h.add=function(a,b){kf(this);this.X=null;a=this.ca(a);var c=this.s.get(a);c||this.s.set(a,c=[]);c.push(b);this.u=Ba(this.u)+1;return this};h.remove=function(a){kf(this);a=this.ca(a);return this.s.Jb(a)?(this.X=null,this.u=Ba(this.u)-this.s.get(a).length,this.s.remove(a)):!1};h.clear=function(){this.s=this.X=null;this.u=0};h.Jb=function(a){kf(this);a=this.ca(a);return this.s.Jb(a)};h.forEach=function(a,b){kf(this);this.s.forEach(function(c,d){x(c,function(c){a.call(b,c,d,this)},this)},this)};
h.va=function(){kf(this);for(var a=this.s.ha(),b=this.s.va(),c=[],d=0;d<b.length;d++)for(var e=a[d],f=0;f<e.length;f++)c.push(b[d]);return c};h.ha=function(a){kf(this);var b=[];if(m(a))this.Jb(a)&&(b=Za(b,this.s.get(this.ca(a))));else{a=this.s.ha();for(var c=0;c<a.length;c++)b=Za(b,a[c])}return b};h.set=function(a,b){kf(this);this.X=null;a=this.ca(a);this.Jb(a)&&(this.u=Ba(this.u)-this.s.get(a).length);this.s.set(a,[b]);this.u=Ba(this.u)+1;return this};
h.get=function(a,b){a=a?this.ha(a):[];return 0<a.length?String(a[0]):b};var lf=function(a,b,c){a.remove(b);0<c.length&&(a.X=null,a.s.set(a.ca(b),$a(c)),a.u=Ba(a.u)+c.length)};h=Ze.prototype;h.toString=function(){if(this.X)return this.X;if(!this.s)return"";for(var a=[],b=this.s.va(),c=0;c<b.length;c++){var d=b[c],e=encodeURIComponent(String(d));d=this.ha(d);for(var f=0;f<d.length;f++){var g=e;""!==d[f]&&(g+="="+encodeURIComponent(String(d[f])));a.push(g)}}return this.X=a.join("&")};
h.clone=function(){var a=new Ze;a.X=this.X;this.s&&(a.s=this.s.clone(),a.u=this.u);return a};h.ca=function(a){a=String(a);this.da&&(a=a.toLowerCase());return a};h.$d=function(a){a&&!this.da&&(kf(this),this.X=null,this.s.forEach(function(a,c){var b=c.toLowerCase();c!=b&&(this.remove(c),lf(this,b,a))},this));this.da=a};h.extend=function(a){for(var b=0;b<arguments.length;b++)ze(arguments[b],function(a,b){this.add(b,a)},this)};var nf={Kg:{qd:"https://www.googleapis.com/identitytoolkit/v3/relyingparty/",Wd:"https://securetoken.googleapis.com/v1/token",id:"p"},Lg:{qd:"https://staging-www.sandbox.googleapis.com/identitytoolkit/v3/relyingparty/",Wd:"https://staging-securetoken.sandbox.googleapis.com/v1/token",id:"s"},Mg:{qd:"https://www-googleapis-test.sandbox.google.com/identitytoolkit/v3/relyingparty/",Wd:"https://test-securetoken.sandbox.googleapis.com/v1/token",id:"t"}},of=function(a){for(var b in nf)if(nf[b].id===a)return a=
nf[b],{firebaseEndpoint:a.qd,secureTokenEndpoint:a.Wd};return null},pf;pf=of("__EID__")?"__EID__":void 0;var qf=function(){var a=L();return z&&!!Cb&&11==Cb||/Edge\/\d+/.test(a)},rf=function(){return k.window&&k.window.location.href||""},sf=function(a,b){b=b||k.window;var c="about:blank";a&&(c=Bc(Ec(a)));b.location.href=c},tf=function(a,b){var c=[],d;for(d in a)d in b?typeof a[d]!=typeof b[d]?c.push(d):ha(a[d])?jb(a[d],b[d])||c.push(d):"object"==typeof a[d]&&null!=a[d]&&null!=b[d]?0<tf(a[d],b[d]).length&&c.push(d):a[d]!==b[d]&&c.push(d):c.push(d);for(d in b)d in a||c.push(d);return c},vf=function(){var a=
L();a="Chrome"!=uf(a)?null:(a=a.match(/\sChrome\/(\d+)/i))&&2==a.length?parseInt(a[1],10):null;return a&&30>a?!1:!z||!Cb||9<Cb},wf=function(a){a=(a||L()).toLowerCase();return a.match(/android/)||a.match(/webos/)||a.match(/iphone|ipad|ipod/)||a.match(/blackberry/)||a.match(/windows phone/)||a.match(/iemobile/)?!0:!1},xf=function(a){a=a||k.window;try{a.close()}catch(b){}},yf=function(a,b,c){var d=Math.floor(1E9*Math.random()).toString();b=b||500;c=c||600;var e=(window.screen.availHeight-c)/2,f=(window.screen.availWidth-
b)/2;b={width:b,height:c,top:0<e?e:0,left:0<f?f:0,location:!0,resizable:!0,statusbar:!0,toolbar:!1};c=L().toLowerCase();d&&(b.target=d,v(c,"crios/")&&(b.target="_blank"));"Firefox"==uf(L())&&(a=a||"http://localhost",b.scrollbars=!0);c=a||"";(a=b)||(a={});d=window;b=c instanceof Ac?c:Ec("undefined"!=typeof c.href?c.href:String(c));c=a.target||c.target;e=[];for(g in a)switch(g){case "width":case "height":case "top":case "left":e.push(g+"="+a[g]);break;case "target":case "noopener":case "noreferrer":break;
default:e.push(g+"="+(a[g]?1:0))}var g=e.join(",");(y("iPhone")&&!y("iPod")&&!y("iPad")||y("iPad")||y("iPod"))&&d.navigator&&d.navigator.standalone&&c&&"_self"!=c?(g=d.document.createElement("A"),fd(g,"HTMLAnchorElement"),b instanceof Ac||b instanceof Ac||(b=b.qb?b.ob():String(b),w(Cc.test(b))||(b="about:invalid#zClosurez"),b=Dc(b)),g.href=Bc(b),g.setAttribute("target",c),a.noreferrer&&g.setAttribute("rel","noreferrer"),a=document.createEvent("MouseEvent"),a.initMouseEvent("click",!0,!0,d,1),g.dispatchEvent(a),
g={}):a.noreferrer?(g=d.open("",c,g),d=Bc(b),g&&(sb&&v(d,";")&&(d="'"+d.replace(/'/g,"%27")+"'"),g.opener=null,a=Ha("b/12014412, meta tag with sanitized URL"),d='<META HTTP-EQUIV="refresh" content="0; url='+wa(d)+'">',Ca(Ga(a),"must provide justification"),w(!/^[\s\xa0]*$/.test(Ga(a)),"must provide non-empty justification"),g.document.write(jd((new id).Tf(d))),g.document.close())):(g=d.open(Bc(b),c,g))&&a.noopener&&(g.opener=null);if(g)try{g.focus()}catch(l){}return g},zf=function(a){return new C(function(b){var c=
function(){Be(2E3).then(function(){if(!a||a.closed)b();else return c()})};return c()})},Af=/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,Bf=function(){var a=null;return(new C(function(b){"complete"==k.document.readyState?b():(a=function(){b()},kc(window,"load",a))})).g(function(b){tc(window,"load",a);throw b;})},Df=function(){return Cf(void 0)?Bf().then(function(){return new C(function(a,b){var c=k.document,d=setTimeout(function(){b(Error("Cordova framework is not ready."))},1E3);c.addEventListener("deviceready",
function(){clearTimeout(d);a()},!1)})}):E(Error("Cordova must run in an Android or iOS file scheme."))},Cf=function(a){a=a||L();return!("file:"!==Ef()||!a.toLowerCase().match(/iphone|ipad|ipod|android/))},Ff=function(){var a=k.window;try{return!(!a||a==a.top)}catch(b){return!1}},Gf=function(){return firebase.INTERNAL.hasOwnProperty("reactNative")?"ReactNative":firebase.INTERNAL.hasOwnProperty("node")?"Node":"Browser"},Hf=function(){var a=Gf();return"ReactNative"===a||"Node"===a},uf=function(a){var b=
a.toLowerCase();if(v(b,"opera/")||v(b,"opr/")||v(b,"opios/"))return"Opera";if(v(b,"iemobile"))return"IEMobile";if(v(b,"msie")||v(b,"trident/"))return"IE";if(v(b,"edge/"))return"Edge";if(v(b,"firefox/"))return"Firefox";if(v(b,"silk/"))return"Silk";if(v(b,"blackberry"))return"Blackberry";if(v(b,"webos"))return"Webos";if(!v(b,"safari/")||v(b,"chrome/")||v(b,"crios/")||v(b,"android"))if(!v(b,"chrome/")&&!v(b,"crios/")||v(b,"edge/")){if(v(b,"android"))return"Android";if((a=a.match(/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/))&&
2==a.length)return a[1]}else return"Chrome";else return"Safari";return"Other"},If={Fg:"FirebaseCore-web",Hg:"FirebaseUI-web"},Jf=function(a,b){b=b||[];var c=[],d={},e;for(e in If)d[If[e]]=!0;for(e=0;e<b.length;e++)"undefined"!==typeof d[b[e]]&&(delete d[b[e]],c.push(b[e]));c.sort();b=c;b.length||(b=["FirebaseCore-web"]);c=Gf();return("Browser"===c?uf(L()):c)+"/JsCore/"+a+"/"+b.join(",")},L=function(){return k.navigator&&k.navigator.userAgent||""},M=function(a,b){a=a.split(".");b=b||k;for(var c=0;c<
a.length&&"object"==typeof b&&null!=b;c++)b=b[a[c]];c!=a.length&&(b=void 0);return b},Lf=function(){try{var a=k.localStorage,b=Kf();if(a)return a.setItem(b,"1"),a.removeItem(b),qf()?!!k.indexedDB:!0}catch(c){}return!1},Nf=function(){return(Mf()||"chrome-extension:"===Ef()||Cf())&&!Hf()&&Lf()},Mf=function(){return"http:"===Ef()||"https:"===Ef()},Ef=function(){return k.location&&k.location.protocol||null},Of=function(a){a=a||L();return wf(a)||"Firefox"==uf(a)?!1:!0},Pf=function(a){return"undefined"===
typeof a?null:Hc(a)},Qf=function(a){var b={},c;for(c in a)a.hasOwnProperty(c)&&null!==a[c]&&void 0!==a[c]&&(b[c]=a[c]);return b},Rf=function(a){if(null!==a)return JSON.parse(a)},Kf=function(a){return a?a:""+Math.floor(1E9*Math.random()).toString()},Sf=function(a){a=a||L();return"Safari"==uf(a)||a.toLowerCase().match(/iphone|ipad|ipod/)?!1:!0},Tf=function(){var a=k.___jsl;if(a&&a.H)for(var b in a.H)if(a.H[b].r=a.H[b].r||[],a.H[b].L=a.H[b].L||[],a.H[b].r=a.H[b].L.concat(),a.CP)for(var c=0;c<a.CP.length;c++)a.CP[c]=
null},Uf=function(){var a=k.navigator;return a&&"boolean"===typeof a.onLine&&(Mf()||"chrome-extension:"===Ef()||"undefined"!==typeof a.connection)?a.onLine:!0},Vf=function(a,b,c,d){if(a>b)throw Error("Short delay should be less than long delay!");this.ug=a;this.ag=b;a=c||L();d=d||Gf();this.Wf=wf(a)||"ReactNative"===d};Vf.prototype.get=function(){return this.Wf?this.ag:this.ug};
var Wf=function(){var a=k.document;return a&&"undefined"!==typeof a.visibilityState?"visible"==a.visibilityState:!0},Xf=function(){var a=k.document,b=null;return Wf()||!a?D():(new C(function(c){b=function(){Wf()&&(a.removeEventListener("visibilitychange",b,!1),c())};a.addEventListener("visibilitychange",b,!1)})).g(function(c){a.removeEventListener("visibilitychange",b,!1);throw c;})},Yf=function(a){try{var b=new Date(parseInt(a,10));if(!isNaN(b.getTime())&&!/[^0-9]/.test(a))return b.toUTCString()}catch(c){}return null};var Zf={};var $f;try{var ag={};Object.defineProperty(ag,"abcd",{configurable:!0,enumerable:!0,value:1});Object.defineProperty(ag,"abcd",{configurable:!0,enumerable:!0,value:2});$f=2==ag.abcd}catch(a){$f=!1}
var N=function(a,b,c){$f?Object.defineProperty(a,b,{configurable:!0,enumerable:!0,value:c}):a[b]=c},bg=function(a,b){if(b)for(var c in b)b.hasOwnProperty(c)&&N(a,c,b[c])},cg=function(a){var b={};bg(b,a);return b},dg=function(a){var b={},c;for(c in a)a.hasOwnProperty(c)&&(b[c]=a[c]);return b},eg=function(a,b){if(!b||!b.length)return!0;if(!a)return!1;for(var c=0;c<b.length;c++){var d=a[b[c]];if(void 0===d||null===d||""===d)return!1}return!0},fg=function(a){var b=a;if("object"==typeof a&&null!=a){b=
"length"in a?[]:{};for(var c in a)N(b,c,fg(a[c]))}return b};var gg="oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_timestamp oauth_token oauth_version".split(" "),hg=["client_id","response_type","scope","redirect_uri","state"],ig={Gg:{Dc:"locale",Zb:500,Yb:600,providerId:"facebook.com",Ud:hg},Ig:{Dc:null,Zb:500,Yb:620,providerId:"github.com",Ud:hg},Jg:{Dc:"hl",Zb:515,Yb:680,providerId:"google.com",Ud:hg},Ng:{Dc:"lang",Zb:485,Yb:705,providerId:"twitter.com",Ud:gg}},jg=function(a){for(var b in ig)if(ig[b].providerId==a)return ig[b];
return null};var O=function(a,b){this.code="auth/"+a;this.message=b||kg[a]||""};t(O,Error);O.prototype.A=function(){return{code:this.code,message:this.message}};O.prototype.toJSON=function(){return this.A()};
var lg=function(a){var b=a&&a.code;return b?new O(b.substring(5),a.message):null},kg={"argument-error":"","app-not-authorized":"This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.","app-not-installed":"The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.","captcha-check-failed":"The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.",
"code-expired":"The SMS code has expired. Please re-send the verification code to try again.","cordova-not-ready":"Cordova framework is not ready.","cors-unsupported":"This browser is not supported.","credential-already-in-use":"This credential is already associated with a different user account.","custom-token-mismatch":"The custom token corresponds to a different audience.","requires-recent-login":"This operation is sensitive and requires recent authentication. Log in again before retrying this request.",
"dynamic-link-not-activated":"Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.","email-already-in-use":"The email address is already in use by another account.","expired-action-code":"The action code has expired. ","cancelled-popup-request":"This operation has been cancelled due to another conflicting popup being opened.","internal-error":"An internal error has occurred.","invalid-app-credential":"The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.",
"invalid-app-id":"The mobile app identifier is not registed for the current project.","invalid-user-token":"The user's credential is no longer valid. The user must sign in again.","invalid-auth-event":"An internal error has occurred.","invalid-verification-code":"The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure use the verification code provided by the user.","invalid-continue-uri":"The continue URL provided in the request is invalid.",
"invalid-cordova-configuration":"The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.","invalid-custom-token":"The custom token format is incorrect. Please check the documentation.","invalid-email":"The email address is badly formatted.","invalid-api-key":"Your API key is invalid, please check you have copied it correctly.","invalid-credential":"The supplied auth credential is malformed or has expired.",
"invalid-persistence-type":"The specified persistence type is invalid. It can only be local, session or none.","invalid-message-payload":"The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the Firebase Console.","invalid-oauth-provider":"EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.","invalid-oauth-client-id":"The OAuth client ID provided is either invalid or does not match the specified API key.",
"unauthorized-domain":"This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.","invalid-action-code":"The action code is invalid. This can happen if the code is malformed, expired, or has already been used.","wrong-password":"The password is invalid or the user does not have a password.","invalid-phone-number":"The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].",
"invalid-recipient-email":"The email corresponding to this action failed to send as the provided recipient email address is invalid.","invalid-sender":"The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the Firebase Console.","invalid-verification-id":"The verification ID used to create the phone auth credential is invalid.","missing-android-pkg-name":"An Android Package Name must be provided if the Android App is required to be installed.",
"auth-domain-config-required":"Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.","missing-app-credential":"The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.","missing-verification-code":"The phone auth credential was created with an empty SMS verification code.","missing-continue-uri":"A continue URL must be provided in the request.","missing-iframe-start":"An internal error has occurred.",
"missing-ios-bundle-id":"An iOS Bundle ID must be provided if an App Store ID is provided.","missing-phone-number":"To send verification codes, provide a phone number for the recipient.","missing-verification-id":"The phone auth credential was created with an empty verification ID.","app-deleted":"This instance of FirebaseApp has been deleted.","account-exists-with-different-credential":"An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.",
"network-request-failed":"A network error (such as timeout, interrupted connection or unreachable host) has occurred.","no-auth-event":"An internal error has occurred.","no-such-provider":"User was not linked to an account with the given provider.","operation-not-allowed":"The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.","operation-not-supported-in-this-environment":'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.',
"popup-blocked":"Unable to establish a connection with the popup. It may have been blocked by the browser.","popup-closed-by-user":"The popup has been closed by the user before finalizing the operation.","provider-already-linked":"User can only be linked to one identity for the given provider.","quota-exceeded":"The project's quota for this operation has been exceeded.","redirect-cancelled-by-user":"The redirect operation has been cancelled by the user before finalizing.","redirect-operation-pending":"A redirect sign-in operation is already pending.",
timeout:"The operation has timed out.","user-token-expired":"The user's credential is no longer valid. The user must sign in again.","too-many-requests":"We have blocked all requests from this device due to unusual activity. Try again later.","unauthorized-continue-uri":"The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Firebase console.","unsupported-persistence-type":"The current environment does not support the specified persistence type.","user-cancelled":"User did not grant your application the permissions it requested.",
"user-not-found":"There is no user record corresponding to this identifier. The user may have been deleted.","user-disabled":"The user account has been disabled by an administrator.","user-mismatch":"The supplied credentials do not correspond to the previously signed in user.","user-signed-out":"","weak-password":"The password must be 6 characters long or more.","web-storage-unsupported":"This browser is not supported or 3rd party cookies and data may be disabled."};var mg=function(a,b,c,d,e){this.ma=a;this.Y=b||null;this.Eb=c||null;this.Yd=d||null;this.ba=e||null;if(this.Eb||this.ba){if(this.Eb&&this.ba)throw new O("invalid-auth-event");if(this.Eb&&!this.Yd)throw new O("invalid-auth-event");}else throw new O("invalid-auth-event");};mg.prototype.tc=function(){return this.Yd};mg.prototype.getError=function(){return this.ba};mg.prototype.A=function(){return{type:this.ma,eventId:this.Y,urlResponse:this.Eb,sessionId:this.Yd,error:this.ba&&this.ba.A()}};
var ng=function(a){a=a||{};return a.type?new mg(a.type,a.eventId,a.urlResponse,a.sessionId,a.error&&lg(a.error)):null};var og=function(a){var b="unauthorized-domain",c=void 0,d=gf(a);a=d.pa;d=d.qa;"chrome-extension"==d?c=na("This chrome extension ID (chrome-extension://%s) is not authorized to run this operation. Add it to the OAuth redirect domains list in the Firebase console -> Auth section -> Sign in method tab.",a):"http"==d||"https"==d?c=na("This domain (%s) is not authorized to run this operation. Add it to the OAuth redirect domains list in the Firebase console -> Auth section -> Sign in method tab.",a):b=
"operation-not-supported-in-this-environment";O.call(this,b,c)};t(og,O);var pg=function(a){this.Zf=a.sub;ma();this.Mb=a.email||null;this.Rd=a.provider_id||a.firebase&&a.firebase.sign_in_provider||null;this.qf=!!a.is_anonymous||"anonymous"==this.Rd};pg.prototype.getEmail=function(){return this.Mb};pg.prototype.isAnonymous=function(){return this.qf};var qg=function(a){a=a.split(".");if(3!=a.length)return null;a=a[1];for(var b=(4-a.length%4)%4,c=0;c<b;c++)a+=".";try{var d=JSON.parse(Hb(a));if(d.sub&&d.iss&&d.aud&&d.exp)return new pg(d)}catch(e){}return null};var rg=function(a,b){return a.then(function(a){if(a.idToken){var c=qg(a.idToken);if(!c||b!=c.Zf)throw new O("user-mismatch");return a}throw new O("user-mismatch");}).g(function(a){throw a&&a.code&&"auth/user-not-found"==a.code?new O("user-mismatch"):a;})},sg=function(a,b){if(b.idToken||b.accessToken)b.idToken&&N(this,"idToken",b.idToken),b.accessToken&&N(this,"accessToken",b.accessToken);else if(b.oauthToken&&b.oauthTokenSecret)N(this,"accessToken",b.oauthToken),N(this,"secret",b.oauthTokenSecret);
else throw new O("internal-error","failed to construct a credential");N(this,"providerId",a)};sg.prototype.Ob=function(a){return tg(a,ug(this))};sg.prototype.Fc=function(a,b){var c=ug(this);c.idToken=b;return vg(a,c)};sg.prototype.Gd=function(a,b){var c=ug(this);return rg(wg(a,c),b)};var ug=function(a){var b={};a.idToken&&(b.id_token=a.idToken);a.accessToken&&(b.access_token=a.accessToken);a.secret&&(b.oauth_token_secret=a.secret);b.providerId=a.providerId;return{postBody:mf(b).toString(),requestUri:"http://localhost"}};
sg.prototype.A=function(){var a={providerId:this.providerId};this.idToken&&(a.oauthIdToken=this.idToken);this.accessToken&&(a.oauthAccessToken=this.accessToken);this.secret&&(a.oauthTokenSecret=this.secret);return a};var xg=function(a,b){this.kg=b||[];bg(this,{providerId:a,isOAuthProvider:!0});this.qe={};this.Ed=(jg(a)||{}).Dc||null;this.nd=null};xg.prototype.setCustomParameters=function(a){this.qe=kb(a);return this};var P=function(a){xg.call(this,a,hg);this.Vd=[]};t(P,xg);
P.prototype.addScope=function(a){Va(this.Vd,a)||this.Vd.push(a);return this};P.prototype.ye=function(){return $a(this.Vd)};P.prototype.credential=function(a,b){if(!a&&!b)throw new O("argument-error","credential failed: must provide the ID token and/or the access token.");return new sg(this.providerId,{idToken:a||null,accessToken:b||null})};var yg=function(){P.call(this,"facebook.com")};t(yg,P);N(yg,"PROVIDER_ID","facebook.com");
var zg=function(a){if(!a)throw new O("argument-error","credential failed: expected 1 argument (the OAuth access token).");var b=a;q(a)&&(b=a.accessToken);return(new yg).credential(null,b)},Ag=function(){P.call(this,"github.com")};t(Ag,P);N(Ag,"PROVIDER_ID","github.com");var Bg=function(a){if(!a)throw new O("argument-error","credential failed: expected 1 argument (the OAuth access token).");var b=a;q(a)&&(b=a.accessToken);return(new Ag).credential(null,b)},Cg=function(){P.call(this,"google.com");this.addScope("profile")};
t(Cg,P);N(Cg,"PROVIDER_ID","google.com");var Dg=function(a,b){var c=a;q(a)&&(c=a.idToken,b=a.accessToken);return(new Cg).credential(c,b)},Eg=function(){xg.call(this,"twitter.com",gg)};t(Eg,xg);N(Eg,"PROVIDER_ID","twitter.com");
var Fg=function(a,b){var c=a;q(c)||(c={oauthToken:a,oauthTokenSecret:b});if(!c.oauthToken||!c.oauthTokenSecret)throw new O("argument-error","credential failed: expected 2 arguments (the OAuth access token and secret).");return new sg("twitter.com",c)},Gg=function(a,b){this.Mb=a;this.Ld=b;N(this,"providerId","password")};Gg.prototype.Ob=function(a){return Q(a,Hg,{email:this.Mb,password:this.Ld})};Gg.prototype.Fc=function(a,b){return Q(a,Ig,{idToken:b,email:this.Mb,password:this.Ld})};
Gg.prototype.Gd=function(a,b){return rg(this.Ob(a),b)};Gg.prototype.A=function(){return{email:this.Mb,password:this.Ld}};var Jg=function(){bg(this,{providerId:"password",isOAuthProvider:!1})};bg(Jg,{PROVIDER_ID:"password"});var Kg=function(a){if(!(a.verificationId&&a.$c||a.hc&&a.phoneNumber))throw new O("internal-error");this.U=a;N(this,"providerId","phone")};Kg.prototype.Ob=function(a){return a.verifyPhoneNumber(Lg(this))};Kg.prototype.Fc=function(a,b){var c=Lg(this);c.idToken=b;return Q(a,Mg,c)};
Kg.prototype.Gd=function(a,b){var c=Lg(this);c.operation="REAUTH";a=Q(a,Ng,c);return rg(a,b)};Kg.prototype.A=function(){var a={providerId:"phone"};this.U.verificationId&&(a.verificationId=this.U.verificationId);this.U.$c&&(a.verificationCode=this.U.$c);this.U.hc&&(a.temporaryProof=this.U.hc);this.U.phoneNumber&&(a.phoneNumber=this.U.phoneNumber);return a};
var Lg=function(a){return a.U.hc&&a.U.phoneNumber?{temporaryProof:a.U.hc,phoneNumber:a.U.phoneNumber}:{sessionInfo:a.U.verificationId,code:a.U.$c}},Og=function(a){try{this.tf=a||firebase.auth()}catch(b){throw new O("argument-error","Either an instance of firebase.auth.Auth must be passed as an argument to the firebase.auth.PhoneAuthProvider constructor, or the default firebase App instance must be initialized via firebase.initializeApp().");}bg(this,{providerId:"phone",isOAuthProvider:!1})};
Og.prototype.verifyPhoneNumber=function(a,b){var c=this.tf.f;return D(b.verify()).then(function(d){if(!m(d))throw new O("argument-error","An implementation of firebase.auth.ApplicationVerifier.prototype.verify() must return a firebase.Promise that resolves with a string.");switch(b.type){case "recaptcha":return Q(c,Pg,{phoneNumber:a,recaptchaToken:d});default:throw new O("argument-error",'Only firebase.auth.ApplicationVerifiers with type="recaptcha" are currently supported.');}})};
var Qg=function(a,b){if(!a)throw new O("missing-verification-id");if(!b)throw new O("missing-verification-code");return new Kg({verificationId:a,$c:b})};bg(Og,{PROVIDER_ID:"phone"});
var Rg=function(a){if(a.temporaryProof&&a.phoneNumber)return new Kg({hc:a.temporaryProof,phoneNumber:a.phoneNumber});var b=a&&a.providerId;if(!b||"password"===b)return null;var c=a&&a.oauthAccessToken,d=a&&a.oauthTokenSecret;a=a&&a.oauthIdToken;try{switch(b){case "google.com":return Dg(a,c);case "facebook.com":return zg(c);case "github.com":return Bg(c);case "twitter.com":return Fg(c,d);default:return(new P(b)).credential(a,c)}}catch(e){return null}},Sg=function(a){if(!a.isOAuthProvider)throw new O("invalid-oauth-provider");
};var Tg=function(a,b,c){O.call(this,a,c);a=b||{};a.email&&N(this,"email",a.email);a.phoneNumber&&N(this,"phoneNumber",a.phoneNumber);a.credential&&N(this,"credential",a.credential)};t(Tg,O);Tg.prototype.A=function(){var a={code:this.code,message:this.message};this.email&&(a.email=this.email);this.phoneNumber&&(a.phoneNumber=this.phoneNumber);var b=this.credential&&this.credential.A();b&&mb(a,b);return a};Tg.prototype.toJSON=function(){return this.A()};
var Ug=function(a){if(a.code){var b=a.code||"";0==b.indexOf("auth/")&&(b=b.substring(5));var c={credential:Rg(a)};if(a.email)c.email=a.email;else if(a.phoneNumber)c.phoneNumber=a.phoneNumber;else return new O(b,a.message||void 0);return new Tg(b,c,a.message)}return null};var Vg=function(a){this.Eg=a};t(Vg,Lc);Vg.prototype.rc=function(){return new this.Eg};Vg.prototype.Cd=function(){return{}};
var R=function(a,b,c){var d="Node"==Gf();d=k.XMLHttpRequest||d&&firebase.INTERNAL.node&&firebase.INTERNAL.node.XMLHttpRequest;if(!d)throw new O("internal-error","The XMLHttpRequest compatibility library was not found.");this.m=a;a=b||{};this.qg=a.secureTokenEndpoint||"https://securetoken.googleapis.com/v1/token";this.rg=a.secureTokenTimeout||Wg;this.Pc=kb(a.secureTokenHeaders||Xg);this.Df=a.firebaseEndpoint||"https://www.googleapis.com/identitytoolkit/v3/relyingparty/";this.Ef=a.firebaseTimeout||
Yg;this.mb=kb(a.firebaseHeaders||Zg);c&&(this.mb["X-Client-Version"]=c,this.Pc["X-Client-Version"]=c);this.vf=new Qc;this.Dg=new Vg(d)},$g,Wg=new Vf(3E4,6E4),Xg={"Content-Type":"application/x-www-form-urlencoded"},Yg=new Vf(3E4,6E4),Zg={"Content-Type":"application/json"},ah=function(a,b){b?a.mb["X-Firebase-Locale"]=b:delete a.mb["X-Firebase-Locale"]},bh=function(a,b){b?(a.mb["X-Client-Version"]=b,a.Pc["X-Client-Version"]=b):(delete a.mb["X-Client-Version"],delete a.Pc["X-Client-Version"])},dh=function(a,
b,c,d,e,f,g){Uf()?(vf()?a=r(a.tg,a):($g||($g=new C(function(a,b){ch(a,b)})),a=r(a.sg,a)),a(b,c,d,e,f,g)):c&&c(null)};
R.prototype.tg=function(a,b,c,d,e,f){var g="Node"==Gf(),l=Hf()?g?new I(this.Dg):new I:new I(this.vf);if(f){l.Db=Math.max(0,f);var n=setTimeout(function(){l.dispatchEvent("timeout")},f)}l.listen("complete",function(){n&&clearTimeout(n);var a=null;try{a=JSON.parse(Re(this))||null}catch(zb){a=null}b&&b(a)});sc(l,"ready",function(){n&&clearTimeout(n);this.Ma||(this.Ma=!0,this.lb())});sc(l,"timeout",function(){n&&clearTimeout(n);this.Ma||(this.Ma=!0,this.lb());b&&b(null)});l.send(a,c,d,e)};
var eh=Ha("https://apis.google.com/js/client.js?onload=%{onload}"),fh="__fcb"+Math.floor(1E6*Math.random()).toString(),ch=function(a,b){if(((window.gapi||{}).client||{}).request)a();else{k[fh]=function(){((window.gapi||{}).client||{}).request?a():b(Error("CORS_UNSUPPORTED"))};var c=Oa(eh,{onload:fh});Wd(de(c),function(){b(Error("CORS_UNSUPPORTED"))})}};
R.prototype.sg=function(a,b,c,d,e){var f=this;$g.then(function(){window.gapi.client.setApiKey(f.m);var g=window.gapi.auth.getToken();window.gapi.auth.setToken(null);window.gapi.client.request({path:a,method:c,body:d,headers:e,authType:"none",callback:function(a){window.gapi.auth.setToken(g);b&&b(a)}})}).g(function(a){b&&b({error:{message:a&&a.message||"CORS_UNSUPPORTED"}})})};
var hh=function(a,b){return new C(function(c,d){"refresh_token"==b.grant_type&&b.refresh_token||"authorization_code"==b.grant_type&&b.code?dh(a,a.qg+"?key="+encodeURIComponent(a.m),function(a){a?a.error?d(gh(a)):a.access_token&&a.refresh_token?c(a):d(new O("internal-error")):d(new O("network-request-failed"))},"POST",mf(b).toString(),a.Pc,a.rg.get()):d(new O("internal-error"))})},ih=function(a,b,c,d,e,f){var g=gf(a.Df+b);K(g,"key",a.m);f&&K(g,"cb",ma().toString());var l="GET"==c;if(l)for(var n in d)d.hasOwnProperty(n)&&
K(g,n,d[n]);return new C(function(b,f){dh(a,g.toString(),function(a){a?a.error?f(gh(a,e||{})):b(a):f(new O("network-request-failed"))},c,l?void 0:Hc(Qf(d)),a.mb,a.Ef.get())})},jh=function(a){if(!yc.test(a.email))throw new O("invalid-email");},kh=function(a){"email"in a&&jh(a)},mh=function(a,b){return Q(a,lh,{identifier:b,continueUri:Mf()?rf():"http://localhost"}).then(function(a){return a.allProviders||[]})},oh=function(a){return Q(a,nh,{}).then(function(a){return a.authorizedDomains||[]})},ph=function(a){if(!a.idToken)throw new O("internal-error");
},qh=function(a){if(a.phoneNumber||a.temporaryProof){if(!a.phoneNumber||!a.temporaryProof)throw new O("internal-error");}else{if(!a.sessionInfo)throw new O("missing-verification-id");if(!a.code)throw new O("missing-verification-code");}};R.prototype.signInAnonymously=function(){return Q(this,rh,{})};R.prototype.updateEmail=function(a,b){return Q(this,sh,{idToken:a,email:b})};R.prototype.updatePassword=function(a,b){return Q(this,Ig,{idToken:a,password:b})};var th={displayName:"DISPLAY_NAME",photoUrl:"PHOTO_URL"};
R.prototype.updateProfile=function(a,b){var c={idToken:a},d=[];eb(th,function(a,f){var e=b[f];null===e?d.push(a):f in b&&(c[f]=e)});d.length&&(c.deleteAttribute=d);return Q(this,sh,c)};R.prototype.sendPasswordResetEmail=function(a,b){a={requestType:"PASSWORD_RESET",email:a};mb(a,b);return Q(this,uh,a)};R.prototype.sendEmailVerification=function(a,b){a={requestType:"VERIFY_EMAIL",idToken:a};mb(a,b);return Q(this,vh,a)};R.prototype.verifyPhoneNumber=function(a){return Q(this,wh,a)};
var yh=function(a,b,c){return Q(a,xh,{idToken:b,deleteProvider:c})},zh=function(a){if(!a.requestUri||!a.sessionId&&!a.postBody)throw new O("internal-error");},Ah=function(a){var b=null;a.needConfirmation?(a.code="account-exists-with-different-credential",b=Ug(a)):"FEDERATED_USER_ID_ALREADY_LINKED"==a.errorMessage?(a.code="credential-already-in-use",b=Ug(a)):"EMAIL_EXISTS"==a.errorMessage&&(a.code="email-already-in-use",b=Ug(a));if(b)throw b;if(!a.idToken)throw new O("internal-error");},tg=function(a,
b){b.returnIdpCredential=!0;return Q(a,Bh,b)},vg=function(a,b){b.returnIdpCredential=!0;return Q(a,Ch,b)},wg=function(a,b){b.returnIdpCredential=!0;b.autoCreate=!1;return Q(a,Dh,b)},Eh=function(a){if(!a.oobCode)throw new O("invalid-action-code");};R.prototype.confirmPasswordReset=function(a,b){return Q(this,Fh,{oobCode:a,newPassword:b})};R.prototype.checkActionCode=function(a){return Q(this,Gh,{oobCode:a})};R.prototype.applyActionCode=function(a){return Q(this,Hh,{oobCode:a})};
var Hh={endpoint:"setAccountInfo",F:Eh,cb:"email"},Gh={endpoint:"resetPassword",F:Eh,$:function(a){if(!a.email||!a.requestType)throw new O("internal-error");}},Ih={endpoint:"signupNewUser",F:function(a){jh(a);if(!a.password)throw new O("weak-password");},$:ph,Aa:!0},lh={endpoint:"createAuthUri"},Jh={endpoint:"deleteAccount",ab:["idToken"]},xh={endpoint:"setAccountInfo",ab:["idToken","deleteProvider"],F:function(a){if(!ha(a.deleteProvider))throw new O("internal-error");}},Kh={endpoint:"getAccountInfo"},
vh={endpoint:"getOobConfirmationCode",ab:["idToken","requestType"],F:function(a){if("VERIFY_EMAIL"!=a.requestType)throw new O("internal-error");},cb:"email"},uh={endpoint:"getOobConfirmationCode",ab:["requestType"],F:function(a){if("PASSWORD_RESET"!=a.requestType)throw new O("internal-error");jh(a)},cb:"email"},nh={ie:!0,endpoint:"getProjectConfig",De:"GET"},Lh={ie:!0,endpoint:"getRecaptchaParam",De:"GET",$:function(a){if(!a.recaptchaSiteKey)throw new O("internal-error");}},Fh={endpoint:"resetPassword",
F:Eh,cb:"email"},Pg={endpoint:"sendVerificationCode",ab:["phoneNumber","recaptchaToken"],cb:"sessionInfo"},sh={endpoint:"setAccountInfo",ab:["idToken"],F:kh,Aa:!0},Ig={endpoint:"setAccountInfo",ab:["idToken"],F:function(a){kh(a);if(!a.password)throw new O("weak-password");},$:ph,Aa:!0},rh={endpoint:"signupNewUser",$:ph,Aa:!0},Bh={endpoint:"verifyAssertion",F:zh,$:Ah,Aa:!0},Dh={endpoint:"verifyAssertion",F:zh,$:function(a){if(a.errorMessage&&"USER_NOT_FOUND"==a.errorMessage)throw new O("user-not-found");
if(!a.idToken)throw new O("internal-error");},Aa:!0},Ch={endpoint:"verifyAssertion",F:function(a){zh(a);if(!a.idToken)throw new O("internal-error");},$:Ah,Aa:!0},Mh={endpoint:"verifyCustomToken",F:function(a){if(!a.token)throw new O("invalid-custom-token");},$:ph,Aa:!0},Hg={endpoint:"verifyPassword",F:function(a){jh(a);if(!a.password)throw new O("wrong-password");},$:ph,Aa:!0},wh={endpoint:"verifyPhoneNumber",F:qh,$:ph},Mg={endpoint:"verifyPhoneNumber",F:function(a){if(!a.idToken)throw new O("internal-error");
qh(a)},$:function(a){if(a.temporaryProof)throw a.code="credential-already-in-use",Ug(a);ph(a)}},Ng={yf:{USER_NOT_FOUND:"user-not-found"},endpoint:"verifyPhoneNumber",F:qh,$:ph},Q=function(a,b,c){if(!eg(c,b.ab))return E(new O("internal-error"));var d=b.De||"POST",e;return D(c).then(b.F).then(function(){b.Aa&&(c.returnSecureToken=!0);return ih(a,b.endpoint,d,c,b.yf,b.ie||!1)}).then(function(a){return e=a}).then(b.$).then(function(){if(!b.cb)return e;if(!(b.cb in e))throw new O("internal-error");return e[b.cb]})},
gh=function(a,b){var c=(a.error&&a.error.errors&&a.error.errors[0]||{}).reason||"";var d={keyInvalid:"invalid-api-key",ipRefererBlocked:"app-not-authorized"};if(c=d[c]?new O(d[c]):null)return c;c=a.error&&a.error.message||"";d={INVALID_CUSTOM_TOKEN:"invalid-custom-token",CREDENTIAL_MISMATCH:"custom-token-mismatch",MISSING_CUSTOM_TOKEN:"internal-error",INVALID_IDENTIFIER:"invalid-email",MISSING_CONTINUE_URI:"internal-error",INVALID_EMAIL:"invalid-email",INVALID_PASSWORD:"wrong-password",USER_DISABLED:"user-disabled",
MISSING_PASSWORD:"internal-error",EMAIL_EXISTS:"email-already-in-use",PASSWORD_LOGIN_DISABLED:"operation-not-allowed",INVALID_IDP_RESPONSE:"invalid-credential",FEDERATED_USER_ID_ALREADY_LINKED:"credential-already-in-use",INVALID_MESSAGE_PAYLOAD:"invalid-message-payload",INVALID_RECIPIENT_EMAIL:"invalid-recipient-email",INVALID_SENDER:"invalid-sender",EMAIL_NOT_FOUND:"user-not-found",EXPIRED_OOB_CODE:"expired-action-code",INVALID_OOB_CODE:"invalid-action-code",MISSING_OOB_CODE:"internal-error",CREDENTIAL_TOO_OLD_LOGIN_AGAIN:"requires-recent-login",
INVALID_ID_TOKEN:"invalid-user-token",TOKEN_EXPIRED:"user-token-expired",USER_NOT_FOUND:"user-token-expired",CORS_UNSUPPORTED:"cors-unsupported",DYNAMIC_LINK_NOT_ACTIVATED:"dynamic-link-not-activated",INVALID_APP_ID:"invalid-app-id",TOO_MANY_ATTEMPTS_TRY_LATER:"too-many-requests",WEAK_PASSWORD:"weak-password",OPERATION_NOT_ALLOWED:"operation-not-allowed",USER_CANCELLED:"user-cancelled",CAPTCHA_CHECK_FAILED:"captcha-check-failed",INVALID_APP_CREDENTIAL:"invalid-app-credential",INVALID_CODE:"invalid-verification-code",
INVALID_PHONE_NUMBER:"invalid-phone-number",INVALID_SESSION_INFO:"invalid-verification-id",INVALID_TEMPORARY_PROOF:"invalid-credential",MISSING_APP_CREDENTIAL:"missing-app-credential",MISSING_CODE:"missing-verification-code",MISSING_PHONE_NUMBER:"missing-phone-number",MISSING_SESSION_INFO:"missing-verification-id",QUOTA_EXCEEDED:"quota-exceeded",SESSION_EXPIRED:"code-expired",INVALID_CONTINUE_URI:"invalid-continue-uri",MISSING_ANDROID_PACKAGE_NAME:"missing-android-pkg-name",MISSING_IOS_BUNDLE_ID:"missing-ios-bundle-id",
UNAUTHORIZED_DOMAIN:"unauthorized-continue-uri",INVALID_OAUTH_CLIENT_ID:"invalid-oauth-client-id"};mb(d,b||{});b=(b=c.match(/^[^\s]+\s*:\s*(.*)$/))&&1<b.length?b[1]:void 0;for(var e in d)if(0===c.indexOf(e))return new O(d[e],b);!b&&a&&(b=Pf(a));return new O("internal-error",b)};var Oh=function(a){this.Bg=a;this.yc=null;this.Id=Nh(this)},Nh=function(a){return Ph().then(function(){return new C(function(b,c){M("gapi.iframes.getContext")().open({where:document.body,url:a.Bg,messageHandlersFilter:M("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"),attributes:{style:{position:"absolute",top:"-100px",width:"1px",height:"1px"}},dontclear:!0},function(d){a.yc=d;a.yc.restyle({setHideOnLeave:!1});var e=setTimeout(function(){c(Error("Network Error"))},Qh.get()),f=function(){clearTimeout(e);
b()};d.ping(f).then(f,function(){c(Error("Network Error"))})})})})};Oh.prototype.sendMessage=function(a){var b=this;return this.Id.then(function(){return new C(function(c){b.yc.send(a.type,a,c,M("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"))})})};
var Rh=function(a,b){a.Id.then(function(){a.yc.register("authEvent",b,M("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"))})},Sh=Ha("https://apis.google.com/js/api.js?onload=%{onload}"),Th=new Vf(3E4,6E4),Qh=new Vf(5E3,15E3),Uh=null,Ph=function(){return Uh?Uh:Uh=(new C(function(a,b){if(Uf()){var c=function(){Tf();M("gapi.load")("gapi.iframes",{callback:a,ontimeout:function(){Tf();b(Error("Network Error"))},timeout:Th.get()})};if(M("gapi.iframes.Iframe"))a();else if(M("gapi.load"))c();else{var d="__iframefcb"+
Math.floor(1E6*Math.random()).toString();k[d]=function(){M("gapi.load")?c():b(Error("Network Error"))};d=Oa(Sh,{onload:d});D(de(d)).g(function(){b(Error("Network Error"))})}}else b(Error("Network Error"))})).g(function(a){Uh=null;throw a;})};var Vh=function(a,b,c){this.B=a;this.m=b;this.o=c;this.fb=null;this.Ba=hf(this.B,"/__/auth/iframe");K(this.Ba,"apiKey",this.m);K(this.Ba,"appName",this.o);this.P=null;this.M=[]};Vh.prototype.ae=function(a){this.fb=a;return this};Vh.prototype.Zd=function(a){this.P=a;return this};
Vh.prototype.toString=function(){this.fb?K(this.Ba,"v",this.fb):this.Ba.removeParameter("v");this.P?K(this.Ba,"eid",this.P):this.Ba.removeParameter("eid");this.M.length?K(this.Ba,"fw",this.M.join(",")):this.Ba.removeParameter("fw");return this.Ba.toString()};var Wh=function(a,b,c,d,e){this.B=a;this.m=b;this.o=c;this.sf=d;this.fb=this.Y=this.Td=null;this.xb=e;this.P=null};Wh.prototype.ae=function(a){this.fb=a;return this};Wh.prototype.Zd=function(a){this.P=a;return this};
Wh.prototype.toString=function(){var a=hf(this.B,"/__/auth/handler");K(a,"apiKey",this.m);K(a,"appName",this.o);K(a,"authType",this.sf);if(this.xb.isOAuthProvider){var b=this.xb;try{var c=firebase.app(this.o).auth().ia}catch(l){c=null}b.nd=c;K(a,"providerId",this.xb.providerId);b=this.xb;c=Qf(b.qe);for(var d in c)c[d]=c[d].toString();d=b.kg;c=kb(c);for(var e=0;e<d.length;e++){var f=d[e];f in c&&delete c[f]}b.Ed&&b.nd&&!c[b.Ed]&&(c[b.Ed]=b.nd);ib(c)||K(a,"customParameters",Pf(c))}"function"===typeof this.xb.ye&&
(b=this.xb.ye(),b.length&&K(a,"scopes",b.join(",")));this.Td?K(a,"redirectUrl",this.Td):a.removeParameter("redirectUrl");this.Y?K(a,"eventId",this.Y):a.removeParameter("eventId");this.fb?K(a,"v",this.fb):a.removeParameter("v");if(this.mc)for(var g in this.mc)this.mc.hasOwnProperty(g)&&!ff(a,g)&&K(a,g,this.mc[g]);this.P?K(a,"eid",this.P):a.removeParameter("eid");g=Xh(this.o);g.length&&K(a,"fw",g.join(","));return a.toString()};
var Xh=function(a){try{return $a(firebase.app(a).auth().M)}catch(b){return[]}},Yh=function(a,b,c,d,e){this.B=a;this.m=b;this.o=c;this.La=d||null;this.P=e||null;this.f=this.yd=this.we=null;this.ta=[];this.Ac=this.wa=null},Zh=function(a){var b=rf();return oh(a).then(function(a){a:{var c=gf(b),e=c.qa;c=c.pa;for(var f=0;f<a.length;f++){var g=a[f];var l=c;var n=e;0==g.indexOf("chrome-extension://")?l=gf(g).pa==l&&"chrome-extension"==n:"http"!=n&&"https"!=n?l=!1:Af.test(g)?l=l==g:(g=g.split(".").join("\\."),
l=(new RegExp("^(.+\\."+g+"|"+g+")$","i")).test(l));if(l){a=!0;break a}}a=!1}if(!a)throw new og(rf());})};h=Yh.prototype;h.Sb=function(){if(this.Ac)return this.Ac;var a=this;return this.Ac=Bf().then(function(){if(!a.yd){var b=a.La,c=a.P,d=Xh(a.o);b=(new Vh(a.B,a.m,a.o)).ae(b).Zd(c);b.M=$a(d||[]);a.yd=b.toString()}a.xc=new Oh(a.yd);$h(a)})};
h.ec=function(a,b,c){var d=new O("popup-closed-by-user"),e=new O("web-storage-unsupported"),f=this,g=!1;return this.Ra().then(function(){ai(f).then(function(c){c||(a&&xf(a),b(e),g=!0)})}).g(function(){}).then(function(){if(!g)return zf(a)}).then(function(){if(!g)return Be(c).then(function(){b(d)})})};h.Ye=function(){var a=L();return!Of(a)&&!Sf(a)};h.Be=function(){return!1};
h.$b=function(a,b,c,d,e,f,g){if(!a)return E(new O("popup-blocked"));if(g&&!Of())return this.Ra().g(function(b){xf(a);e(b)}),d(),D();this.wa||(this.wa=Zh(bi(this)));var l=this;return this.wa.then(function(){var b=l.Ra().g(function(b){xf(a);e(b);throw b;});d();return b}).then(function(){Sg(c);if(!g){var d=ci(l.B,l.m,l.o,b,c,null,f,l.La,void 0,l.P);sf(d,a)}}).g(function(a){"auth/network-request-failed"==a.code&&(l.wa=null);throw a;})};
var bi=function(a){a.f||(a.we=a.La?Jf(a.La,Xh(a.o)):null,a.f=new R(a.m,of(a.P),a.we));return a.f};Yh.prototype.ac=function(a,b,c){this.wa||(this.wa=Zh(bi(this)));var d=this;return this.wa.then(function(){Sg(b);var e=ci(d.B,d.m,d.o,a,b,rf(),c,d.La,void 0,d.P);sf(e)}).g(function(a){"auth/network-request-failed"==a.code&&(d.wa=null);throw a;})};Yh.prototype.Ra=function(){var a=this;return this.Sb().then(function(){return a.xc.Id}).g(function(){a.wa=null;throw new O("network-request-failed");})};
Yh.prototype.bf=function(){return!0};
var ci=function(a,b,c,d,e,f,g,l,n,F){a=new Wh(a,b,c,d,e);a.Td=f;a.Y=g;f=a.ae(l);f.mc=kb(n||null);return f.Zd(F).toString()},$h=function(a){if(!a.xc)throw Error("IfcHandler must be initialized!");Rh(a.xc,function(b){var c={};if(b&&b.authEvent){var d=!1;b=ng(b.authEvent);for(c=0;c<a.ta.length;c++)d=a.ta[c](b)||d;c={};c.status=d?"ACK":"ERROR";return D(c)}c.status="ERROR";return D(c)})},ai=function(a){var b={type:"webStorageSupport"};return a.Sb().then(function(){return a.xc.sendMessage(b)}).then(function(a){if(a&&a.length&&
"undefined"!==typeof a[0].webStorageSupport)return a[0].webStorageSupport;throw Error();})};Yh.prototype.ib=function(a){this.ta.push(a)};Yh.prototype.dc=function(a){Ya(this.ta,function(b){return b==a})};var di=function(a,b,c,d,e,f){N(this,"type","recaptcha");this.ad=this.Ib=null;this.Kb=!1;this.ne=b;this.Fa=c||{theme:"light",type:"image"};this.J=[];if(this.Fa.sitekey)throw new O("argument-error","sitekey should not be provided for reCAPTCHA as one is automatically provisioned for the current project.");this.Bc="invisible"===this.Fa.size;if(!ld(b)||!this.Bc&&ld(b).hasChildNodes())throw new O("argument-error","reCAPTCHA container is either not found or already contains inner elements!");this.f=new R(a,
f||null,e||null);this.Jf=d||function(){return null};var g=this;this.Wc=[];var l=this.Fa.callback;this.Fa.callback=function(a){g.Lb(a);if("function"===typeof l)l(a);else if("string"===typeof l){var b=M(l,k);"function"===typeof b&&b(a)}};var n=this.Fa["expired-callback"];this.Fa["expired-callback"]=function(){g.Lb(null);if("function"===typeof n)n();else if("string"===typeof n){var a=M(n,k);"function"===typeof a&&a()}}};di.prototype.Lb=function(a){for(var b=0;b<this.Wc.length;b++)try{this.Wc[b](a)}catch(c){}};
var ei=function(a,b){Ya(a.Wc,function(a){return a==b})};di.prototype.c=function(a){var b=this;this.J.push(a);Ed(a,function(){Xa(b.J,a)});return a};
di.prototype.Tb=function(){var a=this;return this.Ib?this.Ib:this.Ib=this.c(D().then(function(){if(Mf())return Bf();throw new O("operation-not-supported-in-this-environment","RecaptchaVerifier is only supported in a browser HTTP/HTTPS environment.");}).then(function(){return fi(gi(),a.Jf())}).then(function(){return Q(a.f,Lh,{})}).then(function(b){a.Fa.sitekey=b.recaptchaSiteKey}).g(function(b){a.Ib=null;throw b;}))};
di.prototype.render=function(){hi(this);var a=this;return this.c(this.Tb().then(function(){if(null===a.ad){var b=a.ne;if(!a.Bc){var c=ld(b);b=pd("DIV");c.appendChild(b)}a.ad=grecaptcha.render(b,a.Fa)}return a.ad}))};di.prototype.verify=function(){hi(this);var a=this;return this.c(this.render().then(function(b){return new C(function(c){var d=grecaptcha.getResponse(b);if(d)c(d);else{var e=function(b){b&&(ei(a,e),c(b))};a.Wc.push(e);a.Bc&&grecaptcha.execute(a.ad)}})}))};
var hi=function(a){if(a.Kb)throw new O("internal-error","RecaptchaVerifier instance has been destroyed.");};di.prototype.clear=function(){hi(this);this.Kb=!0;gi().ld--;for(var a=0;a<this.J.length;a++)this.J[a].cancel("RecaptchaVerifier instance has been destroyed.");if(!this.Bc){a=ld(this.ne);for(var b;b=a.firstChild;)a.removeChild(b)}};
var ii=Ha("https://www.google.com/recaptcha/api.js?onload=%{onload}&render=explicit&hl=%{hl}"),ji=function(){this.ld=k.grecaptcha?Infinity:0;this.Ce=null;this.jd="__rcb"+Math.floor(1E6*Math.random()).toString()},fi=function(a,b){return new C(function(c,d){if(Uf())if(!k.grecaptcha||b!==a.Ce&&!a.ld){k[a.jd]=function(){if(k.grecaptcha){a.Ce=b;var e=k.grecaptcha.render;k.grecaptcha.render=function(b,c){b=e(b,c);a.ld++;return b};c()}else d(new O("internal-error"));delete k[a.jd]};var e=Oa(ii,{onload:a.jd,
hl:b||""});D(de(e)).g(function(){d(new O("internal-error","Unable to load external reCAPTCHA dependencies!"))})}else c();else d(new O("network-request-failed"))})},ki=null,gi=function(){ki||(ki=new ji);return ki},li=function(a,b,c){try{this.i=c||firebase.app()}catch(f){throw new O("argument-error","No firebase.app.App instance is currently initialized.");}if(this.i.options&&this.i.options.apiKey)c=this.i.options.apiKey;else throw new O("invalid-api-key");var d=this,e=null;try{e=$a(this.i.auth().M)}catch(f){}e=
firebase.SDK_VERSION?Jf(firebase.SDK_VERSION,e):null;di.call(this,c,a,b,function(){try{var a=d.i.auth().ia}catch(g){a=null}return a},e,of(pf))};t(li,di);var mi=function(a){this.G=a||firebase.INTERNAL.reactNative&&firebase.INTERNAL.reactNative.AsyncStorage;if(!this.G)throw new O("internal-error","The React Native compatibility library was not found.");};h=mi.prototype;h.get=function(a){return D(this.G.getItem(a)).then(function(a){return a&&Rf(a)})};h.set=function(a,b){return D(this.G.setItem(a,Pf(b)))};h.remove=function(a){return D(this.G.removeItem(a))};h.jb=function(){};h.$a=function(){};var ni=function(){this.G={}};h=ni.prototype;h.get=function(a){return D(this.G[a])};h.set=function(a,b){this.G[a]=b;return D()};h.remove=function(a){delete this.G[a];return D()};h.jb=function(){};h.$a=function(){};var pi=function(){if(!oi()){if("Node"==Gf())throw new O("internal-error","The LocalStorage compatibility library was not found.");throw new O("web-storage-unsupported");}this.G=k.localStorage||firebase.INTERNAL.node.localStorage},oi=function(){var a="Node"==Gf();a=k.localStorage||a&&firebase.INTERNAL.node&&firebase.INTERNAL.node.localStorage;if(!a)return!1;try{return a.setItem("__sak","1"),a.removeItem("__sak"),!0}catch(b){return!1}};h=pi.prototype;
h.get=function(a){var b=this;return D().then(function(){var c=b.G.getItem(a);return Rf(c)})};h.set=function(a,b){var c=this;return D().then(function(){var d=Pf(b);null===d?c.remove(a):c.G.setItem(a,d)})};h.remove=function(a){var b=this;return D().then(function(){b.G.removeItem(a)})};h.jb=function(a){k.window&&lc(k.window,"storage",a)};h.$a=function(a){k.window&&tc(k.window,"storage",a)};var qi=function(){this.G={}};h=qi.prototype;h.get=function(){return D(null)};h.set=function(){return D()};h.remove=function(){return D()};h.jb=function(){};h.$a=function(){};var si=function(){if(!ri()){if("Node"==Gf())throw new O("internal-error","The SessionStorage compatibility library was not found.");throw new O("web-storage-unsupported");}this.G=k.sessionStorage||firebase.INTERNAL.node.sessionStorage},ri=function(){var a="Node"==Gf();a=k.sessionStorage||a&&firebase.INTERNAL.node&&firebase.INTERNAL.node.sessionStorage;if(!a)return!1;try{return a.setItem("__sak","1"),a.removeItem("__sak"),!0}catch(b){return!1}};h=si.prototype;
h.get=function(a){var b=this;return D().then(function(){var c=b.G.getItem(a);return Rf(c)})};h.set=function(a,b){var c=this;return D().then(function(){var d=Pf(b);null===d?c.remove(a):c.G.setItem(a,d)})};h.remove=function(a){var b=this;return D().then(function(){b.G.removeItem(a)})};h.jb=function(){};h.$a=function(){};var ti=function(a,b,c,d,e,f){if(!window.indexedDB)throw new O("web-storage-unsupported");this.zf=a;this.Hd=b;this.md=c;this.ff=d;this.gb=e;this.N={};this.fc=[];this.Wb=0;this.Rf=f||k.indexedDB},ui,vi=function(a){return new C(function(b,c){var d=a.Rf.open(a.zf,a.gb);d.onerror=function(a){c(Error(a.target.errorCode))};d.onupgradeneeded=function(b){b=b.target.result;try{b.createObjectStore(a.Hd,{keyPath:a.md})}catch(f){c(f)}};d.onsuccess=function(a){b(a.target.result)}})},wi=function(a){a.Ge||(a.Ge=
vi(a));return a.Ge},xi=function(a,b){return b.objectStore(a.Hd)},zi=function(a,b,c){return b.transaction([a.Hd],c?"readwrite":"readonly")},Ai=function(a){return new C(function(b,c){a.onsuccess=function(a){a&&a.target?b(a.target.result):b()};a.onerror=function(a){c(Error(a.target.errorCode))}})};h=ti.prototype;
h.set=function(a,b){var c=!1,d,e=this;return Ed(wi(this).then(function(b){d=b;b=xi(e,zi(e,d,!0));return Ai(b.get(a))}).then(function(f){var g=xi(e,zi(e,d,!0));if(f)return f.value=b,Ai(g.put(f));e.Wb++;c=!0;f={};f[e.md]=a;f[e.ff]=b;return Ai(g.add(f))}).then(function(){e.N[a]=b}),function(){c&&e.Wb--})};h.get=function(a){var b=this;return wi(this).then(function(c){return Ai(xi(b,zi(b,c,!1)).get(a))}).then(function(a){return a&&a.value})};
h.remove=function(a){var b=!1,c=this;return Ed(wi(this).then(function(d){b=!0;c.Wb++;return Ai(xi(c,zi(c,d,!0))["delete"](a))}).then(function(){delete c.N[a]}),function(){b&&c.Wb--})};
h.xg=function(){var a=this;return wi(this).then(function(b){var c=xi(a,zi(a,b,!1));return c.getAll?Ai(c.getAll()):new C(function(a,b){var d=[],e=c.openCursor();e.onsuccess=function(b){(b=b.target.result)?(d.push(b.value),b["continue"]()):a(d)};e.onerror=function(a){b(Error(a.target.errorCode))}})}).then(function(b){var c={},d=[];if(0==a.Wb){for(d=0;d<b.length;d++)c[b[d][a.md]]=b[d][a.ff];d=tf(a.N,c);a.N=c}return d})};h.jb=function(a){0==this.fc.length&&this.ce();this.fc.push(a)};
h.$a=function(a){Ya(this.fc,function(b){return b==a});0==this.fc.length&&this.Sc()};h.ce=function(){var a=this;this.Sc();var b=function(){a.Nd=Be(800).then(r(a.xg,a)).then(function(b){0<b.length&&x(a.fc,function(a){a(b)})}).then(b).g(function(a){"STOP_EVENT"!=a.message&&b()});return a.Nd};b()};h.Sc=function(){this.Nd&&this.Nd.cancel("STOP_EVENT")};var Ei=function(){this.se={Browser:Bi,Node:Ci,ReactNative:Di}[Gf()]},Fi,Bi={D:pi,ee:si},Ci={D:pi,ee:si},Di={D:mi,ee:qi};var Gi=function(a){this.Bd(a)};
Gi.prototype.Bd=function(a){var b=a.url;if("undefined"===typeof b)throw new O("missing-continue-uri");if("string"!==typeof b||"string"===typeof b&&!b.length)throw new O("invalid-continue-uri");this.uf=b;this.ge=this.nc=null;this.He=!1;var c=a.android;if(c&&"object"===typeof c){b=c.packageName;var d=c.installApp;c=c.minimumVersion;if("string"===typeof b&&b.length){this.nc=b;if("undefined"!==typeof d&&"boolean"!==typeof d)throw new O("argument-error","installApp property must be a boolean when specified.");this.He=
!!d;if("undefined"!==typeof c&&("string"!==typeof c||"string"===typeof c&&!c.length))throw new O("argument-error","minimumVersion property must be a non empty string when specified.");this.ge=c||null}else{if("undefined"!==typeof b)throw new O("argument-error","packageName property must be a non empty string when specified.");if("undefined"!==typeof d||"undefined"!==typeof c)throw new O("missing-android-pkg-name");}}else if("undefined"!==typeof c)throw new O("argument-error","android property must be a non null object when specified.");
this.xd=null;if((b=a.iOS)&&"object"===typeof b)if(b=b.bundleId,"string"===typeof b&&b.length)this.xd=b;else{if("undefined"!==typeof b)throw new O("argument-error","bundleId property must be a non empty string when specified.");}else if("undefined"!==typeof b)throw new O("argument-error","iOS property must be a non null object when specified.");a=a.handleCodeInApp;if("undefined"!==typeof a&&"boolean"!==typeof a)throw new O("argument-error","handleCodeInApp property must be a boolean when specified.");
if((this.le=!!a)&&!this.xd&&!this.nc)throw new O("argument-error","handleCodeInApp property can't be true when no mobile application is provided.");};var Hi=function(a){var b={};b.continueUrl=a.uf;b.canHandleCodeInApp=a.le;if(b.androidPackageName=a.nc)b.androidMinimumVersion=a.ge,b.androidInstallApp=a.He;b.iOSBundleId=a.xd;for(var c in b)null===b[c]&&delete b[c];return b};var Ii=function(a,b){this.xf=b;N(this,"verificationId",a)};Ii.prototype.confirm=function(a){a=Qg(this.verificationId,a);return this.xf(a)};var Ji=function(a,b,c,d){return(new Og(a)).verifyPhoneNumber(b,c).then(function(a){return new Ii(a,d)})};var Ki=function(a){var b={},c=a.email,d=a.newEmail;a=a.requestType;if(!c||!a)throw Error("Invalid provider user info!");b.fromEmail=d||null;b.email=c;N(this,"operation",a);N(this,"data",fg(b))};var Li=function(a,b,c,d,e,f){this.fg=a;this.mg=b;this.Kf=c;this.Gc=d;this.fe=e;this.ng=!!f;this.ub=null;this.Sa=this.Gc;if(this.fe<this.Gc)throw Error("Proactive refresh lower bound greater than upper bound!");};Li.prototype.start=function(){this.Sa=this.Gc;Mi(this,!0)};
var Ni=function(a,b){if(b)return a.Sa=a.Gc,a.Kf();b=a.Sa;a.Sa*=2;a.Sa>a.fe&&(a.Sa=a.fe);return b},Mi=function(a,b){a.stop();a.ub=Be(Ni(a,b)).then(function(){return a.ng?D():Xf()}).then(function(){return a.fg()}).then(function(){Mi(a,!0)}).g(function(b){a.mg(b)&&Mi(a,!1)})};Li.prototype.stop=function(){this.ub&&(this.ub.cancel(),this.ub=null)};var Ui=function(a){var b={};b["facebook.com"]=Oi;b["google.com"]=Pi;b["github.com"]=Qi;b["twitter.com"]=Ri;var c=a&&a.providerId;try{if(c)return b[c]?new b[c](a):new Si(a);if("undefined"!==typeof a.idToken)return new Ti(a)}catch(d){}return null},Ti=function(a){var b=a.providerId;if(!b&&a.idToken){var c=qg(a.idToken);c&&c.Rd&&(b=c.Rd)}if(!b)throw Error("Invalid additional user info!");a=!!a.isNewUser;N(this,"providerId",b);N(this,"isNewUser",a)},Si=function(a){Ti.call(this,a);a=Rf(a.rawUserInfo||"{}");
N(this,"profile",fg(a||{}))};t(Si,Ti);var Oi=function(a){Si.call(this,a);if("facebook.com"!=this.providerId)throw Error("Invalid provider id!");};t(Oi,Si);var Qi=function(a){Si.call(this,a);if("github.com"!=this.providerId)throw Error("Invalid provider id!");N(this,"username",this.profile&&this.profile.login||null)};t(Qi,Si);var Pi=function(a){Si.call(this,a);if("google.com"!=this.providerId)throw Error("Invalid provider id!");};t(Pi,Si);
var Ri=function(a){Si.call(this,a);if("twitter.com"!=this.providerId)throw Error("Invalid provider id!");N(this,"username",a.screenName||null)};t(Ri,Si);var Vi={LOCAL:"local",NONE:"none",SESSION:"session"},Wi=function(a){var b=new O("invalid-persistence-type"),c=new O("unsupported-persistence-type");a:{for(d in Vi)if(Vi[d]==a){var d=!0;break a}d=!1}if(!d||"string"!==typeof a)throw b;switch(Gf()){case "ReactNative":if("session"===a)throw c;break;case "Node":if("none"!==a)throw c;break;default:if(!Lf()&&"none"!==a)throw c;}},Xi=function(a,b,c,d){this.Me=a;this.Xd=b;this.og=c;this.Ve=d;this.S={};Fi||(Fi=new Ei);a=Fi;try{if(qf()){ui||(ui=new ti("firebaseLocalStorageDb",
"firebaseLocalStorage","fbase_key","value",1));var e=ui}else e=new a.se.D;this.Se=e}catch(f){this.Se=new ni,this.Ve=!0}try{this.af=new a.se.ee}catch(f){this.af=new ni}this.Qf=new ni;this.de=r(this.Ze,this);this.N={}},Yi,Zi=function(){Yi||(Yi=new Xi("firebase",":",!Sf(L())&&Ff()?!0:!1,Of()));return Yi},$i=function(a,b){switch(b){case "session":return a.af;case "none":return a.Qf;default:return a.Se}};h=Xi.prototype;h.ca=function(a,b){return this.Me+this.Xd+a.name+(b?this.Xd+b:"")};
h.get=function(a,b){return $i(this,a.D).get(this.ca(a,b))};h.remove=function(a,b){b=this.ca(a,b);"local"==a.D&&(this.N[b]=null);return $i(this,a.D).remove(b)};h.set=function(a,b,c){var d=this.ca(a,c),e=this,f=$i(this,a.D);return f.set(d,b).then(function(){return f.get(d)}).then(function(b){"local"==a.D&&(e.N[d]=b)})};
h.addListener=function(a,b,c){a=this.ca(a,b);"undefined"!==typeof k.localStorage&&"function"===typeof k.localStorage.getItem&&(this.N[a]=k.localStorage.getItem(a));ib(this.S)&&this.ce();this.S[a]||(this.S[a]=[]);this.S[a].push(c)};h.removeListener=function(a,b,c){a=this.ca(a,b);this.S[a]&&(Ya(this.S[a],function(a){return a==c}),0==this.S[a].length&&delete this.S[a]);ib(this.S)&&this.Sc()};h.ce=function(){$i(this,"local").jb(this.de);this.Ve||qf()||aj(this)};
var aj=function(a){bj(a);a.Fd=setInterval(function(){for(var b in a.S){var c=k.localStorage.getItem(b),d=a.N[b];c!=d&&(a.N[b]=c,c=new Yb({type:"storage",key:b,target:window,oldValue:d,newValue:c,Md:!0}),a.Ze(c))}},1E3)},bj=function(a){a.Fd&&(clearInterval(a.Fd),a.Fd=null)};Xi.prototype.Sc=function(){$i(this,"local").$a(this.de);bj(this)};
Xi.prototype.Ze=function(a){if(a&&a.Hf){var b=a.R.key;if(null==b)for(var c in this.S){var d=this.N[c];"undefined"===typeof d&&(d=null);var e=k.localStorage.getItem(c);e!==d&&(this.N[c]=e,this.hd(c))}else if(0==b.indexOf(this.Me+this.Xd)&&this.S[b]){"undefined"!==typeof a.R.Md?$i(this,"local").$a(this.de):bj(this);if(this.og)if(c=k.localStorage.getItem(b),d=a.R.newValue,d!==c)null!==d?k.localStorage.setItem(b,d):k.localStorage.removeItem(b);else if(this.N[b]===d&&"undefined"===typeof a.R.Md)return;
var f=this;c=function(){if("undefined"!==typeof a.R.Md||f.N[b]!==k.localStorage.getItem(b))f.N[b]=k.localStorage.getItem(b),f.hd(b)};z&&Cb&&10==Cb&&k.localStorage.getItem(b)!==a.R.newValue&&a.R.newValue!==a.R.oldValue?setTimeout(c,10):c()}}else x(a,r(this.hd,this))};Xi.prototype.hd=function(a){this.S[a]&&x(this.S[a],function(a){a()})};var cj=function(a,b){this.j=a;this.h=b||Zi()},dj={name:"authEvent",D:"local"},ej=function(a){return a.h.get(dj,a.j).then(function(a){return ng(a)})};cj.prototype.ib=function(a){this.h.addListener(dj,this.j,a)};cj.prototype.dc=function(a){this.h.removeListener(dj,this.j,a)};var fj=function(a){this.h=a||Zi()},gj={name:"sessionId",D:"session"};fj.prototype.tc=function(a){return this.h.get(gj,a)};var hj=function(a,b,c,d,e,f,g){this.B=a;this.m=b;this.o=c;this.La=d||null;this.P=g||null;this.$e=b+":"+c;this.pg=new fj;this.xe=new cj(this.$e);this.Ad=null;this.ta=[];this.Vf=e||500;this.ig=f||2E3;this.Rb=this.Jc=null},ij=function(a){return new O("invalid-cordova-configuration",a)};
hj.prototype.Ra=function(){return this.Tb?this.Tb:this.Tb=Df().then(function(){if("function"!==typeof M("universalLinks.subscribe",k))throw ij("cordova-universal-links-plugin is not installed");if("undefined"===typeof M("BuildInfo.packageName",k))throw ij("cordova-plugin-buildinfo is not installed");if("function"!==typeof M("cordova.plugins.browsertab.openUrl",k))throw ij("cordova-plugin-browsertab is not installed");if("function"!==typeof M("cordova.InAppBrowser.open",k))throw ij("cordova-plugin-inappbrowser is not installed");
},function(){throw new O("cordova-not-ready");})};var jj=function(){for(var a=20,b=[];0<a;)b.push("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Math.floor(62*Math.random()))),a--;return b.join("")},kj=function(a){var b=new Sb;b.update(a);return ab(b.digest())};h=hj.prototype;h.ec=function(a,b){b(new O("operation-not-supported-in-this-environment"));return D()};h.$b=function(){return E(new O("operation-not-supported-in-this-environment"))};h.bf=function(){return!1};h.Ye=function(){return!0};
h.Be=function(){return!0};
h.ac=function(a,b,c){if(this.Jc)return E(new O("redirect-operation-pending"));var d=this,e=k.document,f=null,g=null,l=null,n=null;return this.Jc=Ed(D().then(function(){Sg(b);return lj(d)}).then(function(){return mj(d,a,b,c)}).then(function(){return(new C(function(a,b){g=function(){var b=M("cordova.plugins.browsertab.close",k);a();"function"===typeof b&&b();d.Rb&&"function"===typeof d.Rb.close&&(d.Rb.close(),d.Rb=null);return!1};d.ib(g);l=function(){f||(f=Be(d.ig).then(function(){b(new O("redirect-cancelled-by-user"))}))};n=
function(){Wf()&&l()};e.addEventListener("resume",l,!1);L().toLowerCase().match(/android/)||e.addEventListener("visibilitychange",n,!1)})).g(function(a){return nj(d).then(function(){throw a;})})}),function(){l&&e.removeEventListener("resume",l,!1);n&&e.removeEventListener("visibilitychange",n,!1);f&&f.cancel();g&&d.dc(g);d.Jc=null})};
var mj=function(a,b,c,d){var e=jj(),f=new mg(b,d,null,e,new O("no-auth-event")),g=M("BuildInfo.packageName",k);if("string"!==typeof g)throw new O("invalid-cordova-configuration");var l=M("BuildInfo.displayName",k),n={};if(L().toLowerCase().match(/iphone|ipad|ipod/))n.ibi=g;else if(L().toLowerCase().match(/android/))n.apn=g;else return E(new O("operation-not-supported-in-this-environment"));l&&(n.appDisplayName=l);e=kj(e);n.sessionId=e;var F=ci(a.B,a.m,a.o,b,c,null,d,a.La,n,a.P);return a.Ra().then(function(){var b=
a.$e;return a.pg.h.set(dj,f.A(),b)}).then(function(){var b=M("cordova.plugins.browsertab.isAvailable",k);if("function"!==typeof b)throw new O("invalid-cordova-configuration");var c=null;b(function(b){if(b){c=M("cordova.plugins.browsertab.openUrl",k);if("function"!==typeof c)throw new O("invalid-cordova-configuration");c(F)}else{c=M("cordova.InAppBrowser.open",k);if("function"!==typeof c)throw new O("invalid-cordova-configuration");b=c;var d=L();d=!(!d.match(/(iPad|iPhone|iPod).*OS 7_\d/i)&&!d.match(/(iPad|iPhone|iPod).*OS 8_\d/i));
a.Rb=b(F,d?"_blank":"_system","location=yes")}})})};hj.prototype.Lb=function(a){for(var b=0;b<this.ta.length;b++)try{this.ta[b](a)}catch(c){}};
var lj=function(a){a.Ad||(a.Ad=a.Ra().then(function(){return new C(function(b){var c=function(d){b(d);a.dc(c);return!1};a.ib(c);oj(a)})}));return a.Ad},nj=function(a){var b=null;return ej(a.xe).then(function(c){b=c;c=a.xe;return c.h.remove(dj,c.j)}).then(function(){return b})},oj=function(a){var b=M("universalLinks.subscribe",k);if("function"!==typeof b)throw new O("invalid-cordova-configuration");var c=new mg("unknown",null,null,null,new O("no-auth-event")),d=!1,e=Be(a.Vf).then(function(){return nj(a).then(function(){d||
a.Lb(c)})}),f=function(b){d=!0;e&&e.cancel();nj(a).then(function(d){var e=c;if(d&&b&&b.url){e=null;var f=b.url;var g=gf(f),l=ff(g,"link"),n=ff(gf(l),"link");g=ff(g,"deep_link_id");f=ff(gf(g),"link")||g||n||l||f;-1!=f.indexOf("/__/auth/callback")&&(e=gf(f),e=Rf(ff(e,"firebaseError")||null),e=(e="object"===typeof e?lg(e):null)?new mg(d.ma,d.Y,null,null,e):new mg(d.ma,d.Y,f,d.tc()));e=e||c}a.Lb(e)})},g=k.handleOpenURL;k.handleOpenURL=function(a){0==a.toLowerCase().indexOf(M("BuildInfo.packageName",k).toLowerCase()+
"://")&&f({url:a});if("function"===typeof g)try{g(a)}catch(n){console.error(n)}};b(null,f)};hj.prototype.ib=function(a){this.ta.push(a);lj(this).g(function(b){"auth/invalid-cordova-configuration"===b.code&&(b=new mg("unknown",null,null,null,new O("no-auth-event")),a(b))})};hj.prototype.dc=function(a){Ya(this.ta,function(b){return b==a})};var pj=function(a){this.j=a;this.h=Zi()},qj={name:"pendingRedirect",D:"session"},rj=function(a){return a.h.set(qj,"pending",a.j)},sj=function(a){return a.h.remove(qj,a.j)},tj=function(a){return a.h.get(qj,a.j).then(function(a){return"pending"==a})};var xj=function(a,b,c){this.B=a;this.m=b;this.o=c;this.gc=[];this.sb=!1;this.ed=r(this.vd,this);this.Xa=new uj(this);this.Od=new vj(this);this.Xb=new pj(this.m+":"+this.o);this.Ia={};this.Ia.unknown=this.Xa;this.Ia.signInViaRedirect=this.Xa;this.Ia.linkViaRedirect=this.Xa;this.Ia.reauthViaRedirect=this.Xa;this.Ia.signInViaPopup=this.Od;this.Ia.linkViaPopup=this.Od;this.Ia.reauthViaPopup=this.Od;this.Z=wj(this.B,this.m,this.o,pf)},wj=function(a,b,c,d){var e=firebase.SDK_VERSION||null;return Cf()?new hj(a,
b,c,e,void 0,void 0,d):new Yh(a,b,c,e,d)};xj.prototype.reset=function(){this.sb=!1;this.Z.dc(this.ed);this.Z=wj(this.B,this.m,this.o)};xj.prototype.Sb=function(){var a=this;this.sb||(this.sb=!0,this.Z.ib(this.ed));var b=this.Z;return this.Z.Ra().g(function(c){a.Z==b&&a.reset();throw c;})};var Aj=function(a){a.Z.Ye()&&a.Sb().g(function(b){var c=new mg("unknown",null,null,null,new O("operation-not-supported-in-this-environment"));yj(b)&&a.vd(c)});a.Z.Be()||zj(a.Xa)};
xj.prototype.subscribe=function(a){Va(this.gc,a)||this.gc.push(a);if(!this.sb){var b=this;tj(this.Xb).then(function(a){a?sj(b.Xb).then(function(){b.Sb().g(function(a){var c=new mg("unknown",null,null,null,new O("operation-not-supported-in-this-environment"));yj(a)&&b.vd(c)})}):Aj(b)}).g(function(){Aj(b)})}};xj.prototype.unsubscribe=function(a){Ya(this.gc,function(b){return b==a})};
xj.prototype.vd=function(a){if(!a)throw new O("invalid-auth-event");for(var b=!1,c=0;c<this.gc.length;c++){var d=this.gc[c];if(d.ke(a.ma,a.Y)){(b=this.Ia[a.ma])&&b.Te(a,d);b=!0;break}}zj(this.Xa);return b};var Bj=new Vf(2E3,1E4),Cj=new Vf(3E4,6E4);xj.prototype.getRedirectResult=function(){return this.Xa.getRedirectResult()};xj.prototype.$b=function(a,b,c,d,e){var f=this;return this.Z.$b(a,b,c,function(){f.sb||(f.sb=!0,f.Z.ib(f.ed))},function(){f.reset()},d,e)};
var yj=function(a){return a&&"auth/cordova-not-ready"==a.code?!0:!1};xj.prototype.ac=function(a,b,c){var d=this,e;return rj(this.Xb).then(function(){return d.Z.ac(a,b,c).g(function(a){if(yj(a))throw new O("operation-not-supported-in-this-environment");e=a;return sj(d.Xb).then(function(){throw e;})}).then(function(){return d.Z.bf()?new C(function(){}):sj(d.Xb).then(function(){return d.getRedirectResult()}).then(function(){}).g(function(){})})})};
xj.prototype.ec=function(a,b,c,d){return this.Z.ec(c,function(c){a.bb(b,null,c,d)},Bj.get())};var Dj={},Ej=function(a,b,c){var d=b+":"+c;Dj[d]||(Dj[d]=new xj(a,b,c));return Dj[d]},uj=function(a){this.h=a;this.Ab=null;this.cc=[];this.bc=[];this.yb=null;this.Sd=!1};uj.prototype.reset=function(){this.Ab=null;this.yb&&(this.yb.cancel(),this.yb=null)};
uj.prototype.Te=function(a,b){if(!a)return E(new O("invalid-auth-event"));this.reset();this.Sd=!0;var c=a.ma,d=a.Y,e=a.getError()&&"auth/web-storage-unsupported"==a.getError().code,f=a.getError()&&"auth/operation-not-supported-in-this-environment"==a.getError().code;"unknown"!=c||e||f?a=a.ba?this.Pd(a,b):b.Nb(c,d)?this.Qd(a,b):E(new O("invalid-auth-event")):(Fj(this,!1,null,null),a=D());return a};var zj=function(a){a.Sd||(a.Sd=!0,Fj(a,!1,null,null))};
uj.prototype.Pd=function(a){Fj(this,!0,null,a.getError());return D()};uj.prototype.Qd=function(a,b){var c=this;b=b.Nb(a.ma,a.Y);var d=a.Eb,e=a.tc(),f=!!a.ma.match(/Redirect$/);return b(d,e).then(function(a){Fj(c,f,a,null)}).g(function(a){Fj(c,f,null,a)})};
var Gj=function(a,b){a.Ab=function(){return E(b)};if(a.bc.length)for(var c=0;c<a.bc.length;c++)a.bc[c](b)},Hj=function(a,b){a.Ab=function(){return D(b)};if(a.cc.length)for(var c=0;c<a.cc.length;c++)a.cc[c](b)},Fj=function(a,b,c,d){b?d?Gj(a,d):Hj(a,c):Hj(a,{user:null});a.cc=[];a.bc=[]};uj.prototype.getRedirectResult=function(){var a=this;return new C(function(b,c){a.Ab?a.Ab().then(b,c):(a.cc.push(b),a.bc.push(c),Ij(a))})};
var Ij=function(a){var b=new O("timeout");a.yb&&a.yb.cancel();a.yb=Be(Cj.get()).then(function(){a.Ab||Fj(a,!0,null,b)})},vj=function(a){this.h=a};vj.prototype.Te=function(a,b){if(!a)return E(new O("invalid-auth-event"));var c=a.ma,d=a.Y;return a.ba?this.Pd(a,b):b.Nb(c,d)?this.Qd(a,b):E(new O("invalid-auth-event"))};vj.prototype.Pd=function(a,b){b.bb(a.ma,null,a.getError(),a.Y);return D()};
vj.prototype.Qd=function(a,b){var c=a.Y,d=a.ma,e=b.Nb(d,c),f=a.Eb;a=a.tc();return e(f,a).then(function(a){b.bb(d,a,null,c)}).g(function(a){b.bb(d,null,a,c)})};var Jj=function(a){this.f=a;this.Ja=this.fa=null;this.Na=0};Jj.prototype.A=function(){return{apiKey:this.f.m,refreshToken:this.fa,accessToken:this.Ja,expirationTime:this.Na}};
var Lj=function(a,b){var c=b.idToken,d=b.refreshToken;b=Kj(b.expiresIn);a.Ja=c;a.Na=b;a.fa=d},Kj=function(a){return ma()+1E3*parseInt(a,10)},Mj=function(a,b){return hh(a.f,b).then(function(b){a.Ja=b.access_token;a.Na=Kj(b.expires_in);a.fa=b.refresh_token;return{accessToken:a.Ja,expirationTime:a.Na,refreshToken:a.fa}}).g(function(b){"auth/user-token-expired"==b.code&&(a.fa=null);throw b;})};
Jj.prototype.getToken=function(a){a=!!a;return this.Ja&&!this.fa?E(new O("user-token-expired")):a||!this.Ja||ma()>this.Na-3E4?this.fa?Mj(this,{grant_type:"refresh_token",refresh_token:this.fa}):D(null):D({accessToken:this.Ja,expirationTime:this.Na,refreshToken:this.fa})};var Nj=function(a,b){this.pe=a||null;this.Je=b||null;bg(this,{lastSignInTime:Yf(b||null),creationTime:Yf(a||null)})};Nj.prototype.clone=function(){return new Nj(this.pe,this.Je)};Nj.prototype.A=function(){return{lastLoginAt:this.Je,createdAt:this.pe}};var Oj=function(a,b,c,d,e,f){bg(this,{uid:a,displayName:d||null,photoURL:e||null,email:c||null,phoneNumber:f||null,providerId:b})},Pj=function(a,b){B.call(this,a);for(var c in b)this[c]=b[c]};t(Pj,B);
var S=function(a,b,c){this.J=[];this.m=a.apiKey;this.o=a.appName;this.B=a.authDomain||null;a=firebase.SDK_VERSION?Jf(firebase.SDK_VERSION):null;this.f=new R(this.m,of(pf),a);this.ra=new Jj(this.f);Qj(this,b.idToken);Lj(this.ra,b);N(this,"refreshToken",this.ra.fa);Rj(this,c||{});G.call(this);this.Kc=!1;this.B&&Nf()&&(this.v=Ej(this.B,this.m,this.o));this.Rc=[];this.sa=null;this.wb=Sj(this);this.Gb=r(this.wd,this);var d=this;this.ia=null;this.Pe=function(a){d.Cb(a.languageCode)};this.Dd=null;this.M=
[];this.Oe=function(a){Tj(d,a.Ff)};this.sd=null};t(S,G);S.prototype.Cb=function(a){this.ia=a;ah(this.f,a)};var Uj=function(a,b){a.Dd&&tc(a.Dd,"languageCodeChanged",a.Pe);(a.Dd=b)&&lc(b,"languageCodeChanged",a.Pe)},Tj=function(a,b){a.M=b;bh(a.f,firebase.SDK_VERSION?Jf(firebase.SDK_VERSION,a.M):null)},Vj=function(a,b){a.sd&&tc(a.sd,"frameworkChanged",a.Oe);(a.sd=b)&&lc(b,"frameworkChanged",a.Oe)};S.prototype.wd=function(){this.wb.ub&&(this.wb.stop(),this.wb.start())};
var Wj=function(a){try{return firebase.app(a.o).auth()}catch(b){throw new O("internal-error","No firebase.auth.Auth instance is available for the Firebase App '"+a.o+"'!");}},Sj=function(a){return new Li(function(){return a.getIdToken(!0)},function(a){return a&&"auth/network-request-failed"==a.code?!0:!1},function(){var b=a.ra.Na-ma()-3E5;return 0<b?b:0},3E4,96E4,!1)},Xj=function(a){a.Kb||a.wb.ub||(a.wb.start(),tc(a,"tokenChanged",a.Gb),lc(a,"tokenChanged",a.Gb))},Yj=function(a){tc(a,"tokenChanged",
a.Gb);a.wb.stop()},Qj=function(a,b){a.Ie=b;N(a,"_lat",b)},Zj=function(a,b){Ya(a.Rc,function(a){return a==b})},ak=function(a){for(var b=[],c=0;c<a.Rc.length;c++)b.push(a.Rc[c](a));return Bd(b).then(function(){return a})},bk=function(a){a.v&&!a.Kc&&(a.Kc=!0,a.v.subscribe(a))},Rj=function(a,b){bg(a,{uid:b.uid,displayName:b.displayName||null,photoURL:b.photoURL||null,email:b.email||null,emailVerified:b.emailVerified||!1,phoneNumber:b.phoneNumber||null,isAnonymous:b.isAnonymous||!1,metadata:new Nj(b.createdAt,
b.lastLoginAt),providerData:[]})};N(S.prototype,"providerId","firebase");var ck=function(){},dk=function(a){return D().then(function(){if(a.Kb)throw new O("app-deleted");})},ek=function(a){return Ra(a.providerData,function(a){return a.providerId})},gk=function(a,b){b&&(fk(a,b.providerId),a.providerData.push(b))},fk=function(a,b){Ya(a.providerData,function(a){return a.providerId==b})},hk=function(a,b,c){("uid"!=b||c)&&a.hasOwnProperty(b)&&N(a,b,c)};
S.prototype.copy=function(a){var b=this;b!=a&&(bg(this,{uid:a.uid,displayName:a.displayName,photoURL:a.photoURL,email:a.email,emailVerified:a.emailVerified,phoneNumber:a.phoneNumber,isAnonymous:a.isAnonymous,providerData:[]}),a.metadata?N(this,"metadata",a.metadata.clone()):N(this,"metadata",new Nj),x(a.providerData,function(a){gk(b,a)}),this.ra=a.ra,N(this,"refreshToken",this.ra.fa))};S.prototype.reload=function(){var a=this;return this.c(dk(this).then(function(){return ik(a).then(function(){return ak(a)}).then(ck)}))};
var ik=function(a){return a.getIdToken().then(function(b){var c=a.isAnonymous;return jk(a,b).then(function(){c||hk(a,"isAnonymous",!1);return b})})};S.prototype.getIdToken=function(a){var b=this;return this.c(dk(this).then(function(){return b.ra.getToken(a)}).then(function(a){if(!a)throw new O("internal-error");a.accessToken!=b.Ie&&(Qj(b,a.accessToken),b.Ta());hk(b,"refreshToken",a.refreshToken);return a.accessToken}))};
S.prototype.getToken=function(a){Zf["firebase.User.prototype.getToken is deprecated. Please use firebase.User.prototype.getIdToken instead."]||(Zf["firebase.User.prototype.getToken is deprecated. Please use firebase.User.prototype.getIdToken instead."]=!0,"undefined"!==typeof console&&"function"===typeof console.warn&&console.warn("firebase.User.prototype.getToken is deprecated. Please use firebase.User.prototype.getIdToken instead."));return this.getIdToken(a)};
var kk=function(a,b){b.idToken&&a.Ie!=b.idToken&&(Lj(a.ra,b),a.Ta(),Qj(a,b.idToken),hk(a,"refreshToken",a.ra.fa))};S.prototype.Ta=function(){this.dispatchEvent(new Pj("tokenChanged"))};var jk=function(a,b){return Q(a.f,Kh,{idToken:b}).then(r(a.gg,a))};
S.prototype.gg=function(a){a=a.users;if(!a||!a.length)throw new O("internal-error");a=a[0];Rj(this,{uid:a.localId,displayName:a.displayName,photoURL:a.photoUrl,email:a.email,emailVerified:!!a.emailVerified,phoneNumber:a.phoneNumber,lastLoginAt:a.lastLoginAt,createdAt:a.createdAt});for(var b=lk(a),c=0;c<b.length;c++)gk(this,b[c]);hk(this,"isAnonymous",!(this.email&&a.passwordHash)&&!(this.providerData&&this.providerData.length))};
var lk=function(a){return(a=a.providerUserInfo)&&a.length?Ra(a,function(a){return new Oj(a.rawId,a.providerId,a.email,a.displayName,a.photoUrl,a.phoneNumber)}):[]};S.prototype.reauthenticateAndRetrieveDataWithCredential=function(a){var b=this,c=null;return this.c(a.Gd(this.f,this.uid).then(function(a){kk(b,a);c=mk(b,a,"reauthenticate");b.sa=null;return b.reload()}).then(function(){return c}),!0)};S.prototype.reauthenticateWithCredential=function(a){return this.reauthenticateAndRetrieveDataWithCredential(a).then(function(){})};
var nk=function(a,b){return ik(a).then(function(){if(Va(ek(a),b))return ak(a).then(function(){throw new O("provider-already-linked");})})};S.prototype.linkAndRetrieveDataWithCredential=function(a){var b=this,c=null;return this.c(nk(this,a.providerId).then(function(){return b.getIdToken()}).then(function(c){return a.Fc(b.f,c)}).then(function(a){c=mk(b,a,"link");return ok(b,a)}).then(function(){return c}))};S.prototype.linkWithCredential=function(a){return this.linkAndRetrieveDataWithCredential(a).then(function(a){return a.user})};
S.prototype.linkWithPhoneNumber=function(a,b){var c=this;return this.c(nk(this,"phone").then(function(){return Ji(Wj(c),a,b,r(c.linkAndRetrieveDataWithCredential,c))}))};S.prototype.reauthenticateWithPhoneNumber=function(a,b){var c=this;return this.c(D().then(function(){return Ji(Wj(c),a,b,r(c.reauthenticateAndRetrieveDataWithCredential,c))}),!0)};var mk=function(a,b,c){var d=Rg(b);b=Ui(b);return cg({user:a,credential:d,additionalUserInfo:b,operationType:c})},ok=function(a,b){kk(a,b);return a.reload().then(function(){return a})};
h=S.prototype;h.updateEmail=function(a){var b=this;return this.c(this.getIdToken().then(function(c){return b.f.updateEmail(c,a)}).then(function(a){kk(b,a);return b.reload()}))};h.updatePhoneNumber=function(a){var b=this;return this.c(this.getIdToken().then(function(c){return a.Fc(b.f,c)}).then(function(a){kk(b,a);return b.reload()}))};h.updatePassword=function(a){var b=this;return this.c(this.getIdToken().then(function(c){return b.f.updatePassword(c,a)}).then(function(a){kk(b,a);return b.reload()}))};
h.updateProfile=function(a){if(void 0===a.displayName&&void 0===a.photoURL)return dk(this);var b=this;return this.c(this.getIdToken().then(function(c){return b.f.updateProfile(c,{displayName:a.displayName,photoUrl:a.photoURL})}).then(function(a){kk(b,a);hk(b,"displayName",a.displayName||null);hk(b,"photoURL",a.photoUrl||null);x(b.providerData,function(a){"password"===a.providerId&&(N(a,"displayName",b.displayName),N(a,"photoURL",b.photoURL))});return ak(b)}).then(ck))};
h.unlink=function(a){var b=this;return this.c(ik(this).then(function(c){return Va(ek(b),a)?yh(b.f,c,[a]).then(function(a){var c={};x(a.providerUserInfo||[],function(a){c[a.providerId]=!0});x(ek(b),function(a){c[a]||fk(b,a)});c[Og.PROVIDER_ID]||N(b,"phoneNumber",null);return ak(b)}):ak(b).then(function(){throw new O("no-such-provider");})}))};
h["delete"]=function(){var a=this;return this.c(this.getIdToken().then(function(b){return Q(a.f,Jh,{idToken:b})}).then(function(){a.dispatchEvent(new Pj("userDeleted"))})).then(function(){for(var b=0;b<a.J.length;b++)a.J[b].cancel("app-deleted");Uj(a,null);Vj(a,null);a.J=[];a.Kb=!0;Yj(a);N(a,"refreshToken",null);a.v&&a.v.unsubscribe(a)})};
h.ke=function(a,b){return"linkViaPopup"==a&&(this.la||null)==b&&this.ka||"reauthViaPopup"==a&&(this.la||null)==b&&this.ka||"linkViaRedirect"==a&&(this.Ha||null)==b||"reauthViaRedirect"==a&&(this.Ha||null)==b?!0:!1};h.bb=function(a,b,c,d){"linkViaPopup"!=a&&"reauthViaPopup"!=a||d!=(this.la||null)||(c&&this.Va?this.Va(c):b&&!c&&this.ka&&this.ka(b),this.K&&(this.K.cancel(),this.K=null),delete this.ka,delete this.Va)};
h.Nb=function(a,b){return"linkViaPopup"==a&&b==(this.la||null)?r(this.ue,this):"reauthViaPopup"==a&&b==(this.la||null)?r(this.ve,this):"linkViaRedirect"==a&&(this.Ha||null)==b?r(this.ue,this):"reauthViaRedirect"==a&&(this.Ha||null)==b?r(this.ve,this):null};h.sc=function(){return Kf(this.uid+":::")};h.linkWithPopup=function(a){var b=this;return pk(this,"linkViaPopup",a,function(){return nk(b,a.providerId).then(function(){return ak(b)})},!1)};
h.reauthenticateWithPopup=function(a){return pk(this,"reauthViaPopup",a,function(){return D()},!0)};
var pk=function(a,b,c,d,e){if(!Nf())return E(new O("operation-not-supported-in-this-environment"));if(a.sa&&!e)return E(a.sa);var f=jg(c.providerId),g=a.sc(),l=null;(!Of()||Ff())&&a.B&&c.isOAuthProvider&&(l=ci(a.B,a.m,a.o,b,c,null,g,firebase.SDK_VERSION||null));var n=yf(l,f&&f.Zb,f&&f.Yb);d=d().then(function(){qk(a);if(!e)return a.getIdToken().then(function(){})}).then(function(){return a.v.$b(n,b,c,g,!!l)}).then(function(){return new C(function(c,d){a.bb(b,null,new O("cancelled-popup-request"),a.la||
null);a.ka=c;a.Va=d;a.la=g;a.K=a.v.ec(a,b,n,g)})}).then(function(a){n&&xf(n);return a?cg(a):null}).g(function(a){n&&xf(n);throw a;});return a.c(d,e)};S.prototype.linkWithRedirect=function(a){var b=this;return rk(this,"linkViaRedirect",a,function(){return nk(b,a.providerId)},!1)};S.prototype.reauthenticateWithRedirect=function(a){return rk(this,"reauthViaRedirect",a,function(){return D()},!0)};
var rk=function(a,b,c,d,e){if(!Nf())return E(new O("operation-not-supported-in-this-environment"));if(a.sa&&!e)return E(a.sa);var f=null,g=a.sc();d=d().then(function(){qk(a);if(!e)return a.getIdToken().then(function(){})}).then(function(){a.Ha=g;return ak(a)}).then(function(b){a.Ya&&(b=a.Ya,b=b.h.set(sk,a.A(),b.j));return b}).then(function(){return a.v.ac(b,c,g)}).g(function(b){f=b;if(a.Ya)return tk(a.Ya);throw f;}).then(function(){if(f)throw f;});return a.c(d,e)},qk=function(a){if(!a.v||!a.Kc){if(a.v&&
!a.Kc)throw new O("internal-error");throw new O("auth-domain-config-required");}};S.prototype.ue=function(a,b){var c=this;this.K&&(this.K.cancel(),this.K=null);var d=null,e=this.getIdToken().then(function(d){return vg(c.f,{requestUri:a,sessionId:b,idToken:d})}).then(function(a){d=mk(c,a,"link");return ok(c,a)}).then(function(){return d});return this.c(e)};
S.prototype.ve=function(a,b){var c=this;this.K&&(this.K.cancel(),this.K=null);var d=null,e=D().then(function(){return rg(wg(c.f,{requestUri:a,sessionId:b}),c.uid)}).then(function(a){d=mk(c,a,"reauthenticate");kk(c,a);c.sa=null;return c.reload()}).then(function(){return d});return this.c(e,!0)};
S.prototype.sendEmailVerification=function(a){var b=this,c=null;return this.c(this.getIdToken().then(function(b){c=b;return"undefined"===typeof a||ib(a)?{}:Hi(new Gi(a))}).then(function(a){return b.f.sendEmailVerification(c,a)}).then(function(a){if(b.email!=a)return b.reload()}).then(function(){}))};S.prototype.c=function(a,b){var c=this,d=uk(this,a,b);this.J.push(d);Ed(d,function(){Xa(c.J,d)});return d};
var uk=function(a,b,c){return a.sa&&!c?(b.cancel(),E(a.sa)):b.g(function(b){!b||"auth/user-disabled"!=b.code&&"auth/user-token-expired"!=b.code||(a.sa||a.dispatchEvent(new Pj("userInvalidated")),a.sa=b);throw b;})};S.prototype.toJSON=function(){return this.A()};
S.prototype.A=function(){var a={uid:this.uid,displayName:this.displayName,photoURL:this.photoURL,email:this.email,emailVerified:this.emailVerified,phoneNumber:this.phoneNumber,isAnonymous:this.isAnonymous,providerData:[],apiKey:this.m,appName:this.o,authDomain:this.B,stsTokenManager:this.ra.A(),redirectEventId:this.Ha||null};this.metadata&&mb(a,this.metadata.A());x(this.providerData,function(b){a.providerData.push(dg(b))});return a};
var vk=function(a){if(!a.apiKey)return null;var b={apiKey:a.apiKey,authDomain:a.authDomain,appName:a.appName},c={};if(a.stsTokenManager&&a.stsTokenManager.accessToken&&a.stsTokenManager.expirationTime)c.idToken=a.stsTokenManager.accessToken,c.refreshToken=a.stsTokenManager.refreshToken||null,c.expiresIn=(a.stsTokenManager.expirationTime-ma())/1E3;else return null;var d=new S(b,c,a);a.providerData&&x(a.providerData,function(a){a&&gk(d,cg(a))});a.redirectEventId&&(d.Ha=a.redirectEventId);return d},
wk=function(a,b,c,d){var e=new S(a,b);c&&(e.Ya=c);d&&Tj(e,d);return e.reload().then(function(){return e})};var xk=function(a){this.j=a;this.h=Zi()},sk={name:"redirectUser",D:"session"},tk=function(a){return a.h.remove(sk,a.j)},yk=function(a,b){return a.h.get(sk,a.j).then(function(a){a&&b&&(a.authDomain=b);return vk(a||{})})};var Ak=function(a,b){this.j=a;this.h=b||Zi();this.O=null;this.Jd=this.Bd();this.h.addListener(zk("local"),this.j,r(this.vg,this))};Ak.prototype.vg=function(){var a=this,b=zk("local");Bk(this,function(){return D().then(function(){return a.O&&"local"!=a.O.D?a.h.get(b,a.j):null}).then(function(c){if(c)return Ck(a,"local").then(function(){a.O=b})})})};var Ck=function(a,b){var c=[],d;for(d in Vi)Vi[d]!==b&&c.push(a.h.remove(zk(Vi[d]),a.j));c.push(a.h.remove(Dk,a.j));return Ad(c)};
Ak.prototype.Bd=function(){var a=this,b=zk("local"),c=zk("session"),d=zk("none");return this.h.get(c,this.j).then(function(e){return e?c:a.h.get(d,a.j).then(function(c){return c?d:a.h.get(b,a.j).then(function(c){return c?b:a.h.get(Dk,a.j).then(function(a){return a?zk(a):b})})})}).then(function(b){a.O=b;return Ck(a,b.D)}).g(function(){a.O||(a.O=b)})};var Dk={name:"persistence",D:"session"},zk=function(a){return{name:"authUser",D:a}};
Ak.prototype.setPersistence=function(a){var b=null,c=this;Wi(a);return Bk(this,function(){return a!=c.O.D?c.h.get(c.O,c.j).then(function(d){b=d;return Ck(c,a)}).then(function(){c.O=zk(a);if(b)return c.h.set(c.O,b,c.j)}):D()})};
var Ek=function(a){return Bk(a,function(){return a.h.set(Dk,a.O.D,a.j)})},Fk=function(a,b){return Bk(a,function(){return a.h.set(a.O,b.A(),a.j)})},Gk=function(a){return Bk(a,function(){return a.h.remove(a.O,a.j)})},Hk=function(a,b){return Bk(a,function(){return a.h.get(a.O,a.j).then(function(a){a&&b&&(a.authDomain=b);return vk(a||{})})})},Bk=function(a,b){a.Jd=a.Jd.then(b,b);return a.Jd};var T=function(a){this.Ea=!1;N(this,"app",a);if(this.i().options&&this.i().options.apiKey)a=firebase.SDK_VERSION?Jf(firebase.SDK_VERSION):null,this.f=new R(this.i().options&&this.i().options.apiKey,of(pf),a);else throw new O("invalid-api-key");this.J=[];this.Ka=[];this.Fb=[];this.cg=firebase.INTERNAL.createSubscribe(r(this.Sf,this));this.kc=void 0;this.eg=firebase.INTERNAL.createSubscribe(r(this.Uf,this));Ik(this,null);a=this.i().options.apiKey;var b=this.i().name;this.na=new Ak(a+":"+b);a=this.i().options.apiKey;
b=this.i().name;this.zb=new xk(a+":"+b);this.oc=this.c(Jk(this));this.ya=this.c(Kk(this));this.Cc=!1;this.ud=r(this.wg,this);this.ef=r(this.pb,this);this.Gb=r(this.wd,this);this.cf=r(this.Of,this);this.df=r(this.Pf,this);Lk(this);this.INTERNAL={};this.INTERNAL["delete"]=r(this["delete"],this);this.INTERNAL.logFramework=r(this.$f,this);this.Oa=0;G.call(this);Mk(this);this.M=[]};t(T,G);var Nk=function(a){B.call(this,"languageCodeChanged");this.languageCode=a};t(Nk,B);
var Ok=function(a){B.call(this,"frameworkChanged");this.Ff=a};t(Ok,B);T.prototype.setPersistence=function(a){a=this.na.setPersistence(a);return this.c(a)};T.prototype.Cb=function(a){this.ia===a||this.Ea||(this.ia=a,ah(this.f,this.ia),this.dispatchEvent(new Nk(this.ia)))};T.prototype.useDeviceLanguage=function(){var a=k.navigator;this.Cb(a?a.languages&&a.languages[0]||a.language||a.userLanguage||null:null)};
T.prototype.$f=function(a){this.M.push(a);bh(this.f,firebase.SDK_VERSION?Jf(firebase.SDK_VERSION,this.M):null);this.dispatchEvent(new Ok(this.M))};var Mk=function(a){Object.defineProperty(a,"lc",{get:function(){return this.ia},set:function(a){this.Cb(a)},enumerable:!1});a.ia=null};T.prototype.toJSON=function(){return{apiKey:this.i().options.apiKey,authDomain:this.i().options.authDomain,appName:this.i().name,currentUser:U(this)&&U(this).A()}};
var Pk=function(a){return a.Af||E(new O("auth-domain-config-required"))},Lk=function(a){var b=a.i().options.authDomain,c=a.i().options.apiKey;b&&Nf()&&(a.Af=a.oc.then(function(){if(!a.Ea){a.v=Ej(b,c,a.i().name);a.v.subscribe(a);U(a)&&bk(U(a));if(a.Za){bk(a.Za);var d=a.Za;d.Cb(a.ia);Uj(d,a);d=a.Za;Tj(d,a.M);Vj(d,a);a.Za=null}return a.v}}))};h=T.prototype;h.ke=function(a,b){switch(a){case "unknown":case "signInViaRedirect":return!0;case "signInViaPopup":return this.la==b&&!!this.ka;default:return!1}};
h.bb=function(a,b,c,d){"signInViaPopup"==a&&this.la==d&&(c&&this.Va?this.Va(c):b&&!c&&this.ka&&this.ka(b),this.K&&(this.K.cancel(),this.K=null),delete this.ka,delete this.Va)};h.Nb=function(a,b){return"signInViaRedirect"==a||"signInViaPopup"==a&&this.la==b&&this.ka?r(this.Cf,this):null};
h.Cf=function(a,b){var c=this;a={requestUri:a,sessionId:b};this.K&&(this.K.cancel(),this.K=null);var d=null,e=null,f=tg(c.f,a).then(function(a){d=Rg(a);e=Ui(a);return a});a=c.oc.then(function(){return f}).then(function(a){return Qk(c,a)}).then(function(){return cg({user:U(c),credential:d,additionalUserInfo:e,operationType:"signIn"})});return this.c(a)};h.sc=function(){return Kf()};
h.signInWithPopup=function(a){if(!Nf())return E(new O("operation-not-supported-in-this-environment"));var b=this,c=jg(a.providerId),d=this.sc(),e=null;(!Of()||Ff())&&this.i().options.authDomain&&a.isOAuthProvider&&(e=ci(this.i().options.authDomain,this.i().options.apiKey,this.i().name,"signInViaPopup",a,null,d,firebase.SDK_VERSION||null));var f=yf(e,c&&c.Zb,c&&c.Yb);c=Pk(this).then(function(b){return b.$b(f,"signInViaPopup",a,d,!!e)}).then(function(){return new C(function(a,c){b.bb("signInViaPopup",
null,new O("cancelled-popup-request"),b.la);b.ka=a;b.Va=c;b.la=d;b.K=b.v.ec(b,"signInViaPopup",f,d)})}).then(function(a){f&&xf(f);return a?cg(a):null}).g(function(a){f&&xf(f);throw a;});return this.c(c)};h.signInWithRedirect=function(a){if(!Nf())return E(new O("operation-not-supported-in-this-environment"));var b=this,c=Pk(this).then(function(){return Ek(b.na)}).then(function(){return b.v.ac("signInViaRedirect",a)});return this.c(c)};
h.getRedirectResult=function(){if(!Nf())return E(new O("operation-not-supported-in-this-environment"));var a=this,b=Pk(this).then(function(){return a.v.getRedirectResult()}).then(function(a){return a?cg(a):null});return this.c(b)};
var Qk=function(a,b){var c={};c.apiKey=a.i().options.apiKey;c.authDomain=a.i().options.authDomain;c.appName=a.i().name;return a.oc.then(function(){return wk(c,b,a.zb,$a(a.M))}).then(function(b){if(U(a)&&b.uid==U(a).uid)return U(a).copy(b),a.pb(b);Ik(a,b);bk(b);return a.pb(b)}).then(function(){a.Ta()})},Ik=function(a,b){U(a)&&(Zj(U(a),a.ef),tc(U(a),"tokenChanged",a.Gb),tc(U(a),"userDeleted",a.cf),tc(U(a),"userInvalidated",a.df),Yj(U(a)));b&&(b.Rc.push(a.ef),lc(b,"tokenChanged",a.Gb),lc(b,"userDeleted",
a.cf),lc(b,"userInvalidated",a.df),0<a.Oa&&Xj(b));N(a,"currentUser",b);b&&(b.Cb(a.ia),Uj(b,a),Tj(b,a.M),Vj(b,a))};T.prototype.signOut=function(){var a=this,b=this.ya.then(function(){if(!U(a))return D();Ik(a,null);return Gk(a.na).then(function(){a.Ta()})});return this.c(b)};
var Rk=function(a){var b=a.i().options.authDomain;b=yk(a.zb,b).then(function(b){if(a.Za=b)b.Ya=a.zb;return tk(a.zb)});return a.c(b)},Jk=function(a){var b=a.i().options.authDomain,c=Rk(a).then(function(){return Hk(a.na,b)}).then(function(b){return b?(b.Ya=a.zb,a.Za&&(a.Za.Ha||null)==(b.Ha||null)?b:b.reload().then(function(){return Fk(a.na,b).then(function(){return b})}).g(function(c){return"auth/network-request-failed"==c.code?b:Gk(a.na)})):null}).then(function(b){Ik(a,b||null)});return a.c(c)},Kk=
function(a){return a.oc.then(function(){return a.getRedirectResult()}).g(function(){}).then(function(){if(!a.Ea)return a.ud()}).g(function(){}).then(function(){if(!a.Ea){a.Cc=!0;var b=a.na;b.h.addListener(zk("local"),b.j,a.ud)}})};h=T.prototype;
h.wg=function(){var a=this,b=this.i().options.authDomain;return Hk(this.na,b).then(function(b){if(!a.Ea){var c;if(c=U(a)&&b){c=U(a).uid;var e=b.uid;c=void 0===c||null===c||""===c||void 0===e||null===e||""===e?!1:c==e}if(c)return U(a).copy(b),U(a).getIdToken();if(U(a)||b)Ik(a,b),b&&(bk(b),b.Ya=a.zb),a.v&&a.v.subscribe(a),a.Ta()}})};h.pb=function(a){return Fk(this.na,a)};h.wd=function(){this.Ta();this.pb(U(this))};h.Of=function(){this.signOut()};h.Pf=function(){this.signOut()};
var Sk=function(a,b){var c=null,d=null;return a.c(b.then(function(b){c=Rg(b);d=Ui(b);return Qk(a,b)}).then(function(){return cg({user:U(a),credential:c,additionalUserInfo:d,operationType:"signIn"})}))};h=T.prototype;h.Sf=function(a){var b=this;this.addAuthTokenListener(function(){a.next(U(b))})};h.Uf=function(a){var b=this;Tk(this,function(){a.next(U(b))})};
h.onIdTokenChanged=function(a,b,c){var d=this;this.Cc&&firebase.Promise.resolve().then(function(){p(a)?a(U(d)):p(a.next)&&a.next(U(d))});return this.cg(a,b,c)};h.onAuthStateChanged=function(a,b,c){var d=this;this.Cc&&firebase.Promise.resolve().then(function(){d.kc=d.getUid();p(a)?a(U(d)):p(a.next)&&a.next(U(d))});return this.eg(a,b,c)};h.If=function(a){var b=this,c=this.ya.then(function(){return U(b)?U(b).getIdToken(a).then(function(a){return{accessToken:a}}):null});return this.c(c)};
h.signInWithCustomToken=function(a){var b=this;return this.ya.then(function(){return Sk(b,Q(b.f,Mh,{token:a}))}).then(function(a){a=a.user;hk(a,"isAnonymous",!1);return b.pb(a)}).then(function(){return U(b)})};h.signInWithEmailAndPassword=function(a,b){var c=this;return this.ya.then(function(){return Sk(c,Q(c.f,Hg,{email:a,password:b}))}).then(function(a){return a.user})};h.createUserWithEmailAndPassword=function(a,b){var c=this;return this.ya.then(function(){return Sk(c,Q(c.f,Ih,{email:a,password:b}))}).then(function(a){return a.user})};
h.signInWithCredential=function(a){return this.signInAndRetrieveDataWithCredential(a).then(function(a){return a.user})};h.signInAndRetrieveDataWithCredential=function(a){var b=this;return this.ya.then(function(){return Sk(b,a.Ob(b.f))})};h.signInAnonymously=function(){var a=this;return this.ya.then(function(){var b=U(a);return b&&b.isAnonymous?b:Sk(a,a.f.signInAnonymously()).then(function(b){b=b.user;hk(b,"isAnonymous",!0);return a.pb(b)}).then(function(){return U(a)})})};h.i=function(){return this.app};
var U=function(a){return a.currentUser};T.prototype.getUid=function(){return U(this)&&U(this).uid||null};var Uk=function(a){return U(a)&&U(a)._lat||null};h=T.prototype;h.Ta=function(){if(this.Cc){for(var a=0;a<this.Ka.length;a++)if(this.Ka[a])this.Ka[a](Uk(this));if(this.kc!==this.getUid()&&this.Fb.length)for(this.kc=this.getUid(),a=0;a<this.Fb.length;a++)if(this.Fb[a])this.Fb[a](Uk(this))}};h.pf=function(a){this.addAuthTokenListener(a);this.Oa++;0<this.Oa&&U(this)&&Xj(U(this))};
h.jg=function(a){var b=this;x(this.Ka,function(c){c==a&&b.Oa--});0>this.Oa&&(this.Oa=0);0==this.Oa&&U(this)&&Yj(U(this));this.removeAuthTokenListener(a)};h.addAuthTokenListener=function(a){var b=this;this.Ka.push(a);this.c(this.ya.then(function(){b.Ea||Va(b.Ka,a)&&a(Uk(b))}))};h.removeAuthTokenListener=function(a){Ya(this.Ka,function(b){return b==a})};var Tk=function(a,b){a.Fb.push(b);a.c(a.ya.then(function(){!a.Ea&&Va(a.Fb,b)&&a.kc!==a.getUid()&&(a.kc=a.getUid(),b(Uk(a)))}))};h=T.prototype;
h["delete"]=function(){this.Ea=!0;for(var a=0;a<this.J.length;a++)this.J[a].cancel("app-deleted");this.J=[];this.na&&(a=this.na,a.h.removeListener(zk("local"),a.j,this.ud));this.v&&this.v.unsubscribe(this);return firebase.Promise.resolve()};h.c=function(a){var b=this;this.J.push(a);Ed(a,function(){Xa(b.J,a)});return a};h.fetchProvidersForEmail=function(a){return this.c(mh(this.f,a))};h.verifyPasswordResetCode=function(a){return this.checkActionCode(a).then(function(a){return a.data.email})};
h.confirmPasswordReset=function(a,b){return this.c(this.f.confirmPasswordReset(a,b).then(function(){}))};h.checkActionCode=function(a){return this.c(this.f.checkActionCode(a).then(function(a){return new Ki(a)}))};h.applyActionCode=function(a){return this.c(this.f.applyActionCode(a).then(function(){}))};h.sendPasswordResetEmail=function(a,b){var c=this;return this.c(D().then(function(){return"undefined"===typeof b||ib(b)?{}:Hi(new Gi(b))}).then(function(b){return c.f.sendPasswordResetEmail(a,b)}).then(function(){}))};
h.signInWithPhoneNumber=function(a,b){return this.c(Ji(this,a,b,r(this.signInAndRetrieveDataWithCredential,this)))};var Wk=function(a,b,c,d){a:{c=Array.prototype.slice.call(c);var e=0;for(var f=!1,g=0;g<b.length;g++)if(b[g].optional)f=!0;else{if(f)throw new O("internal-error","Argument validator encountered a required argument after an optional argument.");e++}f=b.length;if(c.length<e||f<c.length)d="Expected "+(e==f?1==e?"1 argument":e+" arguments":e+"-"+f+" arguments")+" but got "+c.length+".";else{for(e=0;e<c.length;e++)if(f=b[e].optional&&void 0===c[e],!b[e].W(c[e])&&!f){b=b[e];if(0>e||e>=Vk.length)throw new O("internal-error",
"Argument validator received an unsupported number of arguments.");c=Vk[e];d=(d?"":c+" argument ")+(b.name?'"'+b.name+'" ':"")+"must be "+b.V+".";break a}d=null}}if(d)throw new O("argument-error",a+" failed: "+d);},Vk="First Second Third Fourth Fifth Sixth Seventh Eighth Ninth".split(" "),V=function(a,b){return{name:a||"",V:"a valid string",optional:!!b,W:m}},Xk=function(){return{name:"opt_forceRefresh",V:"a boolean",optional:!0,W:ca}},W=function(a,b){return{name:a||"",V:"a valid object",optional:!!b,
W:q}},Yk=function(a,b){return{name:a||"",V:"a function",optional:!!b,W:p}},Zk=function(a,b){return{name:a||"",V:"null",optional:!!b,W:fa}},$k=function(){return{name:"",V:"an HTML element",optional:!1,W:function(a){return!!(a&&a instanceof Element)}}},al=function(){return{name:"auth",V:"an instance of Firebase Auth",optional:!0,W:function(a){return!!(a&&a instanceof T)}}},bl=function(){return{name:"app",V:"an instance of Firebase App",optional:!0,W:function(a){return!!(a&&a instanceof firebase.app.App)}}},
cl=function(a){return{name:a?a+"Credential":"credential",V:a?"a valid "+a+" credential":"a valid credential",optional:!1,W:function(b){if(!b)return!1;var c=!a||b.providerId===a;return!(!b.Ob||!c)}}},dl=function(){return{name:"authProvider",V:"a valid Auth provider",optional:!1,W:function(a){return!!(a&&a.providerId&&a.hasOwnProperty&&a.hasOwnProperty("isOAuthProvider"))}}},el=function(){return{name:"applicationVerifier",V:"an implementation of firebase.auth.ApplicationVerifier",optional:!1,W:function(a){return!!(a&&
m(a.type)&&p(a.verify))}}},X=function(a,b,c,d){return{name:c||"",V:a.V+" or "+b.V,optional:!!d,W:function(c){return a.W(c)||b.W(c)}}};var Y=function(a,b){for(var c in b){var d=b[c].name;a[d]=fl(d,a[c],b[c].a)}},Z=function(a,b,c,d){a[b]=fl(b,c,d)},fl=function(a,b,c){if(!c)return b;var d=gl(a);a=function(){var a=Array.prototype.slice.call(arguments);Wk(d,c,a);return b.apply(this,a)};for(var e in b)a[e]=b[e];for(e in b.prototype)a.prototype[e]=b.prototype[e];return a},gl=function(a){a=a.split(".");return a[a.length-1]};Y(T.prototype,{applyActionCode:{name:"applyActionCode",a:[V("code")]},checkActionCode:{name:"checkActionCode",a:[V("code")]},confirmPasswordReset:{name:"confirmPasswordReset",a:[V("code"),V("newPassword")]},createUserWithEmailAndPassword:{name:"createUserWithEmailAndPassword",a:[V("email"),V("password")]},fetchProvidersForEmail:{name:"fetchProvidersForEmail",a:[V("email")]},getRedirectResult:{name:"getRedirectResult",a:[]},onAuthStateChanged:{name:"onAuthStateChanged",a:[X(W(),Yk(),"nextOrObserver"),
Yk("opt_error",!0),Yk("opt_completed",!0)]},onIdTokenChanged:{name:"onIdTokenChanged",a:[X(W(),Yk(),"nextOrObserver"),Yk("opt_error",!0),Yk("opt_completed",!0)]},sendPasswordResetEmail:{name:"sendPasswordResetEmail",a:[V("email"),X(W("opt_actionCodeSettings",!0),Zk(null,!0),"opt_actionCodeSettings",!0)]},setPersistence:{name:"setPersistence",a:[V("persistence")]},signInAndRetrieveDataWithCredential:{name:"signInAndRetrieveDataWithCredential",a:[cl()]},signInAnonymously:{name:"signInAnonymously",a:[]},
signInWithCredential:{name:"signInWithCredential",a:[cl()]},signInWithCustomToken:{name:"signInWithCustomToken",a:[V("token")]},signInWithEmailAndPassword:{name:"signInWithEmailAndPassword",a:[V("email"),V("password")]},signInWithPhoneNumber:{name:"signInWithPhoneNumber",a:[V("phoneNumber"),el()]},signInWithPopup:{name:"signInWithPopup",a:[dl()]},signInWithRedirect:{name:"signInWithRedirect",a:[dl()]},signOut:{name:"signOut",a:[]},toJSON:{name:"toJSON",a:[V(null,!0)]},useDeviceLanguage:{name:"useDeviceLanguage",
a:[]},verifyPasswordResetCode:{name:"verifyPasswordResetCode",a:[V("code")]}});(function(a,b){for(var c in b){var d=b[c].name;if(d!==c){var e=b[c].rf;Object.defineProperty(a,d,{get:function(){return this[c]},set:function(a){Wk(d,[e],[a],!0);this[c]=a},enumerable:!0})}}})(T.prototype,{lc:{name:"languageCode",rf:X(V(),Zk(),"languageCode")}});T.Persistence=Vi;T.Persistence.LOCAL="local";T.Persistence.SESSION="session";T.Persistence.NONE="none";
Y(S.prototype,{"delete":{name:"delete",a:[]},getIdToken:{name:"getIdToken",a:[Xk()]},getToken:{name:"getToken",a:[Xk()]},linkAndRetrieveDataWithCredential:{name:"linkAndRetrieveDataWithCredential",a:[cl()]},linkWithCredential:{name:"linkWithCredential",a:[cl()]},linkWithPhoneNumber:{name:"linkWithPhoneNumber",a:[V("phoneNumber"),el()]},linkWithPopup:{name:"linkWithPopup",a:[dl()]},linkWithRedirect:{name:"linkWithRedirect",a:[dl()]},reauthenticateAndRetrieveDataWithCredential:{name:"reauthenticateAndRetrieveDataWithCredential",
a:[cl()]},reauthenticateWithCredential:{name:"reauthenticateWithCredential",a:[cl()]},reauthenticateWithPhoneNumber:{name:"reauthenticateWithPhoneNumber",a:[V("phoneNumber"),el()]},reauthenticateWithPopup:{name:"reauthenticateWithPopup",a:[dl()]},reauthenticateWithRedirect:{name:"reauthenticateWithRedirect",a:[dl()]},reload:{name:"reload",a:[]},sendEmailVerification:{name:"sendEmailVerification",a:[X(W("opt_actionCodeSettings",!0),Zk(null,!0),"opt_actionCodeSettings",!0)]},toJSON:{name:"toJSON",a:[V(null,
!0)]},unlink:{name:"unlink",a:[V("provider")]},updateEmail:{name:"updateEmail",a:[V("email")]},updatePassword:{name:"updatePassword",a:[V("password")]},updatePhoneNumber:{name:"updatePhoneNumber",a:[cl("phone")]},updateProfile:{name:"updateProfile",a:[W("profile")]}});Y(C.prototype,{g:{name:"catch"},then:{name:"then"}});Y(Ii.prototype,{confirm:{name:"confirm",a:[V("verificationCode")]}});Z(Jg,"credential",function(a,b){return new Gg(a,b)},[V("email"),V("password")]);
Y(yg.prototype,{addScope:{name:"addScope",a:[V("scope")]},setCustomParameters:{name:"setCustomParameters",a:[W("customOAuthParameters")]}});Z(yg,"credential",zg,[X(V(),W(),"token")]);Y(Ag.prototype,{addScope:{name:"addScope",a:[V("scope")]},setCustomParameters:{name:"setCustomParameters",a:[W("customOAuthParameters")]}});Z(Ag,"credential",Bg,[X(V(),W(),"token")]);Y(Cg.prototype,{addScope:{name:"addScope",a:[V("scope")]},setCustomParameters:{name:"setCustomParameters",a:[W("customOAuthParameters")]}});
Z(Cg,"credential",Dg,[X(V(),X(W(),Zk()),"idToken"),X(V(),Zk(),"accessToken",!0)]);Y(Eg.prototype,{setCustomParameters:{name:"setCustomParameters",a:[W("customOAuthParameters")]}});Z(Eg,"credential",Fg,[X(V(),W(),"token"),V("secret",!0)]);Y(P.prototype,{addScope:{name:"addScope",a:[V("scope")]},credential:{name:"credential",a:[X(V(),Zk(),"idToken",!0),X(V(),Zk(),"accessToken",!0)]},setCustomParameters:{name:"setCustomParameters",a:[W("customOAuthParameters")]}});
Z(Og,"credential",Qg,[V("verificationId"),V("verificationCode")]);Y(Og.prototype,{verifyPhoneNumber:{name:"verifyPhoneNumber",a:[V("phoneNumber"),el()]}});Y(O.prototype,{toJSON:{name:"toJSON",a:[V(null,!0)]}});Y(Tg.prototype,{toJSON:{name:"toJSON",a:[V(null,!0)]}});Y(og.prototype,{toJSON:{name:"toJSON",a:[V(null,!0)]}});Y(li.prototype,{clear:{name:"clear",a:[]},render:{name:"render",a:[]},verify:{name:"verify",a:[]}});
(function(){if("undefined"!==typeof firebase&&firebase.INTERNAL&&firebase.INTERNAL.registerService){var a={Auth:T,Error:O};Z(a,"EmailAuthProvider",Jg,[]);Z(a,"FacebookAuthProvider",yg,[]);Z(a,"GithubAuthProvider",Ag,[]);Z(a,"GoogleAuthProvider",Cg,[]);Z(a,"TwitterAuthProvider",Eg,[]);Z(a,"OAuthProvider",P,[V("providerId")]);Z(a,"PhoneAuthProvider",Og,[al()]);Z(a,"RecaptchaVerifier",li,[X(V(),$k(),"recaptchaContainer"),W("recaptchaParameters",!0),bl()]);firebase.INTERNAL.registerService("auth",function(a,
c){a=new T(a);c({INTERNAL:{getUid:r(a.getUid,a),getToken:r(a.If,a),addAuthTokenListener:r(a.pf,a),removeAuthTokenListener:r(a.jg,a)}});return a},a,function(a,c){if("create"===a)try{c.auth()}catch(d){}});firebase.INTERNAL.extendNamespace({User:S})}else throw Error("Cannot find the firebase namespace; be sure to include firebase-app.js before this library.");})();}).call(this);
}).call(typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});

/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (immutable) */ __webpack_exports__["registerDatabase"] = registerDatabase;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_api_Database__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_api_Query__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_api_Reference__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_core_util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_core_RepoManager__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_api_internal__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_api_test_access__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









function registerDatabase(instance) {
    // Register the Database Service with the 'firebase' namespace.
    var namespace = instance.INTERNAL.registerService('database', function (app, unused, url) { return __WEBPACK_IMPORTED_MODULE_5__src_core_RepoManager__["a" /* RepoManager */].getInstance().databaseFromApp(app, url); }, 
    // firebase.database namespace properties
    {
        Reference: __WEBPACK_IMPORTED_MODULE_3__src_api_Reference__["a" /* Reference */],
        Query: __WEBPACK_IMPORTED_MODULE_2__src_api_Query__["a" /* Query */],
        Database: __WEBPACK_IMPORTED_MODULE_1__src_api_Database__["a" /* Database */],
        enableLogging: __WEBPACK_IMPORTED_MODULE_4__src_core_util_util__["a" /* enableLogging */],
        INTERNAL: __WEBPACK_IMPORTED_MODULE_6__src_api_internal__,
        ServerValue: __WEBPACK_IMPORTED_MODULE_1__src_api_Database__["a" /* Database */].ServerValue,
        TEST_ACCESS: __WEBPACK_IMPORTED_MODULE_7__src_api_test_access__
    }, null, true);
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__firebase_util__["f" /* isNodeSdk */])()) {
        module.exports = namespace;
    }
}
registerDatabase(__WEBPACK_IMPORTED_MODULE_0__firebase_app__["default"]);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(148)(module)))

/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TransactionResult; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var TransactionResult = /** @class */ (function () {
    /**
     * A type for the resolve value of Firebase.transaction.
     * @constructor
     * @dict
     * @param {boolean} committed
     * @param {DataSnapshot} snapshot
     */
    function TransactionResult(committed, snapshot) {
        this.committed = committed;
        this.snapshot = snapshot;
    }
    // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary
    // for end-users
    TransactionResult.prototype.toJSON = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('TransactionResult.toJSON', 0, 1, arguments.length);
        return { committed: this.committed, snapshot: this.snapshot.toJSON() };
    };
    return TransactionResult;
}());




/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forceLongPolling", function() { return forceLongPolling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forceWebSockets", function() { return forceWebSockets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWebSocketsAvailable", function() { return isWebSocketsAvailable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setSecurityDebugCallback", function() { return setSecurityDebugCallback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stats", function() { return stats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "statsIncrementCounter", function() { return statsIncrementCounter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dataUpdateCount", function() { return dataUpdateCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interceptServerData", function() { return interceptServerData; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__realtime_WebSocketConnection__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__realtime_BrowserPollConnection__ = __webpack_require__(57);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * INTERNAL methods for internal-use only (tests, etc.).
 *
 * Customers shouldn't use these or else should be aware that they could break at any time.
 *
 * @const
 */
var forceLongPolling = function () {
    __WEBPACK_IMPORTED_MODULE_0__realtime_WebSocketConnection__["a" /* WebSocketConnection */].forceDisallow();
    __WEBPACK_IMPORTED_MODULE_1__realtime_BrowserPollConnection__["a" /* BrowserPollConnection */].forceAllow();
};
var forceWebSockets = function () {
    __WEBPACK_IMPORTED_MODULE_1__realtime_BrowserPollConnection__["a" /* BrowserPollConnection */].forceDisallow();
};
/* Used by App Manager */
var isWebSocketsAvailable = function () {
    return __WEBPACK_IMPORTED_MODULE_0__realtime_WebSocketConnection__["a" /* WebSocketConnection */]['isAvailable']();
};
var setSecurityDebugCallback = function (ref, callback) {
    ref.repo.persistentConnection_.securityDebugCallback_ = callback;
};
var stats = function (ref, showDelta) {
    ref.repo.stats(showDelta);
};
var statsIncrementCounter = function (ref, metric) {
    ref.repo.statsIncrementCounter(metric);
};
var dataUpdateCount = function (ref) {
    return ref.repo.dataUpdateCount;
};
var interceptServerData = function (ref, callback) {
    return ref.repo.interceptServerData_(callback);
};



/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OnDisconnect; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_util_validation__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_util_util__ = __webpack_require__(1);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * @constructor
 */
var OnDisconnect = /** @class */ (function () {
    /**
     * @param {!Repo} repo_
     * @param {!Path} path_
     */
    function OnDisconnect(repo_, path_) {
        this.repo_ = repo_;
        this.path_ = path_;
    }
    /**
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */
    OnDisconnect.prototype.cancel = function (onComplete) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('OnDisconnect.cancel', 0, 1, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["H" /* validateCallback */])('OnDisconnect.cancel', 1, onComplete, true);
        var deferred = new __WEBPACK_IMPORTED_MODULE_0__firebase_util__["J" /* Deferred */]();
        this.repo_.onDisconnectCancel(this.path_, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */
    OnDisconnect.prototype.remove = function (onComplete) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('OnDisconnect.remove', 0, 1, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__core_util_validation__["h" /* validateWritablePath */])('OnDisconnect.remove', this.path_);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["H" /* validateCallback */])('OnDisconnect.remove', 1, onComplete, true);
        var deferred = new __WEBPACK_IMPORTED_MODULE_0__firebase_util__["J" /* Deferred */]();
        this.repo_.onDisconnectSet(this.path_, null, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {*} value
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */
    OnDisconnect.prototype.set = function (value, onComplete) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('OnDisconnect.set', 1, 2, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__core_util_validation__["h" /* validateWritablePath */])('OnDisconnect.set', this.path_);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__core_util_validation__["e" /* validateFirebaseDataArg */])('OnDisconnect.set', 1, value, this.path_, false);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["H" /* validateCallback */])('OnDisconnect.set', 2, onComplete, true);
        var deferred = new __WEBPACK_IMPORTED_MODULE_0__firebase_util__["J" /* Deferred */]();
        this.repo_.onDisconnectSet(this.path_, value, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {*} value
     * @param {number|string|null} priority
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */
    OnDisconnect.prototype.setWithPriority = function (value, priority, onComplete) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('OnDisconnect.setWithPriority', 2, 3, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__core_util_validation__["h" /* validateWritablePath */])('OnDisconnect.setWithPriority', this.path_);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__core_util_validation__["e" /* validateFirebaseDataArg */])('OnDisconnect.setWithPriority', 1, value, this.path_, false);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__core_util_validation__["j" /* validatePriority */])('OnDisconnect.setWithPriority', 2, priority, false);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["H" /* validateCallback */])('OnDisconnect.setWithPriority', 3, onComplete, true);
        var deferred = new __WEBPACK_IMPORTED_MODULE_0__firebase_util__["J" /* Deferred */]();
        this.repo_.onDisconnectSetWithPriority(this.path_, value, priority, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {!Object} objectToMerge
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */
    OnDisconnect.prototype.update = function (objectToMerge, onComplete) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["y" /* validateArgCount */])('OnDisconnect.update', 1, 2, arguments.length);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__core_util_validation__["h" /* validateWritablePath */])('OnDisconnect.update', this.path_);
        if (Array.isArray(objectToMerge)) {
            var newObjectToMerge = {};
            for (var i = 0; i < objectToMerge.length; ++i) {
                newObjectToMerge['' + i] = objectToMerge[i];
            }
            objectToMerge = newObjectToMerge;
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util_util__["f" /* warn */])('Passing an Array to firebase.database.onDisconnect().update() is deprecated. Use set() if you want to overwrite the ' +
                'existing data, or an Object with integer keys if you really do want to only update some of the children.');
        }
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__core_util_validation__["i" /* validateFirebaseMergeDataArg */])('OnDisconnect.update', 1, objectToMerge, this.path_, false);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["H" /* validateCallback */])('OnDisconnect.update', 2, onComplete, true);
        var deferred = new __WEBPACK_IMPORTED_MODULE_0__firebase_util__["J" /* Deferred */]();
        this.repo_.onDisconnectUpdate(this.path_, objectToMerge, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    return OnDisconnect;
}());




/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataConnection", function() { return DataConnection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RealTimeConnection", function() { return RealTimeConnection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hijackHash", function() { return hijackHash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConnectionTarget", function() { return ConnectionTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryIdentifier", function() { return queryIdentifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listens", function() { return listens; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forceRestClient", function() { return forceRestClient; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_RepoInfo__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_PersistentConnection__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_RepoManager__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__realtime_Connection__ = __webpack_require__(58);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var DataConnection = __WEBPACK_IMPORTED_MODULE_1__core_PersistentConnection__["a" /* PersistentConnection */];
/**
 * @param {!string} pathString
 * @param {function(*)} onComplete
 */
__WEBPACK_IMPORTED_MODULE_1__core_PersistentConnection__["a" /* PersistentConnection */].prototype.simpleListen = function (pathString, onComplete) {
    this.sendRequest('q', { p: pathString }, onComplete);
};
/**
 * @param {*} data
 * @param {function(*)} onEcho
 */
__WEBPACK_IMPORTED_MODULE_1__core_PersistentConnection__["a" /* PersistentConnection */].prototype.echo = function (data, onEcho) {
    this.sendRequest('echo', { d: data }, onEcho);
};
// RealTimeConnection properties that we use in tests.
var RealTimeConnection = __WEBPACK_IMPORTED_MODULE_3__realtime_Connection__["a" /* Connection */];
/**
 * @param {function(): string} newHash
 * @return {function()}
 */
var hijackHash = function (newHash) {
    var oldPut = __WEBPACK_IMPORTED_MODULE_1__core_PersistentConnection__["a" /* PersistentConnection */].prototype.put;
    __WEBPACK_IMPORTED_MODULE_1__core_PersistentConnection__["a" /* PersistentConnection */].prototype.put = function (pathString, data, opt_onComplete, opt_hash) {
        if (opt_hash !== undefined) {
            opt_hash = newHash();
        }
        oldPut.call(this, pathString, data, opt_onComplete, opt_hash);
    };
    return function () {
        __WEBPACK_IMPORTED_MODULE_1__core_PersistentConnection__["a" /* PersistentConnection */].prototype.put = oldPut;
    };
};
/**
 * @type {function(new:RepoInfo, !string, boolean, !string, boolean): undefined}
 */
var ConnectionTarget = __WEBPACK_IMPORTED_MODULE_0__core_RepoInfo__["a" /* RepoInfo */];
/**
 * @param {!Query} query
 * @return {!string}
 */
var queryIdentifier = function (query) {
    return query.queryIdentifier();
};
/**
 * @param {!Query} firebaseRef
 * @return {!Object}
 */
var listens = function (firebaseRef) {
    return firebaseRef.repo.persistentConnection_.listens_;
};
/**
 * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.
 *
 * @param {boolean} forceRestClient
 */
var forceRestClient = function (forceRestClient) {
    __WEBPACK_IMPORTED_MODULE_2__core_RepoManager__["a" /* RepoManager */].getInstance().forceRestClient(forceRestClient);
};



/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AuthTokenProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_util__ = __webpack_require__(1);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Abstraction around FirebaseApp's token fetching capabilities.
 */
var AuthTokenProvider = /** @class */ (function () {
    /**
     * @param {!FirebaseApp} app_
     */
    function AuthTokenProvider(app_) {
        this.app_ = app_;
    }
    /**
     * @param {boolean} forceRefresh
     * @return {!Promise<FirebaseAuthTokenData>}
     */
    AuthTokenProvider.prototype.getToken = function (forceRefresh) {
        return this.app_['INTERNAL']['getToken'](forceRefresh).then(null, 
        // .catch
        function (error) {
            // TODO: Need to figure out all the cases this is raised and whether
            // this makes sense.
            if (error && error.code === 'auth/token-not-initialized') {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util_util__["m" /* log */])('Got auth/token-not-initialized error.  Treating as null token.');
                return null;
            }
            else {
                return Promise.reject(error);
            }
        });
    };
    AuthTokenProvider.prototype.addTokenChangeListener = function (listener) {
        // TODO: We might want to wrap the listener and call it with no args to
        // avoid a leaky abstraction, but that makes removing the listener harder.
        this.app_['INTERNAL']['addAuthTokenListener'](listener);
    };
    AuthTokenProvider.prototype.removeTokenChangeListener = function (listener) {
        this.app_['INTERNAL']['removeAuthTokenListener'](listener);
    };
    AuthTokenProvider.prototype.notifyForInvalidToken = function () {
        var errorMessage = 'Provided authentication credentials for the app named "' +
            this.app_.name +
            '" are invalid. This usually indicates your app was not ' +
            'initialized correctly. ';
        if ('credential' in this.app_.options) {
            errorMessage +=
                'Make sure the "credential" property provided to initializeApp() ' +
                    'is authorized to access the specified "databaseURL" and is from the correct ' +
                    'project.';
        }
        else if ('serviceAccount' in this.app_.options) {
            errorMessage +=
                'Make sure the "serviceAccount" property provided to initializeApp() ' +
                    'is authorized to access the specified "databaseURL" and is from the correct ' +
                    'project.';
        }
        else {
            errorMessage +=
                'Make sure the "apiKey" and "databaseURL" properties provided to ' +
                    'initializeApp() match the values provided for your app at ' +
                    'https://console.firebase.google.com/.';
        }
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util_util__["f" /* warn */])(errorMessage);
    };
    return AuthTokenProvider;
}());




/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CompoundWrite; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_ImmutableTree__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__snap_Node__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__snap_indexes_PriorityIndex__ = __webpack_require__(4);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with
 * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write
 * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write
 * to reflect the write added.
 *
 * @constructor
 * @param {!ImmutableTree.<!Node>} writeTree
 */
var CompoundWrite = /** @class */ (function () {
    function CompoundWrite(writeTree_) {
        this.writeTree_ = writeTree_;
    }
    /**
     * @param {!Path} path
     * @param {!Node} node
     * @return {!CompoundWrite}
     */
    CompoundWrite.prototype.addWrite = function (path, node) {
        if (path.isEmpty()) {
            return new CompoundWrite(new __WEBPACK_IMPORTED_MODULE_0__util_ImmutableTree__["a" /* ImmutableTree */](node));
        }
        else {
            var rootmost = this.writeTree_.findRootMostValueAndPath(path);
            if (rootmost != null) {
                var rootMostPath = rootmost.path;
                var value = rootmost.value;
                var relativePath = __WEBPACK_IMPORTED_MODULE_1__util_Path__["a" /* Path */].relativePath(rootMostPath, path);
                value = value.updateChild(relativePath, node);
                return new CompoundWrite(this.writeTree_.set(rootMostPath, value));
            }
            else {
                var subtree = new __WEBPACK_IMPORTED_MODULE_0__util_ImmutableTree__["a" /* ImmutableTree */](node);
                var newWriteTree = this.writeTree_.setTree(path, subtree);
                return new CompoundWrite(newWriteTree);
            }
        }
    };
    /**
     * @param {!Path} path
     * @param {!Object.<string, !Node>} updates
     * @return {!CompoundWrite}
     */
    CompoundWrite.prototype.addWrites = function (path, updates) {
        var newWrite = this;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["h" /* forEach */])(updates, function (childKey, node) {
            newWrite = newWrite.addWrite(path.child(childKey), node);
        });
        return newWrite;
    };
    /**
     * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher
     * location, which must be removed by calling this method with that path.
     *
     * @param {!Path} path The path at which a write and all deeper writes should be removed
     * @return {!CompoundWrite} The new CompoundWrite with the removed path
     */
    CompoundWrite.prototype.removeWrite = function (path) {
        if (path.isEmpty()) {
            return CompoundWrite.Empty;
        }
        else {
            var newWriteTree = this.writeTree_.setTree(path, __WEBPACK_IMPORTED_MODULE_0__util_ImmutableTree__["a" /* ImmutableTree */].Empty);
            return new CompoundWrite(newWriteTree);
        }
    };
    /**
     * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be
     * considered "complete".
     *
     * @param {!Path} path The path to check for
     * @return {boolean} Whether there is a complete write at that path
     */
    CompoundWrite.prototype.hasCompleteWrite = function (path) {
        return this.getCompleteNode(path) != null;
    };
    /**
     * Returns a node for a path if and only if the node is a "complete" overwrite at that path. This will not aggregate
     * writes from deeper paths, but will return child nodes from a more shallow path.
     *
     * @param {!Path} path The path to get a complete write
     * @return {?Node} The node if complete at that path, or null otherwise.
     */
    CompoundWrite.prototype.getCompleteNode = function (path) {
        var rootmost = this.writeTree_.findRootMostValueAndPath(path);
        if (rootmost != null) {
            return this.writeTree_
                .get(rootmost.path)
                .getChild(__WEBPACK_IMPORTED_MODULE_1__util_Path__["a" /* Path */].relativePath(rootmost.path, path));
        }
        else {
            return null;
        }
    };
    /**
     * Returns all children that are guaranteed to be a complete overwrite.
     *
     * @return {!Array.<NamedNode>} A list of all complete children.
     */
    CompoundWrite.prototype.getCompleteChildren = function () {
        var children = [];
        var node = this.writeTree_.value;
        if (node != null) {
            // If it's a leaf node, it has no children; so nothing to do.
            if (!node.isLeafNode()) {
                node.forEachChild(__WEBPACK_IMPORTED_MODULE_4__snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */], function (childName, childNode) {
                    children.push(new __WEBPACK_IMPORTED_MODULE_3__snap_Node__["a" /* NamedNode */](childName, childNode));
                });
            }
        }
        else {
            this.writeTree_.children.inorderTraversal(function (childName, childTree) {
                if (childTree.value != null) {
                    children.push(new __WEBPACK_IMPORTED_MODULE_3__snap_Node__["a" /* NamedNode */](childName, childTree.value));
                }
            });
        }
        return children;
    };
    /**
     * @param {!Path} path
     * @return {!CompoundWrite}
     */
    CompoundWrite.prototype.childCompoundWrite = function (path) {
        if (path.isEmpty()) {
            return this;
        }
        else {
            var shadowingNode = this.getCompleteNode(path);
            if (shadowingNode != null) {
                return new CompoundWrite(new __WEBPACK_IMPORTED_MODULE_0__util_ImmutableTree__["a" /* ImmutableTree */](shadowingNode));
            }
            else {
                return new CompoundWrite(this.writeTree_.subtree(path));
            }
        }
    };
    /**
     * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.
     * @return {boolean} Whether this CompoundWrite is empty
     */
    CompoundWrite.prototype.isEmpty = function () {
        return this.writeTree_.isEmpty();
    };
    /**
     * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the
     * node
     * @param {!Node} node The node to apply this CompoundWrite to
     * @return {!Node} The node with all writes applied
     */
    CompoundWrite.prototype.apply = function (node) {
        return CompoundWrite.applySubtreeWrite_(__WEBPACK_IMPORTED_MODULE_1__util_Path__["a" /* Path */].Empty, this.writeTree_, node);
    };
    /**
     * @type {!CompoundWrite}
     */
    CompoundWrite.Empty = new CompoundWrite(new __WEBPACK_IMPORTED_MODULE_0__util_ImmutableTree__["a" /* ImmutableTree */](null));
    /**
     * @param {!Path} relativePath
     * @param {!ImmutableTree.<!Node>} writeTree
     * @param {!Node} node
     * @return {!Node}
     * @private
     */
    CompoundWrite.applySubtreeWrite_ = function (relativePath, writeTree, node) {
        if (writeTree.value != null) {
            // Since there a write is always a leaf, we're done here
            return node.updateChild(relativePath, writeTree.value);
        }
        else {
            var priorityWrite_1 = null;
            writeTree.children.inorderTraversal(function (childKey, childTree) {
                if (childKey === '.priority') {
                    // Apply priorities at the end so we don't update priorities for either empty nodes or forget
                    // to apply priorities to empty nodes that are later filled
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["g" /* assert */])(childTree.value !== null, 'Priority writes must always be leaf nodes');
                    priorityWrite_1 = childTree.value;
                }
                else {
                    node = CompoundWrite.applySubtreeWrite_(relativePath.child(childKey), childTree, node);
                }
            });
            // If there was a priority write, we only apply it if the node is not empty
            if (!node.getChild(relativePath).isEmpty() && priorityWrite_1 !== null) {
                node = node.updateChild(relativePath.child('.priority'), priorityWrite_1);
            }
            return node;
        }
    };
    return CompoundWrite;
}());




/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ReadonlyRestClient; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ServerActions__ = __webpack_require__(40);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






/**
 * An implementation of ServerActions that communicates with the server via REST requests.
 * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full
 * persistent connection (using WebSockets or long-polling)
 */
var ReadonlyRestClient = /** @class */ (function (_super) {
    __extends(ReadonlyRestClient, _super);
    /**
     * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to
     * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server
     * @param {AuthTokenProvider} authTokenProvider_
     * @implements {ServerActions}
     */
    function ReadonlyRestClient(repoInfo_, onDataUpdate_, authTokenProvider_) {
        var _this = _super.call(this) || this;
        _this.repoInfo_ = repoInfo_;
        _this.onDataUpdate_ = onDataUpdate_;
        _this.authTokenProvider_ = authTokenProvider_;
        /** @private {function(...[*])} */
        _this.log_ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_util__["b" /* logWrapper */])('p:rest:');
        /**
         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen
         * that's been removed. :-/
         *
         * @private {!Object.<string, !Object>}
         */
        _this.listens_ = {};
        return _this;
    }
    ReadonlyRestClient.prototype.reportStats = function (stats) {
        throw new Error('Method not implemented.');
    };
    /**
     * @param {!Query} query
     * @param {?number=} tag
     * @return {string}
     * @private
     */
    ReadonlyRestClient.getListenId_ = function (query, tag) {
        if (tag !== undefined) {
            return 'tag$' + tag;
        }
        else {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(query.getQueryParams().isDefault(), "should have a tag if it's not a default query.");
            return query.path.toString();
        }
    };
    /** @inheritDoc */
    ReadonlyRestClient.prototype.listen = function (query, currentHashFn, tag, onComplete) {
        var _this = this;
        var pathString = query.path.toString();
        this.log_('Listen called for ' + pathString + ' ' + query.queryIdentifier());
        // Mark this listener so we can tell if it's removed.
        var listenId = ReadonlyRestClient.getListenId_(query, tag);
        var thisListen = {};
        this.listens_[listenId] = thisListen;
        var queryStringParamaters = query
            .getQueryParams()
            .toRestQueryStringParameters();
        this.restRequest_(pathString + '.json', queryStringParamaters, function (error, result) {
            var data = result;
            if (error === 404) {
                data = null;
                error = null;
            }
            if (error === null) {
                _this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);
            }
            if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["s" /* safeGet */])(_this.listens_, listenId) === thisListen) {
                var status_1;
                if (!error) {
                    status_1 = 'ok';
                }
                else if (error == 401) {
                    status_1 = 'permission_denied';
                }
                else {
                    status_1 = 'rest_error:' + error;
                }
                onComplete(status_1, null);
            }
        });
    };
    /** @inheritDoc */
    ReadonlyRestClient.prototype.unlisten = function (query, tag) {
        var listenId = ReadonlyRestClient.getListenId_(query, tag);
        delete this.listens_[listenId];
    };
    /** @inheritDoc */
    ReadonlyRestClient.prototype.refreshAuthToken = function (token) {
        // no-op since we just always call getToken.
    };
    /**
     * Performs a REST request to the given path, with the provided query string parameters,
     * and any auth credentials we have.
     *
     * @param {!string} pathString
     * @param {!Object.<string, *>} queryStringParameters
     * @param {?function(?number, *=)} callback
     * @private
     */
    ReadonlyRestClient.prototype.restRequest_ = function (pathString, queryStringParameters, callback) {
        var _this = this;
        if (queryStringParameters === void 0) { queryStringParameters = {}; }
        queryStringParameters['format'] = 'export';
        this.authTokenProvider_
            .getToken(/*forceRefresh=*/ false)
            .then(function (authTokenData) {
            var authToken = authTokenData && authTokenData.accessToken;
            if (authToken) {
                queryStringParameters['auth'] = authToken;
            }
            var url = (_this.repoInfo_.secure ? 'https://' : 'http://') +
                _this.repoInfo_.host +
                pathString +
                '?' +
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["G" /* querystring */])(queryStringParameters);
            _this.log_('Sending REST request for ' + url);
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if (callback && xhr.readyState === 4) {
                    _this.log_('REST Response for ' + url + ' received. status:', xhr.status, 'response:', xhr.responseText);
                    var res = null;
                    if (xhr.status >= 200 && xhr.status < 300) {
                        try {
                            res = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["k" /* jsonEval */])(xhr.responseText);
                        }
                        catch (e) {
                            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_util__["f" /* warn */])('Failed to parse JSON response for ' +
                                url +
                                ': ' +
                                xhr.responseText);
                        }
                        callback(null, res);
                    }
                    else {
                        // 401 and 404 are expected.
                        if (xhr.status !== 401 && xhr.status !== 404) {
                            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_util__["f" /* warn */])('Got unsuccessful REST response for ' +
                                url +
                                ' Status: ' +
                                xhr.status);
                        }
                        callback(xhr.status);
                    }
                    callback = null;
                }
            };
            xhr.open('GET', url, /*asynchronous=*/ true);
            xhr.send();
        });
    };
    return ReadonlyRestClient;
}(__WEBPACK_IMPORTED_MODULE_2__ServerActions__["a" /* ServerActions */]));




/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export TransactionStatus */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__api_Reference__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__api_DataSnapshot__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_Tree__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__snap_indexes_PriorityIndex__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__util_ServerValues__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__util_validation__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__snap_nodeFromJSON__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__snap_ChildrenNode__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__Repo__ = __webpack_require__(18);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */













// TODO: This is pretty messy.  Ideally, a lot of this would move into FirebaseData, or a transaction-specific
// component used by FirebaseData, but it has ties to user callbacks (transaction update and onComplete) as well
// as the realtime connection (to send transactions to the server).  So that all needs to be decoupled first.
// For now it's part of Repo, but in its own file.
/**
 * @enum {number}
 */
var TransactionStatus;
(function (TransactionStatus) {
    // We've run the transaction and updated transactionResultData_ with the result, but it isn't currently sent to the
    // server. A transaction will go from RUN -> SENT -> RUN if it comes back from the server as rejected due to
    // mismatched hash.
    TransactionStatus[TransactionStatus["RUN"] = 0] = "RUN";
    // We've run the transaction and sent it to the server and it's currently outstanding (hasn't come back as accepted
    // or rejected yet).
    TransactionStatus[TransactionStatus["SENT"] = 1] = "SENT";
    // Temporary state used to mark completed transactions (whether successful or aborted).  The transaction will be
    // removed when we get a chance to prune completed ones.
    TransactionStatus[TransactionStatus["COMPLETED"] = 2] = "COMPLETED";
    // Used when an already-sent transaction needs to be aborted (e.g. due to a conflicting set() call that was made).
    // If it comes back as unsuccessful, we'll abort it.
    TransactionStatus[TransactionStatus["SENT_NEEDS_ABORT"] = 3] = "SENT_NEEDS_ABORT";
    // Temporary state used to mark transactions that need to be aborted.
    TransactionStatus[TransactionStatus["NEEDS_ABORT"] = 4] = "NEEDS_ABORT";
})(TransactionStatus = TransactionStatus || (TransactionStatus = {}));
/**
 * If a transaction does not succeed after 25 retries, we abort it.  Among other things this ensure that if there's
 * ever a bug causing a mismatch between client / server hashes for some data, we won't retry indefinitely.
 * @type {number}
 * @const
 * @private
 */
__WEBPACK_IMPORTED_MODULE_11__Repo__["a" /* Repo */].MAX_TRANSACTION_RETRIES_ = 25;
/**
 * Setup the transaction data structures
 * @private
 */
__WEBPACK_IMPORTED_MODULE_11__Repo__["a" /* Repo */].prototype.transactions_init_ = function () {
    /**
     * Stores queues of outstanding transactions for Firebase locations.
     *
     * @type {!Tree.<Array.<!Transaction>>}
     * @private
     */
    this.transactionQueueTree_ = new __WEBPACK_IMPORTED_MODULE_4__util_Tree__["a" /* Tree */]();
};
/**
 * Creates a new transaction, adds it to the transactions we're tracking, and sends it to the server if possible.
 *
 * @param {!Path} path Path at which to do transaction.
 * @param {function(*):*} transactionUpdate Update callback.
 * @param {?function(?Error, boolean, ?DataSnapshot)} onComplete Completion callback.
 * @param {boolean} applyLocally Whether or not to make intermediate results visible
 */
__WEBPACK_IMPORTED_MODULE_11__Repo__["a" /* Repo */].prototype.startTransaction = function (path, transactionUpdate, onComplete, applyLocally) {
    this.log_('transaction on ' + path);
    // Add a watch to make sure we get server updates.
    var valueCallback = function () { };
    var watchRef = new __WEBPACK_IMPORTED_MODULE_1__api_Reference__["a" /* Reference */](this, path);
    watchRef.on('value', valueCallback);
    var unwatcher = function () {
        watchRef.off('value', valueCallback);
    };
    // Initialize transaction.
    var transaction = {
        path: path,
        update: transactionUpdate,
        onComplete: onComplete,
        // One of TransactionStatus enums.
        status: null,
        // Used when combining transactions at different locations to figure out which one goes first.
        order: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__util_util__["l" /* LUIDGenerator */])(),
        // Whether to raise local events for this transaction.
        applyLocally: applyLocally,
        // Count of how many times we've retried the transaction.
        retryCount: 0,
        // Function to call to clean up our .on() listener.
        unwatcher: unwatcher,
        // Stores why a transaction was aborted.
        abortReason: null,
        currentWriteId: null,
        currentInputSnapshot: null,
        currentOutputSnapshotRaw: null,
        currentOutputSnapshotResolved: null
    };
    // Run transaction initially.
    var currentState = this.getLatestState_(path);
    transaction.currentInputSnapshot = currentState;
    var newVal = transaction.update(currentState.val());
    if (newVal === undefined) {
        // Abort transaction.
        transaction.unwatcher();
        transaction.currentOutputSnapshotRaw = null;
        transaction.currentOutputSnapshotResolved = null;
        if (transaction.onComplete) {
            // We just set the input snapshot, so this cast should be safe
            var snapshot = new __WEBPACK_IMPORTED_MODULE_2__api_DataSnapshot__["a" /* DataSnapshot */](transaction.currentInputSnapshot, new __WEBPACK_IMPORTED_MODULE_1__api_Reference__["a" /* Reference */](this, transaction.path), __WEBPACK_IMPORTED_MODULE_5__snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */]);
            transaction.onComplete(null, false, snapshot);
        }
    }
    else {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__util_validation__["l" /* validateFirebaseData */])('transaction failed: Data returned ', newVal, transaction.path);
        // Mark as run and add to our queue.
        transaction.status = TransactionStatus.RUN;
        var queueNode = this.transactionQueueTree_.subTree(path);
        var nodeQueue = queueNode.getValue() || [];
        nodeQueue.push(transaction);
        queueNode.setValue(nodeQueue);
        // Update visibleData and raise events
        // Note: We intentionally raise events after updating all of our transaction state, since the user could
        // start new transactions from the event callbacks.
        var priorityForNode = void 0;
        if (typeof newVal === 'object' &&
            newVal !== null &&
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["i" /* contains */])(newVal, '.priority')) {
            priorityForNode = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["s" /* safeGet */])(newVal, '.priority');
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__util_validation__["b" /* isValidPriority */])(priorityForNode), 'Invalid priority returned by transaction. ' +
                'Priority must be a valid string, finite number, server value, or null.');
        }
        else {
            var currentNode = this.serverSyncTree_.calcCompleteEventCache(path) ||
                __WEBPACK_IMPORTED_MODULE_10__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE;
            priorityForNode = currentNode.getPriority().val();
        }
        priorityForNode /** @type {null|number|string} */ = priorityForNode;
        var serverValues = this.generateServerValues();
        var newNodeUnresolved = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__snap_nodeFromJSON__["a" /* nodeFromJSON */])(newVal, priorityForNode);
        var newNode = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__util_ServerValues__["b" /* resolveDeferredValueSnapshot */])(newNodeUnresolved, serverValues);
        transaction.currentOutputSnapshotRaw = newNodeUnresolved;
        transaction.currentOutputSnapshotResolved = newNode;
        transaction.currentWriteId = this.getNextWriteId_();
        var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, transaction.currentWriteId, transaction.applyLocally);
        this.eventQueue_.raiseEventsForChangedPath(path, events);
        this.sendReadyTransactions_();
    }
};
/**
 * @param {!Path} path
 * @param {Array.<number>=} excludeSets A specific set to exclude
 * @return {Node}
 * @private
 */
__WEBPACK_IMPORTED_MODULE_11__Repo__["a" /* Repo */].prototype.getLatestState_ = function (path, excludeSets) {
    return (this.serverSyncTree_.calcCompleteEventCache(path, excludeSets) ||
        __WEBPACK_IMPORTED_MODULE_10__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE);
};
/**
 * Sends any already-run transactions that aren't waiting for outstanding transactions to
 * complete.
 *
 * Externally it's called with no arguments, but it calls itself recursively with a particular
 * transactionQueueTree node to recurse through the tree.
 *
 * @param {Tree.<Array.<Transaction>>=} node  transactionQueueTree node to start at.
 * @private
 */
__WEBPACK_IMPORTED_MODULE_11__Repo__["a" /* Repo */].prototype.sendReadyTransactions_ = function (node) {
    var _this = this;
    if (node === void 0) { node = this.transactionQueueTree_; }
    // Before recursing, make sure any completed transactions are removed.
    if (!node) {
        this.pruneCompletedTransactionsBelowNode_(node);
    }
    if (node.getValue() !== null) {
        var queue = this.buildTransactionQueue_(node);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(queue.length > 0, 'Sending zero length transaction queue');
        var allRun = queue.every(function (transaction) { return transaction.status === TransactionStatus.RUN; });
        // If they're all run (and not sent), we can send them.  Else, we must wait.
        if (allRun) {
            this.sendTransactionQueue_(node.path(), queue);
        }
    }
    else if (node.hasChildren()) {
        node.forEachChild(function (childNode) {
            _this.sendReadyTransactions_(childNode);
        });
    }
};
/**
 * Given a list of run transactions, send them to the server and then handle the result (success or failure).
 *
 * @param {!Path} path The location of the queue.
 * @param {!Array.<Transaction>} queue Queue of transactions under the specified location.
 * @private
 */
__WEBPACK_IMPORTED_MODULE_11__Repo__["a" /* Repo */].prototype.sendTransactionQueue_ = function (path, queue) {
    var _this = this;
    // Mark transactions as sent and increment retry count!
    var setsToIgnore = queue.map(function (txn) {
        return txn.currentWriteId;
    });
    var latestState = this.getLatestState_(path, setsToIgnore);
    var snapToSend = latestState;
    var latestHash = latestState.hash();
    for (var i = 0; i < queue.length; i++) {
        var txn = queue[i];
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(txn.status === TransactionStatus.RUN, 'tryToSendTransactionQueue_: items in queue should all be run.');
        txn.status = TransactionStatus.SENT;
        txn.retryCount++;
        var relativePath = __WEBPACK_IMPORTED_MODULE_3__util_Path__["a" /* Path */].relativePath(path, txn.path);
        // If we've gotten to this point, the output snapshot must be defined.
        snapToSend = snapToSend.updateChild(relativePath /**@type {!Node} */, txn.currentOutputSnapshotRaw);
    }
    var dataToSend = snapToSend.val(true);
    var pathToSend = path;
    // Send the put.
    this.server_.put(pathToSend.toString(), dataToSend, function (status) {
        _this.log_('transaction put response', {
            path: pathToSend.toString(),
            status: status
        });
        var events = [];
        if (status === 'ok') {
            // Queue up the callbacks and fire them after cleaning up all of our transaction state, since
            // the callback could trigger more transactions or sets.
            var callbacks = [];
            for (var i = 0; i < queue.length; i++) {
                queue[i].status = TransactionStatus.COMPLETED;
                events = events.concat(_this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId));
                if (queue[i].onComplete) {
                    // We never unset the output snapshot, and given that this transaction is complete, it should be set
                    var node = queue[i].currentOutputSnapshotResolved;
                    var ref = new __WEBPACK_IMPORTED_MODULE_1__api_Reference__["a" /* Reference */](_this, queue[i].path);
                    var snapshot = new __WEBPACK_IMPORTED_MODULE_2__api_DataSnapshot__["a" /* DataSnapshot */](node, ref, __WEBPACK_IMPORTED_MODULE_5__snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */]);
                    callbacks.push(queue[i].onComplete.bind(null, null, true, snapshot));
                }
                queue[i].unwatcher();
            }
            // Now remove the completed transactions.
            _this.pruneCompletedTransactionsBelowNode_(_this.transactionQueueTree_.subTree(path));
            // There may be pending transactions that we can now send.
            _this.sendReadyTransactions_();
            _this.eventQueue_.raiseEventsForChangedPath(path, events);
            // Finally, trigger onComplete callbacks.
            for (var i = 0; i < callbacks.length; i++) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__util_util__["n" /* exceptionGuard */])(callbacks[i]);
            }
        }
        else {
            // transactions are no longer sent.  Update their status appropriately.
            if (status === 'datastale') {
                for (var i = 0; i < queue.length; i++) {
                    if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT)
                        queue[i].status = TransactionStatus.NEEDS_ABORT;
                    else
                        queue[i].status = TransactionStatus.RUN;
                }
            }
            else {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__util_util__["f" /* warn */])('transaction at ' + pathToSend.toString() + ' failed: ' + status);
                for (var i = 0; i < queue.length; i++) {
                    queue[i].status = TransactionStatus.NEEDS_ABORT;
                    queue[i].abortReason = status;
                }
            }
            _this.rerunTransactions_(path);
        }
    }, latestHash);
};
/**
 * Finds all transactions dependent on the data at changedPath and reruns them.
 *
 * Should be called any time cached data changes.
 *
 * Return the highest path that was affected by rerunning transactions.  This is the path at which events need to
 * be raised for.
 *
 * @param {!Path} changedPath The path in mergedData that changed.
 * @return {!Path} The rootmost path that was affected by rerunning transactions.
 * @private
 */
__WEBPACK_IMPORTED_MODULE_11__Repo__["a" /* Repo */].prototype.rerunTransactions_ = function (changedPath) {
    var rootMostTransactionNode = this.getAncestorTransactionNode_(changedPath);
    var path = rootMostTransactionNode.path();
    var queue = this.buildTransactionQueue_(rootMostTransactionNode);
    this.rerunTransactionQueue_(queue, path);
    return path;
};
/**
 * Does all the work of rerunning transactions (as well as cleans up aborted transactions and whatnot).
 *
 * @param {Array.<Transaction>} queue The queue of transactions to run.
 * @param {!Path} path The path the queue is for.
 * @private
 */
__WEBPACK_IMPORTED_MODULE_11__Repo__["a" /* Repo */].prototype.rerunTransactionQueue_ = function (queue, path) {
    if (queue.length === 0) {
        return; // Nothing to do!
    }
    // Queue up the callbacks and fire them after cleaning up all of our transaction state, since
    // the callback could trigger more transactions or sets.
    var callbacks = [];
    var events = [];
    // Ignore all of the sets we're going to re-run.
    var txnsToRerun = queue.filter(function (q) {
        return q.status === TransactionStatus.RUN;
    });
    var setsToIgnore = txnsToRerun.map(function (q) {
        return q.currentWriteId;
    });
    for (var i = 0; i < queue.length; i++) {
        var transaction = queue[i];
        var relativePath = __WEBPACK_IMPORTED_MODULE_3__util_Path__["a" /* Path */].relativePath(path, transaction.path);
        var abortTransaction = false, abortReason = void 0;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(relativePath !== null, 'rerunTransactionsUnderNode_: relativePath should not be null.');
        if (transaction.status === TransactionStatus.NEEDS_ABORT) {
            abortTransaction = true;
            abortReason = transaction.abortReason;
            events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));
        }
        else if (transaction.status === TransactionStatus.RUN) {
            if (transaction.retryCount >= __WEBPACK_IMPORTED_MODULE_11__Repo__["a" /* Repo */].MAX_TRANSACTION_RETRIES_) {
                abortTransaction = true;
                abortReason = 'maxretry';
                events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));
            }
            else {
                // This code reruns a transaction
                var currentNode = this.getLatestState_(transaction.path, setsToIgnore);
                transaction.currentInputSnapshot = currentNode;
                var newData = queue[i].update(currentNode.val());
                if (newData !== undefined) {
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__util_validation__["l" /* validateFirebaseData */])('transaction failed: Data returned ', newData, transaction.path);
                    var newDataNode = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__snap_nodeFromJSON__["a" /* nodeFromJSON */])(newData);
                    var hasExplicitPriority = typeof newData === 'object' &&
                        newData != null &&
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["i" /* contains */])(newData, '.priority');
                    if (!hasExplicitPriority) {
                        // Keep the old priority if there wasn't a priority explicitly specified.
                        newDataNode = newDataNode.updatePriority(currentNode.getPriority());
                    }
                    var oldWriteId = transaction.currentWriteId;
                    var serverValues = this.generateServerValues();
                    var newNodeResolved = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__util_ServerValues__["b" /* resolveDeferredValueSnapshot */])(newDataNode, serverValues);
                    transaction.currentOutputSnapshotRaw = newDataNode;
                    transaction.currentOutputSnapshotResolved = newNodeResolved;
                    transaction.currentWriteId = this.getNextWriteId_();
                    // Mutates setsToIgnore in place
                    setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);
                    events = events.concat(this.serverSyncTree_.applyUserOverwrite(transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));
                    events = events.concat(this.serverSyncTree_.ackUserWrite(oldWriteId, true));
                }
                else {
                    abortTransaction = true;
                    abortReason = 'nodata';
                    events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));
                }
            }
        }
        this.eventQueue_.raiseEventsForChangedPath(path, events);
        events = [];
        if (abortTransaction) {
            // Abort.
            queue[i].status = TransactionStatus.COMPLETED;
            // Removing a listener can trigger pruning which can muck with mergedData/visibleData (as it prunes data).
            // So defer the unwatcher until we're done.
            (function (unwatcher) {
                setTimeout(unwatcher, Math.floor(0));
            })(queue[i].unwatcher);
            if (queue[i].onComplete) {
                if (abortReason === 'nodata') {
                    var ref = new __WEBPACK_IMPORTED_MODULE_1__api_Reference__["a" /* Reference */](this, queue[i].path);
                    // We set this field immediately, so it's safe to cast to an actual snapshot
                    var lastInput /** @type {!Node} */ = queue[i].currentInputSnapshot;
                    var snapshot = new __WEBPACK_IMPORTED_MODULE_2__api_DataSnapshot__["a" /* DataSnapshot */](lastInput, ref, __WEBPACK_IMPORTED_MODULE_5__snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */]);
                    callbacks.push(queue[i].onComplete.bind(null, null, false, snapshot));
                }
                else {
                    callbacks.push(queue[i].onComplete.bind(null, new Error(abortReason), false, null));
                }
            }
        }
    }
    // Clean up completed transactions.
    this.pruneCompletedTransactionsBelowNode_(this.transactionQueueTree_);
    // Now fire callbacks, now that we're in a good, known state.
    for (var i = 0; i < callbacks.length; i++) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__util_util__["n" /* exceptionGuard */])(callbacks[i]);
    }
    // Try to send the transaction result to the server.
    this.sendReadyTransactions_();
};
/**
 * Returns the rootmost ancestor node of the specified path that has a pending transaction on it, or just returns
 * the node for the given path if there are no pending transactions on any ancestor.
 *
 * @param {!Path} path The location to start at.
 * @return {!Tree.<Array.<!Transaction>>} The rootmost node with a transaction.
 * @private
 */
__WEBPACK_IMPORTED_MODULE_11__Repo__["a" /* Repo */].prototype.getAncestorTransactionNode_ = function (path) {
    var front;
    // Start at the root and walk deeper into the tree towards path until we find a node with pending transactions.
    var transactionNode = this.transactionQueueTree_;
    while ((front = path.getFront()) !== null &&
        transactionNode.getValue() === null) {
        transactionNode = transactionNode.subTree(front);
        path = path.popFront();
    }
    return transactionNode;
};
/**
 * Builds the queue of all transactions at or below the specified transactionNode.
 *
 * @param {!Tree.<Array.<Transaction>>} transactionNode
 * @return {Array.<Transaction>} The generated queue.
 * @private
 */
__WEBPACK_IMPORTED_MODULE_11__Repo__["a" /* Repo */].prototype.buildTransactionQueue_ = function (transactionNode) {
    // Walk any child transaction queues and aggregate them into a single queue.
    var transactionQueue = [];
    this.aggregateTransactionQueuesForNode_(transactionNode, transactionQueue);
    // Sort them by the order the transactions were created.
    transactionQueue.sort(function (a, b) {
        return a.order - b.order;
    });
    return transactionQueue;
};
/**
 * @param {!Tree.<Array.<Transaction>>} node
 * @param {Array.<Transaction>} queue
 * @private
 */
__WEBPACK_IMPORTED_MODULE_11__Repo__["a" /* Repo */].prototype.aggregateTransactionQueuesForNode_ = function (node, queue) {
    var _this = this;
    var nodeQueue = node.getValue();
    if (nodeQueue !== null) {
        for (var i = 0; i < nodeQueue.length; i++) {
            queue.push(nodeQueue[i]);
        }
    }
    node.forEachChild(function (child) {
        _this.aggregateTransactionQueuesForNode_(child, queue);
    });
};
/**
 * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.
 *
 * @param {!Tree.<Array.<!Transaction>>} node
 * @private
 */
__WEBPACK_IMPORTED_MODULE_11__Repo__["a" /* Repo */].prototype.pruneCompletedTransactionsBelowNode_ = function (node) {
    var _this = this;
    var queue = node.getValue();
    if (queue) {
        var to = 0;
        for (var from = 0; from < queue.length; from++) {
            if (queue[from].status !== TransactionStatus.COMPLETED) {
                queue[to] = queue[from];
                to++;
            }
        }
        queue.length = to;
        node.setValue(queue.length > 0 ? queue : null);
    }
    node.forEachChild(function (childNode) {
        _this.pruneCompletedTransactionsBelowNode_(childNode);
    });
};
/**
 * Aborts all transactions on ancestors or descendants of the specified path.  Called when doing a set() or update()
 * since we consider them incompatible with transactions.
 *
 * @param {!Path} path Path for which we want to abort related transactions.
 * @return {!Path}
 * @private
 */
__WEBPACK_IMPORTED_MODULE_11__Repo__["a" /* Repo */].prototype.abortTransactions_ = function (path) {
    var _this = this;
    var affectedPath = this.getAncestorTransactionNode_(path).path();
    var transactionNode = this.transactionQueueTree_.subTree(path);
    transactionNode.forEachAncestor(function (node) {
        _this.abortTransactionsOnNode_(node);
    });
    this.abortTransactionsOnNode_(transactionNode);
    transactionNode.forEachDescendant(function (node) {
        _this.abortTransactionsOnNode_(node);
    });
    return affectedPath;
};
/**
 * Abort transactions stored in this transaction queue node.
 *
 * @param {!Tree.<Array.<Transaction>>} node Node to abort transactions for.
 * @private
 */
__WEBPACK_IMPORTED_MODULE_11__Repo__["a" /* Repo */].prototype.abortTransactionsOnNode_ = function (node) {
    var queue = node.getValue();
    if (queue !== null) {
        // Queue up the callbacks and fire them after cleaning up all of our transaction state, since
        // the callback could trigger more transactions or sets.
        var callbacks = [];
        // Go through queue.  Any already-sent transactions must be marked for abort, while the unsent ones
        // can be immediately aborted and removed.
        var events = [];
        var lastSent = -1;
        for (var i = 0; i < queue.length; i++) {
            if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) {
                // Already marked.  No action needed.
            }
            else if (queue[i].status === TransactionStatus.SENT) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(lastSent === i - 1, 'All SENT items should be at beginning of queue.');
                lastSent = i;
                // Mark transaction for abort when it comes back.
                queue[i].status = TransactionStatus.SENT_NEEDS_ABORT;
                queue[i].abortReason = 'set';
            }
            else {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(queue[i].status === TransactionStatus.RUN, 'Unexpected transaction status in abort');
                // We can abort it immediately.
                queue[i].unwatcher();
                events = events.concat(this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId, true));
                if (queue[i].onComplete) {
                    var snapshot = null;
                    callbacks.push(queue[i].onComplete.bind(null, new Error('set'), false, snapshot));
                }
            }
        }
        if (lastSent === -1) {
            // We're not waiting for any sent transactions.  We can clear the queue.
            node.setValue(null);
        }
        else {
            // Remove the transactions we aborted.
            queue.length = lastSent + 1;
        }
        // Now fire the callbacks.
        this.eventQueue_.raiseEventsForChangedPath(node.path(), events);
        for (var i = 0; i < callbacks.length; i++) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__util_util__["n" /* exceptionGuard */])(callbacks[i]);
        }
    }
};



/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SnapshotHolder; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__snap_ChildrenNode__ = __webpack_require__(6);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Mutable object which basically just stores a reference to the "latest" immutable snapshot.
 *
 * @constructor
 */
var SnapshotHolder = /** @class */ (function () {
    function SnapshotHolder() {
        this.rootNode_ = __WEBPACK_IMPORTED_MODULE_0__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE;
    }
    SnapshotHolder.prototype.getNode = function (path) {
        return this.rootNode_.getChild(path);
    };
    SnapshotHolder.prototype.updateSnapshot = function (path, newSnapshotNode) {
        this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);
    };
    return SnapshotHolder;
}());




/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SyncTree; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__operation_AckUserWrite__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__snap_ChildrenNode__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_ImmutableTree__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__operation_ListenComplete__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__operation_Merge__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__operation_Operation__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__operation_Overwrite__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__util_Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__SyncPoint__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__WriteTree__ = __webpack_require__(99);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */













/**
 * SyncTree is the central class for managing event callback registration, data caching, views
 * (query processing), and event generation.  There are typically two SyncTree instances for
 * each Repo, one for the normal Firebase data, and one for the .info data.
 *
 * It has a number of responsibilities, including:
 *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).
 *  - Applying and caching data changes for user set(), transaction(), and update() calls
 *    (applyUserOverwrite(), applyUserMerge()).
 *  - Applying and caching data changes for server data changes (applyServerOverwrite(),
 *    applyServerMerge()).
 *  - Generating user-facing events for server and user changes (all of the apply* methods
 *    return the set of events that need to be raised as a result).
 *  - Maintaining the appropriate set of server listens to ensure we are always subscribed
 *    to the correct set of paths and queries to satisfy the current set of user event
 *    callbacks (listens are started/stopped using the provided listenProvider).
 *
 * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual
 * events are returned to the caller rather than raised synchronously.
 *
 * @constructor
 */
var SyncTree = /** @class */ (function () {
    /**
     * @param {!ListenProvider} listenProvider_ Used by SyncTree to start / stop listening
     *   to server data.
     */
    function SyncTree(listenProvider_) {
        this.listenProvider_ = listenProvider_;
        /**
         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.
         * @type {!ImmutableTree.<!SyncPoint>}
         * @private
         */
        this.syncPointTree_ = __WEBPACK_IMPORTED_MODULE_4__util_ImmutableTree__["a" /* ImmutableTree */].Empty;
        /**
         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).
         * @type {!WriteTree}
         * @private
         */
        this.pendingWriteTree_ = new __WEBPACK_IMPORTED_MODULE_11__WriteTree__["a" /* WriteTree */]();
        this.tagToQueryMap_ = {};
        this.queryToTagMap_ = {};
    }
    /**
     * Apply the data changes for a user-generated set() or transaction() call.
     *
     * @param {!Path} path
     * @param {!Node} newData
     * @param {number} writeId
     * @param {boolean=} visible
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyUserOverwrite = function (path, newData, writeId, visible) {
        // Record pending write.
        this.pendingWriteTree_.addOverwrite(path, newData, writeId, visible);
        if (!visible) {
            return [];
        }
        else {
            return this.applyOperationToSyncPoints_(new __WEBPACK_IMPORTED_MODULE_8__operation_Overwrite__["a" /* Overwrite */](__WEBPACK_IMPORTED_MODULE_7__operation_Operation__["a" /* OperationSource */].User, path, newData));
        }
    };
    /**
     * Apply the data from a user-generated update() call
     *
     * @param {!Path} path
     * @param {!Object.<string, !Node>} changedChildren
     * @param {!number} writeId
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyUserMerge = function (path, changedChildren, writeId) {
        // Record pending merge.
        this.pendingWriteTree_.addMerge(path, changedChildren, writeId);
        var changeTree = __WEBPACK_IMPORTED_MODULE_4__util_ImmutableTree__["a" /* ImmutableTree */].fromObject(changedChildren);
        return this.applyOperationToSyncPoints_(new __WEBPACK_IMPORTED_MODULE_6__operation_Merge__["a" /* Merge */](__WEBPACK_IMPORTED_MODULE_7__operation_Operation__["a" /* OperationSource */].User, path, changeTree));
    };
    /**
     * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().
     *
     * @param {!number} writeId
     * @param {boolean=} revert True if the given write failed and needs to be reverted
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.ackUserWrite = function (writeId, revert) {
        if (revert === void 0) { revert = false; }
        var write = this.pendingWriteTree_.getWrite(writeId);
        var needToReevaluate = this.pendingWriteTree_.removeWrite(writeId);
        if (!needToReevaluate) {
            return [];
        }
        else {
            var affectedTree_1 = __WEBPACK_IMPORTED_MODULE_4__util_ImmutableTree__["a" /* ImmutableTree */].Empty;
            if (write.snap != null) {
                // overwrite
                affectedTree_1 = affectedTree_1.set(__WEBPACK_IMPORTED_MODULE_9__util_Path__["a" /* Path */].Empty, true);
            }
            else {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["h" /* forEach */])(write.children, function (pathString, node) {
                    affectedTree_1 = affectedTree_1.set(new __WEBPACK_IMPORTED_MODULE_9__util_Path__["a" /* Path */](pathString), node);
                });
            }
            return this.applyOperationToSyncPoints_(new __WEBPACK_IMPORTED_MODULE_2__operation_AckUserWrite__["a" /* AckUserWrite */](write.path, affectedTree_1, revert));
        }
    };
    /**
     * Apply new server data for the specified path..
     *
     * @param {!Path} path
     * @param {!Node} newData
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyServerOverwrite = function (path, newData) {
        return this.applyOperationToSyncPoints_(new __WEBPACK_IMPORTED_MODULE_8__operation_Overwrite__["a" /* Overwrite */](__WEBPACK_IMPORTED_MODULE_7__operation_Operation__["a" /* OperationSource */].Server, path, newData));
    };
    /**
     * Apply new server data to be merged in at the specified path.
     *
     * @param {!Path} path
     * @param {!Object.<string, !Node>} changedChildren
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyServerMerge = function (path, changedChildren) {
        var changeTree = __WEBPACK_IMPORTED_MODULE_4__util_ImmutableTree__["a" /* ImmutableTree */].fromObject(changedChildren);
        return this.applyOperationToSyncPoints_(new __WEBPACK_IMPORTED_MODULE_6__operation_Merge__["a" /* Merge */](__WEBPACK_IMPORTED_MODULE_7__operation_Operation__["a" /* OperationSource */].Server, path, changeTree));
    };
    /**
     * Apply a listen complete for a query
     *
     * @param {!Path} path
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyListenComplete = function (path) {
        return this.applyOperationToSyncPoints_(new __WEBPACK_IMPORTED_MODULE_5__operation_ListenComplete__["a" /* ListenComplete */](__WEBPACK_IMPORTED_MODULE_7__operation_Operation__["a" /* OperationSource */].Server, path));
    };
    /**
     * Apply new server data for the specified tagged query.
     *
     * @param {!Path} path
     * @param {!Node} snap
     * @param {!number} tag
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyTaggedQueryOverwrite = function (path, snap, tag) {
        var queryKey = this.queryKeyForTag_(tag);
        if (queryKey != null) {
            var r = SyncTree.parseQueryKey_(queryKey);
            var queryPath = r.path, queryId = r.queryId;
            var relativePath = __WEBPACK_IMPORTED_MODULE_9__util_Path__["a" /* Path */].relativePath(queryPath, path);
            var op = new __WEBPACK_IMPORTED_MODULE_8__operation_Overwrite__["a" /* Overwrite */](__WEBPACK_IMPORTED_MODULE_7__operation_Operation__["a" /* OperationSource */].forServerTaggedQuery(queryId), relativePath, snap);
            return this.applyTaggedOperation_(queryPath, op);
        }
        else {
            // Query must have been removed already
            return [];
        }
    };
    /**
     * Apply server data to be merged in for the specified tagged query.
     *
     * @param {!Path} path
     * @param {!Object.<string, !Node>} changedChildren
     * @param {!number} tag
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyTaggedQueryMerge = function (path, changedChildren, tag) {
        var queryKey = this.queryKeyForTag_(tag);
        if (queryKey) {
            var r = SyncTree.parseQueryKey_(queryKey);
            var queryPath = r.path, queryId = r.queryId;
            var relativePath = __WEBPACK_IMPORTED_MODULE_9__util_Path__["a" /* Path */].relativePath(queryPath, path);
            var changeTree = __WEBPACK_IMPORTED_MODULE_4__util_ImmutableTree__["a" /* ImmutableTree */].fromObject(changedChildren);
            var op = new __WEBPACK_IMPORTED_MODULE_6__operation_Merge__["a" /* Merge */](__WEBPACK_IMPORTED_MODULE_7__operation_Operation__["a" /* OperationSource */].forServerTaggedQuery(queryId), relativePath, changeTree);
            return this.applyTaggedOperation_(queryPath, op);
        }
        else {
            // We've already removed the query. No big deal, ignore the update
            return [];
        }
    };
    /**
     * Apply a listen complete for a tagged query
     *
     * @param {!Path} path
     * @param {!number} tag
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyTaggedListenComplete = function (path, tag) {
        var queryKey = this.queryKeyForTag_(tag);
        if (queryKey) {
            var r = SyncTree.parseQueryKey_(queryKey);
            var queryPath = r.path, queryId = r.queryId;
            var relativePath = __WEBPACK_IMPORTED_MODULE_9__util_Path__["a" /* Path */].relativePath(queryPath, path);
            var op = new __WEBPACK_IMPORTED_MODULE_5__operation_ListenComplete__["a" /* ListenComplete */](__WEBPACK_IMPORTED_MODULE_7__operation_Operation__["a" /* OperationSource */].forServerTaggedQuery(queryId), relativePath);
            return this.applyTaggedOperation_(queryPath, op);
        }
        else {
            // We've already removed the query. No big deal, ignore the update
            return [];
        }
    };
    /**
     * Add an event callback for the specified query.
     *
     * @param {!Query} query
     * @param {!EventRegistration} eventRegistration
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.addEventRegistration = function (query, eventRegistration) {
        var path = query.path;
        var serverCache = null;
        var foundAncestorDefaultView = false;
        // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.
        // Consider optimizing this once there's a better understanding of what actual behavior will be.
        this.syncPointTree_.foreachOnPath(path, function (pathToSyncPoint, sp) {
            var relativePath = __WEBPACK_IMPORTED_MODULE_9__util_Path__["a" /* Path */].relativePath(pathToSyncPoint, path);
            serverCache = serverCache || sp.getCompleteServerCache(relativePath);
            foundAncestorDefaultView =
                foundAncestorDefaultView || sp.hasCompleteView();
        });
        var syncPoint = this.syncPointTree_.get(path);
        if (!syncPoint) {
            syncPoint = new __WEBPACK_IMPORTED_MODULE_10__SyncPoint__["a" /* SyncPoint */]();
            this.syncPointTree_ = this.syncPointTree_.set(path, syncPoint);
        }
        else {
            foundAncestorDefaultView =
                foundAncestorDefaultView || syncPoint.hasCompleteView();
            serverCache = serverCache || syncPoint.getCompleteServerCache(__WEBPACK_IMPORTED_MODULE_9__util_Path__["a" /* Path */].Empty);
        }
        var serverCacheComplete;
        if (serverCache != null) {
            serverCacheComplete = true;
        }
        else {
            serverCacheComplete = false;
            serverCache = __WEBPACK_IMPORTED_MODULE_3__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE;
            var subtree = this.syncPointTree_.subtree(path);
            subtree.foreachChild(function (childName, childSyncPoint) {
                var completeCache = childSyncPoint.getCompleteServerCache(__WEBPACK_IMPORTED_MODULE_9__util_Path__["a" /* Path */].Empty);
                if (completeCache) {
                    serverCache = serverCache.updateImmediateChild(childName, completeCache);
                }
            });
        }
        var viewAlreadyExists = syncPoint.viewExistsForQuery(query);
        if (!viewAlreadyExists && !query.getQueryParams().loadsAllData()) {
            // We need to track a tag for this query
            var queryKey = SyncTree.makeQueryKey_(query);
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(!(queryKey in this.queryToTagMap_), 'View does not exist, but we have a tag');
            var tag = SyncTree.getNextQueryTag_();
            this.queryToTagMap_[queryKey] = tag;
            // Coerce to string to avoid sparse arrays.
            this.tagToQueryMap_['_' + tag] = queryKey;
        }
        var writesCache = this.pendingWriteTree_.childWrites(path);
        var events = syncPoint.addEventRegistration(query, eventRegistration, writesCache, serverCache, serverCacheComplete);
        if (!viewAlreadyExists && !foundAncestorDefaultView) {
            var view /** @type !View */ = syncPoint.viewForQuery(query);
            events = events.concat(this.setupListener_(query, view));
        }
        return events;
    };
    /**
     * Remove event callback(s).
     *
     * If query is the default query, we'll check all queries for the specified eventRegistration.
     * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.
     *
     * @param {!Query} query
     * @param {?EventRegistration} eventRegistration If null, all callbacks are removed.
     * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.
     * @return {!Array.<!Event>} Cancel events, if cancelError was provided.
     */
    SyncTree.prototype.removeEventRegistration = function (query, eventRegistration, cancelError) {
        var _this = this;
        // Find the syncPoint first. Then deal with whether or not it has matching listeners
        var path = query.path;
        var maybeSyncPoint = this.syncPointTree_.get(path);
        var cancelEvents = [];
        // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without
        // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and
        // not loadsAllData().
        if (maybeSyncPoint &&
            (query.queryIdentifier() === 'default' ||
                maybeSyncPoint.viewExistsForQuery(query))) {
            /**
             * @type {{removed: !Array.<!Query>, events: !Array.<!Event>}}
             */
            var removedAndEvents = maybeSyncPoint.removeEventRegistration(query, eventRegistration, cancelError);
            if (maybeSyncPoint.isEmpty()) {
                this.syncPointTree_ = this.syncPointTree_.remove(path);
            }
            var removed = removedAndEvents.removed;
            cancelEvents = removedAndEvents.events;
            // We may have just removed one of many listeners and can short-circuit this whole process
            // We may also not have removed a default listener, in which case all of the descendant listeners should already be
            // properly set up.
            //
            // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of
            // queryId === 'default'
            var removingDefault = -1 !==
                removed.findIndex(function (query) {
                    return query.getQueryParams().loadsAllData();
                });
            var covered = this.syncPointTree_.findOnPath(path, function (relativePath, parentSyncPoint) {
                return parentSyncPoint.hasCompleteView();
            });
            if (removingDefault && !covered) {
                var subtree = this.syncPointTree_.subtree(path);
                // There are potentially child listeners. Determine what if any listens we need to send before executing the
                // removal
                if (!subtree.isEmpty()) {
                    // We need to fold over our subtree and collect the listeners to send
                    var newViews = this.collectDistinctViewsForSubTree_(subtree);
                    // Ok, we've collected all the listens we need. Set them up.
                    for (var i = 0; i < newViews.length; ++i) {
                        var view = newViews[i], newQuery = view.getQuery();
                        var listener = this.createListenerForView_(view);
                        this.listenProvider_.startListening(SyncTree.queryForListening_(newQuery), this.tagForQuery_(newQuery), listener.hashFn, listener.onComplete);
                    }
                }
                else {
                    // There's nothing below us, so nothing we need to start listening on
                }
            }
            // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query
            // The above block has us covered in terms of making sure we're set up on listens lower in the tree.
            // Also, note that if we have a cancelError, it's already been removed at the provider level.
            if (!covered && removed.length > 0 && !cancelError) {
                // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one
                // default. Otherwise, we need to iterate through and cancel each individual query
                if (removingDefault) {
                    // We don't tag default listeners
                    var defaultTag = null;
                    this.listenProvider_.stopListening(SyncTree.queryForListening_(query), defaultTag);
                }
                else {
                    removed.forEach(function (queryToRemove) {
                        var tagToRemove = _this.queryToTagMap_[SyncTree.makeQueryKey_(queryToRemove)];
                        _this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToRemove), tagToRemove);
                    });
                }
            }
            // Now, clear all of the tags we're tracking for the removed listens
            this.removeTags_(removed);
        }
        else {
            // No-op, this listener must've been already removed
        }
        return cancelEvents;
    };
    /**
     * Returns a complete cache, if we have one, of the data at a particular path. The location must have a listener above
     * it, but as this is only used by transaction code, that should always be the case anyways.
     *
     * Note: this method will *include* hidden writes from transaction with applyLocally set to false.
     * @param {!Path} path The path to the data we want
     * @param {Array.<number>=} writeIdsToExclude A specific set to be excluded
     * @return {?Node}
     */
    SyncTree.prototype.calcCompleteEventCache = function (path, writeIdsToExclude) {
        var includeHiddenSets = true;
        var writeTree = this.pendingWriteTree_;
        var serverCache = this.syncPointTree_.findOnPath(path, function (pathSoFar, syncPoint) {
            var relativePath = __WEBPACK_IMPORTED_MODULE_9__util_Path__["a" /* Path */].relativePath(pathSoFar, path);
            var serverCache = syncPoint.getCompleteServerCache(relativePath);
            if (serverCache) {
                return serverCache;
            }
        });
        return writeTree.calcCompleteEventCache(path, serverCache, writeIdsToExclude, includeHiddenSets);
    };
    /**
     * This collapses multiple unfiltered views into a single view, since we only need a single
     * listener for them.
     *
     * @param {!ImmutableTree.<!SyncPoint>} subtree
     * @return {!Array.<!View>}
     * @private
     */
    SyncTree.prototype.collectDistinctViewsForSubTree_ = function (subtree) {
        return subtree.fold(function (relativePath, maybeChildSyncPoint, childMap) {
            if (maybeChildSyncPoint && maybeChildSyncPoint.hasCompleteView()) {
                var completeView = maybeChildSyncPoint.getCompleteView();
                return [completeView];
            }
            else {
                // No complete view here, flatten any deeper listens into an array
                var views_1 = [];
                if (maybeChildSyncPoint) {
                    views_1 = maybeChildSyncPoint.getQueryViews();
                }
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["h" /* forEach */])(childMap, function (key, childViews) {
                    views_1 = views_1.concat(childViews);
                });
                return views_1;
            }
        });
    };
    /**
     * @param {!Array.<!Query>} queries
     * @private
     */
    SyncTree.prototype.removeTags_ = function (queries) {
        for (var j = 0; j < queries.length; ++j) {
            var removedQuery = queries[j];
            if (!removedQuery.getQueryParams().loadsAllData()) {
                // We should have a tag for this
                var removedQueryKey = SyncTree.makeQueryKey_(removedQuery);
                var removedQueryTag = this.queryToTagMap_[removedQueryKey];
                delete this.queryToTagMap_[removedQueryKey];
                delete this.tagToQueryMap_['_' + removedQueryTag];
            }
        }
    };
    /**
     * Normalizes a query to a query we send the server for listening
     * @param {!Query} query
     * @return {!Query} The normalized query
     * @private
     */
    SyncTree.queryForListening_ = function (query) {
        if (query.getQueryParams().loadsAllData() &&
            !query.getQueryParams().isDefault()) {
            // We treat queries that load all data as default queries
            // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits
            // from Query
            return /** @type {!Query} */ query.getRef();
        }
        else {
            return query;
        }
    };
    /**
     * For a given new listen, manage the de-duplication of outstanding subscriptions.
     *
     * @param {!Query} query
     * @param {!View} view
     * @return {!Array.<!Event>} This method can return events to support synchronous data sources
     * @private
     */
    SyncTree.prototype.setupListener_ = function (query, view) {
        var path = query.path;
        var tag = this.tagForQuery_(query);
        var listener = this.createListenerForView_(view);
        var events = this.listenProvider_.startListening(SyncTree.queryForListening_(query), tag, listener.hashFn, listener.onComplete);
        var subtree = this.syncPointTree_.subtree(path);
        // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we
        // may need to shadow other listens as well.
        if (tag) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(!subtree.value.hasCompleteView(), "If we're adding a query, it shouldn't be shadowed");
        }
        else {
            // Shadow everything at or below this location, this is a default listener.
            var queriesToStop = subtree.fold(function (relativePath, maybeChildSyncPoint, childMap) {
                if (!relativePath.isEmpty() &&
                    maybeChildSyncPoint &&
                    maybeChildSyncPoint.hasCompleteView()) {
                    return [maybeChildSyncPoint.getCompleteView().getQuery()];
                }
                else {
                    // No default listener here, flatten any deeper queries into an array
                    var queries_1 = [];
                    if (maybeChildSyncPoint) {
                        queries_1 = queries_1.concat(maybeChildSyncPoint.getQueryViews().map(function (view) { return view.getQuery(); }));
                    }
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["h" /* forEach */])(childMap, function (key, childQueries) {
                        queries_1 = queries_1.concat(childQueries);
                    });
                    return queries_1;
                }
            });
            for (var i = 0; i < queriesToStop.length; ++i) {
                var queryToStop = queriesToStop[i];
                this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToStop), this.tagForQuery_(queryToStop));
            }
        }
        return events;
    };
    /**
     *
     * @param {!View} view
     * @return {{hashFn: function(), onComplete: function(!string, *)}}
     * @private
     */
    SyncTree.prototype.createListenerForView_ = function (view) {
        var _this = this;
        var query = view.getQuery();
        var tag = this.tagForQuery_(query);
        return {
            hashFn: function () {
                var cache = view.getServerCache() || __WEBPACK_IMPORTED_MODULE_3__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE;
                return cache.hash();
            },
            onComplete: function (status) {
                if (status === 'ok') {
                    if (tag) {
                        return _this.applyTaggedListenComplete(query.path, tag);
                    }
                    else {
                        return _this.applyListenComplete(query.path);
                    }
                }
                else {
                    // If a listen failed, kill all of the listeners here, not just the one that triggered the error.
                    // Note that this may need to be scoped to just this listener if we change permissions on filtered children
                    var error = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_util__["y" /* errorForServerCode */])(status, query);
                    return _this.removeEventRegistration(query, 
                    /*eventRegistration*/ null, error);
                }
            }
        };
    };
    /**
     * Given a query, computes a "queryKey" suitable for use in our queryToTagMap_.
     * @private
     * @param {!Query} query
     * @return {string}
     */
    SyncTree.makeQueryKey_ = function (query) {
        return query.path.toString() + '$' + query.queryIdentifier();
    };
    /**
     * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.
     * @private
     * @param {!string} queryKey
     * @return {{queryId: !string, path: !Path}}
     */
    SyncTree.parseQueryKey_ = function (queryKey) {
        var splitIndex = queryKey.indexOf('$');
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(splitIndex !== -1 && splitIndex < queryKey.length - 1, 'Bad queryKey.');
        return {
            queryId: queryKey.substr(splitIndex + 1),
            path: new __WEBPACK_IMPORTED_MODULE_9__util_Path__["a" /* Path */](queryKey.substr(0, splitIndex))
        };
    };
    /**
     * Return the query associated with the given tag, if we have one
     * @param {!number} tag
     * @return {?string}
     * @private
     */
    SyncTree.prototype.queryKeyForTag_ = function (tag) {
        return this.tagToQueryMap_['_' + tag];
    };
    /**
     * Return the tag associated with the given query.
     * @param {!Query} query
     * @return {?number}
     * @private
     */
    SyncTree.prototype.tagForQuery_ = function (query) {
        var queryKey = SyncTree.makeQueryKey_(query);
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["s" /* safeGet */])(this.queryToTagMap_, queryKey);
    };
    /**
     * Static accessor for query tags.
     * @return {number}
     * @private
     */
    SyncTree.getNextQueryTag_ = function () {
        return SyncTree.nextQueryTag_++;
    };
    /**
     * A helper method to apply tagged operations
     *
     * @param {!Path} queryPath
     * @param {!Operation} operation
     * @return {!Array.<!Event>}
     * @private
     */
    SyncTree.prototype.applyTaggedOperation_ = function (queryPath, operation) {
        var syncPoint = this.syncPointTree_.get(queryPath);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(syncPoint, "Missing sync point for query tag that we're tracking");
        var writesCache = this.pendingWriteTree_.childWrites(queryPath);
        return syncPoint.applyOperation(operation, writesCache, 
        /*serverCache=*/ null);
    };
    /**
     * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.
     *
     * NOTES:
     * - Descendant SyncPoints will be visited first (since we raise events depth-first).
  
     * - We call applyOperation() on each SyncPoint passing three things:
     *   1. A version of the Operation that has been made relative to the SyncPoint location.
     *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.
     *   3. A snapshot Node with cached server data, if we have it.
  
     * - We concatenate all of the events returned by each SyncPoint and return the result.
     *
     * @param {!Operation} operation
     * @return {!Array.<!Event>}
     * @private
     */
    SyncTree.prototype.applyOperationToSyncPoints_ = function (operation) {
        return this.applyOperationHelper_(operation, this.syncPointTree_, 
        /*serverCache=*/ null, this.pendingWriteTree_.childWrites(__WEBPACK_IMPORTED_MODULE_9__util_Path__["a" /* Path */].Empty));
    };
    /**
     * Recursive helper for applyOperationToSyncPoints_
     *
     * @private
     * @param {!Operation} operation
     * @param {ImmutableTree.<!SyncPoint>} syncPointTree
     * @param {?Node} serverCache
     * @param {!WriteTreeRef} writesCache
     * @return {!Array.<!Event>}
     */
    SyncTree.prototype.applyOperationHelper_ = function (operation, syncPointTree, serverCache, writesCache) {
        if (operation.path.isEmpty()) {
            return this.applyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);
        }
        else {
            var syncPoint = syncPointTree.get(__WEBPACK_IMPORTED_MODULE_9__util_Path__["a" /* Path */].Empty);
            // If we don't have cached server data, see if we can get it from this SyncPoint.
            if (serverCache == null && syncPoint != null) {
                serverCache = syncPoint.getCompleteServerCache(__WEBPACK_IMPORTED_MODULE_9__util_Path__["a" /* Path */].Empty);
            }
            var events = [];
            var childName = operation.path.getFront();
            var childOperation = operation.operationForChild(childName);
            var childTree = syncPointTree.children.get(childName);
            if (childTree && childOperation) {
                var childServerCache = serverCache
                    ? serverCache.getImmediateChild(childName)
                    : null;
                var childWritesCache = writesCache.child(childName);
                events = events.concat(this.applyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));
            }
            if (syncPoint) {
                events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache));
            }
            return events;
        }
    };
    /**
     * Recursive helper for applyOperationToSyncPoints_
     *
     * @private
     * @param {!Operation} operation
     * @param {ImmutableTree.<!SyncPoint>} syncPointTree
     * @param {?Node} serverCache
     * @param {!WriteTreeRef} writesCache
     * @return {!Array.<!Event>}
     */
    SyncTree.prototype.applyOperationDescendantsHelper_ = function (operation, syncPointTree, serverCache, writesCache) {
        var _this = this;
        var syncPoint = syncPointTree.get(__WEBPACK_IMPORTED_MODULE_9__util_Path__["a" /* Path */].Empty);
        // If we don't have cached server data, see if we can get it from this SyncPoint.
        if (serverCache == null && syncPoint != null) {
            serverCache = syncPoint.getCompleteServerCache(__WEBPACK_IMPORTED_MODULE_9__util_Path__["a" /* Path */].Empty);
        }
        var events = [];
        syncPointTree.children.inorderTraversal(function (childName, childTree) {
            var childServerCache = serverCache
                ? serverCache.getImmediateChild(childName)
                : null;
            var childWritesCache = writesCache.child(childName);
            var childOperation = operation.operationForChild(childName);
            if (childOperation) {
                events = events.concat(_this.applyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));
            }
        });
        if (syncPoint) {
            events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache));
        }
        return events;
    };
    /**
     * Static tracker for next query tag.
     * @type {number}
     * @private
     */
    SyncTree.nextQueryTag_ = 1;
    return SyncTree;
}());




/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WriteTree; });
/* unused harmony export WriteTreeRef */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__CompoundWrite__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__snap_indexes_PriorityIndex__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__snap_ChildrenNode__ = __webpack_require__(6);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * WriteTree tracks all pending user-initiated writes and has methods to calculate the result of merging them
 * with underlying server data (to create "event cache" data).  Pending writes are added with addOverwrite()
 * and addMerge(), and removed with removeWrite().
 *
 * @constructor
 */
var WriteTree = /** @class */ (function () {
    function WriteTree() {
        /**
         * A tree tracking the result of applying all visible writes.  This does not include transactions with
         * applyLocally=false or writes that are completely shadowed by other writes.
         *
         * @type {!CompoundWrite}
         * @private
         */
        this.visibleWrites_ = __WEBPACK_IMPORTED_MODULE_2__CompoundWrite__["a" /* CompoundWrite */].Empty;
        /**
         * A list of all pending writes, regardless of visibility and shadowed-ness.  Used to calculate arbitrary
         * sets of the changed data, such as hidden writes (from transactions) or changes with certain writes excluded (also
         * used by transactions).
         *
         * @type {!Array.<!WriteRecord>}
         * @private
         */
        this.allWrites_ = [];
        this.lastWriteId_ = -1;
    }
    /**
     * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.
     *
     * @param {!Path} path
     * @return {!WriteTreeRef}
     */
    WriteTree.prototype.childWrites = function (path) {
        return new WriteTreeRef(path, this);
    };
    /**
     * Record a new overwrite from user code.
     *
     * @param {!Path} path
     * @param {!Node} snap
     * @param {!number} writeId
     * @param {boolean=} visible This is set to false by some transactions. It should be excluded from event caches
     */
    WriteTree.prototype.addOverwrite = function (path, snap, writeId, visible) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(writeId > this.lastWriteId_, 'Stacking an older write on top of newer ones');
        if (visible === undefined) {
            visible = true;
        }
        this.allWrites_.push({
            path: path,
            snap: snap,
            writeId: writeId,
            visible: visible
        });
        if (visible) {
            this.visibleWrites_ = this.visibleWrites_.addWrite(path, snap);
        }
        this.lastWriteId_ = writeId;
    };
    /**
     * Record a new merge from user code.
     *
     * @param {!Path} path
     * @param {!Object.<string, !Node>} changedChildren
     * @param {!number} writeId
     */
    WriteTree.prototype.addMerge = function (path, changedChildren, writeId) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(writeId > this.lastWriteId_, 'Stacking an older merge on top of newer ones');
        this.allWrites_.push({
            path: path,
            children: changedChildren,
            writeId: writeId,
            visible: true
        });
        this.visibleWrites_ = this.visibleWrites_.addWrites(path, changedChildren);
        this.lastWriteId_ = writeId;
    };
    /**
     * @param {!number} writeId
     * @return {?WriteRecord}
     */
    WriteTree.prototype.getWrite = function (writeId) {
        for (var i = 0; i < this.allWrites_.length; i++) {
            var record = this.allWrites_[i];
            if (record.writeId === writeId) {
                return record;
            }
        }
        return null;
    };
    /**
     * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates
     * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.
     *
     * @param {!number} writeId
     * @return {boolean} true if the write may have been visible (meaning we'll need to reevaluate / raise
     * events as a result).
     */
    WriteTree.prototype.removeWrite = function (writeId) {
        // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied
        // out of order.
        //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;
        //assert(validClear, "Either we don't have this write, or it's the first one in the queue");
        var _this = this;
        var idx = this.allWrites_.findIndex(function (s) {
            return s.writeId === writeId;
        });
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(idx >= 0, 'removeWrite called with nonexistent writeId.');
        var writeToRemove = this.allWrites_[idx];
        this.allWrites_.splice(idx, 1);
        var removedWriteWasVisible = writeToRemove.visible;
        var removedWriteOverlapsWithOtherWrites = false;
        var i = this.allWrites_.length - 1;
        while (removedWriteWasVisible && i >= 0) {
            var currentWrite = this.allWrites_[i];
            if (currentWrite.visible) {
                if (i >= idx &&
                    this.recordContainsPath_(currentWrite, writeToRemove.path)) {
                    // The removed write was completely shadowed by a subsequent write.
                    removedWriteWasVisible = false;
                }
                else if (writeToRemove.path.contains(currentWrite.path)) {
                    // Either we're covering some writes or they're covering part of us (depending on which came first).
                    removedWriteOverlapsWithOtherWrites = true;
                }
            }
            i--;
        }
        if (!removedWriteWasVisible) {
            return false;
        }
        else if (removedWriteOverlapsWithOtherWrites) {
            // There's some shadowing going on. Just rebuild the visible writes from scratch.
            this.resetTree_();
            return true;
        }
        else {
            // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.
            if (writeToRemove.snap) {
                this.visibleWrites_ = this.visibleWrites_.removeWrite(writeToRemove.path);
            }
            else {
                var children = writeToRemove.children;
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["h" /* forEach */])(children, function (childName) {
                    _this.visibleWrites_ = _this.visibleWrites_.removeWrite(writeToRemove.path.child(childName));
                });
            }
            return true;
        }
    };
    /**
     * Return a complete snapshot for the given path if there's visible write data at that path, else null.
     * No server data is considered.
     *
     * @param {!Path} path
     * @return {?Node}
     */
    WriteTree.prototype.getCompleteWriteData = function (path) {
        return this.visibleWrites_.getCompleteNode(path);
    };
    /**
     * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden
     * writes), attempt to calculate a complete snapshot for the given path
     *
     * @param {!Path} treePath
     * @param {?Node} completeServerCache
     * @param {Array.<number>=} writeIdsToExclude An optional set to be excluded
     * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false
     * @return {?Node}
     */
    WriteTree.prototype.calcCompleteEventCache = function (treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
        if (!writeIdsToExclude && !includeHiddenWrites) {
            var shadowingNode = this.visibleWrites_.getCompleteNode(treePath);
            if (shadowingNode != null) {
                return shadowingNode;
            }
            else {
                var subMerge = this.visibleWrites_.childCompoundWrite(treePath);
                if (subMerge.isEmpty()) {
                    return completeServerCache;
                }
                else if (completeServerCache == null &&
                    !subMerge.hasCompleteWrite(__WEBPACK_IMPORTED_MODULE_1__util_Path__["a" /* Path */].Empty)) {
                    // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow
                    return null;
                }
                else {
                    var layeredCache = completeServerCache || __WEBPACK_IMPORTED_MODULE_4__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE;
                    return subMerge.apply(layeredCache);
                }
            }
        }
        else {
            var merge = this.visibleWrites_.childCompoundWrite(treePath);
            if (!includeHiddenWrites && merge.isEmpty()) {
                return completeServerCache;
            }
            else {
                // If the server cache is null, and we don't have a complete cache, we need to return null
                if (!includeHiddenWrites &&
                    completeServerCache == null &&
                    !merge.hasCompleteWrite(__WEBPACK_IMPORTED_MODULE_1__util_Path__["a" /* Path */].Empty)) {
                    return null;
                }
                else {
                    var filter = function (write) {
                        return ((write.visible || includeHiddenWrites) &&
                            (!writeIdsToExclude ||
                                !~writeIdsToExclude.indexOf(write.writeId)) &&
                            (write.path.contains(treePath) || treePath.contains(write.path)));
                    };
                    var mergeAtPath = WriteTree.layerTree_(this.allWrites_, filter, treePath);
                    var layeredCache = completeServerCache || __WEBPACK_IMPORTED_MODULE_4__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE;
                    return mergeAtPath.apply(layeredCache);
                }
            }
        }
    };
    /**
     * With optional, underlying server data, attempt to return a children node of children that we have complete data for.
     * Used when creating new views, to pre-fill their complete event children snapshot.
     *
     * @param {!Path} treePath
     * @param {?ChildrenNode} completeServerChildren
     * @return {!ChildrenNode}
     */
    WriteTree.prototype.calcCompleteEventChildren = function (treePath, completeServerChildren) {
        var completeChildren = __WEBPACK_IMPORTED_MODULE_4__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE;
        var topLevelSet = this.visibleWrites_.getCompleteNode(treePath);
        if (topLevelSet) {
            if (!topLevelSet.isLeafNode()) {
                // we're shadowing everything. Return the children.
                topLevelSet.forEachChild(__WEBPACK_IMPORTED_MODULE_3__snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */], function (childName, childSnap) {
                    completeChildren = completeChildren.updateImmediateChild(childName, childSnap);
                });
            }
            return completeChildren;
        }
        else if (completeServerChildren) {
            // Layer any children we have on top of this
            // We know we don't have a top-level set, so just enumerate existing children
            var merge_1 = this.visibleWrites_.childCompoundWrite(treePath);
            completeServerChildren.forEachChild(__WEBPACK_IMPORTED_MODULE_3__snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */], function (childName, childNode) {
                var node = merge_1
                    .childCompoundWrite(new __WEBPACK_IMPORTED_MODULE_1__util_Path__["a" /* Path */](childName))
                    .apply(childNode);
                completeChildren = completeChildren.updateImmediateChild(childName, node);
            });
            // Add any complete children we have from the set
            merge_1.getCompleteChildren().forEach(function (namedNode) {
                completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
            });
            return completeChildren;
        }
        else {
            // We don't have anything to layer on top of. Layer on any children we have
            // Note that we can return an empty snap if we have a defined delete
            var merge = this.visibleWrites_.childCompoundWrite(treePath);
            merge.getCompleteChildren().forEach(function (namedNode) {
                completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
            });
            return completeChildren;
        }
    };
    /**
     * Given that the underlying server data has updated, determine what, if anything, needs to be
     * applied to the event cache.
     *
     * Possibilities:
     *
     * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
     *
     * 2. Some write is completely shadowing. No events to be raised
     *
     * 3. Is partially shadowed. Events
     *
     * Either existingEventSnap or existingServerSnap must exist
     *
     * @param {!Path} treePath
     * @param {!Path} childPath
     * @param {?Node} existingEventSnap
     * @param {?Node} existingServerSnap
     * @return {?Node}
     */
    WriteTree.prototype.calcEventCacheAfterServerOverwrite = function (treePath, childPath, existingEventSnap, existingServerSnap) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(existingEventSnap || existingServerSnap, 'Either existingEventSnap or existingServerSnap must exist');
        var path = treePath.child(childPath);
        if (this.visibleWrites_.hasCompleteWrite(path)) {
            // At this point we can probably guarantee that we're in case 2, meaning no events
            // May need to check visibility while doing the findRootMostValueAndPath call
            return null;
        }
        else {
            // No complete shadowing. We're either partially shadowing or not shadowing at all.
            var childMerge = this.visibleWrites_.childCompoundWrite(path);
            if (childMerge.isEmpty()) {
                // We're not shadowing at all. Case 1
                return existingServerSnap.getChild(childPath);
            }
            else {
                // This could be more efficient if the serverNode + updates doesn't change the eventSnap
                // However this is tricky to find out, since user updates don't necessary change the server
                // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server
                // adds nodes, but doesn't change any existing writes. It is therefore not enough to
                // only check if the updates change the serverNode.
                // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?
                return childMerge.apply(existingServerSnap.getChild(childPath));
            }
        }
    };
    /**
     * Returns a complete child for a given server snap after applying all user writes or null if there is no
     * complete child for this ChildKey.
     *
     * @param {!Path} treePath
     * @param {!string} childKey
     * @param {!CacheNode} existingServerSnap
     * @return {?Node}
     */
    WriteTree.prototype.calcCompleteChild = function (treePath, childKey, existingServerSnap) {
        var path = treePath.child(childKey);
        var shadowingNode = this.visibleWrites_.getCompleteNode(path);
        if (shadowingNode != null) {
            return shadowingNode;
        }
        else {
            if (existingServerSnap.isCompleteForChild(childKey)) {
                var childMerge = this.visibleWrites_.childCompoundWrite(path);
                return childMerge.apply(existingServerSnap.getNode().getImmediateChild(childKey));
            }
            else {
                return null;
            }
        }
    };
    /**
     * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
     * a higher path, this will return the child of that write relative to the write and this path.
     * Returns null if there is no write at this path.
     *
     * @param {!Path} path
     * @return {?Node}
     */
    WriteTree.prototype.shadowingWrite = function (path) {
        return this.visibleWrites_.getCompleteNode(path);
    };
    /**
     * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
     * the window, but may now be in the window.
     *
     * @param {!Path} treePath
     * @param {?Node} completeServerData
     * @param {!NamedNode} startPost
     * @param {!number} count
     * @param {boolean} reverse
     * @param {!Index} index
     * @return {!Array.<!NamedNode>}
     */
    WriteTree.prototype.calcIndexedSlice = function (treePath, completeServerData, startPost, count, reverse, index) {
        var toIterate;
        var merge = this.visibleWrites_.childCompoundWrite(treePath);
        var shadowingNode = merge.getCompleteNode(__WEBPACK_IMPORTED_MODULE_1__util_Path__["a" /* Path */].Empty);
        if (shadowingNode != null) {
            toIterate = shadowingNode;
        }
        else if (completeServerData != null) {
            toIterate = merge.apply(completeServerData);
        }
        else {
            // no children to iterate on
            return [];
        }
        toIterate = toIterate.withIndex(index);
        if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {
            var nodes = [];
            var cmp = index.getCompare();
            var iter = reverse
                ? toIterate.getReverseIteratorFrom(startPost, index)
                : toIterate.getIteratorFrom(startPost, index);
            var next = iter.getNext();
            while (next && nodes.length < count) {
                if (cmp(next, startPost) !== 0) {
                    nodes.push(next);
                }
                next = iter.getNext();
            }
            return nodes;
        }
        else {
            return [];
        }
    };
    /**
     * @param {!WriteRecord} writeRecord
     * @param {!Path} path
     * @return {boolean}
     * @private
     */
    WriteTree.prototype.recordContainsPath_ = function (writeRecord, path) {
        if (writeRecord.snap) {
            return writeRecord.path.contains(path);
        }
        else {
            // findKey can return undefined, so use !! to coerce to boolean
            return !!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["F" /* findKey */])(writeRecord.children, function (childSnap, childName) {
                return writeRecord.path.child(childName).contains(path);
            });
        }
    };
    /**
     * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots
     * @private
     */
    WriteTree.prototype.resetTree_ = function () {
        this.visibleWrites_ = WriteTree.layerTree_(this.allWrites_, WriteTree.DefaultFilter_, __WEBPACK_IMPORTED_MODULE_1__util_Path__["a" /* Path */].Empty);
        if (this.allWrites_.length > 0) {
            this.lastWriteId_ = this.allWrites_[this.allWrites_.length - 1].writeId;
        }
        else {
            this.lastWriteId_ = -1;
        }
    };
    /**
     * The default filter used when constructing the tree. Keep everything that's visible.
     *
     * @param {!WriteRecord} write
     * @return {boolean}
     * @private
     */
    WriteTree.DefaultFilter_ = function (write) {
        return write.visible;
    };
    /**
     * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of
     * event data at that path.
     *
     * @param {!Array.<!WriteRecord>} writes
     * @param {!function(!WriteRecord):boolean} filter
     * @param {!Path} treeRoot
     * @return {!CompoundWrite}
     * @private
     */
    WriteTree.layerTree_ = function (writes, filter, treeRoot) {
        var compoundWrite = __WEBPACK_IMPORTED_MODULE_2__CompoundWrite__["a" /* CompoundWrite */].Empty;
        for (var i = 0; i < writes.length; ++i) {
            var write = writes[i];
            // Theory, a later set will either:
            // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction
            // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction
            if (filter(write)) {
                var writePath = write.path;
                var relativePath = void 0;
                if (write.snap) {
                    if (treeRoot.contains(writePath)) {
                        relativePath = __WEBPACK_IMPORTED_MODULE_1__util_Path__["a" /* Path */].relativePath(treeRoot, writePath);
                        compoundWrite = compoundWrite.addWrite(relativePath, write.snap);
                    }
                    else if (writePath.contains(treeRoot)) {
                        relativePath = __WEBPACK_IMPORTED_MODULE_1__util_Path__["a" /* Path */].relativePath(writePath, treeRoot);
                        compoundWrite = compoundWrite.addWrite(__WEBPACK_IMPORTED_MODULE_1__util_Path__["a" /* Path */].Empty, write.snap.getChild(relativePath));
                    }
                    else {
                        // There is no overlap between root path and write path, ignore write
                    }
                }
                else if (write.children) {
                    if (treeRoot.contains(writePath)) {
                        relativePath = __WEBPACK_IMPORTED_MODULE_1__util_Path__["a" /* Path */].relativePath(treeRoot, writePath);
                        compoundWrite = compoundWrite.addWrites(relativePath, write.children);
                    }
                    else if (writePath.contains(treeRoot)) {
                        relativePath = __WEBPACK_IMPORTED_MODULE_1__util_Path__["a" /* Path */].relativePath(writePath, treeRoot);
                        if (relativePath.isEmpty()) {
                            compoundWrite = compoundWrite.addWrites(__WEBPACK_IMPORTED_MODULE_1__util_Path__["a" /* Path */].Empty, write.children);
                        }
                        else {
                            var child = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["s" /* safeGet */])(write.children, relativePath.getFront());
                            if (child) {
                                // There exists a child in this node that matches the root path
                                var deepNode = child.getChild(relativePath.popFront());
                                compoundWrite = compoundWrite.addWrite(__WEBPACK_IMPORTED_MODULE_1__util_Path__["a" /* Path */].Empty, deepNode);
                            }
                        }
                    }
                    else {
                        // There is no overlap between root path and write path, ignore write
                    }
                }
                else {
                    throw __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["C" /* assertionError */])('WriteRecord should have .snap or .children');
                }
            }
        }
        return compoundWrite;
    };
    return WriteTree;
}());

/**
 * A WriteTreeRef wraps a WriteTree and a path, for convenient access to a particular subtree.  All of the methods
 * just proxy to the underlying WriteTree.
 *
 * @constructor
 */
var WriteTreeRef = /** @class */ (function () {
    /**
     * @param {!Path} path
     * @param {!WriteTree} writeTree
     */
    function WriteTreeRef(path, writeTree) {
        this.treePath_ = path;
        this.writeTree_ = writeTree;
    }
    /**
     * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used
     * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node
     * can lead to a more expensive calculation.
     *
     * @param {?Node} completeServerCache
     * @param {Array.<number>=} writeIdsToExclude Optional writes to exclude.
     * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false
     * @return {?Node}
     */
    WriteTreeRef.prototype.calcCompleteEventCache = function (completeServerCache, writeIdsToExclude, includeHiddenWrites) {
        return this.writeTree_.calcCompleteEventCache(this.treePath_, completeServerCache, writeIdsToExclude, includeHiddenWrites);
    };
    /**
     * If possible, returns a children node containing all of the complete children we have data for. The returned data is a
     * mix of the given server data and write data.
     *
     * @param {?ChildrenNode} completeServerChildren
     * @return {!ChildrenNode}
     */
    WriteTreeRef.prototype.calcCompleteEventChildren = function (completeServerChildren) {
        return this.writeTree_.calcCompleteEventChildren(this.treePath_, completeServerChildren);
    };
    /**
     * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,
     * if anything, needs to be applied to the event cache.
     *
     * Possibilities:
     *
     * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
     *
     * 2. Some write is completely shadowing. No events to be raised
     *
     * 3. Is partially shadowed. Events should be raised
     *
     * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert
     *
     * @param {!Path} path
     * @param {?Node} existingEventSnap
     * @param {?Node} existingServerSnap
     * @return {?Node}
     */
    WriteTreeRef.prototype.calcEventCacheAfterServerOverwrite = function (path, existingEventSnap, existingServerSnap) {
        return this.writeTree_.calcEventCacheAfterServerOverwrite(this.treePath_, path, existingEventSnap, existingServerSnap);
    };
    /**
     * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
     * a higher path, this will return the child of that write relative to the write and this path.
     * Returns null if there is no write at this path.
     *
     * @param {!Path} path
     * @return {?Node}
     */
    WriteTreeRef.prototype.shadowingWrite = function (path) {
        return this.writeTree_.shadowingWrite(this.treePath_.child(path));
    };
    /**
     * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
     * the window, but may now be in the window
     *
     * @param {?Node} completeServerData
     * @param {!NamedNode} startPost
     * @param {!number} count
     * @param {boolean} reverse
     * @param {!Index} index
     * @return {!Array.<!NamedNode>}
     */
    WriteTreeRef.prototype.calcIndexedSlice = function (completeServerData, startPost, count, reverse, index) {
        return this.writeTree_.calcIndexedSlice(this.treePath_, completeServerData, startPost, count, reverse, index);
    };
    /**
     * Returns a complete child for a given server snap after applying all user writes or null if there is no
     * complete child for this ChildKey.
     *
     * @param {!string} childKey
     * @param {!CacheNode} existingServerCache
     * @return {?Node}
     */
    WriteTreeRef.prototype.calcCompleteChild = function (childKey, existingServerCache) {
        return this.writeTree_.calcCompleteChild(this.treePath_, childKey, existingServerCache);
    };
    /**
     * Return a WriteTreeRef for a child.
     *
     * @param {string} childName
     * @return {!WriteTreeRef}
     */
    WriteTreeRef.prototype.child = function (childName) {
        return new WriteTreeRef(this.treePath_.child(childName), this.writeTree_);
    };
    return WriteTreeRef;
}());




/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AckUserWrite; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Operation__ = __webpack_require__(9);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var AckUserWrite = /** @class */ (function () {
    /**
     *
     * @param {!Path} path
     * @param {!ImmutableTree<!boolean>} affectedTree A tree containing true for each affected path. Affected paths can't overlap.
     * @param {!boolean} revert
     */
    function AckUserWrite(
        /**@inheritDoc */ path, 
        /**@inheritDoc */ affectedTree, 
        /**@inheritDoc */ revert) {
        this.path = path;
        this.affectedTree = affectedTree;
        this.revert = revert;
        /** @inheritDoc */
        this.type = __WEBPACK_IMPORTED_MODULE_2__Operation__["b" /* OperationType */].ACK_USER_WRITE;
        /** @inheritDoc */
        this.source = __WEBPACK_IMPORTED_MODULE_2__Operation__["a" /* OperationSource */].User;
    }
    /**
     * @inheritDoc
     */
    AckUserWrite.prototype.operationForChild = function (childName) {
        if (!this.path.isEmpty()) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(this.path.getFront() === childName, 'operationForChild called for unrelated child.');
            return new AckUserWrite(this.path.popFront(), this.affectedTree, this.revert);
        }
        else if (this.affectedTree.value != null) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(this.affectedTree.children.isEmpty(), 'affectedTree should not have overlapping affected paths.');
            // All child locations are affected as well; just return same operation.
            return this;
        }
        else {
            var childTree = this.affectedTree.subtree(new __WEBPACK_IMPORTED_MODULE_1__util_Path__["a" /* Path */](childName));
            return new AckUserWrite(__WEBPACK_IMPORTED_MODULE_1__util_Path__["a" /* Path */].Empty, childTree, this.revert);
        }
    };
    return AckUserWrite;
}());




/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ListenComplete; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Operation__ = __webpack_require__(9);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {!OperationSource} source
 * @param {!Path} path
 * @constructor
 * @implements {Operation}
 */
var ListenComplete = /** @class */ (function () {
    function ListenComplete(source, path) {
        this.source = source;
        this.path = path;
        /** @inheritDoc */
        this.type = __WEBPACK_IMPORTED_MODULE_1__Operation__["b" /* OperationType */].LISTEN_COMPLETE;
    }
    ListenComplete.prototype.operationForChild = function (childName) {
        if (this.path.isEmpty()) {
            return new ListenComplete(this.source, __WEBPACK_IMPORTED_MODULE_0__util_Path__["a" /* Path */].Empty);
        }
        else {
            return new ListenComplete(this.source, this.path.popFront());
        }
    };
    return ListenComplete;
}());




/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Merge; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Operation__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Overwrite__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * @param {!OperationSource} source
 * @param {!Path} path
 * @param {!ImmutableTree.<!Node>} children
 * @constructor
 * @implements {Operation}
 */
var Merge = /** @class */ (function () {
    function Merge(
        /**@inheritDoc */ source, 
        /**@inheritDoc */ path, 
        /**@inheritDoc */ children) {
        this.source = source;
        this.path = path;
        this.children = children;
        /** @inheritDoc */
        this.type = __WEBPACK_IMPORTED_MODULE_0__Operation__["b" /* OperationType */].MERGE;
    }
    /**
     * @inheritDoc
     */
    Merge.prototype.operationForChild = function (childName) {
        if (this.path.isEmpty()) {
            var childTree = this.children.subtree(new __WEBPACK_IMPORTED_MODULE_2__util_Path__["a" /* Path */](childName));
            if (childTree.isEmpty()) {
                // This child is unaffected
                return null;
            }
            else if (childTree.value) {
                // We have a snapshot for the child in question.  This becomes an overwrite of the child.
                return new __WEBPACK_IMPORTED_MODULE_1__Overwrite__["a" /* Overwrite */](this.source, __WEBPACK_IMPORTED_MODULE_2__util_Path__["a" /* Path */].Empty, childTree.value);
            }
            else {
                // This is a merge at a deeper level
                return new Merge(this.source, __WEBPACK_IMPORTED_MODULE_2__util_Path__["a" /* Path */].Empty, childTree);
            }
        }
        else {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__firebase_util__["g" /* assert */])(this.path.getFront() === childName, "Can't get a merge for a child not on the path of the operation");
            return new Merge(this.source, this.path.popFront(), this.children);
        }
    };
    /**
     * @inheritDoc
     */
    Merge.prototype.toString = function () {
        return ('Operation(' +
            this.path +
            ': ' +
            this.source.toString() +
            ' merge: ' +
            this.children.toString() +
            ')');
    };
    return Merge;
}());




/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return StatsCollection; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Tracks a collection of stats.
 *
 * @constructor
 */
var StatsCollection = /** @class */ (function () {
    function StatsCollection() {
        this.counters_ = {};
    }
    StatsCollection.prototype.incrementCounter = function (name, amount) {
        if (amount === void 0) { amount = 1; }
        if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["i" /* contains */])(this.counters_, name))
            this.counters_[name] = 0;
        this.counters_[name] += amount;
    };
    StatsCollection.prototype.get = function () {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["a" /* deepCopy */])(this.counters_);
    };
    return StatsCollection;
}());




/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return StatsReporter; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__StatsListener__ = __webpack_require__(50);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



// Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably
// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10
// seconds to try to ensure the Firebase connection is established / settled.
var FIRST_STATS_MIN_TIME = 10 * 1000;
var FIRST_STATS_MAX_TIME = 30 * 1000;
// We'll continue to report stats on average every 5 minutes.
var REPORT_STATS_INTERVAL = 5 * 60 * 1000;
/**
 * @constructor
 */
var StatsReporter = /** @class */ (function () {
    /**
     * @param collection
     * @param server_
     */
    function StatsReporter(collection, server_) {
        this.server_ = server_;
        this.statsToReport_ = {};
        this.statsListener_ = new __WEBPACK_IMPORTED_MODULE_2__StatsListener__["a" /* StatsListener */](collection);
        var timeout = FIRST_STATS_MIN_TIME +
            (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_util__["c" /* setTimeoutNonBlocking */])(this.reportStats_.bind(this), Math.floor(timeout));
    }
    StatsReporter.prototype.includeStat = function (stat) {
        this.statsToReport_[stat] = true;
    };
    StatsReporter.prototype.reportStats_ = function () {
        var _this = this;
        var stats = this.statsListener_.get();
        var reportedStats = {};
        var haveStatsToReport = false;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["h" /* forEach */])(stats, function (stat, value) {
            if (value > 0 && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["i" /* contains */])(_this.statsToReport_, stat)) {
                reportedStats[stat] = value;
                haveStatsToReport = true;
            }
        });
        if (haveStatsToReport) {
            this.server_.reportStats(reportedStats);
        }
        // queue our next run.
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_util__["c" /* setTimeoutNonBlocking */])(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));
    };
    return StatsReporter;
}());




/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DOMStorageWrapper; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Wraps a DOM Storage object and:
 * - automatically encode objects as JSON strings before storing them to allow us to store arbitrary types.
 * - prefixes names with "firebase:" to avoid collisions with app data.
 *
 * We automatically (see storage.js) create two such wrappers, one for sessionStorage,
 * and one for localStorage.
 *
 * @constructor
 */
var DOMStorageWrapper = /** @class */ (function () {
    /**
     * @param {Storage} domStorage_ The underlying storage object (e.g. localStorage or sessionStorage)
     */
    function DOMStorageWrapper(domStorage_) {
        this.domStorage_ = domStorage_;
        // Use a prefix to avoid collisions with other stuff saved by the app.
        this.prefix_ = 'firebase:';
    }
    /**
     * @param {string} key The key to save the value under
     * @param {?Object} value The value being stored, or null to remove the key.
     */
    DOMStorageWrapper.prototype.set = function (key, value) {
        if (value == null) {
            this.domStorage_.removeItem(this.prefixedName_(key));
        }
        else {
            this.domStorage_.setItem(this.prefixedName_(key), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["j" /* stringify */])(value));
        }
    };
    /**
     * @param {string} key
     * @return {*} The value that was stored under this key, or null
     */
    DOMStorageWrapper.prototype.get = function (key) {
        var storedVal = this.domStorage_.getItem(this.prefixedName_(key));
        if (storedVal == null) {
            return null;
        }
        else {
            return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["k" /* jsonEval */])(storedVal);
        }
    };
    /**
     * @param {string} key
     */
    DOMStorageWrapper.prototype.remove = function (key) {
        this.domStorage_.removeItem(this.prefixedName_(key));
    };
    /**
     * @param {string} name
     * @return {string}
     */
    DOMStorageWrapper.prototype.prefixedName_ = function (name) {
        return this.prefix_ + name;
    };
    DOMStorageWrapper.prototype.toString = function () {
        return this.domStorage_.toString();
    };
    return DOMStorageWrapper;
}());




/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MemoryStorage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * An in-memory storage implementation that matches the API of DOMStorageWrapper
 * (TODO: create interface for both to implement).
 *
 * @constructor
 */
var MemoryStorage = /** @class */ (function () {
    function MemoryStorage() {
        this.cache_ = {};
        this.isInMemoryStorage = true;
    }
    MemoryStorage.prototype.set = function (key, value) {
        if (value == null) {
            delete this.cache_[key];
        }
        else {
            this.cache_[key] = value;
        }
    };
    MemoryStorage.prototype.get = function (key) {
        if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["i" /* contains */])(this.cache_, key)) {
            return this.cache_[key];
        }
        return null;
    };
    MemoryStorage.prototype.remove = function (key) {
        delete this.cache_[key];
    };
    return MemoryStorage;
}());




/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return nextPushId; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Fancy ID generator that creates 20-character string identifiers with the
 * following properties:
 *
 * 1. They're based on timestamp so that they sort *after* any existing ids.
 * 2. They contain 72-bits of random data after the timestamp so that IDs won't
 *    collide with other clients' IDs.
 * 3. They sort *lexicographically* (so the timestamp is converted to characters
 *    that will sort properly).
 * 4. They're monotonically increasing. Even if you generate more than one in
 *    the same timestamp, the latter ones will sort after the former ones. We do
 *    this by using the previous random bits but "incrementing" them by 1 (only
 *    in the case of a timestamp collision).
 */
var nextPushId = (function () {
    // Modeled after base64 web-safe chars, but ordered by ASCII.
    var PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';
    // Timestamp of last push, used to prevent local collisions if you push twice
    // in one ms.
    var lastPushTime = 0;
    // We generate 72-bits of randomness which get turned into 12 characters and
    // appended to the timestamp to prevent collisions with other clients. We
    // store the last characters we generated because in the event of a collision,
    // we'll use those same characters except "incremented" by one.
    var lastRandChars = [];
    return function (now) {
        var duplicateTime = now === lastPushTime;
        lastPushTime = now;
        var i;
        var timeStampChars = new Array(8);
        for (i = 7; i >= 0; i--) {
            timeStampChars[i] = PUSH_CHARS.charAt(now % 64);
            // NOTE: Can't use << here because javascript will convert to int and lose
            // the upper bits.
            now = Math.floor(now / 64);
        }
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(now === 0, 'Cannot push at time == 0');
        var id = timeStampChars.join('');
        if (!duplicateTime) {
            for (i = 0; i < 12; i++) {
                lastRandChars[i] = Math.floor(Math.random() * 64);
            }
        }
        else {
            // If the timestamp hasn't changed since last push, use the same random
            // number, except incremented by 1.
            for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {
                lastRandChars[i] = 0;
            }
            lastRandChars[i]++;
        }
        for (i = 0; i < 12; i++) {
            id += PUSH_CHARS.charAt(lastRandChars[i]);
        }
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(id.length === 20, 'nextPushId: Length should be 20.');
        return id;
    };
})();



/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OnlineMonitor; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__EventEmitter__ = __webpack_require__(52);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



/**
 * Monitors online state (as reported by window.online/offline events).
 *
 * The expectation is that this could have many false positives (thinks we are online
 * when we're not), but no false negatives.  So we can safely use it to determine when
 * we definitely cannot reach the internet.
 *
 * @extends {EventEmitter}
 */
var OnlineMonitor = /** @class */ (function (_super) {
    __extends(OnlineMonitor, _super);
    function OnlineMonitor() {
        var _this = _super.call(this, ['online']) || this;
        _this.online_ = true;
        // We've had repeated complaints that Cordova apps can get stuck "offline", e.g.
        // https://forum.ionicframework.com/t/firebase-connection-is-lost-and-never-come-back/43810
        // It would seem that the 'online' event does not always fire consistently. So we disable it
        // for Cordova.
        if (typeof window !== 'undefined' &&
            typeof window.addEventListener !== 'undefined' &&
            !__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["v" /* isMobileCordova */])()) {
            window.addEventListener('online', function () {
                if (!_this.online_) {
                    _this.online_ = true;
                    _this.trigger('online', true);
                }
            }, false);
            window.addEventListener('offline', function () {
                if (_this.online_) {
                    _this.online_ = false;
                    _this.trigger('online', false);
                }
            }, false);
        }
        return _this;
    }
    OnlineMonitor.getInstance = function () {
        return new OnlineMonitor();
    };
    /**
     * @param {!string} eventType
     * @return {Array.<boolean>}
     */
    OnlineMonitor.prototype.getInitialEvent = function (eventType) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(eventType === 'online', 'Unknown event type: ' + eventType);
        return [this.online_];
    };
    /**
     * @return {boolean}
     */
    OnlineMonitor.prototype.currentlyOnline = function () {
        return this.online_;
    };
    return OnlineMonitor;
}(__WEBPACK_IMPORTED_MODULE_1__EventEmitter__["a" /* EventEmitter */]));




/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export TreeNode */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Tree; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Path__ = __webpack_require__(2);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Node in a Tree.
 */
var TreeNode = /** @class */ (function () {
    function TreeNode() {
        // TODO: Consider making accessors that create children and value lazily or
        // separate Internal / Leaf 'types'.
        this.children = {};
        this.childCount = 0;
        this.value = null;
    }
    return TreeNode;
}());

/**
 * A light-weight tree, traversable by path.  Nodes can have both values and children.
 * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty
 * children.
 */
var Tree = /** @class */ (function () {
    /**
     * @template T
     * @param {string=} name_ Optional name of the node.
     * @param {Tree=} parent_ Optional parent node.
     * @param {TreeNode=} node_ Optional node to wrap.
     */
    function Tree(name_, parent_, node_) {
        if (name_ === void 0) { name_ = ''; }
        if (parent_ === void 0) { parent_ = null; }
        if (node_ === void 0) { node_ = new TreeNode(); }
        this.name_ = name_;
        this.parent_ = parent_;
        this.node_ = node_;
    }
    /**
     * Returns a sub-Tree for the given path.
     *
     * @param {!(string|Path)} pathObj Path to look up.
     * @return {!Tree.<T>} Tree for path.
     */
    Tree.prototype.subTree = function (pathObj) {
        // TODO: Require pathObj to be Path?
        var path = pathObj instanceof __WEBPACK_IMPORTED_MODULE_1__Path__["a" /* Path */] ? pathObj : new __WEBPACK_IMPORTED_MODULE_1__Path__["a" /* Path */](pathObj);
        var child = this, next;
        while ((next = path.getFront()) !== null) {
            var childNode = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["s" /* safeGet */])(child.node_.children, next) || new TreeNode();
            child = new Tree(next, child, childNode);
            path = path.popFront();
        }
        return child;
    };
    /**
     * Returns the data associated with this tree node.
     *
     * @return {?T} The data or null if no data exists.
     */
    Tree.prototype.getValue = function () {
        return this.node_.value;
    };
    /**
     * Sets data to this tree node.
     *
     * @param {!T} value Value to set.
     */
    Tree.prototype.setValue = function (value) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(typeof value !== 'undefined', 'Cannot set value to undefined');
        this.node_.value = value;
        this.updateParents_();
    };
    /**
     * Clears the contents of the tree node (its value and all children).
     */
    Tree.prototype.clear = function () {
        this.node_.value = null;
        this.node_.children = {};
        this.node_.childCount = 0;
        this.updateParents_();
    };
    /**
     * @return {boolean} Whether the tree has any children.
     */
    Tree.prototype.hasChildren = function () {
        return this.node_.childCount > 0;
    };
    /**
     * @return {boolean} Whether the tree is empty (no value or children).
     */
    Tree.prototype.isEmpty = function () {
        return this.getValue() === null && !this.hasChildren();
    };
    /**
     * Calls action for each child of this tree node.
     *
     * @param {function(!Tree.<T>)} action Action to be called for each child.
     */
    Tree.prototype.forEachChild = function (action) {
        var _this = this;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["h" /* forEach */])(this.node_.children, function (child, childTree) {
            action(new Tree(child, _this, childTree));
        });
    };
    /**
     * Does a depth-first traversal of this node's descendants, calling action for each one.
     *
     * @param {function(!Tree.<T>)} action Action to be called for each child.
     * @param {boolean=} includeSelf Whether to call action on this node as well. Defaults to
     *   false.
     * @param {boolean=} childrenFirst Whether to call action on children before calling it on
     *   parent.
     */
    Tree.prototype.forEachDescendant = function (action, includeSelf, childrenFirst) {
        if (includeSelf && !childrenFirst)
            action(this);
        this.forEachChild(function (child) {
            child.forEachDescendant(action, /*includeSelf=*/ true, childrenFirst);
        });
        if (includeSelf && childrenFirst)
            action(this);
    };
    /**
     * Calls action on each ancestor node.
     *
     * @param {function(!Tree.<T>)} action Action to be called on each parent; return
     *   true to abort.
     * @param {boolean=} includeSelf Whether to call action on this node as well.
     * @return {boolean} true if the action callback returned true.
     */
    Tree.prototype.forEachAncestor = function (action, includeSelf) {
        var node = includeSelf ? this : this.parent();
        while (node !== null) {
            if (action(node)) {
                return true;
            }
            node = node.parent();
        }
        return false;
    };
    /**
     * Does a depth-first traversal of this node's descendants.  When a descendant with a value
     * is found, action is called on it and traversal does not continue inside the node.
     * Action is *not* called on this node.
     *
     * @param {function(!Tree.<T>)} action Action to be called for each child.
     */
    Tree.prototype.forEachImmediateDescendantWithValue = function (action) {
        this.forEachChild(function (child) {
            if (child.getValue() !== null)
                action(child);
            else
                child.forEachImmediateDescendantWithValue(action);
        });
    };
    /**
     * @return {!Path} The path of this tree node, as a Path.
     */
    Tree.prototype.path = function () {
        return new __WEBPACK_IMPORTED_MODULE_1__Path__["a" /* Path */](this.parent_ === null
            ? this.name_
            : this.parent_.path() + '/' + this.name_);
    };
    /**
     * @return {string} The name of the tree node.
     */
    Tree.prototype.name = function () {
        return this.name_;
    };
    /**
     * @return {?Tree} The parent tree node, or null if this is the root of the tree.
     */
    Tree.prototype.parent = function () {
        return this.parent_;
    };
    /**
     * Adds or removes this child from its parent based on whether it's empty or not.
     *
     * @private
     */
    Tree.prototype.updateParents_ = function () {
        if (this.parent_ !== null)
            this.parent_.updateChild_(this.name_, this);
    };
    /**
     * Adds or removes the passed child to this tree node, depending on whether it's empty.
     *
     * @param {string} childName The name of the child to update.
     * @param {!Tree.<T>} child The child to update.
     * @private
     */
    Tree.prototype.updateChild_ = function (childName, child) {
        var childEmpty = child.isEmpty();
        var childExists = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["i" /* contains */])(this.node_.children, childName);
        if (childEmpty && childExists) {
            delete this.node_.children[childName];
            this.node_.childCount--;
            this.updateParents_();
        }
        else if (!childEmpty && !childExists) {
            this.node_.children[childName] = child.node_;
            this.node_.childCount++;
            this.updateParents_();
        }
    };
    return Tree;
}());




/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return VisibilityMonitor; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__EventEmitter__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * @extends {EventEmitter}
 */
var VisibilityMonitor = /** @class */ (function (_super) {
    __extends(VisibilityMonitor, _super);
    function VisibilityMonitor() {
        var _this = _super.call(this, ['visible']) || this;
        var hidden;
        var visibilityChange;
        if (typeof document !== 'undefined' &&
            typeof document.addEventListener !== 'undefined') {
            if (typeof document['hidden'] !== 'undefined') {
                // Opera 12.10 and Firefox 18 and later support
                visibilityChange = 'visibilitychange';
                hidden = 'hidden';
            }
            else if (typeof document['mozHidden'] !== 'undefined') {
                visibilityChange = 'mozvisibilitychange';
                hidden = 'mozHidden';
            }
            else if (typeof document['msHidden'] !== 'undefined') {
                visibilityChange = 'msvisibilitychange';
                hidden = 'msHidden';
            }
            else if (typeof document['webkitHidden'] !== 'undefined') {
                visibilityChange = 'webkitvisibilitychange';
                hidden = 'webkitHidden';
            }
        }
        // Initially, we always assume we are visible. This ensures that in browsers
        // without page visibility support or in cases where we are never visible
        // (e.g. chrome extension), we act as if we are visible, i.e. don't delay
        // reconnects
        _this.visible_ = true;
        if (visibilityChange) {
            document.addEventListener(visibilityChange, function () {
                var visible = !document[hidden];
                if (visible !== _this.visible_) {
                    _this.visible_ = visible;
                    _this.trigger('visible', visible);
                }
            }, false);
        }
        return _this;
    }
    VisibilityMonitor.getInstance = function () {
        return new VisibilityMonitor();
    };
    /**
     * @param {!string} eventType
     * @return {Array.<boolean>}
     */
    VisibilityMonitor.prototype.getInitialEvent = function (eventType) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["g" /* assert */])(eventType === 'visible', 'Unknown event type: ' + eventType);
        return [this.visible_];
    };
    return VisibilityMonitor;
}(__WEBPACK_IMPORTED_MODULE_0__EventEmitter__["a" /* EventEmitter */]));




/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ChildChangeAccumulator; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Change__ = __webpack_require__(12);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @constructor
 */
var ChildChangeAccumulator = /** @class */ (function () {
    function ChildChangeAccumulator() {
        this.changeMap_ = {};
    }
    /**
     * @param {!Change} change
     */
    ChildChangeAccumulator.prototype.trackChildChange = function (change) {
        var type = change.type;
        var childKey /** @type {!string} */ = change.childName;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(type == __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].CHILD_ADDED ||
            type == __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].CHILD_CHANGED ||
            type == __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].CHILD_REMOVED, 'Only child changes supported for tracking');
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(childKey !== '.priority', 'Only non-priority child changes can be tracked.');
        var oldChange = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["s" /* safeGet */])(this.changeMap_, childKey);
        if (oldChange) {
            var oldType = oldChange.type;
            if (type == __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].CHILD_ADDED && oldType == __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].CHILD_REMOVED) {
                this.changeMap_[childKey] = __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].childChangedChange(childKey, change.snapshotNode, oldChange.snapshotNode);
            }
            else if (type == __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].CHILD_REMOVED &&
                oldType == __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].CHILD_ADDED) {
                delete this.changeMap_[childKey];
            }
            else if (type == __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].CHILD_REMOVED &&
                oldType == __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].CHILD_CHANGED) {
                this.changeMap_[childKey] = __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].childRemovedChange(childKey, oldChange.oldSnap);
            }
            else if (type == __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].CHILD_CHANGED &&
                oldType == __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].CHILD_ADDED) {
                this.changeMap_[childKey] = __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].childAddedChange(childKey, change.snapshotNode);
            }
            else if (type == __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].CHILD_CHANGED &&
                oldType == __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].CHILD_CHANGED) {
                this.changeMap_[childKey] = __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].childChangedChange(childKey, change.snapshotNode, oldChange.oldSnap);
            }
            else {
                throw __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["C" /* assertionError */])('Illegal combination of changes: ' +
                    change +
                    ' occurred after ' +
                    oldChange);
            }
        }
        else {
            this.changeMap_[childKey] = change;
        }
    };
    /**
     * @return {!Array.<!Change>}
     */
    ChildChangeAccumulator.prototype.getChanges = function () {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["E" /* getValues */])(this.changeMap_);
    };
    return ChildChangeAccumulator;
}());




/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export NoCompleteChildSource_ */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NO_COMPLETE_CHILD_SOURCE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return WriteTreeCompleteChildSource; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__CacheNode__ = __webpack_require__(23);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * An implementation of CompleteChildSource that never returns any additional children
 *
 * @private
 * @constructor
 * @implements CompleteChildSource
 */
var NoCompleteChildSource_ = /** @class */ (function () {
    function NoCompleteChildSource_() {
    }
    /**
     * @inheritDoc
     */
    NoCompleteChildSource_.prototype.getCompleteChild = function (childKey) {
        return null;
    };
    /**
     * @inheritDoc
     */
    NoCompleteChildSource_.prototype.getChildAfterChild = function (index, child, reverse) {
        return null;
    };
    return NoCompleteChildSource_;
}());

/**
 * Singleton instance.
 * @const
 * @type {!CompleteChildSource}
 */
var NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();
/**
 * An implementation of CompleteChildSource that uses a WriteTree in addition to any other server data or
 * old event caches available to calculate complete children.
 *
 *
 * @implements CompleteChildSource
 */
var WriteTreeCompleteChildSource = /** @class */ (function () {
    /**
     * @param {!WriteTreeRef} writes_
     * @param {!ViewCache} viewCache_
     * @param {?Node} optCompleteServerCache_
     */
    function WriteTreeCompleteChildSource(writes_, viewCache_, optCompleteServerCache_) {
        if (optCompleteServerCache_ === void 0) { optCompleteServerCache_ = null; }
        this.writes_ = writes_;
        this.viewCache_ = viewCache_;
        this.optCompleteServerCache_ = optCompleteServerCache_;
    }
    /**
     * @inheritDoc
     */
    WriteTreeCompleteChildSource.prototype.getCompleteChild = function (childKey) {
        var node = this.viewCache_.getEventCache();
        if (node.isCompleteForChild(childKey)) {
            return node.getNode().getImmediateChild(childKey);
        }
        else {
            var serverNode = this.optCompleteServerCache_ != null
                ? new __WEBPACK_IMPORTED_MODULE_0__CacheNode__["a" /* CacheNode */](this.optCompleteServerCache_, true, false)
                : this.viewCache_.getServerCache();
            return this.writes_.calcCompleteChild(childKey, serverNode);
        }
    };
    /**
     * @inheritDoc
     */
    WriteTreeCompleteChildSource.prototype.getChildAfterChild = function (index, child, reverse) {
        var completeServerData = this.optCompleteServerCache_ != null
            ? this.optCompleteServerCache_
            : this.viewCache_.getCompleteServerSnap();
        var nodes = this.writes_.calcIndexedSlice(completeServerData, child, 1, reverse, index);
        if (nodes.length === 0) {
            return null;
        }
        else {
            return nodes[0];
        }
    };
    return WriteTreeCompleteChildSource;
}());




/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DataEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CancelEvent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Encapsulates the data needed to raise an event
 * @implements {Event}
 */
var DataEvent = /** @class */ (function () {
    /**
     * @param {!string} eventType One of: value, child_added, child_changed, child_moved, child_removed
     * @param {!EventRegistration} eventRegistration The function to call to with the event data. User provided
     * @param {!DataSnapshot} snapshot The data backing the event
     * @param {?string=} prevName Optional, the name of the previous child for child_* events.
     */
    function DataEvent(eventType, eventRegistration, snapshot, prevName) {
        this.eventType = eventType;
        this.eventRegistration = eventRegistration;
        this.snapshot = snapshot;
        this.prevName = prevName;
    }
    /**
     * @inheritDoc
     */
    DataEvent.prototype.getPath = function () {
        var ref = this.snapshot.getRef();
        if (this.eventType === 'value') {
            return ref.path;
        }
        else {
            return ref.getParent().path;
        }
    };
    /**
     * @inheritDoc
     */
    DataEvent.prototype.getEventType = function () {
        return this.eventType;
    };
    /**
     * @inheritDoc
     */
    DataEvent.prototype.getEventRunner = function () {
        return this.eventRegistration.getEventRunner(this);
    };
    /**
     * @inheritDoc
     */
    DataEvent.prototype.toString = function () {
        return (this.getPath().toString() +
            ':' +
            this.eventType +
            ':' +
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["j" /* stringify */])(this.snapshot.exportVal()));
    };
    return DataEvent;
}());

var CancelEvent = /** @class */ (function () {
    /**
     * @param {EventRegistration} eventRegistration
     * @param {Error} error
     * @param {!Path} path
     */
    function CancelEvent(eventRegistration, error, path) {
        this.eventRegistration = eventRegistration;
        this.error = error;
        this.path = path;
    }
    /**
     * @inheritDoc
     */
    CancelEvent.prototype.getPath = function () {
        return this.path;
    };
    /**
     * @inheritDoc
     */
    CancelEvent.prototype.getEventType = function () {
        return 'cancel';
    };
    /**
     * @inheritDoc
     */
    CancelEvent.prototype.getEventRunner = function () {
        return this.eventRegistration.getEventRunner(this);
    };
    /**
     * @inheritDoc
     */
    CancelEvent.prototype.toString = function () {
        return this.path.toString() + ':cancel';
    };
    return CancelEvent;
}());




/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EventGenerator; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__snap_Node__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Change__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * An EventGenerator is used to convert "raw" changes (Change) as computed by the
 * CacheDiffer into actual events (Event) that can be raised.  See generateEventsForChanges()
 * for details.
 *
 * @constructor
 */
var EventGenerator = /** @class */ (function () {
    /**
     *
     * @param {!Query} query_
     */
    function EventGenerator(query_) {
        this.query_ = query_;
        /**
         * @private
         * @type {!Index}
         */
        this.index_ = this.query_.getQueryParams().getIndex();
    }
    /**
     * Given a set of raw changes (no moved events and prevName not specified yet), and a set of
     * EventRegistrations that should be notified of these changes, generate the actual events to be raised.
     *
     * Notes:
     *  - child_moved events will be synthesized at this time for any child_changed events that affect
     *    our index.
     *  - prevName will be calculated based on the index ordering.
     *
     * @param {!Array.<!Change>} changes
     * @param {!Node} eventCache
     * @param {!Array.<!EventRegistration>} eventRegistrations
     * @return {!Array.<!Event>}
     */
    EventGenerator.prototype.generateEventsForChanges = function (changes, eventCache, eventRegistrations) {
        var _this = this;
        var events = [];
        var moves = [];
        changes.forEach(function (change) {
            if (change.type === __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].CHILD_CHANGED &&
                _this.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) {
                moves.push(__WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].childMovedChange(change.childName, change.snapshotNode));
            }
        });
        this.generateEventsForType_(events, __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].CHILD_REMOVED, changes, eventRegistrations, eventCache);
        this.generateEventsForType_(events, __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].CHILD_ADDED, changes, eventRegistrations, eventCache);
        this.generateEventsForType_(events, __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].CHILD_MOVED, moves, eventRegistrations, eventCache);
        this.generateEventsForType_(events, __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].CHILD_CHANGED, changes, eventRegistrations, eventCache);
        this.generateEventsForType_(events, __WEBPACK_IMPORTED_MODULE_1__Change__["a" /* Change */].VALUE, changes, eventRegistrations, eventCache);
        return events;
    };
    /**
     * Given changes of a single change type, generate the corresponding events.
     *
     * @param {!Array.<!Event>} events
     * @param {!string} eventType
     * @param {!Array.<!Change>} changes
     * @param {!Array.<!EventRegistration>} registrations
     * @param {!Node} eventCache
     * @private
     */
    EventGenerator.prototype.generateEventsForType_ = function (events, eventType, changes, registrations, eventCache) {
        var _this = this;
        var filteredChanges = changes.filter(function (change) { return change.type === eventType; });
        filteredChanges.sort(this.compareChanges_.bind(this));
        filteredChanges.forEach(function (change) {
            var materializedChange = _this.materializeSingleChange_(change, eventCache);
            registrations.forEach(function (registration) {
                if (registration.respondsTo(change.type)) {
                    events.push(registration.createEvent(materializedChange, _this.query_));
                }
            });
        });
    };
    /**
     * @param {!Change} change
     * @param {!Node} eventCache
     * @return {!Change}
     * @private
     */
    EventGenerator.prototype.materializeSingleChange_ = function (change, eventCache) {
        if (change.type === 'value' || change.type === 'child_removed') {
            return change;
        }
        else {
            change.prevName = eventCache.getPredecessorChildName(
            /** @type {!string} */
            change.childName, change.snapshotNode, this.index_);
            return change;
        }
    };
    /**
     * @param {!Change} a
     * @param {!Change} b
     * @return {number}
     * @private
     */
    EventGenerator.prototype.compareChanges_ = function (a, b) {
        if (a.childName == null || b.childName == null) {
            throw __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["C" /* assertionError */])('Should only compare child_ events.');
        }
        var aWrapped = new __WEBPACK_IMPORTED_MODULE_0__snap_Node__["a" /* NamedNode */](a.childName, a.snapshotNode);
        var bWrapped = new __WEBPACK_IMPORTED_MODULE_0__snap_Node__["a" /* NamedNode */](b.childName, b.snapshotNode);
        return this.index_.compare(aWrapped, bWrapped);
    };
    return EventGenerator;
}());




/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EventQueue; });
/* unused harmony export EventList */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_util__ = __webpack_require__(1);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * The event queue serves a few purposes:
 * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more
 *    events being queued.
 * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,
 *    raiseQueuedEvents() is called again, the "inner" call will pick up raising events where the "outer" call
 *    left off, ensuring that the events are still raised synchronously and in order.
 * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued
 *    events are raised synchronously.
 *
 * NOTE: This can all go away if/when we move to async events.
 *
 * @constructor
 */
var EventQueue = /** @class */ (function () {
    function EventQueue() {
        /**
         * @private
         * @type {!Array.<EventList>}
         */
        this.eventLists_ = [];
        /**
         * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.
         * @private
         * @type {!number}
         */
        this.recursionDepth_ = 0;
    }
    /**
     * @param {!Array.<Event>} eventDataList The new events to queue.
     */
    EventQueue.prototype.queueEvents = function (eventDataList) {
        // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.
        var currList = null;
        for (var i = 0; i < eventDataList.length; i++) {
            var eventData = eventDataList[i];
            var eventPath = eventData.getPath();
            if (currList !== null && !eventPath.equals(currList.getPath())) {
                this.eventLists_.push(currList);
                currList = null;
            }
            if (currList === null) {
                currList = new EventList(eventPath);
            }
            currList.add(eventData);
        }
        if (currList) {
            this.eventLists_.push(currList);
        }
    };
    /**
     * Queues the specified events and synchronously raises all events (including previously queued ones)
     * for the specified path.
     *
     * It is assumed that the new events are all for the specified path.
     *
     * @param {!Path} path The path to raise events for.
     * @param {!Array.<Event>} eventDataList The new events to raise.
     */
    EventQueue.prototype.raiseEventsAtPath = function (path, eventDataList) {
        this.queueEvents(eventDataList);
        this.raiseQueuedEventsMatchingPredicate_(function (eventPath) {
            return eventPath.equals(path);
        });
    };
    /**
     * Queues the specified events and synchronously raises all events (including previously queued ones) for
     * locations related to the specified change path (i.e. all ancestors and descendants).
     *
     * It is assumed that the new events are all related (ancestor or descendant) to the specified path.
     *
     * @param {!Path} changedPath The path to raise events for.
     * @param {!Array.<!Event>} eventDataList The events to raise
     */
    EventQueue.prototype.raiseEventsForChangedPath = function (changedPath, eventDataList) {
        this.queueEvents(eventDataList);
        this.raiseQueuedEventsMatchingPredicate_(function (eventPath) {
            return eventPath.contains(changedPath) || changedPath.contains(eventPath);
        });
    };
    /**
     * @param {!function(!Path):boolean} predicate
     * @private
     */
    EventQueue.prototype.raiseQueuedEventsMatchingPredicate_ = function (predicate) {
        this.recursionDepth_++;
        var sentAll = true;
        for (var i = 0; i < this.eventLists_.length; i++) {
            var eventList = this.eventLists_[i];
            if (eventList) {
                var eventPath = eventList.getPath();
                if (predicate(eventPath)) {
                    this.eventLists_[i].raise();
                    this.eventLists_[i] = null;
                }
                else {
                    sentAll = false;
                }
            }
        }
        if (sentAll) {
            this.eventLists_ = [];
        }
        this.recursionDepth_--;
    };
    return EventQueue;
}());

/**
 * @param {!Path} path
 * @constructor
 */
var EventList = /** @class */ (function () {
    function EventList(path_) {
        this.path_ = path_;
        /**
         * @type {!Array.<Event>}
         * @private
         */
        this.events_ = [];
    }
    /**
     * @param {!Event} eventData
     */
    EventList.prototype.add = function (eventData) {
        this.events_.push(eventData);
    };
    /**
     * Iterates through the list and raises each event
     */
    EventList.prototype.raise = function () {
        for (var i = 0; i < this.events_.length; i++) {
            var eventData = this.events_[i];
            if (eventData !== null) {
                this.events_[i] = null;
                var eventFn = eventData.getEventRunner();
                if (__WEBPACK_IMPORTED_MODULE_0__util_util__["A" /* logger */]) {
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util_util__["m" /* log */])('event: ' + eventData.toString());
                }
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util_util__["n" /* exceptionGuard */])(eventFn);
            }
        }
    };
    /**
     * @return {!Path}
     */
    EventList.prototype.getPath = function () {
        return this.path_;
    };
    return EventList;
}());




/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ValueEventRegistration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ChildEventRegistration; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api_DataSnapshot__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Event__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__firebase_util__ = __webpack_require__(0);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Represents registration for 'value' events.
 */
var ValueEventRegistration = /** @class */ (function () {
    /**
     * @param {?function(!DataSnapshot)} callback_
     * @param {?function(Error)} cancelCallback_
     * @param {?Object} context_
     */
    function ValueEventRegistration(callback_, cancelCallback_, context_) {
        this.callback_ = callback_;
        this.cancelCallback_ = cancelCallback_;
        this.context_ = context_;
    }
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.respondsTo = function (eventType) {
        return eventType === 'value';
    };
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.createEvent = function (change, query) {
        var index = query.getQueryParams().getIndex();
        return new __WEBPACK_IMPORTED_MODULE_1__Event__["a" /* DataEvent */]('value', this, new __WEBPACK_IMPORTED_MODULE_0__api_DataSnapshot__["a" /* DataSnapshot */](change.snapshotNode, query.getRef(), index));
    };
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.getEventRunner = function (eventData) {
        var ctx = this.context_;
        if (eventData.getEventType() === 'cancel') {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["g" /* assert */])(this.cancelCallback_, 'Raising a cancel event on a listener with no cancel callback');
            var cancelCB_1 = this.cancelCallback_;
            return function () {
                // We know that error exists, we checked above that this is a cancel event
                cancelCB_1.call(ctx, eventData.error);
            };
        }
        else {
            var cb_1 = this.callback_;
            return function () {
                cb_1.call(ctx, eventData.snapshot);
            };
        }
    };
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.createCancelEvent = function (error, path) {
        if (this.cancelCallback_) {
            return new __WEBPACK_IMPORTED_MODULE_1__Event__["b" /* CancelEvent */](this, error, path);
        }
        else {
            return null;
        }
    };
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.matches = function (other) {
        if (!(other instanceof ValueEventRegistration)) {
            return false;
        }
        else if (!other.callback_ || !this.callback_) {
            // If no callback specified, we consider it to match any callback.
            return true;
        }
        else {
            return (other.callback_ === this.callback_ && other.context_ === this.context_);
        }
    };
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.hasAnyCallback = function () {
        return this.callback_ !== null;
    };
    return ValueEventRegistration;
}());

/**
 * Represents the registration of 1 or more child_xxx events.
 *
 * Currently, it is always exactly 1 child_xxx event, but the idea is we might let you
 * register a group of callbacks together in the future.
 *
 * @constructor
 * @implements {EventRegistration}
 */
var ChildEventRegistration = /** @class */ (function () {
    /**
     * @param {?Object.<string, function(!DataSnapshot, ?string=)>} callbacks_
     * @param {?function(Error)} cancelCallback_
     * @param {Object=} context_
     */
    function ChildEventRegistration(callbacks_, cancelCallback_, context_) {
        this.callbacks_ = callbacks_;
        this.cancelCallback_ = cancelCallback_;
        this.context_ = context_;
    }
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.respondsTo = function (eventType) {
        var eventToCheck = eventType === 'children_added' ? 'child_added' : eventType;
        eventToCheck =
            eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["i" /* contains */])(this.callbacks_, eventToCheck);
    };
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.createCancelEvent = function (error, path) {
        if (this.cancelCallback_) {
            return new __WEBPACK_IMPORTED_MODULE_1__Event__["b" /* CancelEvent */](this, error, path);
        }
        else {
            return null;
        }
    };
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.createEvent = function (change, query) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["g" /* assert */])(change.childName != null, 'Child events should have a childName.');
        var ref = query.getRef().child(/** @type {!string} */ (change.childName));
        var index = query.getQueryParams().getIndex();
        return new __WEBPACK_IMPORTED_MODULE_1__Event__["a" /* DataEvent */](change.type, this, new __WEBPACK_IMPORTED_MODULE_0__api_DataSnapshot__["a" /* DataSnapshot */](change.snapshotNode, ref, index), change.prevName);
    };
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.getEventRunner = function (eventData) {
        var ctx = this.context_;
        if (eventData.getEventType() === 'cancel') {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["g" /* assert */])(this.cancelCallback_, 'Raising a cancel event on a listener with no cancel callback');
            var cancelCB_2 = this.cancelCallback_;
            return function () {
                // We know that error exists, we checked above that this is a cancel event
                cancelCB_2.call(ctx, eventData.error);
            };
        }
        else {
            var cb_2 = this.callbacks_[eventData.eventType];
            return function () {
                cb_2.call(ctx, eventData.snapshot, eventData.prevName);
            };
        }
    };
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.matches = function (other) {
        if (other instanceof ChildEventRegistration) {
            if (!this.callbacks_ || !other.callbacks_) {
                return true;
            }
            else if (this.context_ === other.context_) {
                var otherCount = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["r" /* getCount */])(other.callbacks_);
                var thisCount = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["r" /* getCount */])(this.callbacks_);
                if (otherCount === thisCount) {
                    // If count is 1, do an exact match on eventType, if either is defined but null, it's a match.
                    //  If event types don't match, not a match
                    // If count is not 1, exact match across all
                    if (otherCount === 1) {
                        var otherKey /** @type {!string} */ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["K" /* getAnyKey */])(other.callbacks_);
                        var thisKey /** @type {!string} */ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["K" /* getAnyKey */])(this.callbacks_);
                        return (thisKey === otherKey &&
                            (!other.callbacks_[otherKey] ||
                                !this.callbacks_[thisKey] ||
                                other.callbacks_[otherKey] === this.callbacks_[thisKey]));
                    }
                    else {
                        // Exact match on each key.
                        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__firebase_util__["L" /* every */])(this.callbacks_, function (eventType, cb) { return other.callbacks_[eventType] === cb; });
                    }
                }
            }
        }
        return false;
    };
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.hasAnyCallback = function () {
        return this.callbacks_ !== null;
    };
    return ChildEventRegistration;
}());




/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return QueryParams; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_util__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__snap_indexes_KeyIndex__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__snap_indexes_PriorityIndex__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__snap_indexes_ValueIndex__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__snap_indexes_PathIndex__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__filter_IndexedFilter__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__filter_LimitedFilter__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__filter_RangedFilter__ = __webpack_require__(56);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










/**
 * This class is an immutable-from-the-public-api struct containing a set of query parameters defining a
 * range to be returned for a particular location. It is assumed that validation of parameters is done at the
 * user-facing API level, so it is not done here.
 * @constructor
 */
var QueryParams = /** @class */ (function () {
    function QueryParams() {
        this.limitSet_ = false;
        this.startSet_ = false;
        this.startNameSet_ = false;
        this.endSet_ = false;
        this.endNameSet_ = false;
        this.limit_ = 0;
        this.viewFrom_ = '';
        this.indexStartValue_ = null;
        this.indexStartName_ = '';
        this.indexEndValue_ = null;
        this.indexEndName_ = '';
        this.index_ = __WEBPACK_IMPORTED_MODULE_3__snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */];
    }
    /**
     * @return {boolean}
     */
    QueryParams.prototype.hasStart = function () {
        return this.startSet_;
    };
    /**
     * @return {boolean} True if it would return from left.
     */
    QueryParams.prototype.isViewFromLeft = function () {
        if (this.viewFrom_ === '') {
            // limit(), rather than limitToFirst or limitToLast was called.
            // This means that only one of startSet_ and endSet_ is true. Use them
            // to calculate which side of the view to anchor to. If neither is set,
            // anchor to the end.
            return this.startSet_;
        }
        else {
            return (this.viewFrom_ === QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_LEFT);
        }
    };
    /**
     * Only valid to call if hasStart() returns true
     * @return {*}
     */
    QueryParams.prototype.getIndexStartValue = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(this.startSet_, 'Only valid if start has been set');
        return this.indexStartValue_;
    };
    /**
     * Only valid to call if hasStart() returns true.
     * Returns the starting key name for the range defined by these query parameters
     * @return {!string}
     */
    QueryParams.prototype.getIndexStartName = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(this.startSet_, 'Only valid if start has been set');
        if (this.startNameSet_) {
            return this.indexStartName_;
        }
        else {
            return __WEBPACK_IMPORTED_MODULE_1__util_util__["v" /* MIN_NAME */];
        }
    };
    /**
     * @return {boolean}
     */
    QueryParams.prototype.hasEnd = function () {
        return this.endSet_;
    };
    /**
     * Only valid to call if hasEnd() returns true.
     * @return {*}
     */
    QueryParams.prototype.getIndexEndValue = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(this.endSet_, 'Only valid if end has been set');
        return this.indexEndValue_;
    };
    /**
     * Only valid to call if hasEnd() returns true.
     * Returns the end key name for the range defined by these query parameters
     * @return {!string}
     */
    QueryParams.prototype.getIndexEndName = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(this.endSet_, 'Only valid if end has been set');
        if (this.endNameSet_) {
            return this.indexEndName_;
        }
        else {
            return __WEBPACK_IMPORTED_MODULE_1__util_util__["u" /* MAX_NAME */];
        }
    };
    /**
     * @return {boolean}
     */
    QueryParams.prototype.hasLimit = function () {
        return this.limitSet_;
    };
    /**
     * @return {boolean} True if a limit has been set and it has been explicitly anchored
     */
    QueryParams.prototype.hasAnchoredLimit = function () {
        return this.limitSet_ && this.viewFrom_ !== '';
    };
    /**
     * Only valid to call if hasLimit() returns true
     * @return {!number}
     */
    QueryParams.prototype.getLimit = function () {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(this.limitSet_, 'Only valid if limit has been set');
        return this.limit_;
    };
    /**
     * @return {!Index}
     */
    QueryParams.prototype.getIndex = function () {
        return this.index_;
    };
    /**
     * @return {!QueryParams}
     * @private
     */
    QueryParams.prototype.copy_ = function () {
        var copy = new QueryParams();
        copy.limitSet_ = this.limitSet_;
        copy.limit_ = this.limit_;
        copy.startSet_ = this.startSet_;
        copy.indexStartValue_ = this.indexStartValue_;
        copy.startNameSet_ = this.startNameSet_;
        copy.indexStartName_ = this.indexStartName_;
        copy.endSet_ = this.endSet_;
        copy.indexEndValue_ = this.indexEndValue_;
        copy.endNameSet_ = this.endNameSet_;
        copy.indexEndName_ = this.indexEndName_;
        copy.index_ = this.index_;
        copy.viewFrom_ = this.viewFrom_;
        return copy;
    };
    /**
     * @param {!number} newLimit
     * @return {!QueryParams}
     */
    QueryParams.prototype.limit = function (newLimit) {
        var newParams = this.copy_();
        newParams.limitSet_ = true;
        newParams.limit_ = newLimit;
        newParams.viewFrom_ = '';
        return newParams;
    };
    /**
     * @param {!number} newLimit
     * @return {!QueryParams}
     */
    QueryParams.prototype.limitToFirst = function (newLimit) {
        var newParams = this.copy_();
        newParams.limitSet_ = true;
        newParams.limit_ = newLimit;
        newParams.viewFrom_ = QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_LEFT;
        return newParams;
    };
    /**
     * @param {!number} newLimit
     * @return {!QueryParams}
     */
    QueryParams.prototype.limitToLast = function (newLimit) {
        var newParams = this.copy_();
        newParams.limitSet_ = true;
        newParams.limit_ = newLimit;
        newParams.viewFrom_ = QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_RIGHT;
        return newParams;
    };
    /**
     * @param {*} indexValue
     * @param {?string=} key
     * @return {!QueryParams}
     */
    QueryParams.prototype.startAt = function (indexValue, key) {
        var newParams = this.copy_();
        newParams.startSet_ = true;
        if (!(indexValue !== undefined)) {
            indexValue = null;
        }
        newParams.indexStartValue_ = indexValue;
        if (key != null) {
            newParams.startNameSet_ = true;
            newParams.indexStartName_ = key;
        }
        else {
            newParams.startNameSet_ = false;
            newParams.indexStartName_ = '';
        }
        return newParams;
    };
    /**
     * @param {*} indexValue
     * @param {?string=} key
     * @return {!QueryParams}
     */
    QueryParams.prototype.endAt = function (indexValue, key) {
        var newParams = this.copy_();
        newParams.endSet_ = true;
        if (!(indexValue !== undefined)) {
            indexValue = null;
        }
        newParams.indexEndValue_ = indexValue;
        if (key !== undefined) {
            newParams.endNameSet_ = true;
            newParams.indexEndName_ = key;
        }
        else {
            newParams.endNameSet_ = false;
            newParams.indexEndName_ = '';
        }
        return newParams;
    };
    /**
     * @param {!Index} index
     * @return {!QueryParams}
     */
    QueryParams.prototype.orderBy = function (index) {
        var newParams = this.copy_();
        newParams.index_ = index;
        return newParams;
    };
    /**
     * @return {!Object}
     */
    QueryParams.prototype.getQueryObject = function () {
        var WIRE_PROTOCOL_CONSTANTS = QueryParams.WIRE_PROTOCOL_CONSTANTS_;
        var obj = {};
        if (this.startSet_) {
            obj[WIRE_PROTOCOL_CONSTANTS.INDEX_START_VALUE] = this.indexStartValue_;
            if (this.startNameSet_) {
                obj[WIRE_PROTOCOL_CONSTANTS.INDEX_START_NAME] = this.indexStartName_;
            }
        }
        if (this.endSet_) {
            obj[WIRE_PROTOCOL_CONSTANTS.INDEX_END_VALUE] = this.indexEndValue_;
            if (this.endNameSet_) {
                obj[WIRE_PROTOCOL_CONSTANTS.INDEX_END_NAME] = this.indexEndName_;
            }
        }
        if (this.limitSet_) {
            obj[WIRE_PROTOCOL_CONSTANTS.LIMIT] = this.limit_;
            var viewFrom = this.viewFrom_;
            if (viewFrom === '') {
                if (this.isViewFromLeft()) {
                    viewFrom = WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT;
                }
                else {
                    viewFrom = WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT;
                }
            }
            obj[WIRE_PROTOCOL_CONSTANTS.VIEW_FROM] = viewFrom;
        }
        // For now, priority index is the default, so we only specify if it's some other index
        if (this.index_ !== __WEBPACK_IMPORTED_MODULE_3__snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */]) {
            obj[WIRE_PROTOCOL_CONSTANTS.INDEX] = this.index_.toString();
        }
        return obj;
    };
    /**
     * @return {boolean}
     */
    QueryParams.prototype.loadsAllData = function () {
        return !(this.startSet_ || this.endSet_ || this.limitSet_);
    };
    /**
     * @return {boolean}
     */
    QueryParams.prototype.isDefault = function () {
        return this.loadsAllData() && this.index_ == __WEBPACK_IMPORTED_MODULE_3__snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */];
    };
    /**
     * @return {!NodeFilter}
     */
    QueryParams.prototype.getNodeFilter = function () {
        if (this.loadsAllData()) {
            return new __WEBPACK_IMPORTED_MODULE_6__filter_IndexedFilter__["a" /* IndexedFilter */](this.getIndex());
        }
        else if (this.hasLimit()) {
            return new __WEBPACK_IMPORTED_MODULE_7__filter_LimitedFilter__["a" /* LimitedFilter */](this);
        }
        else {
            return new __WEBPACK_IMPORTED_MODULE_8__filter_RangedFilter__["a" /* RangedFilter */](this);
        }
    };
    /**
     * Returns a set of REST query string parameters representing this query.
     *
     * @return {!Object.<string,*>} query string parameters
     */
    QueryParams.prototype.toRestQueryStringParameters = function () {
        var REST_CONSTANTS = QueryParams.REST_QUERY_CONSTANTS_;
        var qs = {};
        if (this.isDefault()) {
            return qs;
        }
        var orderBy;
        if (this.index_ === __WEBPACK_IMPORTED_MODULE_3__snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */]) {
            orderBy = REST_CONSTANTS.PRIORITY_INDEX;
        }
        else if (this.index_ === __WEBPACK_IMPORTED_MODULE_4__snap_indexes_ValueIndex__["a" /* VALUE_INDEX */]) {
            orderBy = REST_CONSTANTS.VALUE_INDEX;
        }
        else if (this.index_ === __WEBPACK_IMPORTED_MODULE_2__snap_indexes_KeyIndex__["a" /* KEY_INDEX */]) {
            orderBy = REST_CONSTANTS.KEY_INDEX;
        }
        else {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["g" /* assert */])(this.index_ instanceof __WEBPACK_IMPORTED_MODULE_5__snap_indexes_PathIndex__["a" /* PathIndex */], 'Unrecognized index type!');
            orderBy = this.index_.toString();
        }
        qs[REST_CONSTANTS.ORDER_BY] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["j" /* stringify */])(orderBy);
        if (this.startSet_) {
            qs[REST_CONSTANTS.START_AT] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["j" /* stringify */])(this.indexStartValue_);
            if (this.startNameSet_) {
                qs[REST_CONSTANTS.START_AT] += ',' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["j" /* stringify */])(this.indexStartName_);
            }
        }
        if (this.endSet_) {
            qs[REST_CONSTANTS.END_AT] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["j" /* stringify */])(this.indexEndValue_);
            if (this.endNameSet_) {
                qs[REST_CONSTANTS.END_AT] += ',' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["j" /* stringify */])(this.indexEndName_);
            }
        }
        if (this.limitSet_) {
            if (this.isViewFromLeft()) {
                qs[REST_CONSTANTS.LIMIT_TO_FIRST] = this.limit_;
            }
            else {
                qs[REST_CONSTANTS.LIMIT_TO_LAST] = this.limit_;
            }
        }
        return qs;
    };
    /**
     * Wire Protocol Constants
     * @const
     * @enum {string}
     * @private
     */
    QueryParams.WIRE_PROTOCOL_CONSTANTS_ = {
        INDEX_START_VALUE: 'sp',
        INDEX_START_NAME: 'sn',
        INDEX_END_VALUE: 'ep',
        INDEX_END_NAME: 'en',
        LIMIT: 'l',
        VIEW_FROM: 'vf',
        VIEW_FROM_LEFT: 'l',
        VIEW_FROM_RIGHT: 'r',
        INDEX: 'i'
    };
    /**
     * REST Query Constants
     * @const
     * @enum {string}
     * @private
     */
    QueryParams.REST_QUERY_CONSTANTS_ = {
        ORDER_BY: 'orderBy',
        PRIORITY_INDEX: '$priority',
        VALUE_INDEX: '$value',
        KEY_INDEX: '$key',
        START_AT: 'startAt',
        END_AT: 'endAt',
        LIMIT_TO_FIRST: 'limitToFirst',
        LIMIT_TO_LAST: 'limitToLast'
    };
    /**
     * Default, empty query parameters
     * @type {!QueryParams}
     * @const
     */
    QueryParams.DEFAULT = new QueryParams();
    return QueryParams;
}());




/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return View; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__filter_IndexedFilter__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ViewProcessor__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__snap_ChildrenNode__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__CacheNode__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ViewCache__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__EventGenerator__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__operation_Operation__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Change__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__snap_indexes_PriorityIndex__ = __webpack_require__(4);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










/**
 * A view represents a specific location and query that has 1 or more event registrations.
 *
 * It does several things:
 *  - Maintains the list of event registrations for this location/query.
 *  - Maintains a cache of the data visible for this location/query.
 *  - Applies new operations (via applyOperation), updates the cache, and based on the event
 *    registrations returns the set of events to be raised.
 * @constructor
 */
var View = /** @class */ (function () {
    /**
     *
     * @param {!Query} query_
     * @param {!ViewCache} initialViewCache
     */
    function View(query_, initialViewCache) {
        this.query_ = query_;
        this.eventRegistrations_ = [];
        var params = this.query_.getQueryParams();
        var indexFilter = new __WEBPACK_IMPORTED_MODULE_0__filter_IndexedFilter__["a" /* IndexedFilter */](params.getIndex());
        var filter = params.getNodeFilter();
        /**
         * @type {ViewProcessor}
         * @private
         */
        this.processor_ = new __WEBPACK_IMPORTED_MODULE_1__ViewProcessor__["a" /* ViewProcessor */](filter);
        var initialServerCache = initialViewCache.getServerCache();
        var initialEventCache = initialViewCache.getEventCache();
        // Don't filter server node with other filter than index, wait for tagged listen
        var serverSnap = indexFilter.updateFullNode(__WEBPACK_IMPORTED_MODULE_2__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE, initialServerCache.getNode(), null);
        var eventSnap = filter.updateFullNode(__WEBPACK_IMPORTED_MODULE_2__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE, initialEventCache.getNode(), null);
        var newServerCache = new __WEBPACK_IMPORTED_MODULE_3__CacheNode__["a" /* CacheNode */](serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());
        var newEventCache = new __WEBPACK_IMPORTED_MODULE_3__CacheNode__["a" /* CacheNode */](eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());
        /**
         * @type {!ViewCache}
         * @private
         */
        this.viewCache_ = new __WEBPACK_IMPORTED_MODULE_4__ViewCache__["a" /* ViewCache */](newEventCache, newServerCache);
        /**
         * @type {!EventGenerator}
         * @private
         */
        this.eventGenerator_ = new __WEBPACK_IMPORTED_MODULE_5__EventGenerator__["a" /* EventGenerator */](this.query_);
    }
    /**
     * @return {!Query}
     */
    View.prototype.getQuery = function () {
        return this.query_;
    };
    /**
     * @return {?Node}
     */
    View.prototype.getServerCache = function () {
        return this.viewCache_.getServerCache().getNode();
    };
    /**
     * @param {!Path} path
     * @return {?Node}
     */
    View.prototype.getCompleteServerCache = function (path) {
        var cache = this.viewCache_.getCompleteServerSnap();
        if (cache) {
            // If this isn't a "loadsAllData" view, then cache isn't actually a complete cache and
            // we need to see if it contains the child we're interested in.
            if (this.query_.getQueryParams().loadsAllData() ||
                (!path.isEmpty() && !cache.getImmediateChild(path.getFront()).isEmpty())) {
                return cache.getChild(path);
            }
        }
        return null;
    };
    /**
     * @return {boolean}
     */
    View.prototype.isEmpty = function () {
        return this.eventRegistrations_.length === 0;
    };
    /**
     * @param {!EventRegistration} eventRegistration
     */
    View.prototype.addEventRegistration = function (eventRegistration) {
        this.eventRegistrations_.push(eventRegistration);
    };
    /**
     * @param {?EventRegistration} eventRegistration If null, remove all callbacks.
     * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.
     * @return {!Array.<!Event>} Cancel events, if cancelError was provided.
     */
    View.prototype.removeEventRegistration = function (eventRegistration, cancelError) {
        var cancelEvents = [];
        if (cancelError) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__firebase_util__["g" /* assert */])(eventRegistration == null, 'A cancel should cancel all event registrations.');
            var path_1 = this.query_.path;
            this.eventRegistrations_.forEach(function (registration) {
                cancelError /** @type {!Error} */ = cancelError;
                var maybeEvent = registration.createCancelEvent(cancelError, path_1);
                if (maybeEvent) {
                    cancelEvents.push(maybeEvent);
                }
            });
        }
        if (eventRegistration) {
            var remaining = [];
            for (var i = 0; i < this.eventRegistrations_.length; ++i) {
                var existing = this.eventRegistrations_[i];
                if (!existing.matches(eventRegistration)) {
                    remaining.push(existing);
                }
                else if (eventRegistration.hasAnyCallback()) {
                    // We're removing just this one
                    remaining = remaining.concat(this.eventRegistrations_.slice(i + 1));
                    break;
                }
            }
            this.eventRegistrations_ = remaining;
        }
        else {
            this.eventRegistrations_ = [];
        }
        return cancelEvents;
    };
    /**
     * Applies the given Operation, updates our cache, and returns the appropriate events.
     *
     * @param {!Operation} operation
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeServerCache
     * @return {!Array.<!Event>}
     */
    View.prototype.applyOperation = function (operation, writesCache, completeServerCache) {
        if (operation.type === __WEBPACK_IMPORTED_MODULE_7__operation_Operation__["b" /* OperationType */].MERGE &&
            operation.source.queryId !== null) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__firebase_util__["g" /* assert */])(this.viewCache_.getCompleteServerSnap(), 'We should always have a full cache before handling merges');
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__firebase_util__["g" /* assert */])(this.viewCache_.getCompleteEventSnap(), 'Missing event cache, even though we have a server cache');
        }
        var oldViewCache = this.viewCache_;
        var result = this.processor_.applyOperation(oldViewCache, operation, writesCache, completeServerCache);
        this.processor_.assertIndexed(result.viewCache);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__firebase_util__["g" /* assert */])(result.viewCache.getServerCache().isFullyInitialized() ||
            !oldViewCache.getServerCache().isFullyInitialized(), 'Once a server snap is complete, it should never go back');
        this.viewCache_ = result.viewCache;
        return this.generateEventsForChanges_(result.changes, result.viewCache.getEventCache().getNode(), null);
    };
    /**
     * @param {!EventRegistration} registration
     * @return {!Array.<!Event>}
     */
    View.prototype.getInitialEvents = function (registration) {
        var eventSnap = this.viewCache_.getEventCache();
        var initialChanges = [];
        if (!eventSnap.getNode().isLeafNode()) {
            var eventNode = eventSnap.getNode();
            eventNode.forEachChild(__WEBPACK_IMPORTED_MODULE_9__snap_indexes_PriorityIndex__["a" /* PRIORITY_INDEX */], function (key, childNode) {
                initialChanges.push(__WEBPACK_IMPORTED_MODULE_8__Change__["a" /* Change */].childAddedChange(key, childNode));
            });
        }
        if (eventSnap.isFullyInitialized()) {
            initialChanges.push(__WEBPACK_IMPORTED_MODULE_8__Change__["a" /* Change */].valueChange(eventSnap.getNode()));
        }
        return this.generateEventsForChanges_(initialChanges, eventSnap.getNode(), registration);
    };
    /**
     * @private
     * @param {!Array.<!Change>} changes
     * @param {!Node} eventCache
     * @param {EventRegistration=} eventRegistration
     * @return {!Array.<!Event>}
     */
    View.prototype.generateEventsForChanges_ = function (changes, eventCache, eventRegistration) {
        var registrations = eventRegistration
            ? [eventRegistration]
            : this.eventRegistrations_;
        return this.eventGenerator_.generateEventsForChanges(changes, eventCache, registrations);
    };
    return View;
}());




/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ProcessorResult */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ViewProcessor; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__operation_Operation__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ChildChangeAccumulator__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Change__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__snap_ChildrenNode__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__snap_indexes_KeyIndex__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__util_ImmutableTree__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__util_Path__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__CompleteChildSource__ = __webpack_require__(112);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









/**
 * @constructor
 * @struct
 */
var ProcessorResult = /** @class */ (function () {
    /**
     * @param {!ViewCache} viewCache
     * @param {!Array.<!Change>} changes
     */
    function ProcessorResult(viewCache, changes) {
        this.viewCache = viewCache;
        this.changes = changes;
    }
    return ProcessorResult;
}());

/**
 * @constructor
 */
var ViewProcessor = /** @class */ (function () {
    /**
     * @param {!NodeFilter} filter_
     */
    function ViewProcessor(filter_) {
        this.filter_ = filter_;
    }
    /**
     * @param {!ViewCache} viewCache
     */
    ViewProcessor.prototype.assertIndexed = function (viewCache) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["g" /* assert */])(viewCache
            .getEventCache()
            .getNode()
            .isIndexed(this.filter_.getIndex()), 'Event snap not indexed');
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["g" /* assert */])(viewCache
            .getServerCache()
            .getNode()
            .isIndexed(this.filter_.getIndex()), 'Server snap not indexed');
    };
    /**
     * @param {!ViewCache} oldViewCache
     * @param {!Operation} operation
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeCache
     * @return {!ProcessorResult}
     */
    ViewProcessor.prototype.applyOperation = function (oldViewCache, operation, writesCache, completeCache) {
        var accumulator = new __WEBPACK_IMPORTED_MODULE_2__ChildChangeAccumulator__["a" /* ChildChangeAccumulator */]();
        var newViewCache, filterServerNode;
        if (operation.type === __WEBPACK_IMPORTED_MODULE_0__operation_Operation__["b" /* OperationType */].OVERWRITE) {
            var overwrite = operation;
            if (overwrite.source.fromUser) {
                newViewCache = this.applyUserOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);
            }
            else {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["g" /* assert */])(overwrite.source.fromServer, 'Unknown source.');
                // We filter the node if it's a tagged update or the node has been previously filtered  and the
                // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered
                // again
                filterServerNode =
                    overwrite.source.tagged ||
                        (oldViewCache.getServerCache().isFiltered() &&
                            !overwrite.path.isEmpty());
                newViewCache = this.applyServerOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);
            }
        }
        else if (operation.type === __WEBPACK_IMPORTED_MODULE_0__operation_Operation__["b" /* OperationType */].MERGE) {
            var merge = operation;
            if (merge.source.fromUser) {
                newViewCache = this.applyUserMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);
            }
            else {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["g" /* assert */])(merge.source.fromServer, 'Unknown source.');
                // We filter the node if it's a tagged update or the node has been previously filtered
                filterServerNode =
                    merge.source.tagged || oldViewCache.getServerCache().isFiltered();
                newViewCache = this.applyServerMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);
            }
        }
        else if (operation.type === __WEBPACK_IMPORTED_MODULE_0__operation_Operation__["b" /* OperationType */].ACK_USER_WRITE) {
            var ackUserWrite = operation;
            if (!ackUserWrite.revert) {
                newViewCache = this.ackUserWrite_(oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);
            }
            else {
                newViewCache = this.revertUserWrite_(oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);
            }
        }
        else if (operation.type === __WEBPACK_IMPORTED_MODULE_0__operation_Operation__["b" /* OperationType */].LISTEN_COMPLETE) {
            newViewCache = this.listenComplete_(oldViewCache, operation.path, writesCache, accumulator);
        }
        else {
            throw __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["C" /* assertionError */])('Unknown operation type: ' + operation.type);
        }
        var changes = accumulator.getChanges();
        ViewProcessor.maybeAddValueEvent_(oldViewCache, newViewCache, changes);
        return new ProcessorResult(newViewCache, changes);
    };
    /**
     * @param {!ViewCache} oldViewCache
     * @param {!ViewCache} newViewCache
     * @param {!Array.<!Change>} accumulator
     * @private
     */
    ViewProcessor.maybeAddValueEvent_ = function (oldViewCache, newViewCache, accumulator) {
        var eventSnap = newViewCache.getEventCache();
        if (eventSnap.isFullyInitialized()) {
            var isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();
            var oldCompleteSnap = oldViewCache.getCompleteEventSnap();
            if (accumulator.length > 0 ||
                !oldViewCache.getEventCache().isFullyInitialized() ||
                (isLeafOrEmpty &&
                    !eventSnap
                        .getNode()
                        .equals(/** @type {!Node} */ (oldCompleteSnap))) ||
                !eventSnap
                    .getNode()
                    .getPriority()
                    .equals(oldCompleteSnap.getPriority())) {
                accumulator.push(__WEBPACK_IMPORTED_MODULE_3__Change__["a" /* Change */].valueChange(
                /** @type {!Node} */ newViewCache.getCompleteEventSnap()));
            }
        }
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {!Path} changePath
     * @param {!WriteTreeRef} writesCache
     * @param {!CompleteChildSource} source
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.generateEventCacheAfterServerEvent_ = function (viewCache, changePath, writesCache, source, accumulator) {
        var oldEventSnap = viewCache.getEventCache();
        if (writesCache.shadowingWrite(changePath) != null) {
            // we have a shadowing write, ignore changes
            return viewCache;
        }
        else {
            var newEventCache = void 0, serverNode = void 0;
            if (changePath.isEmpty()) {
                // TODO: figure out how this plays with "sliding ack windows"
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["g" /* assert */])(viewCache.getServerCache().isFullyInitialized(), 'If change path is empty, we must have complete server data');
                if (viewCache.getServerCache().isFiltered()) {
                    // We need to special case this, because we need to only apply writes to complete children, or
                    // we might end up raising events for incomplete children. If the server data is filtered deep
                    // writes cannot be guaranteed to be complete
                    var serverCache = viewCache.getCompleteServerSnap();
                    var completeChildren = serverCache instanceof __WEBPACK_IMPORTED_MODULE_4__snap_ChildrenNode__["a" /* ChildrenNode */]
                        ? serverCache
                        : __WEBPACK_IMPORTED_MODULE_4__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE;
                    var completeEventChildren = writesCache.calcCompleteEventChildren(completeChildren);
                    newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeEventChildren, accumulator);
                }
                else {
                    var completeNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());
                    newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeNode, accumulator);
                }
            }
            else {
                var childKey = changePath.getFront();
                if (childKey == '.priority') {
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["g" /* assert */])(changePath.getLength() == 1, "Can't have a priority with additional path components");
                    var oldEventNode = oldEventSnap.getNode();
                    serverNode = viewCache.getServerCache().getNode();
                    // we might have overwrites for this priority
                    var updatedPriority = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventNode, serverNode);
                    if (updatedPriority != null) {
                        newEventCache = this.filter_.updatePriority(oldEventNode, updatedPriority);
                    }
                    else {
                        // priority didn't change, keep old node
                        newEventCache = oldEventSnap.getNode();
                    }
                }
                else {
                    var childChangePath = changePath.popFront();
                    // update child
                    var newEventChild = void 0;
                    if (oldEventSnap.isCompleteForChild(childKey)) {
                        serverNode = viewCache.getServerCache().getNode();
                        var eventChildUpdate = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventSnap.getNode(), serverNode);
                        if (eventChildUpdate != null) {
                            newEventChild = oldEventSnap
                                .getNode()
                                .getImmediateChild(childKey)
                                .updateChild(childChangePath, eventChildUpdate);
                        }
                        else {
                            // Nothing changed, just keep the old child
                            newEventChild = oldEventSnap
                                .getNode()
                                .getImmediateChild(childKey);
                        }
                    }
                    else {
                        newEventChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());
                    }
                    if (newEventChild != null) {
                        newEventCache = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);
                    }
                    else {
                        // no complete child available or no change
                        newEventCache = oldEventSnap.getNode();
                    }
                }
            }
            return viewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized() || changePath.isEmpty(), this.filter_.filtersNodes());
        }
    };
    /**
     * @param {!ViewCache} oldViewCache
     * @param {!Path} changePath
     * @param {!Node} changedSnap
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeCache
     * @param {boolean} filterServerNode
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.applyServerOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {
        var oldServerSnap = oldViewCache.getServerCache();
        var newServerCache;
        var serverFilter = filterServerNode
            ? this.filter_
            : this.filter_.getIndexedFilter();
        if (changePath.isEmpty()) {
            newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);
        }
        else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {
            // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update
            var newServerNode = oldServerSnap
                .getNode()
                .updateChild(changePath, changedSnap);
            newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);
        }
        else {
            var childKey = changePath.getFront();
            if (!oldServerSnap.isCompleteForPath(changePath) &&
                changePath.getLength() > 1) {
                // We don't update incomplete nodes with updates intended for other listeners
                return oldViewCache;
            }
            var childChangePath = changePath.popFront();
            var childNode = oldServerSnap.getNode().getImmediateChild(childKey);
            var newChildNode = childNode.updateChild(childChangePath, changedSnap);
            if (childKey == '.priority') {
                newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);
            }
            else {
                newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, __WEBPACK_IMPORTED_MODULE_8__CompleteChildSource__["a" /* NO_COMPLETE_CHILD_SOURCE */], null);
            }
        }
        var newViewCache = oldViewCache.updateServerSnap(newServerCache, oldServerSnap.isFullyInitialized() || changePath.isEmpty(), serverFilter.filtersNodes());
        var source = new __WEBPACK_IMPORTED_MODULE_8__CompleteChildSource__["b" /* WriteTreeCompleteChildSource */](writesCache, newViewCache, completeCache);
        return this.generateEventCacheAfterServerEvent_(newViewCache, changePath, writesCache, source, accumulator);
    };
    /**
     * @param {!ViewCache} oldViewCache
     * @param {!Path} changePath
     * @param {!Node} changedSnap
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.applyUserOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {
        var oldEventSnap = oldViewCache.getEventCache();
        var newViewCache, newEventCache;
        var source = new __WEBPACK_IMPORTED_MODULE_8__CompleteChildSource__["b" /* WriteTreeCompleteChildSource */](writesCache, oldViewCache, completeCache);
        if (changePath.isEmpty()) {
            newEventCache = this.filter_.updateFullNode(oldViewCache.getEventCache().getNode(), changedSnap, accumulator);
            newViewCache = oldViewCache.updateEventSnap(newEventCache, true, this.filter_.filtersNodes());
        }
        else {
            var childKey = changePath.getFront();
            if (childKey === '.priority') {
                newEventCache = this.filter_.updatePriority(oldViewCache.getEventCache().getNode(), changedSnap);
                newViewCache = oldViewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());
            }
            else {
                var childChangePath = changePath.popFront();
                var oldChild = oldEventSnap.getNode().getImmediateChild(childKey);
                var newChild = void 0;
                if (childChangePath.isEmpty()) {
                    // Child overwrite, we can replace the child
                    newChild = changedSnap;
                }
                else {
                    var childNode = source.getCompleteChild(childKey);
                    if (childNode != null) {
                        if (childChangePath.getBack() === '.priority' &&
                            childNode.getChild(childChangePath.parent()).isEmpty()) {
                            // This is a priority update on an empty node. If this node exists on the server, the
                            // server will send down the priority in the update, so ignore for now
                            newChild = childNode;
                        }
                        else {
                            newChild = childNode.updateChild(childChangePath, changedSnap);
                        }
                    }
                    else {
                        // There is no complete child node available
                        newChild = __WEBPACK_IMPORTED_MODULE_4__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE;
                    }
                }
                if (!oldChild.equals(newChild)) {
                    var newEventSnap = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);
                    newViewCache = oldViewCache.updateEventSnap(newEventSnap, oldEventSnap.isFullyInitialized(), this.filter_.filtersNodes());
                }
                else {
                    newViewCache = oldViewCache;
                }
            }
        }
        return newViewCache;
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {string} childKey
     * @return {boolean}
     * @private
     */
    ViewProcessor.cacheHasChild_ = function (viewCache, childKey) {
        return viewCache.getEventCache().isCompleteForChild(childKey);
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {!Path} path
     * @param {ImmutableTree.<!Node>} changedChildren
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} serverCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.applyUserMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, accumulator) {
        var _this = this;
        // HACK: In the case of a limit query, there may be some changes that bump things out of the
        // window leaving room for new items.  It's important we process these changes first, so we
        // iterate the changes twice, first processing any that affect items currently in view.
        // TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
        // and event snap.  I'm not sure if this will result in edge cases when a child is in one but
        // not the other.
        var curViewCache = viewCache;
        changedChildren.foreach(function (relativePath, childNode) {
            var writePath = path.child(relativePath);
            if (ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {
                curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
            }
        });
        changedChildren.foreach(function (relativePath, childNode) {
            var writePath = path.child(relativePath);
            if (!ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {
                curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
            }
        });
        return curViewCache;
    };
    /**
     * @param {!Node} node
     * @param {ImmutableTree.<!Node>} merge
     * @return {!Node}
     * @private
     */
    ViewProcessor.prototype.applyMerge_ = function (node, merge) {
        merge.foreach(function (relativePath, childNode) {
            node = node.updateChild(relativePath, childNode);
        });
        return node;
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {!Path} path
     * @param {!ImmutableTree.<!Node>} changedChildren
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} serverCache
     * @param {boolean} filterServerNode
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.applyServerMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {
        var _this = this;
        // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and
        // wait for the complete data update coming soon.
        if (viewCache
            .getServerCache()
            .getNode()
            .isEmpty() &&
            !viewCache.getServerCache().isFullyInitialized()) {
            return viewCache;
        }
        // HACK: In the case of a limit query, there may be some changes that bump things out of the
        // window leaving room for new items.  It's important we process these changes first, so we
        // iterate the changes twice, first processing any that affect items currently in view.
        // TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
        // and event snap.  I'm not sure if this will result in edge cases when a child is in one but
        // not the other.
        var curViewCache = viewCache;
        var viewMergeTree;
        if (path.isEmpty()) {
            viewMergeTree = changedChildren;
        }
        else {
            viewMergeTree = __WEBPACK_IMPORTED_MODULE_6__util_ImmutableTree__["a" /* ImmutableTree */].Empty.setTree(path, changedChildren);
        }
        var serverNode = viewCache.getServerCache().getNode();
        viewMergeTree.children.inorderTraversal(function (childKey, childTree) {
            if (serverNode.hasChild(childKey)) {
                var serverChild = viewCache
                    .getServerCache()
                    .getNode()
                    .getImmediateChild(childKey);
                var newChild = _this.applyMerge_(serverChild, childTree);
                curViewCache = _this.applyServerOverwrite_(curViewCache, new __WEBPACK_IMPORTED_MODULE_7__util_Path__["a" /* Path */](childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
            }
        });
        viewMergeTree.children.inorderTraversal(function (childKey, childMergeTree) {
            var isUnknownDeepMerge = !viewCache.getServerCache().isCompleteForChild(childKey) &&
                childMergeTree.value == null;
            if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {
                var serverChild = viewCache
                    .getServerCache()
                    .getNode()
                    .getImmediateChild(childKey);
                var newChild = _this.applyMerge_(serverChild, childMergeTree);
                curViewCache = _this.applyServerOverwrite_(curViewCache, new __WEBPACK_IMPORTED_MODULE_7__util_Path__["a" /* Path */](childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
            }
        });
        return curViewCache;
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {!Path} ackPath
     * @param {!ImmutableTree<!boolean>} affectedTree
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.ackUserWrite_ = function (viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {
        if (writesCache.shadowingWrite(ackPath) != null) {
            return viewCache;
        }
        // Only filter server node if it is currently filtered
        var filterServerNode = viewCache.getServerCache().isFiltered();
        // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update
        // now that it won't be shadowed.
        var serverCache = viewCache.getServerCache();
        if (affectedTree.value != null) {
            // This is an overwrite.
            if ((ackPath.isEmpty() && serverCache.isFullyInitialized()) ||
                serverCache.isCompleteForPath(ackPath)) {
                return this.applyServerOverwrite_(viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);
            }
            else if (ackPath.isEmpty()) {
                // This is a goofy edge case where we are acking data at this location but don't have full data.  We
                // should just re-apply whatever we have in our cache as a merge.
                var changedChildren_1 = __WEBPACK_IMPORTED_MODULE_6__util_ImmutableTree__["a" /* ImmutableTree */].Empty;
                serverCache.getNode().forEachChild(__WEBPACK_IMPORTED_MODULE_5__snap_indexes_KeyIndex__["a" /* KEY_INDEX */], function (name, node) {
                    changedChildren_1 = changedChildren_1.set(new __WEBPACK_IMPORTED_MODULE_7__util_Path__["a" /* Path */](name), node);
                });
                return this.applyServerMerge_(viewCache, ackPath, changedChildren_1, writesCache, completeCache, filterServerNode, accumulator);
            }
            else {
                return viewCache;
            }
        }
        else {
            // This is a merge.
            var changedChildren_2 = __WEBPACK_IMPORTED_MODULE_6__util_ImmutableTree__["a" /* ImmutableTree */].Empty;
            affectedTree.foreach(function (mergePath, value) {
                var serverCachePath = ackPath.child(mergePath);
                if (serverCache.isCompleteForPath(serverCachePath)) {
                    changedChildren_2 = changedChildren_2.set(mergePath, serverCache.getNode().getChild(serverCachePath));
                }
            });
            return this.applyServerMerge_(viewCache, ackPath, changedChildren_2, writesCache, completeCache, filterServerNode, accumulator);
        }
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {!Path} path
     * @param {!WriteTreeRef} writesCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.listenComplete_ = function (viewCache, path, writesCache, accumulator) {
        var oldServerNode = viewCache.getServerCache();
        var newViewCache = viewCache.updateServerSnap(oldServerNode.getNode(), oldServerNode.isFullyInitialized() || path.isEmpty(), oldServerNode.isFiltered());
        return this.generateEventCacheAfterServerEvent_(newViewCache, path, writesCache, __WEBPACK_IMPORTED_MODULE_8__CompleteChildSource__["a" /* NO_COMPLETE_CHILD_SOURCE */], accumulator);
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {!Path} path
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeServerCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.revertUserWrite_ = function (viewCache, path, writesCache, completeServerCache, accumulator) {
        var complete;
        if (writesCache.shadowingWrite(path) != null) {
            return viewCache;
        }
        else {
            var source = new __WEBPACK_IMPORTED_MODULE_8__CompleteChildSource__["b" /* WriteTreeCompleteChildSource */](writesCache, viewCache, completeServerCache);
            var oldEventCache = viewCache.getEventCache().getNode();
            var newEventCache = void 0;
            if (path.isEmpty() || path.getFront() === '.priority') {
                var newNode = void 0;
                if (viewCache.getServerCache().isFullyInitialized()) {
                    newNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());
                }
                else {
                    var serverChildren = viewCache.getServerCache().getNode();
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__firebase_util__["g" /* assert */])(serverChildren instanceof __WEBPACK_IMPORTED_MODULE_4__snap_ChildrenNode__["a" /* ChildrenNode */], 'serverChildren would be complete if leaf node');
                    newNode = writesCache.calcCompleteEventChildren(serverChildren);
                }
                newNode = newNode;
                newEventCache = this.filter_.updateFullNode(oldEventCache, newNode, accumulator);
            }
            else {
                var childKey = path.getFront();
                var newChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());
                if (newChild == null &&
                    viewCache.getServerCache().isCompleteForChild(childKey)) {
                    newChild = oldEventCache.getImmediateChild(childKey);
                }
                if (newChild != null) {
                    newEventCache = this.filter_.updateChild(oldEventCache, childKey, newChild, path.popFront(), source, accumulator);
                }
                else if (viewCache
                    .getEventCache()
                    .getNode()
                    .hasChild(childKey)) {
                    // No complete child available, delete the existing one, if any
                    newEventCache = this.filter_.updateChild(oldEventCache, childKey, __WEBPACK_IMPORTED_MODULE_4__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE, path.popFront(), source, accumulator);
                }
                else {
                    newEventCache = oldEventCache;
                }
                if (newEventCache.isEmpty() &&
                    viewCache.getServerCache().isFullyInitialized()) {
                    // We might have reverted all child writes. Maybe the old event was a leaf node
                    complete = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());
                    if (complete.isLeafNode()) {
                        newEventCache = this.filter_.updateFullNode(newEventCache, complete, accumulator);
                    }
                }
            }
            complete =
                viewCache.getServerCache().isFullyInitialized() ||
                    writesCache.shadowingWrite(__WEBPACK_IMPORTED_MODULE_7__util_Path__["a" /* Path */].Empty) != null;
            return viewCache.updateEventSnap(newEventCache, complete, this.filter_.filtersNodes());
        }
    };
    return ViewProcessor;
}());




/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LimitedFilter; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__RangedFilter__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__snap_ChildrenNode__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__snap_Node__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Change__ = __webpack_require__(12);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible
 *
 * @constructor
 * @implements {NodeFilter}
 */
var LimitedFilter = /** @class */ (function () {
    /**
     * @param {!QueryParams} params
     */
    function LimitedFilter(params) {
        this.rangedFilter_ = new __WEBPACK_IMPORTED_MODULE_0__RangedFilter__["a" /* RangedFilter */](params);
        this.index_ = params.getIndex();
        this.limit_ = params.getLimit();
        this.reverse_ = !params.isViewFromLeft();
    }
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        if (!this.rangedFilter_.matches(new __WEBPACK_IMPORTED_MODULE_2__snap_Node__["a" /* NamedNode */](key, newChild))) {
            newChild = __WEBPACK_IMPORTED_MODULE_1__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE;
        }
        if (snap.getImmediateChild(key).equals(newChild)) {
            // No change
            return snap;
        }
        else if (snap.numChildren() < this.limit_) {
            return this.rangedFilter_
                .getIndexedFilter()
                .updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
        }
        else {
            return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);
        }
    };
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {
        var filtered;
        if (newSnap.isLeafNode() || newSnap.isEmpty()) {
            // Make sure we have a children node with the correct index, not a leaf node;
            filtered = __WEBPACK_IMPORTED_MODULE_1__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE.withIndex(this.index_);
        }
        else {
            if (this.limit_ * 2 < newSnap.numChildren() &&
                newSnap.isIndexed(this.index_)) {
                // Easier to build up a snapshot, since what we're given has more than twice the elements we want
                filtered = __WEBPACK_IMPORTED_MODULE_1__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE.withIndex(this.index_);
                // anchor to the startPost, endPost, or last element as appropriate
                var iterator = void 0;
                if (this.reverse_) {
                    iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);
                }
                else {
                    iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);
                }
                var count = 0;
                while (iterator.hasNext() && count < this.limit_) {
                    var next = iterator.getNext();
                    var inRange = void 0;
                    if (this.reverse_) {
                        inRange =
                            this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0;
                    }
                    else {
                        inRange =
                            this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;
                    }
                    if (inRange) {
                        filtered = filtered.updateImmediateChild(next.name, next.node);
                        count++;
                    }
                    else {
                        // if we have reached the end post, we cannot keep adding elemments
                        break;
                    }
                }
            }
            else {
                // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one
                filtered = newSnap.withIndex(this.index_);
                // Don't support priorities on queries
                filtered = filtered.updatePriority(__WEBPACK_IMPORTED_MODULE_1__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE);
                var startPost = void 0;
                var endPost = void 0;
                var cmp = void 0;
                var iterator = void 0;
                if (this.reverse_) {
                    iterator = filtered.getReverseIterator(this.index_);
                    startPost = this.rangedFilter_.getEndPost();
                    endPost = this.rangedFilter_.getStartPost();
                    var indexCompare_1 = this.index_.getCompare();
                    cmp = function (a, b) { return indexCompare_1(b, a); };
                }
                else {
                    iterator = filtered.getIterator(this.index_);
                    startPost = this.rangedFilter_.getStartPost();
                    endPost = this.rangedFilter_.getEndPost();
                    cmp = this.index_.getCompare();
                }
                var count = 0;
                var foundStartPost = false;
                while (iterator.hasNext()) {
                    var next = iterator.getNext();
                    if (!foundStartPost && cmp(startPost, next) <= 0) {
                        // start adding
                        foundStartPost = true;
                    }
                    var inRange = foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;
                    if (inRange) {
                        count++;
                    }
                    else {
                        filtered = filtered.updateImmediateChild(next.name, __WEBPACK_IMPORTED_MODULE_1__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE);
                    }
                }
            }
        }
        return this.rangedFilter_
            .getIndexedFilter()
            .updateFullNode(oldSnap, filtered, optChangeAccumulator);
    };
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.updatePriority = function (oldSnap, newPriority) {
        // Don't support priorities on queries
        return oldSnap;
    };
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.filtersNodes = function () {
        return true;
    };
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.getIndexedFilter = function () {
        return this.rangedFilter_.getIndexedFilter();
    };
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.getIndex = function () {
        return this.index_;
    };
    /**
     * @param {!Node} snap
     * @param {string} childKey
     * @param {!Node} childSnap
     * @param {!CompleteChildSource} source
     * @param {?ChildChangeAccumulator} changeAccumulator
     * @return {!Node}
     * @private
     */
    LimitedFilter.prototype.fullLimitUpdateChild_ = function (snap, childKey, childSnap, source, changeAccumulator) {
        // TODO: rename all cache stuff etc to general snap terminology
        var cmp;
        if (this.reverse_) {
            var indexCmp_1 = this.index_.getCompare();
            cmp = function (a, b) { return indexCmp_1(b, a); };
        }
        else {
            cmp = this.index_.getCompare();
        }
        var oldEventCache = snap;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__firebase_util__["g" /* assert */])(oldEventCache.numChildren() == this.limit_, '');
        var newChildNamedNode = new __WEBPACK_IMPORTED_MODULE_2__snap_Node__["a" /* NamedNode */](childKey, childSnap);
        var windowBoundary = this.reverse_
            ? oldEventCache.getFirstChild(this.index_)
            : oldEventCache.getLastChild(this.index_);
        var inRange = this.rangedFilter_.matches(newChildNamedNode);
        if (oldEventCache.hasChild(childKey)) {
            var oldChildSnap = oldEventCache.getImmediateChild(childKey);
            var nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);
            while (nextChild != null &&
                (nextChild.name == childKey || oldEventCache.hasChild(nextChild.name))) {
                // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't
                // been applied to the limited filter yet. Ignore this next child which will be updated later in
                // the limited filter...
                nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);
            }
            var compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);
            var remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;
            if (remainsInWindow) {
                if (changeAccumulator != null) {
                    changeAccumulator.trackChildChange(__WEBPACK_IMPORTED_MODULE_4__Change__["a" /* Change */].childChangedChange(childKey, childSnap, oldChildSnap));
                }
                return oldEventCache.updateImmediateChild(childKey, childSnap);
            }
            else {
                if (changeAccumulator != null) {
                    changeAccumulator.trackChildChange(__WEBPACK_IMPORTED_MODULE_4__Change__["a" /* Change */].childRemovedChange(childKey, oldChildSnap));
                }
                var newEventCache = oldEventCache.updateImmediateChild(childKey, __WEBPACK_IMPORTED_MODULE_1__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE);
                var nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);
                if (nextChildInRange) {
                    if (changeAccumulator != null) {
                        changeAccumulator.trackChildChange(__WEBPACK_IMPORTED_MODULE_4__Change__["a" /* Change */].childAddedChange(nextChild.name, nextChild.node));
                    }
                    return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);
                }
                else {
                    return newEventCache;
                }
            }
        }
        else if (childSnap.isEmpty()) {
            // we're deleting a node, but it was not in the window, so ignore it
            return snap;
        }
        else if (inRange) {
            if (cmp(windowBoundary, newChildNamedNode) >= 0) {
                if (changeAccumulator != null) {
                    changeAccumulator.trackChildChange(__WEBPACK_IMPORTED_MODULE_4__Change__["a" /* Change */].childRemovedChange(windowBoundary.name, windowBoundary.node));
                    changeAccumulator.trackChildChange(__WEBPACK_IMPORTED_MODULE_4__Change__["a" /* Change */].childAddedChange(childKey, childSnap));
                }
                return oldEventCache
                    .updateImmediateChild(childKey, childSnap)
                    .updateImmediateChild(windowBoundary.name, __WEBPACK_IMPORTED_MODULE_1__snap_ChildrenNode__["a" /* ChildrenNode */].EMPTY_NODE);
            }
            else {
                return snap;
            }
        }
        else {
            return snap;
        }
    };
    return LimitedFilter;
}());




/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TransportManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BrowserPollConnection__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__WebSocketConnection__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_util_util__ = __webpack_require__(1);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Currently simplistic, this class manages what transport a Connection should use at various stages of its
 * lifecycle.
 *
 * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if
 * they are available.
 * @constructor
 */
var TransportManager = /** @class */ (function () {
    /**
     * @param {!RepoInfo} repoInfo Metadata around the namespace we're connecting to
     */
    function TransportManager(repoInfo) {
        this.initTransports_(repoInfo);
    }
    Object.defineProperty(TransportManager, "ALL_TRANSPORTS", {
        /**
         * @const
         * @type {!Array.<function(new:Transport, string, RepoInfo, string=)>}
         */
        get: function () {
            return [__WEBPACK_IMPORTED_MODULE_0__BrowserPollConnection__["a" /* BrowserPollConnection */], __WEBPACK_IMPORTED_MODULE_1__WebSocketConnection__["a" /* WebSocketConnection */]];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {!RepoInfo} repoInfo
     * @private
     */
    TransportManager.prototype.initTransports_ = function (repoInfo) {
        var isWebSocketsAvailable = __WEBPACK_IMPORTED_MODULE_1__WebSocketConnection__["a" /* WebSocketConnection */] && __WEBPACK_IMPORTED_MODULE_1__WebSocketConnection__["a" /* WebSocketConnection */]['isAvailable']();
        var isSkipPollConnection = isWebSocketsAvailable && !__WEBPACK_IMPORTED_MODULE_1__WebSocketConnection__["a" /* WebSocketConnection */].previouslyFailed();
        if (repoInfo.webSocketOnly) {
            if (!isWebSocketsAvailable)
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util_util__["f" /* warn */])("wss:// URL used, but browser isn't known to support websockets.  Trying anyway.");
            isSkipPollConnection = true;
        }
        if (isSkipPollConnection) {
            this.transports_ = [__WEBPACK_IMPORTED_MODULE_1__WebSocketConnection__["a" /* WebSocketConnection */]];
        }
        else {
            var transports_1 = (this.transports_ = []);
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util_util__["g" /* each */])(TransportManager.ALL_TRANSPORTS, function (i, transport) {
                if (transport && transport['isAvailable']()) {
                    transports_1.push(transport);
                }
            });
        }
    };
    /**
     * @return {function(new:Transport, !string, !RepoInfo, string=, string=)} The constructor for the
     * initial transport to use
     */
    TransportManager.prototype.initialTransport = function () {
        if (this.transports_.length > 0) {
            return this.transports_[0];
        }
        else {
            throw new Error('No transports available');
        }
    };
    /**
     * @return {?function(new:Transport, function(),function(), string=)} The constructor for the next
     * transport, or null
     */
    TransportManager.prototype.upgradeTransport = function () {
        if (this.transports_.length > 1) {
            return this.transports_[1];
        }
        else {
            return null;
        }
    };
    return TransportManager;
}());




/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PacketReceiver; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_util_util__ = __webpack_require__(1);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This class ensures the packets from the server arrive in order
 * This class takes data from the server and ensures it gets passed into the callbacks in order.
 * @constructor
 */
var PacketReceiver = /** @class */ (function () {
    /**
     * @param onMessage_
     */
    function PacketReceiver(onMessage_) {
        this.onMessage_ = onMessage_;
        this.pendingResponses = [];
        this.currentResponseNum = 0;
        this.closeAfterResponse = -1;
        this.onClose = null;
    }
    PacketReceiver.prototype.closeAfter = function (responseNum, callback) {
        this.closeAfterResponse = responseNum;
        this.onClose = callback;
        if (this.closeAfterResponse < this.currentResponseNum) {
            this.onClose();
            this.onClose = null;
        }
    };
    /**
     * Each message from the server comes with a response number, and an array of data. The responseNumber
     * allows us to ensure that we process them in the right order, since we can't be guaranteed that all
     * browsers will respond in the same order as the requests we sent
     * @param {number} requestNum
     * @param {Array} data
     */
    PacketReceiver.prototype.handleResponse = function (requestNum, data) {
        var _this = this;
        this.pendingResponses[requestNum] = data;
        var _loop_1 = function () {
            var toProcess = this_1.pendingResponses[this_1.currentResponseNum];
            delete this_1.pendingResponses[this_1.currentResponseNum];
            var _loop_2 = function (i) {
                if (toProcess[i]) {
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util_util__["n" /* exceptionGuard */])(function () {
                        _this.onMessage_(toProcess[i]);
                    });
                }
            };
            for (var i = 0; i < toProcess.length; ++i) {
                _loop_2(i);
            }
            if (this_1.currentResponseNum === this_1.closeAfterResponse) {
                if (this_1.onClose) {
                    this_1.onClose();
                    this_1.onClose = null;
                }
                return "break";
            }
            this_1.currentResponseNum++;
        };
        var this_1 = this;
        while (this.pendingResponses[this.currentResponseNum]) {
            var state_1 = _loop_1();
            if (state_1 === "break")
                break;
        }
    };
    return PacketReceiver;
}());




/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_polyfills_promise__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_polyfills_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__src_polyfills_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_shims_find__ = __webpack_require__(125);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_shims_find___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__src_shims_find__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_shims_findIndex__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_shims_findIndex___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__src_shims_findIndex__);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __global = (function () {
    if (typeof global !== 'undefined') {
        return global;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof self !== 'undefined') {
        return self;
    }
    throw new Error('unable to locate global object');
})();
// Polyfill Promise
if (typeof Promise === 'undefined') {
    // HACK: TS throws an error if I attempt to use 'dot-notation'
    __global['Promise'] = Promise = __webpack_require__(140);
}



/***/ }),
/* 125 */
/***/ (function(module, exports) {

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This is the Array.prototype.find polyfill from MDN
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
 * https://tc39.github.io/ecma262/#sec-array.prototype.find
 */
if (!Array.prototype.find) {
    Object.defineProperty(Array.prototype, 'find', {
        value: function (predicate) {
            // 1. Let O be ? ToObject(this value).
            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }
            var o = Object(this);
            // 2. Let len be ? ToLength(? Get(O, "length")).
            var len = o.length >>> 0;
            // 3. If IsCallable(predicate) is false, throw a TypeError exception.
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
            var thisArg = arguments[1];
            // 5. Let k be 0.
            var k = 0;
            // 6. Repeat, while k < len
            while (k < len) {
                // a. Let Pk be ! ToString(k).
                // b. Let kValue be ? Get(O, Pk).
                // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
                // d. If testResult is true, return kValue.
                var kValue = o[k];
                if (predicate.call(thisArg, kValue, k, o)) {
                    return kValue;
                }
                // e. Increase k by 1.
                k++;
            }
            // 7. Return undefined.
            return undefined;
        }
    });
}



/***/ }),
/* 126 */
/***/ (function(module, exports) {

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This is the Array.prototype.findIndex polyfill from MDN
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
 * https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
 */
if (!Array.prototype.findIndex) {
    Object.defineProperty(Array.prototype, 'findIndex', {
        value: function (predicate) {
            // 1. Let O be ? ToObject(this value).
            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }
            var o = Object(this);
            // 2. Let len be ? ToLength(? Get(O, "length")).
            var len = o.length >>> 0;
            // 3. If IsCallable(predicate) is false, throw a TypeError exception.
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
            var thisArg = arguments[1];
            // 5. Let k be 0.
            var k = 0;
            // 6. Repeat, while k < len
            while (k < len) {
                // a. Let Pk be ! ToString(k).
                // b. Let kValue be ? Get(O, Pk).
                // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
                // d. If testResult is true, return k.
                var kValue = o[k];
                if (predicate.call(thisArg, kValue, k, o)) {
                    return k;
                }
                // e. Increase k by 1.
                k++;
            }
            // 7. Return -1.
            return -1;
        }
    });
}



/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = deepCopy;
/* harmony export (immutable) */ __webpack_exports__["b"] = deepExtend;
/* harmony export (immutable) */ __webpack_exports__["c"] = patchProperty;
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Do a deep-copy of basic JavaScript Objects or Arrays.
 */
function deepCopy(value) {
    return deepExtend(undefined, value);
}
/**
 * Copy properties from source to target (recursively allows extension
 * of Objects and Arrays).  Scalar values in the target are over-written.
 * If target is undefined, an object of the appropriate type will be created
 * (and returned).
 *
 * We recursively copy all child properties of plain Objects in the source- so
 * that namespace- like dictionaries are merged.
 *
 * Note that the target can be a function, in which case the properties in
 * the source Object are copied onto it as static properties of the Function.
 */
function deepExtend(target, source) {
    if (!(source instanceof Object)) {
        return source;
    }
    switch (source.constructor) {
        case Date:
            // Treat Dates like scalars; if the target date object had any child
            // properties - they will be lost!
            var dateValue = source;
            return new Date(dateValue.getTime());
        case Object:
            if (target === undefined) {
                target = {};
            }
            break;
        case Array:
            // Always copy the array source and overwrite the target.
            target = [];
            break;
        default:
            // Not a plain Object - treat it as a scalar.
            return source;
    }
    for (var prop in source) {
        if (!source.hasOwnProperty(prop)) {
            continue;
        }
        target[prop] = deepExtend(target[prop], source[prop]);
    }
    return target;
}
// TODO: Really needed (for JSCompiler type checking)?
function patchProperty(obj, prop, value) {
    obj[prop] = value;
}



/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Deferred; });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Deferred = /** @class */ (function () {
    function Deferred() {
        var _this = this;
        this.promise = new Promise(function (resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
        });
    }
    /**
    * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
    * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
    * and returns a node-style callback which will resolve or reject the Deferred's promise.
    * @param {((?function(?(Error)): (?|undefined))| (?function(?(Error),?=): (?|undefined)))=} callback
    * @return {!function(?(Error), ?=)}
    */
    Deferred.prototype.wrapCallback = function (callback) {
        var _this = this;
        return function (error, value) {
            if (error) {
                _this.reject(error);
            }
            else {
                _this.resolve(value);
            }
            if (typeof callback === 'function') {
                // Attaching noop handler just in case developer wasn't expecting
                // promises
                _this.promise.catch(function () { });
                // Some of our callbacks don't expect a value and our own tests
                // assert that the parameter length is 1
                if (callback.length === 1) {
                    callback(error);
                }
                else {
                    callback(error, value);
                }
            }
        };
    };
    return Deferred;
}());




/***/ }),
/* 129 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export getUA */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isMobileCordova; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isReactNative; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isNodeSdk; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(30);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns navigator.userAgent string or '' if it's not defined.
 * @return {string} user agent string
 */
var getUA = function () {
    if (typeof navigator !== 'undefined' &&
        typeof navigator['userAgent'] === 'string') {
        return navigator['userAgent'];
    }
    else {
        return '';
    }
};
/**
 * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.
 *
 * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap in the Ripple emulator) nor
 * Cordova `onDeviceReady`, which would normally wait for a callback.
 *
 * @return {boolean} isMobileCordova
 */
var isMobileCordova = function () {
    return (typeof window !== 'undefined' &&
        !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&
        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA()));
};
/**
 * Detect React Native.
 *
 * @return {boolean} True if ReactNative environment is detected.
 */
var isReactNative = function () {
    return (typeof navigator === 'object' && navigator['product'] === 'ReactNative');
};
/**
 * Detect Node.js.
 *
 * @return {boolean} True if Node.js environment is detected.
 */
var isNodeSdk = function () {
    return __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* CONSTANTS */].NODE_CLIENT === true || __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* CONSTANTS */].NODE_ADMIN === true;
};



/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export patchCapture */
/* unused harmony export FirebaseError */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ErrorFactory; });
var ERROR_NAME = 'FirebaseError';
var captureStackTrace = Error
    .captureStackTrace;
// Export for faking in tests
function patchCapture(captureFake) {
    var result = captureStackTrace;
    captureStackTrace = captureFake;
    return result;
}
var FirebaseError = /** @class */ (function () {
    function FirebaseError(code, message) {
        this.code = code;
        this.message = message;
        var stack;
        // We want the stack value, if implemented by Error
        if (captureStackTrace) {
            // Patches this.stack, omitted calls above ErrorFactory#create
            captureStackTrace(this, ErrorFactory.prototype.create);
        }
        else {
            var err_1 = Error.apply(this, arguments);
            this.name = ERROR_NAME;
            // Make non-enumerable getter for the property.
            Object.defineProperty(this, 'stack', {
                get: function () {
                    return err_1.stack;
                }
            });
        }
    }
    return FirebaseError;
}());

// Back-door inheritance
FirebaseError.prototype = Object.create(Error.prototype);
FirebaseError.prototype.constructor = FirebaseError;
FirebaseError.prototype.name = ERROR_NAME;
var ErrorFactory = /** @class */ (function () {
    function ErrorFactory(service, serviceName, errors) {
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
        // Matches {$name}, by default.
        this.pattern = /\{\$([^}]+)}/g;
        // empty
    }
    ErrorFactory.prototype.create = function (code, data) {
        if (data === undefined) {
            data = {};
        }
        var template = this.errors[code];
        var fullCode = this.service + '/' + code;
        var message;
        if (template === undefined) {
            message = 'Error';
        }
        else {
            message = template.replace(this.pattern, function (match, key) {
                var value = data[key];
                return value !== undefined ? value.toString() : '<' + key + '?>';
            });
        }
        // Service: Error message (service/code).
        message = this.serviceName + ': ' + message + ' (' + fullCode + ').';
        var err = new FirebaseError(fullCode, message);
        // Populate the Error object with message parts for programmatic
        // accesses (e.g., e.file).
        for (var prop in data) {
            if (!data.hasOwnProperty(prop) || prop.slice(-1) === '_') {
                continue;
            }
            err[prop] = data[prop];
        }
        return err;
    };
    return ErrorFactory;
}());




/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Hash; });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Abstract cryptographic hash interface.
 *
 * See Sha1 and Md5 for sample implementations.
 *
 */
/**
 * Create a cryptographic hash instance.
 *
 * @constructor
 * @struct
 */
var Hash = /** @class */ (function () {
    function Hash() {
        /**
         * The block size for the hasher.
         * @type {number}
         */
        this.blockSize = -1;
    }
    return Hash;
}());




/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export decode */
/* unused harmony export isValidTimestamp */
/* unused harmony export issuedAtTime */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isValidFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isAdmin; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__crypt__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__json__ = __webpack_require__(62);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Decodes a Firebase auth. token into constituent parts.
 *
 * Notes:
 * - May return with invalid / incomplete claims if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {{header: *, claims: *, data: *, signature: string}}
 */
var decode = function (token) {
    var header = {}, claims = {}, data = {}, signature = '';
    try {
        var parts = token.split('.');
        header = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__json__["a" /* jsonEval */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__crypt__["a" /* base64Decode */])(parts[0]) || '');
        claims = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__json__["a" /* jsonEval */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__crypt__["a" /* base64Decode */])(parts[1]) || '');
        signature = parts[2];
        data = claims['d'] || {};
        delete claims['d'];
    }
    catch (e) { }
    return {
        header: header,
        claims: claims,
        data: data,
        signature: signature
    };
};
/**
 * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the
 * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {boolean}
 */
var isValidTimestamp = function (token) {
    var claims = decode(token).claims, now = Math.floor(new Date().getTime() / 1000), validSince, validUntil;
    if (typeof claims === 'object') {
        if (claims.hasOwnProperty('nbf')) {
            validSince = claims['nbf'];
        }
        else if (claims.hasOwnProperty('iat')) {
            validSince = claims['iat'];
        }
        if (claims.hasOwnProperty('exp')) {
            validUntil = claims['exp'];
        }
        else {
            // token will expire after 24h by default
            validUntil = validSince + 86400;
        }
    }
    return (now && validSince && validUntil && now >= validSince && now <= validUntil);
};
/**
 * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.
 *
 * Notes:
 * - May return null if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {?number}
 */
var issuedAtTime = function (token) {
    var claims = decode(token).claims;
    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {
        return claims['iat'];
    }
    return null;
};
/**
 * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time and non-empty
 * signature.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {boolean}
 */
var isValidFormat = function (token) {
    var decoded = decode(token), claims = decoded.claims;
    return (!!decoded.signature &&
        !!claims &&
        typeof claims === 'object' &&
        claims.hasOwnProperty('iat'));
};
/**
 * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {boolean}
 */
var isAdmin = function (token) {
    var claims = decode(token).claims;
    return typeof claims === 'object' && claims['admin'] === true;
};



/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return querystring; });
/* unused harmony export querystringDecode */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__obj__ = __webpack_require__(63);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a params
 * object (e.g. {arg: 'val', arg2: 'val2'})
 * Note: You must prepend it with ? when adding it to a URL.
 *
 * @param {!Object} querystringParams
 * @return {string}
 */
var querystring = function (querystringParams) {
    var params = [];
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__obj__["a" /* forEach */])(querystringParams, function (key, value) {
        if (Array.isArray(value)) {
            value.forEach(function (arrayVal) {
                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));
            });
        }
        else {
            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
        }
    });
    return params.length ? '&' + params.join('&') : '';
};
/**
 * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object (e.g. {arg: 'val', arg2: 'val2'})
 *
 * @param {string} querystring
 * @return {!Object}
 */
var querystringDecode = function (querystring) {
    var obj = {};
    var tokens = querystring.replace(/^\?/, '').split('&');
    tokens.forEach(function (token) {
        if (token) {
            var key = token.split('=');
            obj[key[0]] = key[1];
        }
    });
    return obj;
};



/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Sha1; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__hash__ = __webpack_require__(131);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * @fileoverview SHA-1 cryptographic hash.
 * Variable names follow the notation in FIPS PUB 180-3:
 * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.
 *
 * Usage:
 *   var sha1 = new sha1();
 *   sha1.update(bytes);
 *   var hash = sha1.digest();
 *
 * Performance:
 *   Chrome 23:   ~400 Mbit/s
 *   Firefox 16:  ~250 Mbit/s
 *
 */
/**
 * SHA-1 cryptographic hash constructor.
 *
 * The properties declared here are discussed in the above algorithm document.
 * @constructor
 * @extends {Hash}
 * @final
 * @struct
 */
var Sha1 = /** @class */ (function (_super) {
    __extends(Sha1, _super);
    function Sha1() {
        var _this = _super.call(this) || this;
        /**
         * Holds the previous values of accumulated variables a-e in the compress_
         * function.
         * @type {!Array<number>}
         * @private
         */
        _this.chain_ = [];
        /**
         * A buffer holding the partially computed hash result.
         * @type {!Array<number>}
         * @private
         */
        _this.buf_ = [];
        /**
         * An array of 80 bytes, each a part of the message to be hashed.  Referred to
         * as the message schedule in the docs.
         * @type {!Array<number>}
         * @private
         */
        _this.W_ = [];
        /**
         * Contains data needed to pad messages less than 64 bytes.
         * @type {!Array<number>}
         * @private
         */
        _this.pad_ = [];
        /**
         * @private {number}
         */
        _this.inbuf_ = 0;
        /**
         * @private {number}
         */
        _this.total_ = 0;
        _this.blockSize = 512 / 8;
        _this.pad_[0] = 128;
        for (var i = 1; i < _this.blockSize; ++i) {
            _this.pad_[i] = 0;
        }
        _this.reset();
        return _this;
    }
    Sha1.prototype.reset = function () {
        this.chain_[0] = 0x67452301;
        this.chain_[1] = 0xefcdab89;
        this.chain_[2] = 0x98badcfe;
        this.chain_[3] = 0x10325476;
        this.chain_[4] = 0xc3d2e1f0;
        this.inbuf_ = 0;
        this.total_ = 0;
    };
    /**
     * Internal compress helper function.
     * @param {!Array<number>|!Uint8Array|string} buf Block to compress.
     * @param {number=} opt_offset Offset of the block in the buffer.
     * @private
     */
    Sha1.prototype.compress_ = function (buf, opt_offset) {
        if (!opt_offset) {
            opt_offset = 0;
        }
        var W = this.W_;
        // get 16 big endian words
        if (typeof buf === 'string') {
            for (var i = 0; i < 16; i++) {
                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS
                // have a bug that turns the post-increment ++ operator into pre-increment
                // during JIT compilation.  We have code that depends heavily on SHA-1 for
                // correctness and which is affected by this bug, so I've removed all uses
                // of post-increment ++ in which the result value is used.  We can revert
                // this change once the Safari bug
                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and
                // most clients have been updated.
                W[i] =
                    (buf.charCodeAt(opt_offset) << 24) |
                        (buf.charCodeAt(opt_offset + 1) << 16) |
                        (buf.charCodeAt(opt_offset + 2) << 8) |
                        buf.charCodeAt(opt_offset + 3);
                opt_offset += 4;
            }
        }
        else {
            for (var i = 0; i < 16; i++) {
                W[i] =
                    (buf[opt_offset] << 24) |
                        (buf[opt_offset + 1] << 16) |
                        (buf[opt_offset + 2] << 8) |
                        buf[opt_offset + 3];
                opt_offset += 4;
            }
        }
        // expand to 80 words
        for (var i = 16; i < 80; i++) {
            var t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
            W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;
        }
        var a = this.chain_[0];
        var b = this.chain_[1];
        var c = this.chain_[2];
        var d = this.chain_[3];
        var e = this.chain_[4];
        var f, k;
        // TODO(user): Try to unroll this loop to speed up the computation.
        for (var i = 0; i < 80; i++) {
            if (i < 40) {
                if (i < 20) {
                    f = d ^ (b & (c ^ d));
                    k = 0x5a827999;
                }
                else {
                    f = b ^ c ^ d;
                    k = 0x6ed9eba1;
                }
            }
            else {
                if (i < 60) {
                    f = (b & c) | (d & (b | c));
                    k = 0x8f1bbcdc;
                }
                else {
                    f = b ^ c ^ d;
                    k = 0xca62c1d6;
                }
            }
            var t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;
            e = d;
            d = c;
            c = ((b << 30) | (b >>> 2)) & 0xffffffff;
            b = a;
            a = t;
        }
        this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;
        this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;
        this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;
        this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;
        this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;
    };
    Sha1.prototype.update = function (bytes, opt_length) {
        // TODO(johnlenz): tighten the function signature and remove this check
        if (bytes == null) {
            return;
        }
        if (opt_length === undefined) {
            opt_length = bytes.length;
        }
        var lengthMinusBlock = opt_length - this.blockSize;
        var n = 0;
        // Using local instead of member variables gives ~5% speedup on Firefox 16.
        var buf = this.buf_;
        var inbuf = this.inbuf_;
        // The outer while loop should execute at most twice.
        while (n < opt_length) {
            // When we have no data in the block to top up, we can directly process the
            // input buffer (assuming it contains sufficient data). This gives ~25%
            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that
            // the data is provided in large chunks (or in multiples of 64 bytes).
            if (inbuf == 0) {
                while (n <= lengthMinusBlock) {
                    this.compress_(bytes, n);
                    n += this.blockSize;
                }
            }
            if (typeof bytes === 'string') {
                while (n < opt_length) {
                    buf[inbuf] = bytes.charCodeAt(n);
                    ++inbuf;
                    ++n;
                    if (inbuf == this.blockSize) {
                        this.compress_(buf);
                        inbuf = 0;
                        // Jump to the outer loop so we use the full-block optimization.
                        break;
                    }
                }
            }
            else {
                while (n < opt_length) {
                    buf[inbuf] = bytes[n];
                    ++inbuf;
                    ++n;
                    if (inbuf == this.blockSize) {
                        this.compress_(buf);
                        inbuf = 0;
                        // Jump to the outer loop so we use the full-block optimization.
                        break;
                    }
                }
            }
        }
        this.inbuf_ = inbuf;
        this.total_ += opt_length;
    };
    /** @override */
    Sha1.prototype.digest = function () {
        var digest = [];
        var totalBits = this.total_ * 8;
        // Add pad 0x80 0x00*.
        if (this.inbuf_ < 56) {
            this.update(this.pad_, 56 - this.inbuf_);
        }
        else {
            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
        }
        // Add # bits.
        for (var i = this.blockSize - 1; i >= 56; i--) {
            this.buf_[i] = totalBits & 255;
            totalBits /= 256; // Don't use bit-shifting here!
        }
        this.compress_(this.buf_);
        var n = 0;
        for (var i = 0; i < 5; i++) {
            for (var j = 24; j >= 0; j -= 8) {
                digest[n] = (this.chain_[i] >> j) & 255;
                ++n;
            }
        }
        return digest;
    };
    return Sha1;
}(__WEBPACK_IMPORTED_MODULE_0__hash__["a" /* Hash */]));




/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createSubscribe;
/* unused harmony export async */
/**
 * Helper to make a Subscribe function (just like Promise helps make a
 * Thenable).
 *
 * @param executor Function which can make calls to a single Observer
 *     as a proxy.
 * @param onNoObservers Callback when count of Observers goes to zero.
 */
function createSubscribe(executor, onNoObservers) {
    var proxy = new ObserverProxy(executor, onNoObservers);
    return proxy.subscribe.bind(proxy);
}
/**
 * Implement fan-out for any number of Observers attached via a subscribe
 * function.
 */
var ObserverProxy = /** @class */ (function () {
    /**
     * @param executor Function which can make calls to a single Observer
     *     as a proxy.
     * @param onNoObservers Callback when count of Observers goes to zero.
     */
    function ObserverProxy(executor, onNoObservers) {
        var _this = this;
        this.observers = [];
        this.unsubscribes = [];
        this.observerCount = 0;
        // Micro-task scheduling by calling task.then().
        this.task = Promise.resolve();
        this.finalized = false;
        this.onNoObservers = onNoObservers;
        // Call the executor asynchronously so subscribers that are called
        // synchronously after the creation of the subscribe function
        // can still receive the very first value generated in the executor.
        this.task
            .then(function () {
            executor(_this);
        })
            .catch(function (e) {
            _this.error(e);
        });
    }
    ObserverProxy.prototype.next = function (value) {
        this.forEachObserver(function (observer) {
            observer.next(value);
        });
    };
    ObserverProxy.prototype.error = function (error) {
        this.forEachObserver(function (observer) {
            observer.error(error);
        });
        this.close(error);
    };
    ObserverProxy.prototype.complete = function () {
        this.forEachObserver(function (observer) {
            observer.complete();
        });
        this.close();
    };
    /**
     * Subscribe function that can be used to add an Observer to the fan-out list.
     *
     * - We require that no event is sent to a subscriber sychronously to their
     *   call to subscribe().
     */
    ObserverProxy.prototype.subscribe = function (nextOrObserver, error, complete) {
        var _this = this;
        var observer;
        if (nextOrObserver === undefined &&
            error === undefined &&
            complete === undefined) {
            throw new Error('Missing Observer.');
        }
        // Assemble an Observer object when passed as callback functions.
        if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {
            observer = nextOrObserver;
        }
        else {
            observer = {
                next: nextOrObserver,
                error: error,
                complete: complete
            };
        }
        if (observer.next === undefined) {
            observer.next = noop;
        }
        if (observer.error === undefined) {
            observer.error = noop;
        }
        if (observer.complete === undefined) {
            observer.complete = noop;
        }
        var unsub = this.unsubscribeOne.bind(this, this.observers.length);
        // Attempt to subscribe to a terminated Observable - we
        // just respond to the Observer with the final error or complete
        // event.
        if (this.finalized) {
            this.task.then(function () {
                try {
                    if (_this.finalError) {
                        observer.error(_this.finalError);
                    }
                    else {
                        observer.complete();
                    }
                }
                catch (e) {
                    // nothing
                }
                return;
            });
        }
        this.observers.push(observer);
        return unsub;
    };
    // Unsubscribe is synchronous - we guarantee that no events are sent to
    // any unsubscribed Observer.
    ObserverProxy.prototype.unsubscribeOne = function (i) {
        if (this.observers === undefined || this.observers[i] === undefined) {
            return;
        }
        delete this.observers[i];
        this.observerCount -= 1;
        if (this.observerCount === 0 && this.onNoObservers !== undefined) {
            this.onNoObservers(this);
        }
    };
    ObserverProxy.prototype.forEachObserver = function (fn) {
        if (this.finalized) {
            // Already closed by previous event....just eat the additional values.
            return;
        }
        // Since sendOne calls asynchronously - there is no chance that
        // this.observers will become undefined.
        for (var i = 0; i < this.observers.length; i++) {
            this.sendOne(i, fn);
        }
    };
    // Call the Observer via one of it's callback function. We are careful to
    // confirm that the observe has not been unsubscribed since this asynchronous
    // function had been queued.
    ObserverProxy.prototype.sendOne = function (i, fn) {
        var _this = this;
        // Execute the callback asynchronously
        this.task.then(function () {
            if (_this.observers !== undefined && _this.observers[i] !== undefined) {
                try {
                    fn(_this.observers[i]);
                }
                catch (e) {
                    // Ignore exceptions raised in Observers or missing methods of an
                    // Observer.
                    // Log error to console. b/31404806
                    if (typeof console !== 'undefined' && console.error) {
                        console.error(e);
                    }
                }
            }
        });
    };
    ObserverProxy.prototype.close = function (err) {
        var _this = this;
        if (this.finalized) {
            return;
        }
        this.finalized = true;
        if (err !== undefined) {
            this.finalError = err;
        }
        // Proxy is no longer needed - garbage collect references
        this.task.then(function () {
            _this.observers = undefined;
            _this.onNoObservers = undefined;
        });
    };
    return ObserverProxy;
}());
/** Turn synchronous function into one called asynchronously. */
function async(fn, onError) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        Promise.resolve(true)
            .then(function () {
            fn.apply(void 0, args);
        })
            .catch(function (error) {
            if (onError) {
                onError(error);
            }
        });
    };
}
/**
 * Return true if the object passed in implements any of the named methods.
 */
function implementsAnyMethods(obj, methods) {
    if (typeof obj !== 'object' || obj === null) {
        return false;
    }
    for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {
        var method = methods_1[_i];
        if (method in obj && typeof obj[method] === 'function') {
            return true;
        }
    }
    return false;
}
function noop() {
    // do nothing
}



/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return stringToByteArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return stringLength; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assert__ = __webpack_require__(60);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they
// automatically replaced '\r\n' with '\n', and they didn't handle surrogate pairs,
// so it's been modified.
// Note that not all Unicode characters appear as single characters in JavaScript strings.
// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters
// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first
// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate
// pair).
// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3
/**
 * @param {string} str
 * @return {Array}
 */
var stringToByteArray = function (str) {
    var out = [], p = 0;
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        // Is this the lead surrogate in a surrogate pair?
        if (c >= 0xd800 && c <= 0xdbff) {
            var high = c - 0xd800; // the high 10 bits.
            i++;
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__assert__["a" /* assert */])(i < str.length, 'Surrogate pair missing trail surrogate.');
            var low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.
            c = 0x10000 + (high << 10) + low;
        }
        if (c < 128) {
            out[p++] = c;
        }
        else if (c < 2048) {
            out[p++] = (c >> 6) | 192;
            out[p++] = (c & 63) | 128;
        }
        else if (c < 65536) {
            out[p++] = (c >> 12) | 224;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
        else {
            out[p++] = (c >> 18) | 240;
            out[p++] = ((c >> 12) & 63) | 128;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
    }
    return out;
};
/**
 * Calculate length without actually converting; useful for doing cheaper validation.
 * @param {string} str
 * @return {number}
 */
var stringLength = function (str) {
    var p = 0;
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c < 128) {
            p++;
        }
        else if (c < 2048) {
            p += 2;
        }
        else if (c >= 0xd800 && c <= 0xdbff) {
            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.
            p += 4;
            i++; // skip trail surrogate.
        }
        else {
            p += 3;
        }
    }
    return p;
};



/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return validateArgCount; });
/* harmony export (immutable) */ __webpack_exports__["b"] = errorPrefix;
/* unused harmony export validateNamespace */
/* harmony export (immutable) */ __webpack_exports__["c"] = validateCallback;
/* harmony export (immutable) */ __webpack_exports__["d"] = validateContextObject;
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Check to make sure the appropriate number of arguments are provided for a public function.
 * Throws an error if it fails.
 *
 * @param {!string} fnName The function name
 * @param {!number} minCount The minimum number of arguments to allow for the function call
 * @param {!number} maxCount The maximum number of argument to allow for the function call
 * @param {!number} argCount The actual number of arguments provided.
 */
var validateArgCount = function (fnName, minCount, maxCount, argCount) {
    var argError;
    if (argCount < minCount) {
        argError = 'at least ' + minCount;
    }
    else if (argCount > maxCount) {
        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;
    }
    if (argError) {
        var error = fnName +
            ' failed: Was called with ' +
            argCount +
            (argCount === 1 ? ' argument.' : ' arguments.') +
            ' Expects ' +
            argError +
            '.';
        throw new Error(error);
    }
};
/**
 * Generates a string to prefix an error message about failed argument validation
 *
 * @param {!string} fnName The function name
 * @param {!number} argumentNumber The index of the argument
 * @param {boolean} optional Whether or not the argument is optional
 * @return {!string} The prefix to add to the error thrown for validation.
 */
function errorPrefix(fnName, argumentNumber, optional) {
    var argName = '';
    switch (argumentNumber) {
        case 1:
            argName = optional ? 'first' : 'First';
            break;
        case 2:
            argName = optional ? 'second' : 'Second';
            break;
        case 3:
            argName = optional ? 'third' : 'Third';
            break;
        case 4:
            argName = optional ? 'fourth' : 'Fourth';
            break;
        default:
            throw new Error('errorPrefix called with argumentNumber > 4.  Need to update it?');
    }
    var error = fnName + ' failed: ';
    error += argName + ' argument ';
    return error;
}
/**
 * @param {!string} fnName
 * @param {!number} argumentNumber
 * @param {!string} namespace
 * @param {boolean} optional
 */
function validateNamespace(fnName, argumentNumber, namespace, optional) {
    if (optional && !namespace)
        return;
    if (typeof namespace !== 'string') {
        //TODO: I should do more validation here. We only allow certain chars in namespaces.
        throw new Error(errorPrefix(fnName, argumentNumber, optional) +
            'must be a valid firebase namespace.');
    }
}
function validateCallback(fnName, argumentNumber, callback, optional) {
    if (optional && !callback)
        return;
    if (typeof callback !== 'function')
        throw new Error(errorPrefix(fnName, argumentNumber, optional) +
            'must be a valid function.');
}
function validateContextObject(fnName, argumentNumber, context, optional) {
    if (optional && !context)
        return;
    if (typeof context !== 'object' || context === null)
        throw new Error(errorPrefix(fnName, argumentNumber, optional) +
            'must be a valid context object.');
}



/***/ }),
/* 138 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.4';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      reLeadingDot = /^\./,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g,
      reTrimStart = /^\s+/,
      reTrimEnd = /\s+$/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)',
      rsOrdUpper = '\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * Adds the key-value `pair` to `map`.
   *
   * @private
   * @param {Object} map The map to modify.
   * @param {Array} pair The key-value pair to add.
   * @returns {Object} Returns `map`.
   */
  function addMapEntry(map, pair) {
    // Don't return `map.set` because it's not chainable in IE 11.
    map.set(pair[0], pair[1]);
    return map;
  }

  /**
   * Adds `value` to `set`.
   *
   * @private
   * @param {Object} set The set to modify.
   * @param {*} value The value to add.
   * @returns {Object} Returns `set`.
   */
  function addSetEntry(set, value) {
    // Don't return `set.add` because it's not chainable in IE 11.
    set.add(value);
    return set;
  }

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        if (isObject(srcValue)) {
          stack || (stack = new Stack);
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(object[key], srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = object[key],
          srcValue = source[key],
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array == null ? 0 : array.length,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `map`.
     *
     * @private
     * @param {Object} map The map to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned map.
     */
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of `set`.
     *
     * @private
     * @param {Object} set The set to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned set.
     */
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor);
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return cloneSet(object, isDeep, cloneFunc);

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length &&
        (typeof value == 'number' || reIsUint.test(value)) &&
        (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            result = wait - timeSinceLastCall;

        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(args) {
      args.push(undefined, customDefaultsAssignIn);
      return apply(assignInWith, undefined, args);
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrim, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimEnd, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = (lodashFunc.name + ''),
            names = realNames[key] || (realNames[key] = []);

        names.push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (true) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
      return _;
    }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = _)._ = _;
    // Export for CommonJS support.
    freeExports._ = _;
  }
  else {
    // Export to the global object.
    root._ = _;
  }
}.call(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(149)(module)))

/***/ }),
/* 140 */
/***/ (function(module, exports) {

(function (root) {

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}
  
  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }

  function Promise(fn) {
    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = 0;
    this._handled = false;
    this._value = undefined;
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function() {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    var prom = new (this.constructor)(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.all = function (arr) {
    var args = Array.prototype.slice.call(arr);

    return new Promise(function (resolve, reject) {
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
    function (fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /**
   * Set the immediate function to execute callbacks
   * @param fn {function} Function to execute
   * @deprecated
   */
  Promise._setImmediateFn = function _setImmediateFn(fn) {
    Promise._immediateFn = fn;
  };

  /**
   * Change the function to execute on unhandled rejection
   * @param {function} fn Function to execute on unhandled rejection
   * @deprecated
   */
  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
    Promise._unhandledRejectionFn = fn;
  };
  
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Promise;
  } else if (!root.Promise) {
    root.Promise = Promise;
  }

})(this);


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			memo[selector] = fn.call(this, selector);
		}

		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(142);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 142 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

class Dispatcher {

  constructor() {

    this.callbacks  = [];

  }

  addListener(type, callback) {

    if (!type || !callback) return;

    if (this.callbacks[type] === undefined) {
      this.callbacks[type]  = [];
    }

    if (this.callbacks[type].indexOf(callback) === -1) {
      this.callbacks[type].push(callback);
    }

  }
  hasListener(type, callback) {

    if ((this.callbacks[type] !== undefined) && (this.callbacks[type].indexOf(callback) !== -1)) {
      return true;
    }

    return false;

  }

  removeListener(type, callback) {

    let typeCallbacks  = this.callbacks[type];

    if (typeCallbacks !== undefined) {

      let index = typeCallbacks.indexOf(callback);

      if (index !== - 1) {
        typeCallbacks.splice(index, 1);
      }

    }

  }
  removeAllListeners(type) {

    if (!type) {
      this.callbacks = { };
    } else {
      if (this.callbacks) {
        delete(this.callbacks[type]);
      }
    }

  }

  dispatch(type, data) {

    if (!type) return;

    let typeCallbacks  = this.callbacks[type];

    if (typeCallbacks !== undefined) {

      data          = (data === undefined) ? { } : data;
      data.target   = this;
      data.type     = type;

      for (let i = 0; i < typeCallbacks.length; i++) {
        typeCallbacks[i].call(this, data);
      }

    }

  }

}
/* unused harmony export default */




/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__maths__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__random__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Range__ = __webpack_require__(31);





class Rect {

  // Constructor

  constructor(x, y, w, h) {

    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;

  }

  // Get/set

  get width() {
    return this.w;
  }
  get height() {
    return this.h;
  }

  set width(val) {
    this.w = val;
  }
  set height(val) {
    this.h = val;
  }

  get left() {
    return this.x;
  }
  get top() {
    return this.y;
  }
  get right() {
    return this.x + this.w;
  }
  get bottom() {
    return this.y + this.h;
  }

  get xRange() {
    return new __WEBPACK_IMPORTED_MODULE_2__Range__(this.x, this.x + this.w);
  }
  get yRange() {
    return new __WEBPACK_IMPORTED_MODULE_2__Range__(this.y, this.y + this.h);
  }

  get centerX() {
    return this.lerpX(0.5);
  }
  get centerY() {
    return this.lerpY(0.5);
  }
  get center() {
    return {
      x: this.centerX,
      y: this.centerY
    };
  }

  get bottomRight() {
    return {
      x: this.right,
      y: this.bottom
    }
  }
  get topLeft() {
    return {
      x: this.left,
      y: this.top
    }
  }

  get randomX() {
    return __WEBPACK_IMPORTED_MODULE_1__random__["a" /* num */](this.left, this.right);
  }
  get randomY() {
    return __WEBPACK_IMPORTED_MODULE_1__random__["a" /* num */](this.top, this.bottom);
  }
  get randomPt() {
    return {
      x: this.randomX,
      y: this.randomY
    };
  }

  get whRatio() {
    return this.w / this.h;
  }
  get hwRatio() {
    return this.h / this.w;
  }


  // Public methods

  clone() {
    return new Rect(this.x, this.y, this.w, this.h);
  }

  toString() {
    return `(x: ${this.x}, y: ${this.y}, w: ${this.w}, h: ${this.h})`;
  }

  contains(x, y) {
    if (x < this.left) return false;
    if (x > this.right) return false;
    if (y < this.top) return false;
    if (y > this.bottom) return false;
    return true;
  }

  equals(rectB) {
    if (this.x !== rectB.x) return false;
    if (this.y !== rectB.y) return false;
    if (this.w !== rectB.w) return false;
    if (this.h !== rectB.h) return false;
    return true;
  }

  clampXY(x, y) {
    return {
      x: __WEBPACK_IMPORTED_MODULE_0__maths__["f" /* clamp */](x, this.left, this.right),
      y: __WEBPACK_IMPORTED_MODULE_0__maths__["f" /* clamp */](y, this.top, this.bottom)
    }
  }

  lerpX(val) {
    return __WEBPACK_IMPORTED_MODULE_0__maths__["b" /* lerp */](this.left, this.right, val);
  }
  lerpY(val) {
    return __WEBPACK_IMPORTED_MODULE_0__maths__["b" /* lerp */](this.top, this.bottom, val);
  }

  normX(val) {
    return __WEBPACK_IMPORTED_MODULE_0__maths__["d" /* norm */](val, this.left, this.right);
  }
  normY(val) {
    return __WEBPACK_IMPORTED_MODULE_0__maths__["d" /* norm */](val, this.top, this.bottom);
  }

  mapX(val, min, max) {
    return __WEBPACK_IMPORTED_MODULE_0__maths__["b" /* lerp */](min, max, this.normX(val));
  }
  mapY(val, min, max) {
    return __WEBPACK_IMPORTED_MODULE_0__maths__["b" /* lerp */](min, max, this.normY(val));
  }

  absolutize() {
    if (this.w < 0) {
      this.x  += this.w;
      this.w  = -this.w;
    }
    if (this.h < 0) {
      this.y  += this.h;
      this.h  = -this.h;
    }
  }
  absolutized() {
    let r = this.clone();
        r.absolutize()
    return r;
  }

}
/* unused harmony export default */



/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__random__ = __webpack_require__(13);




class Vec {

  constructor(x, y) {

    const xIsVec  = (x !== null) && (typeof x === "object") && (x.x !== undefined) && (x.y !== undefined);

    if (xIsVec) {
      this.x  = x.x;
      this.y  = x.y;

    } else {
      this.x  = x;
      this.y  = y;
    }

  }

  // Get/set

  get magnitude() {
    return Math.sqrt(this.magSq)
  }
  get length() {
    return this.magnitude;
  }

  get magSq() {
    return (this.x * this.x) + (this.y * this.y);
  }
  get lenSq() {
    return this.magSq;
  }


  // Methods

  static random(minX, maxX, minY, maxY) {
    return new Vec(__WEBPACK_IMPORTED_MODULE_1__random__["a" /* num */](minX, maxX), __WEBPACK_IMPORTED_MODULE_1__random__["a" /* num */](minY, maxY));
  }

  static fromPts(x1, y1, x2, y2) {
    return new Vec(x2 - x1, y2 - y1);
  }

  distTo(pt) {
    return __WEBPACK_IMPORTED_MODULE_0__geom__["a" /* dist */](this.x, this.y, pt.x, pt.y);
  }
  distToXY(x, y) {
    return __WEBPACK_IMPORTED_MODULE_0__geom__["a" /* dist */](this.x, this.y, x, y);
  }
  distSqTo(pt) {
    return __WEBPACK_IMPORTED_MODULE_0__geom__["b" /* distSq */](this.x, this.y, pt.x, pt.y);
  }
  distSqToXY(x, y) {
    return __WEBPACK_IMPORTED_MODULE_0__geom__["b" /* distSq */](this.x, this.y, x, y);
  }

  add(v) {
    this.x  += v.x;
    this.y  += v.y;
  }
  subtract(v) {
    this.x  -= v.x;
    this.y  -= v.y;
  }
  multiply(val) {
    this.x  *= val;
    this.y  *= val;
  }
  divide(val) {
    this.x  /= val;
    this.y  /= val;
  }

  normalize(scale) {
    var mag  = this.magnitude;
    if (mag != 0) {
      this.divide(mag);
      if (scale !== undefined) {
        this.multiply(scale);
      }
    }
  }
  limit(val) {
    var mag  = this.magnitude;
    if (mag > val && mag != 0) {
      this.divide(mag);
      this.multiply(val);
    }
  }

  dot(v) {
    return (this.x * v.x) + (this.y * v.y);
  }
  angleBetween(v) {
    return Math.acos(this.dot(v) / (this.magnitude * v.magnitude));
  }

  wrapIn(x, y, w, h) {
    while (this.x < x) this.x += w;
    while (this.y < y) this.y += h;
    while (this.x > w + x) this.x -= w;
    while (this.y > h + y) this.y -= h;
  }
  wrapInRect(rect) {
    this.wrapIn(rect.x, rect.y, rect.w, rect.h);
  }

  clone() {
    return new Vec(this.x, this.y);
  }
  toString() {
    return "(x: " + this.x + ", y: " + this.y + ")";
  }

}
/* unused harmony export default */



/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrays__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__maths__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__net__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__random__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__text__ = __webpack_require__(66);
/* unused harmony reexport arrays */
/* unused harmony reexport geom */
/* unused harmony reexport maths */
/* unused harmony reexport net */
/* unused harmony reexport random */
/* unused harmony reexport text */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Rect__ = __webpack_require__(144);
/* unused harmony reexport Rect */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Range__ = __webpack_require__(31);
/* unused harmony reexport Range */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Vec__ = __webpack_require__(145);
/* unused harmony reexport Vec */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__Dispatcher__ = __webpack_require__(143);
/* unused harmony reexport Dispatcher */





















/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export xhrFetch */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__text__ = __webpack_require__(66);



function xhrFetch(path, body = null) {

  return new Promise(function(resolve, reject) {

    const xhr = new XMLHttpRequest();

    xhr.onload = function(data) {

      // Successful local files will not return 200 OK status,
      // but they will hit the onerror handler if they fail,
      // so we don't need to check their status

      const statusOK  = (xhr.status === 200),
            isLocal   = __WEBPACK_IMPORTED_MODULE_0__text__["a" /* beginsWith */](xhr.responseURL, 'file:');

      if (statusOK || isLocal) {
        resolve(new Response(xhr.responseText));
      } else {
        reject(new TypeError('Problem loading: ' + path));
      }

    }
    xhr.onerror = function(data) {
      reject(new TypeError('Problem loading: ' + path));
    }

    xhr.open('GET', path);
    xhr.send(body);

  });

}


/***/ }),
/* 148 */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if(!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true,
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 149 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzb3VyY2VzL3NjcmlwdHMvYXBwLmJ1bmRsZS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA4YWI3MThjMjYyNDIyODUzZjVhOSIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS91dGlsL2Rpc3QvZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3V0aWwvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS91dGlsL1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9jb21wb25lbnRzL0FwcC5qc3giLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvc25hcC9DaGlsZHJlbk5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvc25hcC9Ob2RlLmpzIiwid2VicGFjazovLy8uL34vY2xhc3NuYW1lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9vcGVyYXRpb24vT3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3V0aWwvdmFsaWRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZpcmViYXNlL2FwcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS92aWV3L0NoYW5nZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3ZhcnlkLXV0aWxzL3JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9hcHAvZGlzdC9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvc25hcC9pbmRleGVzL0tleUluZGV4LmpzIiwid2VicGFjazovLy8uL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3NuYXAvbm9kZUZyb21KU09OLmpzIiwid2VicGFjazovLy8uL34vdmFyeWQtdXRpbHMvbWF0aHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvUmVwby5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9zbmFwL0xlYWZOb2RlLmpzIiwid2VicGFjazovLy8uL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3NuYXAvaW5kZXhlcy9JbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9zdG9yYWdlL3N0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvdXRpbC9Tb3J0ZWRNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvdmlldy9DYWNoZU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL3JlYWx0aW1lL0NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvYXBpL1JlZmVyZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9SZXBvTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9zdGF0cy9TdGF0c01hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvdXRpbC9JbW11dGFibGVUcmVlLmpzIiwid2VicGFjazovLy8uL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3ZpZXcvZmlsdGVyL0luZGV4ZWRGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvdXRpbC9kaXN0L2VzbS9zcmMvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL34vdmFyeWQtdXRpbHMvUmFuZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9jb21wb25lbnRzL0N1c3RvbWl6ZUFjdGl2aXR5Rm9ybS5qc3giLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9jb21wb25lbnRzL0N1c3RvbWl6ZVRhYmxlLmpzeCIsIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvQ3VzdG9taXplVmFsdWVGb3JtLmpzeCIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvYXBpL0RhdGFTbmFwc2hvdC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvYXBpL0RhdGFiYXNlLmpzIiwid2VicGFjazovLy8uL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9hcGkvUXVlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvUGVyc2lzdGVudENvbm5lY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvUmVwb0luZm8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvU2VydmVyQWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9TcGFyc2VTbmFwc2hvdFRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvU3luY1BvaW50LmpzIiwid2VicGFjazovLy8uL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL29wZXJhdGlvbi9PdmVyd3JpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvc25hcC9JbmRleE1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9zbmFwL2NoaWxkU2V0LmpzIiwid2VicGFjazovLy8uL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3NuYXAvY29tcGFyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvc25hcC9pbmRleGVzL1BhdGhJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9zbmFwL2luZGV4ZXMvVmFsdWVJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9zbmFwL3NuYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvc3RhdHMvU3RhdHNMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS91dGlsL0NvdW50ZWRTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvdXRpbC9FdmVudEVtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvdXRpbC9TZXJ2ZXJWYWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvdXRpbC9saWJzL3BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS92aWV3L1ZpZXdDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS92aWV3L2ZpbHRlci9SYW5nZWRGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL3JlYWx0aW1lL0Jyb3dzZXJQb2xsQ29ubmVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvcmVhbHRpbWUvQ29ubmVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvcmVhbHRpbWUvV2ViU29ja2V0Q29ubmVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS91dGlsL2Rpc3QvZXNtL3NyYy9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvdXRpbC9kaXN0L2VzbS9zcmMvY3J5cHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvdXRpbC9kaXN0L2VzbS9zcmMvanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS91dGlsL2Rpc3QvZXNtL3NyYy9vYmouanMiLCJ3ZWJwYWNrOi8vLy4vfi92YXJ5ZC11dGlscy9hcnJheXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi92YXJ5ZC11dGlscy9nZW9tLmpzIiwid2VicGFjazovLy8uL34vdmFyeWQtdXRpbHMvdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZpcmViYXNlL2F1dGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9maXJlYmFzZS9kYXRhYmFzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvc3JjL3N0eWxlcy9zdHlsZS5zY3NzPzAxZjUiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9jb21wb25lbnRzL0N1c3RvbWl6ZUNhdGVnb3J5Rm9ybS5qc3giLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9jb21wb25lbnRzL0N1c3RvbWl6ZVRhYmxlQ2VsbC5qc3giLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9jb21wb25lbnRzL0N1c3RvbWl6ZVZpZXcuanN4Iiwid2VicGFjazovLy8uL2FwcC9zcmMvY29tcG9uZW50cy9FdmFsdWF0ZVZpZXcuanN4Iiwid2VicGFjazovLy8uL2FwcC9zcmMvY29tcG9uZW50cy9Mb2dpblZpZXcuanN4Iiwid2VicGFjazovLy8uL2FwcC9zcmMvY29tcG9uZW50cy9TZXR0aW5nc1ZpZXcuanN4Iiwid2VicGFjazovLy8uL2FwcC9zcmMvY29tcG9uZW50cy9TaWRlYmFyLmpzeCIsIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2NvbXBvbmVudHMvU2lkZWJhckl0ZW0uanN4Iiwid2VicGFjazovLy8uL2FwcC9zcmMvY29tcG9uZW50cy9UcmFja1ZpZXcuanN4Iiwid2VicGFjazovLy8uL2FwcC9zcmMvZW50cnkuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9zdHlsZXMvc3R5bGUuc2NzcyIsIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2ZvbnRzL21hdGVyaWFsLWljb25zL01hdGVyaWFsSWNvbnMtUmVndWxhci5lb3QiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9mb250cy9tYXRlcmlhbC1pY29ucy9NYXRlcmlhbEljb25zLVJlZ3VsYXIudHRmIiwid2VicGFjazovLy8uL2FwcC9zcmMvZm9udHMvbWF0ZXJpYWwtaWNvbnMvTWF0ZXJpYWxJY29ucy1SZWd1bGFyLndvZmYiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9mb250cy9tYXRlcmlhbC1pY29ucy9NYXRlcmlhbEljb25zLVJlZ3VsYXIud29mZjIiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvYXBwL2Rpc3QvZXNtL3NyYy9maXJlYmFzZUFwcC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9hdXRoL2Rpc3QvYXV0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvYXBpL1RyYW5zYWN0aW9uUmVzdWx0LmpzIiwid2VicGFjazovLy8uL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9hcGkvaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2FwaS9vbkRpc2Nvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2FwaS90ZXN0X2FjY2Vzcy5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9BdXRoVG9rZW5Qcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9Db21wb3VuZFdyaXRlLmpzIiwid2VicGFjazovLy8uL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL1JlYWRvbmx5UmVzdENsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9SZXBvX3RyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL1NuYXBzaG90SG9sZGVyLmpzIiwid2VicGFjazovLy8uL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL1N5bmNUcmVlLmpzIiwid2VicGFjazovLy8uL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL1dyaXRlVHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9vcGVyYXRpb24vQWNrVXNlcldyaXRlLmpzIiwid2VicGFjazovLy8uL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL29wZXJhdGlvbi9MaXN0ZW5Db21wbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9vcGVyYXRpb24vTWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvc3RhdHMvU3RhdHNDb2xsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3N0YXRzL1N0YXRzUmVwb3J0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvc3RvcmFnZS9ET01TdG9yYWdlV3JhcHBlci5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9zdG9yYWdlL01lbW9yeVN0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvdXRpbC9OZXh0UHVzaElkLmpzIiwid2VicGFjazovLy8uL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3V0aWwvT25saW5lTW9uaXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS91dGlsL1RyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvdXRpbC9WaXNpYmlsaXR5TW9uaXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS92aWV3L0NoaWxkQ2hhbmdlQWNjdW11bGF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvdmlldy9Db21wbGV0ZUNoaWxkU291cmNlLmpzIiwid2VicGFjazovLy8uL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3ZpZXcvRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvdmlldy9FdmVudEdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS92aWV3L0V2ZW50UXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvdmlldy9FdmVudFJlZ2lzdHJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS92aWV3L1F1ZXJ5UGFyYW1zLmpzIiwid2VicGFjazovLy8uL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3ZpZXcvVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS92aWV3L1ZpZXdQcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvdmlldy9maWx0ZXIvTGltaXRlZEZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvcmVhbHRpbWUvVHJhbnNwb3J0TWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvcmVhbHRpbWUvcG9sbGluZy9QYWNrZXRSZWNlaXZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9wb2x5ZmlsbC9kaXN0L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS9wb2x5ZmlsbC9kaXN0L2VzbS9zcmMvcG9seWZpbGxzL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvcG9seWZpbGwvZGlzdC9lc20vc3JjL3NoaW1zL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvcG9seWZpbGwvZGlzdC9lc20vc3JjL3NoaW1zL2ZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS91dGlsL2Rpc3QvZXNtL3NyYy9kZWVwQ29weS5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS91dGlsL2Rpc3QvZXNtL3NyYy9kZWZlcnJlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS91dGlsL2Rpc3QvZXNtL3NyYy9lbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS91dGlsL2Rpc3QvZXNtL3NyYy9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvdXRpbC9kaXN0L2VzbS9zcmMvaGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS91dGlsL2Rpc3QvZXNtL3NyYy9qd3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvdXRpbC9kaXN0L2VzbS9zcmMvcXVlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvdXRpbC9kaXN0L2VzbS9zcmMvc2hhMS5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS91dGlsL2Rpc3QvZXNtL3NyYy9zdWJzY3JpYmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AZmlyZWJhc2UvdXRpbC9kaXN0L2VzbS9zcmMvdXRmOC5qcyIsIndlYnBhY2s6Ly8vLi9+L0BmaXJlYmFzZS91dGlsL2Rpc3QvZXNtL3NyYy92YWxpZGF0aW9uLmpzIiwid2VicGFjazovLy8uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvbG9kYXNoLmpzIiwid2VicGFjazovLy8uL34vcHJvbWlzZS1wb2x5ZmlsbC9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi92YXJ5ZC11dGlscy9EaXNwYXRjaGVyLmpzIiwid2VicGFjazovLy8uL34vdmFyeWQtdXRpbHMvUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3ZhcnlkLXV0aWxzL1ZlYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3ZhcnlkLXV0aWxzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vdmFyeWQtdXRpbHMvbmV0LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9oYXJtb255LW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gODApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDhhYjcxOGMyNjI0MjI4NTNmNWE5IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCAqIGZyb20gJy4vc3JjL2Fzc2VydCc7XG5leHBvcnQgKiBmcm9tICcuL3NyYy9jcnlwdCc7XG5leHBvcnQgKiBmcm9tICcuL3NyYy9jb25zdGFudHMnO1xuZXhwb3J0ICogZnJvbSAnLi9zcmMvZGVlcENvcHknO1xuZXhwb3J0ICogZnJvbSAnLi9zcmMvZGVmZXJyZWQnO1xuZXhwb3J0ICogZnJvbSAnLi9zcmMvZW52aXJvbm1lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9zcmMvZXJyb3JzJztcbmV4cG9ydCAqIGZyb20gJy4vc3JjL2pzb24nO1xuZXhwb3J0ICogZnJvbSAnLi9zcmMvand0JztcbmV4cG9ydCAqIGZyb20gJy4vc3JjL29iaic7XG5leHBvcnQgKiBmcm9tICcuL3NyYy9xdWVyeSc7XG5leHBvcnQgKiBmcm9tICcuL3NyYy9zaGExJztcbmV4cG9ydCAqIGZyb20gJy4vc3JjL3N1YnNjcmliZSc7XG5leHBvcnQgKiBmcm9tICcuL3NyYy92YWxpZGF0aW9uJztcbmV4cG9ydCAqIGZyb20gJy4vc3JjL3V0ZjgnO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL3V0aWwvZGlzdC9lc20vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IGZvckVhY2ggfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBiYXNlNjQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBTaGExIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgc3RyaW5nVG9CeXRlQXJyYXkgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBTZXNzaW9uU3RvcmFnZSB9IGZyb20gJy4uL3N0b3JhZ2Uvc3RvcmFnZSc7XG5pbXBvcnQgeyBpc05vZGVTZGsgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG4vKipcbiAqIFJldHVybnMgYSBsb2NhbGx5LXVuaXF1ZSBJRCAoZ2VuZXJhdGVkIGJ5IGp1c3QgaW5jcmVtZW50aW5nIHVwIGZyb20gMCBlYWNoIHRpbWUgaXRzIGNhbGxlZCkuXG4gKiBAdHlwZSB7ZnVuY3Rpb24oKTogbnVtYmVyfSBHZW5lcmF0ZWQgSUQuXG4gKi9cbmV4cG9ydCB2YXIgTFVJREdlbmVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkID0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaWQrKztcbiAgICB9O1xufSkoKTtcbi8qKlxuICogU2hhMSBoYXNoIG9mIHRoZSBpbnB1dCBzdHJpbmdcbiAqIEBwYXJhbSB7IXN0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gaGFzaFxuICogQHJldHVybiB7IXN0cmluZ30gVGhlIHJlc3VsdGluZyBoYXNoXG4gKi9cbmV4cG9ydCB2YXIgc2hhMSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgdXRmOEJ5dGVzID0gc3RyaW5nVG9CeXRlQXJyYXkoc3RyKTtcbiAgICB2YXIgc2hhMSA9IG5ldyBTaGExKCk7XG4gICAgc2hhMS51cGRhdGUodXRmOEJ5dGVzKTtcbiAgICB2YXIgc2hhMUJ5dGVzID0gc2hhMS5kaWdlc3QoKTtcbiAgICByZXR1cm4gYmFzZTY0LmVuY29kZUJ5dGVBcnJheShzaGExQnl0ZXMpO1xufTtcbi8qKlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJnc1xuICogQHJldHVybiB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xudmFyIGJ1aWxkTG9nTWVzc2FnZV8gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhcl9hcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyX2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIG1lc3NhZ2UgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcl9hcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhcl9hcmdzW2ldKSB8fFxuICAgICAgICAgICAgKHZhcl9hcmdzW2ldICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhcl9hcmdzW2ldID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YXJfYXJnc1tpXS5sZW5ndGggPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBidWlsZExvZ01lc3NhZ2VfLmFwcGx5KG51bGwsIHZhcl9hcmdzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFyX2FyZ3NbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IHN0cmluZ2lmeSh2YXJfYXJnc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IHZhcl9hcmdzW2ldO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UgKz0gJyAnO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbn07XG4vKipcbiAqIFVzZSB0aGlzIGZvciBhbGwgZGVidWcgbWVzc2FnZXMgaW4gRmlyZWJhc2UuXG4gKiBAdHlwZSB7P2Z1bmN0aW9uKHN0cmluZyl9XG4gKi9cbmV4cG9ydCB2YXIgbG9nZ2VyID0gbnVsbDtcbi8qKlxuICogRmxhZyB0byBjaGVjayBmb3IgbG9nIGF2YWlsYWJpbGl0eSBvbiBmaXJzdCBsb2cgbWVzc2FnZVxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZmlyc3RMb2dfID0gdHJ1ZTtcbi8qKlxuICogVGhlIGltcGxlbWVudGF0aW9uIG9mIEZpcmViYXNlLmVuYWJsZUxvZ2dpbmcgKGRlZmluZWQgaGVyZSB0byBicmVhayBkZXBlbmRlbmNpZXMpXG4gKiBAcGFyYW0ge2Jvb2xlYW58P2Z1bmN0aW9uKHN0cmluZyl9IGxvZ2dlcl8gQSBmbGFnIHRvIHR1cm4gb24gbG9nZ2luZywgb3IgYSBjdXN0b20gbG9nZ2VyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBwZXJzaXN0ZW50IFdoZXRoZXIgb3Igbm90IHRvIHBlcnNpc3QgbG9nZ2luZyBzZXR0aW5ncyBhY3Jvc3MgcmVmcmVzaGVzXG4gKi9cbmV4cG9ydCB2YXIgZW5hYmxlTG9nZ2luZyA9IGZ1bmN0aW9uIChsb2dnZXJfLCBwZXJzaXN0ZW50KSB7XG4gICAgYXNzZXJ0KCFwZXJzaXN0ZW50IHx8IChsb2dnZXJfID09PSB0cnVlIHx8IGxvZ2dlcl8gPT09IGZhbHNlKSwgXCJDYW4ndCB0dXJuIG9uIGN1c3RvbSBsb2dnZXJzIHBlcnNpc3RlbnRseS5cIik7XG4gICAgaWYgKGxvZ2dlcl8gPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlciA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29uc29sZS5sb2cgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gSUUgZG9lcyB0aGlzLlxuICAgICAgICAgICAgICAgIGxvZ2dlciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcnNpc3RlbnQpXG4gICAgICAgICAgICBTZXNzaW9uU3RvcmFnZS5zZXQoJ2xvZ2dpbmdfZW5hYmxlZCcsIHRydWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbG9nZ2VyXyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsb2dnZXIgPSBsb2dnZXJfO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG9nZ2VyID0gbnVsbDtcbiAgICAgICAgU2Vzc2lvblN0b3JhZ2UucmVtb3ZlKCdsb2dnaW5nX2VuYWJsZWQnKTtcbiAgICB9XG59O1xuLyoqXG4gKlxuICogQHBhcmFtIHsuLi4oc3RyaW5nfEFyZ3VtZW50cyl9IHZhcl9hcmdzXG4gKi9cbmV4cG9ydCB2YXIgbG9nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YXJfYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhcl9hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmIChmaXJzdExvZ18gPT09IHRydWUpIHtcbiAgICAgICAgZmlyc3RMb2dfID0gZmFsc2U7XG4gICAgICAgIGlmIChsb2dnZXIgPT09IG51bGwgJiYgU2Vzc2lvblN0b3JhZ2UuZ2V0KCdsb2dnaW5nX2VuYWJsZWQnKSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmcodHJ1ZSk7XG4gICAgfVxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBidWlsZExvZ01lc3NhZ2VfLmFwcGx5KG51bGwsIHZhcl9hcmdzKTtcbiAgICAgICAgbG9nZ2VyKG1lc3NhZ2UpO1xuICAgIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7IXN0cmluZ30gcHJlZml4XG4gKiBAcmV0dXJuIHtmdW5jdGlvbiguLi5bKl0pfVxuICovXG5leHBvcnQgdmFyIGxvZ1dyYXBwZXIgPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhcl9hcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXJfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGxvZy5hcHBseSh2b2lkIDAsIFtwcmVmaXhdLmNvbmNhdCh2YXJfYXJncykpO1xuICAgIH07XG59O1xuLyoqXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gdmFyX2FyZ3NcbiAqL1xuZXhwb3J0IHZhciBlcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFyX2FyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXJfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJ0ZJUkVCQVNFIElOVEVSTkFMIEVSUk9SOiAnICsgYnVpbGRMb2dNZXNzYWdlXy5hcHBseSh2b2lkIDAsIHZhcl9hcmdzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLmVycm9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogQHBhcmFtIHsuLi5zdHJpbmd9IHZhcl9hcmdzXG4gKi9cbmV4cG9ydCB2YXIgZmF0YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhcl9hcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyX2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIG1lc3NhZ2UgPSBidWlsZExvZ01lc3NhZ2VfLmFwcGx5KHZvaWQgMCwgdmFyX2FyZ3MpO1xuICAgIHRocm93IG5ldyBFcnJvcignRklSRUJBU0UgRkFUQUwgRVJST1I6ICcgKyBtZXNzYWdlKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3NcbiAqL1xuZXhwb3J0IHZhciB3YXJuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YXJfYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhcl9hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnRklSRUJBU0UgV0FSTklORzogJyArIGJ1aWxkTG9nTWVzc2FnZV8uYXBwbHkodm9pZCAwLCB2YXJfYXJncyk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZS53YXJuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBMb2dzIGEgd2FybmluZyBpZiB0aGUgY29udGFpbmluZyBwYWdlIHVzZXMgaHR0cHMuIENhbGxlZCB3aGVuIGEgY2FsbCB0byBuZXcgRmlyZWJhc2VcbiAqIGRvZXMgbm90IHVzZSBodHRwcy5cbiAqL1xuZXhwb3J0IHZhciB3YXJuSWZQYWdlSXNTZWN1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQmUgdmVyeSBjYXJlZnVsIGFjY2Vzc2luZyBicm93c2VyIGdsb2JhbHMuIFdobyBrbm93cyB3aGF0IG1heSBvciBtYXkgbm90IGV4aXN0LlxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB3aW5kb3cubG9jYXRpb24gJiZcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICYmXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKCdodHRwczonKSAhPT0gLTEpIHtcbiAgICAgICAgd2FybignSW5zZWN1cmUgRmlyZWJhc2UgYWNjZXNzIGZyb20gYSBzZWN1cmUgcGFnZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIHVzZSBodHRwcyBpbiBjYWxscyB0byBuZXcgRmlyZWJhc2UoKS4nKTtcbiAgICB9XG59O1xuLyoqXG4gKiBAcGFyYW0geyFTdHJpbmd9IG1ldGhvZE5hbWVcbiAqL1xuZXhwb3J0IHZhciB3YXJuQWJvdXRVbnN1cHBvcnRlZE1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgd2FybihtZXRob2ROYW1lICtcbiAgICAgICAgJyBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgY2hhbmdlIHNvb24uICAnICtcbiAgICAgICAgJ1BsZWFzZSBkbyBub3QgdXNlLicpO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGRhdGEgaXMgTmFOLCBvciArLy0gSW5maW5pdHkuXG4gKiBAcGFyYW0geyp9IGRhdGFcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCB2YXIgaXNJbnZhbGlkSlNPTk51bWJlciA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgKGRhdGEgIT0gZGF0YSB8fCAvLyBOYU5cbiAgICAgICAgICAgIGRhdGEgPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8XG4gICAgICAgICAgICBkYXRhID09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkpO1xufTtcbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBmblxuICovXG5leHBvcnQgdmFyIGV4ZWN1dGVXaGVuRE9NUmVhZHkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBpZiAoaXNOb2RlU2RrKCkgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBmbigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTW9kZWxlZCBhZnRlciBqUXVlcnkuIFRyeSBET01Db250ZW50TG9hZGVkIGFuZCBvbnJlYWR5c3RhdGVjaGFuZ2UgKHdoaWNoXG4gICAgICAgIC8vIGZpcmUgYmVmb3JlIG9ubG9hZCksIGJ1dCBmYWxsIGJhY2sgdG8gb25sb2FkLlxuICAgICAgICB2YXIgY2FsbGVkXzEgPSBmYWxzZTtcbiAgICAgICAgdmFyIHdyYXBwZWRGbl8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCh3cmFwcGVkRm5fMSwgTWF0aC5mbG9vcigxMCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FsbGVkXzEpIHtcbiAgICAgICAgICAgICAgICBjYWxsZWRfMSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB3cmFwcGVkRm5fMSwgZmFsc2UpO1xuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gb25sb2FkLlxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB3cmFwcGVkRm5fMSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAvLyBJRS5cbiAgICAgICAgICAgIGRvY3VtZW50LmF0dGFjaEV2ZW50KCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpXG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZWRGbl8xKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIG9ubG9hZC5cbiAgICAgICAgICAgIHdpbmRvdy5hdHRhY2hFdmVudCgnb25sb2FkJywgd3JhcHBlZEZuXzEpO1xuICAgICAgICAgICAgLy8galF1ZXJ5IGhhcyBhbiBleHRyYSBoYWNrIGZvciBJRSB0aGF0IHdlIGNvdWxkIGVtcGxveSAoYmFzZWQgb25cbiAgICAgICAgICAgIC8vIGh0dHA6Ly9qYXZhc2NyaXB0Lm53Ym94LmNvbS9JRUNvbnRlbnRMb2FkZWQvKSBCdXQgaXQgbG9va3MgcmVhbGx5IG9sZC5cbiAgICAgICAgICAgIC8vIEknbSBob3Bpbmcgd2UgZG9uJ3QgbmVlZCBpdC5cbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIE1pbmltdW0ga2V5IG5hbWUuIEludmFsaWQgZm9yIGFjdHVhbCBkYXRhLCB1c2VkIGFzIGEgbWFya2VyIHRvIHNvcnQgYmVmb3JlIGFueSB2YWxpZCBuYW1lc1xuICogQHR5cGUgeyFzdHJpbmd9XG4gKi9cbmV4cG9ydCB2YXIgTUlOX05BTUUgPSAnW01JTl9OQU1FXSc7XG4vKipcbiAqIE1heGltdW0ga2V5IG5hbWUuIEludmFsaWQgZm9yIGFjdHVhbCBkYXRhLCB1c2VkIGFzIGEgbWFya2VyIHRvIHNvcnQgYWJvdmUgYW55IHZhbGlkIG5hbWVzXG4gKiBAdHlwZSB7IXN0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBNQVhfTkFNRSA9ICdbTUFYX05BTUVdJztcbi8qKlxuICogQ29tcGFyZXMgdmFsaWQgRmlyZWJhc2Uga2V5IG5hbWVzLCBwbHVzIG1pbiBhbmQgbWF4IG5hbWVcbiAqIEBwYXJhbSB7IXN0cmluZ30gYVxuICogQHBhcmFtIHshc3RyaW5nfSBiXG4gKiBAcmV0dXJuIHshbnVtYmVyfVxuICovXG5leHBvcnQgdmFyIG5hbWVDb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYSA9PT0gTUlOX05BTUUgfHwgYiA9PT0gTUFYX05BTUUpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChiID09PSBNSU5fTkFNRSB8fCBhID09PSBNQVhfTkFNRSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBhQXNJbnQgPSB0cnlQYXJzZUludChhKSwgYkFzSW50ID0gdHJ5UGFyc2VJbnQoYik7XG4gICAgICAgIGlmIChhQXNJbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChiQXNJbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYUFzSW50IC0gYkFzSW50ID09IDAgPyBhLmxlbmd0aCAtIGIubGVuZ3RoIDogYUFzSW50IC0gYkFzSW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJBc0ludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBAcGFyYW0geyFzdHJpbmd9IGFcbiAqIEBwYXJhbSB7IXN0cmluZ30gYlxuICogQHJldHVybiB7IW51bWJlcn0gY29tcGFyaXNvbiByZXN1bHQuXG4gKi9cbmV4cG9ydCB2YXIgc3RyaW5nQ29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4geyp9XG4gKi9cbmV4cG9ydCB2YXIgcmVxdWlyZUtleSA9IGZ1bmN0aW9uIChrZXksIG9iaikge1xuICAgIGlmIChvYmogJiYga2V5IGluIG9iaikge1xuICAgICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQga2V5ICgnICsga2V5ICsgJykgaW4gb2JqZWN0OiAnICsgc3RyaW5naWZ5KG9iaikpO1xuICAgIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCB2YXIgT2JqZWN0VG9VbmlxdWVLZXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAga2V5cy5wdXNoKGspO1xuICAgIH1cbiAgICAvLyBFeHBvcnQgYXMganNvbiwgYnV0IHdpdGggdGhlIGtleXMgc29ydGVkLlxuICAgIGtleXMuc29ydCgpO1xuICAgIHZhciBrZXkgPSAneyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpICE9PSAwKVxuICAgICAgICAgICAga2V5ICs9ICcsJztcbiAgICAgICAga2V5ICs9IHN0cmluZ2lmeShrZXlzW2ldKTtcbiAgICAgICAga2V5ICs9ICc6JztcbiAgICAgICAga2V5ICs9IE9iamVjdFRvVW5pcXVlS2V5KG9ialtrZXlzW2ldXSk7XG4gICAgfVxuICAgIGtleSArPSAnfSc7XG4gICAgcmV0dXJuIGtleTtcbn07XG4vKipcbiAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIGEgbnVtYmVyIG9mIHNtYWxsZXIgc2VnbWVudHMgb2YgbWF4aW11bSBzaXplXG4gKiBAcGFyYW0geyFzdHJpbmd9IHN0ciBUaGUgc3RyaW5nXG4gKiBAcGFyYW0geyFudW1iZXJ9IHNlZ3NpemUgVGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJzIGluIHRoZSBzdHJpbmcuXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gVGhlIHN0cmluZywgc3BsaXQgaW50byBhcHByb3ByaWF0ZWx5LXNpemVkIGNodW5rc1xuICovXG5leHBvcnQgdmFyIHNwbGl0U3RyaW5nQnlTaXplID0gZnVuY3Rpb24gKHN0ciwgc2Vnc2l6ZSkge1xuICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGlmIChsZW4gPD0gc2Vnc2l6ZSkge1xuICAgICAgICByZXR1cm4gW3N0cl07XG4gICAgfVxuICAgIHZhciBkYXRhU2VncyA9IFtdO1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbGVuOyBjICs9IHNlZ3NpemUpIHtcbiAgICAgICAgaWYgKGMgKyBzZWdzaXplID4gbGVuKSB7XG4gICAgICAgICAgICBkYXRhU2Vncy5wdXNoKHN0ci5zdWJzdHJpbmcoYywgbGVuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhU2Vncy5wdXNoKHN0ci5zdWJzdHJpbmcoYywgYyArIHNlZ3NpemUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YVNlZ3M7XG59O1xuLyoqXG4gKiBBcHBseSBhIGZ1bmN0aW9uIHRvIGVhY2ggKGtleSwgdmFsdWUpIHBhaXIgaW4gYW4gb2JqZWN0IG9yXG4gKiBhcHBseSBhIGZ1bmN0aW9uIHRvIGVhY2ggKGluZGV4LCB2YWx1ZSkgcGFpciBpbiBhbiBhcnJheVxuICogQHBhcmFtIHshKE9iamVjdHxBcnJheSl9IG9iaiBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtmdW5jdGlvbig/LCA/KX0gZm4gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5XG4gKi9cbmV4cG9ydCB2YXIgZWFjaCA9IGZ1bmN0aW9uIChvYmosIGZuKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgZm4oaSwgb2JqW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluIHRoZSBjb252ZXJzaW9uIG9mIGNvZGUgd2UgcmVtb3ZlZCB0aGUgZ29vZy5vYmplY3QuZm9yRWFjaFxuICAgICAgICAgKiBmdW5jdGlvbiB3aGljaCBkaWQgYSB2YWx1ZSxrZXkgY2FsbGJhY2suIFdlIHN0YW5kYXJkaXplZCBvblxuICAgICAgICAgKiBhIHNpbmdsZSBpbXBsIHRoYXQgZG9lcyBhIGtleSwgdmFsdWUgY2FsbGJhY2suIFNvIHdlIGludmVydFxuICAgICAgICAgKiB0byBub3QgaGF2ZSB0byB0b3VjaCB0aGUgYGVhY2hgIGNvZGUgcG9pbnRzXG4gICAgICAgICAqL1xuICAgICAgICBmb3JFYWNoKG9iaiwgZnVuY3Rpb24gKGtleSwgdmFsKSB7IHJldHVybiBmbih2YWwsIGtleSk7IH0pO1xuICAgIH1cbn07XG4vKipcbiAqIExpa2UgZ29vZy5iaW5kLCBidXQgZG9lc24ndCBib3RoZXIgdG8gY3JlYXRlIGEgY2xvc3VyZSBpZiBvcHRfY29udGV4dCBpcyBudWxsL3VuZGVmaW5lZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKil9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHs/T2JqZWN0PX0gY29udGV4dCBPcHRpb25hbCBjb250ZXh0IHRvIGJpbmQgdG8uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigqKX1cbiAqL1xuZXhwb3J0IHZhciBiaW5kQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY29udGV4dCA/IGNhbGxiYWNrLmJpbmQoY29udGV4dCkgOiBjYWxsYmFjaztcbn07XG4vKipcbiAqIEJvcnJvd2VkIGZyb20gaHR0cDovL2hnLnNlY29uZGxpZmUuY29tL2xsc2Qvc3JjL3RpcC9qcy90eXBlZGFycmF5LmpzIChNSVQgTGljZW5zZSlcbiAqIEkgbWFkZSBvbmUgbW9kaWZpY2F0aW9uIGF0IHRoZSBlbmQgYW5kIHJlbW92ZWQgdGhlIE5hTiAvIEluZmluaXR5XG4gKiBoYW5kbGluZyAoc2luY2UgaXQgc2VlbWVkIGJyb2tlbiBbY2F1c2VkIGFuIG92ZXJmbG93XSBhbmQgd2UgZG9uJ3QgbmVlZCBpdCkuICBTZWUgTUpMIGNvbW1lbnRzLlxuICogQHBhcmFtIHshbnVtYmVyfSB2IEEgZG91YmxlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCB2YXIgZG91YmxlVG9JRUVFNzU0U3RyaW5nID0gZnVuY3Rpb24gKHYpIHtcbiAgICBhc3NlcnQoIWlzSW52YWxpZEpTT05OdW1iZXIodiksICdJbnZhbGlkIEpTT04gbnVtYmVyJyk7IC8vIE1KTFxuICAgIHZhciBlYml0cyA9IDExLCBmYml0cyA9IDUyO1xuICAgIHZhciBiaWFzID0gKDEgPDwgKGViaXRzIC0gMSkpIC0gMSwgcywgZSwgZiwgbG4sIGksIGJpdHMsIHN0cjtcbiAgICAvLyBDb21wdXRlIHNpZ24sIGV4cG9uZW50LCBmcmFjdGlvblxuICAgIC8vIFNraXAgTmFOIC8gSW5maW5pdHkgaGFuZGxpbmcgLS1NSkwuXG4gICAgaWYgKHYgPT09IDApIHtcbiAgICAgICAgZSA9IDA7XG4gICAgICAgIGYgPSAwO1xuICAgICAgICBzID0gMSAvIHYgPT09IC1JbmZpbml0eSA/IDEgOiAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcyA9IHYgPCAwO1xuICAgICAgICB2ID0gTWF0aC5hYnModik7XG4gICAgICAgIGlmICh2ID49IE1hdGgucG93KDIsIDEgLSBiaWFzKSkge1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplZFxuICAgICAgICAgICAgbG4gPSBNYXRoLm1pbihNYXRoLmZsb29yKE1hdGgubG9nKHYpIC8gTWF0aC5MTjIpLCBiaWFzKTtcbiAgICAgICAgICAgIGUgPSBsbiArIGJpYXM7XG4gICAgICAgICAgICBmID0gTWF0aC5yb3VuZCh2ICogTWF0aC5wb3coMiwgZmJpdHMgLSBsbikgLSBNYXRoLnBvdygyLCBmYml0cykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRGVub3JtYWxpemVkXG4gICAgICAgICAgICBlID0gMDtcbiAgICAgICAgICAgIGYgPSBNYXRoLnJvdW5kKHYgLyBNYXRoLnBvdygyLCAxIC0gYmlhcyAtIGZiaXRzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUGFjayBzaWduLCBleHBvbmVudCwgZnJhY3Rpb25cbiAgICBiaXRzID0gW107XG4gICAgZm9yIChpID0gZmJpdHM7IGk7IGkgLT0gMSkge1xuICAgICAgICBiaXRzLnB1c2goZiAlIDIgPyAxIDogMCk7XG4gICAgICAgIGYgPSBNYXRoLmZsb29yKGYgLyAyKTtcbiAgICB9XG4gICAgZm9yIChpID0gZWJpdHM7IGk7IGkgLT0gMSkge1xuICAgICAgICBiaXRzLnB1c2goZSAlIDIgPyAxIDogMCk7XG4gICAgICAgIGUgPSBNYXRoLmZsb29yKGUgLyAyKTtcbiAgICB9XG4gICAgYml0cy5wdXNoKHMgPyAxIDogMCk7XG4gICAgYml0cy5yZXZlcnNlKCk7XG4gICAgc3RyID0gYml0cy5qb2luKCcnKTtcbiAgICAvLyBSZXR1cm4gdGhlIGRhdGEgYXMgYSBoZXggc3RyaW5nLiAtLU1KTFxuICAgIHZhciBoZXhCeXRlU3RyaW5nID0gJyc7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpICs9IDgpIHtcbiAgICAgICAgdmFyIGhleEJ5dGUgPSBwYXJzZUludChzdHIuc3Vic3RyKGksIDgpLCAyKS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChoZXhCeXRlLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIGhleEJ5dGUgPSAnMCcgKyBoZXhCeXRlO1xuICAgICAgICBoZXhCeXRlU3RyaW5nID0gaGV4Qnl0ZVN0cmluZyArIGhleEJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBoZXhCeXRlU3RyaW5nLnRvTG93ZXJDYXNlKCk7XG59O1xuLyoqXG4gKiBVc2VkIHRvIGRldGVjdCBpZiB3ZSdyZSBpbiBhIENocm9tZSBjb250ZW50IHNjcmlwdCAod2hpY2ggZXhlY3V0ZXMgaW4gYW5cbiAqIGlzb2xhdGVkIGVudmlyb25tZW50IHdoZXJlIGxvbmctcG9sbGluZyBkb2Vzbid0IHdvcmspLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IHZhciBpc0Nocm9tZUV4dGVuc2lvbkNvbnRlbnRTY3JpcHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHdpbmRvd1snY2hyb21lJ10gJiZcbiAgICAgICAgd2luZG93WydjaHJvbWUnXVsnZXh0ZW5zaW9uJ10gJiZcbiAgICAgICAgIS9eY2hyb21lLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ocmVmKSk7XG59O1xuLyoqXG4gKiBVc2VkIHRvIGRldGVjdCBpZiB3ZSdyZSBpbiBhIFdpbmRvd3MgOCBTdG9yZSBhcHAuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgdmFyIGlzV2luZG93c1N0b3JlQXBwID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIENoZWNrIGZvciB0aGUgcHJlc2VuY2Ugb2YgYSBjb3VwbGUgV2luUlQgZ2xvYmFsc1xuICAgIHJldHVybiB0eXBlb2YgV2luZG93cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIFdpbmRvd3MuVUkgPT09ICdvYmplY3QnO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBzZXJ2ZXIgZXJyb3IgY29kZSB0byBhIEphdmFzY3JpcHQgRXJyb3JcbiAqIEBwYXJhbSB7IXN0cmluZ30gY29kZVxuICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqL1xuZXhwb3J0IHZhciBlcnJvckZvclNlcnZlckNvZGUgPSBmdW5jdGlvbiAoY29kZSwgcXVlcnkpIHtcbiAgICB2YXIgcmVhc29uID0gJ1Vua25vd24gRXJyb3InO1xuICAgIGlmIChjb2RlID09PSAndG9vX2JpZycpIHtcbiAgICAgICAgcmVhc29uID1cbiAgICAgICAgICAgICdUaGUgZGF0YSByZXF1ZXN0ZWQgZXhjZWVkcyB0aGUgbWF4aW11bSBzaXplICcgK1xuICAgICAgICAgICAgICAgICd0aGF0IGNhbiBiZSBhY2Nlc3NlZCB3aXRoIGEgc2luZ2xlIHJlcXVlc3QuJztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAncGVybWlzc2lvbl9kZW5pZWQnKSB7XG4gICAgICAgIHJlYXNvbiA9IFwiQ2xpZW50IGRvZXNuJ3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyB0aGUgZGVzaXJlZCBkYXRhLlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09ICd1bmF2YWlsYWJsZScpIHtcbiAgICAgICAgcmVhc29uID0gJ1RoZSBzZXJ2aWNlIGlzIHVuYXZhaWxhYmxlJztcbiAgICB9XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKGNvZGUgKyAnIGF0ICcgKyBxdWVyeS5wYXRoLnRvU3RyaW5nKCkgKyAnOiAnICsgcmVhc29uKTtcbiAgICBlcnJvci5jb2RlID0gY29kZS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBlcnJvcjtcbn07XG4vKipcbiAqIFVzZWQgdG8gdGVzdCBmb3IgaW50ZWdlci1sb29raW5nIHN0cmluZ3NcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgdmFyIElOVEVHRVJfUkVHRVhQXyA9IG5ldyBSZWdFeHAoJ14tP1xcXFxkezEsMTB9JCcpO1xuLyoqXG4gKiBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIGEgMzItYml0IGludGVnZXIsIHJldHVybiBpdC4gIEVsc2UgcmV0dXJuIG51bGwuXG4gKiBAcGFyYW0geyFzdHJpbmd9IHN0clxuICogQHJldHVybiB7P251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciB0cnlQYXJzZUludCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoSU5URUdFUl9SRUdFWFBfLnRlc3Qoc3RyKSkge1xuICAgICAgICB2YXIgaW50VmFsID0gTnVtYmVyKHN0cik7XG4gICAgICAgIGlmIChpbnRWYWwgPj0gLTIxNDc0ODM2NDggJiYgaW50VmFsIDw9IDIxNDc0ODM2NDcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRWYWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBIZWxwZXIgdG8gcnVuIHNvbWUgY29kZSBidXQgY2F0Y2ggYW55IGV4Y2VwdGlvbnMgYW5kIHJlLXRocm93IHRoZW0gbGF0ZXIuXG4gKiBVc2VmdWwgZm9yIHByZXZlbnRpbmcgdXNlciBjYWxsYmFja3MgZnJvbSBicmVha2luZyBpbnRlcm5hbCBjb2RlLlxuICpcbiAqIFJlLXRocm93aW5nIHRoZSBleGNlcHRpb24gZnJvbSBhIHNldFRpbWVvdXQgaXMgYSBsaXR0bGUgZXZpbCwgYnV0IGl0J3MgdmVyeVxuICogY29udmVuaWVudCAod2UgZG9uJ3QgaGF2ZSB0byB0cnkgdG8gZmlndXJlIG91dCB3aGVuIGlzIGEgc2FmZSBwb2ludCB0b1xuICogcmUtdGhyb3cgaXQpLCBhbmQgdGhlIGJlaGF2aW9yIHNlZW1zIHJlYXNvbmFibGU6XG4gKlxuICogKiBJZiB5b3UgYXJlbid0IHBhdXNpbmcgb24gZXhjZXB0aW9ucywgeW91IGdldCBhbiBlcnJvciBpbiB0aGUgY29uc29sZSB3aXRoXG4gKiAgIHRoZSBjb3JyZWN0IHN0YWNrIHRyYWNlLlxuICogKiBJZiB5b3UncmUgcGF1c2luZyBvbiBhbGwgZXhjZXB0aW9ucywgdGhlIGRlYnVnZ2VyIHdpbGwgcGF1c2Ugb24geW91clxuICogICBleGNlcHRpb24gYW5kIHRoZW4gYWdhaW4gd2hlbiB3ZSByZXRocm93IGl0LlxuICogKiBJZiB5b3UncmUgb25seSBwYXVzaW5nIG9uIHVuY2F1Z2h0IGV4Y2VwdGlvbnMsIHRoZSBkZWJ1Z2dlciB3aWxsIG9ubHkgcGF1c2VcbiAqICAgb24gdXMgcmUtdGhyb3dpbmcgaXQuXG4gKlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gZm4gVGhlIGNvZGUgdG8gZ3VhcmQuXG4gKi9cbmV4cG9ydCB2YXIgZXhjZXB0aW9uR3VhcmQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBSZS10aHJvdyBleGNlcHRpb24gd2hlbiBpdCdzIHNhZmUuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gSXQgdXNlZCB0byBiZSB0aGF0IFwidGhyb3cgZVwiIHdvdWxkIHJlc3VsdCBpbiBhIGdvb2QgY29uc29sZSBlcnJvciB3aXRoXG4gICAgICAgICAgICAvLyByZWxldmFudCBjb250ZXh0LCBidXQgYXMgb2YgQ2hyb21lIDM5LCB5b3UganVzdCBnZXQgdGhlIGZpcmViYXNlLmpzXG4gICAgICAgICAgICAvLyBmaWxlL2xpbmUgbnVtYmVyIHdoZXJlIHdlIHJlLXRocm93IGl0LCB3aGljaCBpcyB1c2VsZXNzLiBTbyB3ZSBsb2dcbiAgICAgICAgICAgIC8vIGUuc3RhY2sgZXhwbGljaXRseS5cbiAgICAgICAgICAgIHZhciBzdGFjayA9IGUuc3RhY2sgfHwgJyc7XG4gICAgICAgICAgICB3YXJuKCdFeGNlcHRpb24gd2FzIHRocm93biBieSB1c2VyIGNhbGxiYWNrLicsIHN0YWNrKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0sIE1hdGguZmxvb3IoMCkpO1xuICAgIH1cbn07XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBzYWZlbHkgY2FsbCBvcHRfY2FsbGJhY2sgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cy4gIEl0OlxuICogMS4gVHVybnMgaW50byBhIG5vLW9wIGlmIG9wdF9jYWxsYmFjayBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqIDIuIFdyYXBzIHRoZSBjYWxsIGluc2lkZSBleGNlcHRpb25HdWFyZCB0byBwcmV2ZW50IGV4Y2VwdGlvbnMgZnJvbSBicmVha2luZyBvdXIgc3RhdGUuXG4gKlxuICogQHBhcmFtIHs/RnVuY3Rpb249fSBjYWxsYmFjayBPcHRpb25hbCBvbkNvbXBsZXRlIGNhbGxiYWNrLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBBcmJpdHJhcnkgYXJncyB0byBiZSBwYXNzZWQgdG8gb3B0X29uQ29tcGxldGVcbiAqL1xuZXhwb3J0IHZhciBjYWxsVXNlckNhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIHZhcl9hcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyX2FyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXhjZXB0aW9uR3VhcmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodm9pZCAwLCB2YXJfYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgd2UgdGhpbmsgd2UncmUgY3VycmVudGx5IGJlaW5nIGNyYXdsZWQuXG4gKi9cbmV4cG9ydCB2YXIgYmVpbmdDcmF3bGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VyQWdlbnQgPSAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgd2luZG93WyduYXZpZ2F0b3InXSAmJlxuICAgICAgICB3aW5kb3dbJ25hdmlnYXRvciddWyd1c2VyQWdlbnQnXSkgfHxcbiAgICAgICAgJyc7XG4gICAgLy8gRm9yIG5vdyB3ZSB3aGl0ZWxpc3QgdGhlIG1vc3QgcG9wdWxhciBjcmF3bGVycy4gIFdlIHNob3VsZCByZWZpbmUgdGhpcyB0byBiZSB0aGUgc2V0IG9mIGNyYXdsZXJzIHdlXG4gICAgLy8gYmVsaWV2ZSB0byBzdXBwb3J0IEphdmFTY3JpcHQvQUpBWCByZW5kZXJpbmcuXG4gICAgLy8gTk9URTogR29vZ2xlIFdlYm1hc3RlciBUb29scyBkb2Vzbid0IHJlYWxseSBiZWxvbmcsIGJ1dCB0aGVpciBcIlRoaXMgaXMgaG93IGEgdmlzaXRvciB0byB5b3VyIHdlYnNpdGVcbiAgICAvLyB3b3VsZCBoYXZlIHNlZW4gdGhlIHBhZ2VcIiBpcyBmbGFreSBpZiB3ZSBkb24ndCB0cmVhdCBpdCBhcyBhIGNyYXdsZXIuXG4gICAgcmV0dXJuICh1c2VyQWdlbnQuc2VhcmNoKC9nb29nbGVib3R8Z29vZ2xlIHdlYm1hc3RlciB0b29sc3xiaW5nYm90fHlhaG9vISBzbHVycHxiYWlkdXNwaWRlcnx5YW5kZXhib3R8ZHVja2R1Y2tib3QvaSkgPj0gMCk7XG59O1xuLyoqXG4gKiBFeHBvcnQgYSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgdXNpbmcgYSBnZXR0ZXIgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpOiAqfSBmbkdldFxuICovXG5leHBvcnQgdmFyIGV4cG9ydFByb3BHZXR0ZXIgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBmbkdldCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHsgZ2V0OiBmbkdldCB9KTtcbn07XG4vKipcbiAqIFNhbWUgYXMgc2V0VGltZW91dCgpIGV4Y2VwdCBvbiBOb2RlLkpTIGl0IHdpbGwgL25vdC8gcHJldmVudCB0aGUgcHJvY2VzcyBmcm9tIGV4aXRpbmcuXG4gKlxuICogSXQgaXMgcmVtb3ZlZCB3aXRoIGNsZWFyVGltZW91dCgpIGFzIG5vcm1hbC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBydW4uXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZSBNaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgcnVubmluZy5cbiAqIEByZXR1cm4ge251bWJlcnxPYmplY3R9IFRoZSBzZXRUaW1lb3V0KCkgcmV0dXJuIHZhbHVlLlxuICovXG5leHBvcnQgdmFyIHNldFRpbWVvdXROb25CbG9ja2luZyA9IGZ1bmN0aW9uIChmbiwgdGltZSkge1xuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChmbiwgdGltZSk7XG4gICAgaWYgKHR5cGVvZiB0aW1lb3V0ID09PSAnb2JqZWN0JyAmJiB0aW1lb3V0Wyd1bnJlZiddKSB7XG4gICAgICAgIHRpbWVvdXRbJ3VucmVmJ10oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVvdXQ7XG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3V0aWwvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgbmFtZUNvbXBhcmUgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgc3RyaW5nTGVuZ3RoIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuLyoqXG4gKiBBbiBpbW11dGFibGUgb2JqZWN0IHJlcHJlc2VudGluZyBhIHBhcnNlZCBwYXRoLiAgSXQncyBpbW11dGFibGUgc28gdGhhdCB5b3VcbiAqIGNhbiBwYXNzIHRoZW0gYXJvdW5kIHRvIG90aGVyIGZ1bmN0aW9ucyB3aXRob3V0IHdvcnJ5aW5nIGFib3V0IHRoZW0gY2hhbmdpbmdcbiAqIGl0LlxuICovXG52YXIgUGF0aCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gcGF0aE9yU3RyaW5nIFBhdGggc3RyaW5nIHRvIHBhcnNlLFxuICAgICAqICAgICAgb3IgYW5vdGhlciBwYXRoLCBvciB0aGUgcmF3IHRva2VucyBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcGllY2VOdW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXRoKHBhdGhPclN0cmluZywgcGllY2VOdW0pIHtcbiAgICAgICAgaWYgKHBpZWNlTnVtID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRoaXMucGllY2VzXyA9IHBhdGhPclN0cmluZy5zcGxpdCgnLycpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGVtcHR5IHBpZWNlcy5cbiAgICAgICAgICAgIHZhciBjb3B5VG8gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBpZWNlc18ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5waWVjZXNfW2ldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5waWVjZXNfW2NvcHlUb10gPSB0aGlzLnBpZWNlc19baV07XG4gICAgICAgICAgICAgICAgICAgIGNvcHlUbysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGllY2VzXy5sZW5ndGggPSBjb3B5VG87XG4gICAgICAgICAgICB0aGlzLnBpZWNlTnVtXyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBpZWNlc18gPSBwYXRoT3JTdHJpbmc7XG4gICAgICAgICAgICB0aGlzLnBpZWNlTnVtXyA9IHBpZWNlTnVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYXRoLCBcIkVtcHR5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpbmdsZXRvbiB0byByZXByZXNlbnQgYW4gZW1wdHkgcGF0aFxuICAgICAgICAgKlxuICAgICAgICAgKiBAY29uc3RcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXRoKCcnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUGF0aC5wcm90b3R5cGUuZ2V0RnJvbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBpZWNlTnVtXyA+PSB0aGlzLnBpZWNlc18ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnBpZWNlc19bdGhpcy5waWVjZU51bV9dO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoaXMgcGF0aFxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGllY2VzXy5sZW5ndGggLSB0aGlzLnBpZWNlTnVtXztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFQYXRofVxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLnBvcEZyb250ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGllY2VOdW0gPSB0aGlzLnBpZWNlTnVtXztcbiAgICAgICAgaWYgKHBpZWNlTnVtIDwgdGhpcy5waWVjZXNfLmxlbmd0aCkge1xuICAgICAgICAgICAgcGllY2VOdW0rKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhdGgodGhpcy5waWVjZXNfLCBwaWVjZU51bSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLmdldEJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBpZWNlTnVtXyA8IHRoaXMucGllY2VzXy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5waWVjZXNfW3RoaXMucGllY2VzXy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBQYXRoLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhdGhTdHJpbmcgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucGllY2VOdW1fOyBpIDwgdGhpcy5waWVjZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5waWVjZXNfW2ldICE9PSAnJylcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nICs9ICcvJyArIHRoaXMucGllY2VzX1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aFN0cmluZyB8fCAnLyc7XG4gICAgfTtcbiAgICBQYXRoLnByb3RvdHlwZS50b1VybEVuY29kZWRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXRoU3RyaW5nID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBpZWNlTnVtXzsgaSA8IHRoaXMucGllY2VzXy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMucGllY2VzX1tpXSAhPT0gJycpXG4gICAgICAgICAgICAgICAgcGF0aFN0cmluZyArPSAnLycgKyBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHRoaXMucGllY2VzX1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoU3RyaW5nIHx8ICcvJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNoYWxsb3cgY29weSBvZiB0aGUgcGFydHMgb2YgdGhlIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luXG4gICAgICogQHJldHVybiB7IUFycmF5PHN0cmluZz59XG4gICAgICovXG4gICAgUGF0aC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoYmVnaW4pIHtcbiAgICAgICAgaWYgKGJlZ2luID09PSB2b2lkIDApIHsgYmVnaW4gPSAwOyB9XG4gICAgICAgIHJldHVybiB0aGlzLnBpZWNlc18uc2xpY2UodGhpcy5waWVjZU51bV8gKyBiZWdpbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/UGF0aH1cbiAgICAgKi9cbiAgICBQYXRoLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBpZWNlTnVtXyA+PSB0aGlzLnBpZWNlc18ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBwaWVjZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucGllY2VOdW1fOyBpIDwgdGhpcy5waWVjZXNfLmxlbmd0aCAtIDE7IGkrKylcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKHRoaXMucGllY2VzX1tpXSk7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aChwaWVjZXMsIDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8IVBhdGh9IGNoaWxkUGF0aE9ialxuICAgICAqIEByZXR1cm4geyFQYXRofVxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLmNoaWxkID0gZnVuY3Rpb24gKGNoaWxkUGF0aE9iaikge1xuICAgICAgICB2YXIgcGllY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBpZWNlTnVtXzsgaSA8IHRoaXMucGllY2VzXy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKHRoaXMucGllY2VzX1tpXSk7XG4gICAgICAgIGlmIChjaGlsZFBhdGhPYmogaW5zdGFuY2VvZiBQYXRoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRQYXRoT2JqLnBpZWNlTnVtXzsgaSA8IGNoaWxkUGF0aE9iai5waWVjZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGllY2VzLnB1c2goY2hpbGRQYXRoT2JqLnBpZWNlc19baV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNoaWxkUGllY2VzID0gY2hpbGRQYXRoT2JqLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkUGllY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkUGllY2VzW2ldLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHBpZWNlcy5wdXNoKGNoaWxkUGllY2VzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhdGgocGllY2VzLCAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlcmUgYXJlIG5vIHNlZ21lbnRzIGluIHRoaXMgcGF0aFxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpZWNlTnVtXyA+PSB0aGlzLnBpZWNlc18ubGVuZ3RoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gb3V0ZXJQYXRoXG4gICAgICogQHBhcmFtIHshUGF0aH0gaW5uZXJQYXRoXG4gICAgICogQHJldHVybiB7IVBhdGh9IFRoZSBwYXRoIGZyb20gb3V0ZXJQYXRoIHRvIGlubmVyUGF0aFxuICAgICAqL1xuICAgIFBhdGgucmVsYXRpdmVQYXRoID0gZnVuY3Rpb24gKG91dGVyUGF0aCwgaW5uZXJQYXRoKSB7XG4gICAgICAgIHZhciBvdXRlciA9IG91dGVyUGF0aC5nZXRGcm9udCgpLCBpbm5lciA9IGlubmVyUGF0aC5nZXRGcm9udCgpO1xuICAgICAgICBpZiAob3V0ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpbm5lclBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3V0ZXIgPT09IGlubmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gUGF0aC5yZWxhdGl2ZVBhdGgob3V0ZXJQYXRoLnBvcEZyb250KCksIGlubmVyUGF0aC5wb3BGcm9udCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSU5URVJOQUwgRVJST1I6IGlubmVyUGF0aCAoJyArXG4gICAgICAgICAgICAgICAgaW5uZXJQYXRoICtcbiAgICAgICAgICAgICAgICAnKSBpcyBub3Qgd2l0aGluICcgK1xuICAgICAgICAgICAgICAgICdvdXRlclBhdGggKCcgK1xuICAgICAgICAgICAgICAgIG91dGVyUGF0aCArXG4gICAgICAgICAgICAgICAgJyknKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gbGVmdFxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHJpZ2h0XG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtMSwgMCwgMSBpZiBsZWZ0IGlzIGxlc3MsIGVxdWFsLCBvciBncmVhdGVyIHRoYW4gdGhlIHJpZ2h0LlxuICAgICAqL1xuICAgIFBhdGguY29tcGFyZVBhdGhzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBsZWZ0S2V5cyA9IGxlZnQuc2xpY2UoKTtcbiAgICAgICAgdmFyIHJpZ2h0S2V5cyA9IHJpZ2h0LnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdEtleXMubGVuZ3RoICYmIGkgPCByaWdodEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjbXAgPSBuYW1lQ29tcGFyZShsZWZ0S2V5c1tpXSwgcmlnaHRLZXlzW2ldKTtcbiAgICAgICAgICAgIGlmIChjbXAgIT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdEtleXMubGVuZ3RoID09PSByaWdodEtleXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiBsZWZ0S2V5cy5sZW5ndGggPCByaWdodEtleXMubGVuZ3RoID8gLTEgOiAxO1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhdGh9IG90aGVyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBwYXRocyBhcmUgdGhlIHNhbWUuXG4gICAgICovXG4gICAgUGF0aC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmdldExlbmd0aCgpICE9PSBvdGhlci5nZXRMZW5ndGgoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBpZWNlTnVtXywgaiA9IG90aGVyLnBpZWNlTnVtXzsgaSA8PSB0aGlzLnBpZWNlc18ubGVuZ3RoOyBpKyssIGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXMucGllY2VzX1tpXSAhPT0gb3RoZXIucGllY2VzX1tqXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gb3RoZXJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgcGF0aCBpcyBhIHBhcmVudCAob3IgdGhlIHNhbWUgYXMpIG90aGVyXG4gICAgICovXG4gICAgUGF0aC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnBpZWNlTnVtXztcbiAgICAgICAgdmFyIGogPSBvdGhlci5waWVjZU51bV87XG4gICAgICAgIGlmICh0aGlzLmdldExlbmd0aCgpID4gb3RoZXIuZ2V0TGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaSA8IHRoaXMucGllY2VzXy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBpZWNlc19baV0gIT09IG90aGVyLnBpZWNlc19bal0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICArK2o7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gUGF0aDtcbn0oKSk7IC8vIGVuZCBQYXRoXG5leHBvcnQgeyBQYXRoIH07XG4vKipcbiAqIER5bmFtaWMgKG11dGFibGUpIHBhdGggdXNlZCB0byBjb3VudCBwYXRoIGxlbmd0aHMuXG4gKlxuICogVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGVmZmljaWVudGx5IGNoZWNrIHBhdGhzIGZvciB2YWxpZFxuICogbGVuZ3RoIChpbiBVVEY4IGJ5dGVzKSBhbmQgZGVwdGggKHVzZWQgaW4gcGF0aCB2YWxpZGF0aW9uKS5cbiAqXG4gKiBUaHJvd3MgRXJyb3IgZXhjZXB0aW9uIGlmIHBhdGggaXMgZXZlciBpbnZhbGlkLlxuICpcbiAqIFRoZSBkZWZpbml0aW9uIG9mIGEgcGF0aCBhbHdheXMgYmVnaW5zIHdpdGggJy8nLlxuICovXG52YXIgVmFsaWRhdGlvblBhdGggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aCBJbml0aWFsIFBhdGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVycm9yUHJlZml4XyBQcmVmaXggZm9yIGFueSBlcnJvciBtZXNzYWdlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWYWxpZGF0aW9uUGF0aChwYXRoLCBlcnJvclByZWZpeF8pIHtcbiAgICAgICAgdGhpcy5lcnJvclByZWZpeF8gPSBlcnJvclByZWZpeF87XG4gICAgICAgIC8qKiBAdHlwZSB7IUFycmF5PHN0cmluZz59ICovXG4gICAgICAgIHRoaXMucGFydHNfID0gcGF0aC5zbGljZSgpO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gSW5pdGlhbGl6ZSB0byBudW1iZXIgb2YgJy8nIGNoYXJzIG5lZWRlZCBpbiBwYXRoLiAqL1xuICAgICAgICB0aGlzLmJ5dGVMZW5ndGhfID0gTWF0aC5tYXgoMSwgdGhpcy5wYXJ0c18ubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhcnRzXy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoXyArPSBzdHJpbmdMZW5ndGgodGhpcy5wYXJ0c19baV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tWYWxpZF8oKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZhbGlkYXRpb25QYXRoLCBcIk1BWF9QQVRIX0RFUFRIXCIsIHtcbiAgICAgICAgLyoqIEBjb25zdCB7bnVtYmVyfSBNYXhpbXVtIGtleSBkZXB0aC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gMzI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWYWxpZGF0aW9uUGF0aCwgXCJNQVhfUEFUSF9MRU5HVEhfQllURVNcIiwge1xuICAgICAgICAvKiogQGNvbnN0IHtudW1iZXJ9IE1heGltdW0gbnVtYmVyIG9mIChVVEY4KSBieXRlcyBpbiBhIEZpcmViYXNlIHBhdGguICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIDc2ODtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZCAqL1xuICAgIFZhbGlkYXRpb25QYXRoLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIC8vIENvdW50IHRoZSBuZWVkZWQgJy8nXG4gICAgICAgIGlmICh0aGlzLnBhcnRzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGhfICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJ0c18ucHVzaChjaGlsZCk7XG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aF8gKz0gc3RyaW5nTGVuZ3RoKGNoaWxkKTtcbiAgICAgICAgdGhpcy5jaGVja1ZhbGlkXygpO1xuICAgIH07XG4gICAgVmFsaWRhdGlvblBhdGgucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLnBhcnRzXy5wb3AoKTtcbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoXyAtPSBzdHJpbmdMZW5ndGgobGFzdCk7XG4gICAgICAgIC8vIFVuLWNvdW50IHRoZSBwcmV2aW91cyAnLydcbiAgICAgICAgaWYgKHRoaXMucGFydHNfLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aF8gLT0gMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmFsaWRhdGlvblBhdGgucHJvdG90eXBlLmNoZWNrVmFsaWRfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5ieXRlTGVuZ3RoXyA+IFZhbGlkYXRpb25QYXRoLk1BWF9QQVRIX0xFTkdUSF9CWVRFUykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZXJyb3JQcmVmaXhfICtcbiAgICAgICAgICAgICAgICAnaGFzIGEga2V5IHBhdGggbG9uZ2VyIHRoYW4gJyArXG4gICAgICAgICAgICAgICAgVmFsaWRhdGlvblBhdGguTUFYX1BBVEhfTEVOR1RIX0JZVEVTICtcbiAgICAgICAgICAgICAgICAnIGJ5dGVzICgnICtcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGhfICtcbiAgICAgICAgICAgICAgICAnKS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJ0c18ubGVuZ3RoID4gVmFsaWRhdGlvblBhdGguTUFYX1BBVEhfREVQVEgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmVycm9yUHJlZml4XyArXG4gICAgICAgICAgICAgICAgJ3BhdGggc3BlY2lmaWVkIGV4Y2VlZHMgdGhlIG1heGltdW0gZGVwdGggdGhhdCBjYW4gYmUgd3JpdHRlbiAoJyArXG4gICAgICAgICAgICAgICAgVmFsaWRhdGlvblBhdGguTUFYX1BBVEhfREVQVEggK1xuICAgICAgICAgICAgICAgICcpIG9yIG9iamVjdCBjb250YWlucyBhIGN5Y2xlICcgK1xuICAgICAgICAgICAgICAgIHRoaXMudG9FcnJvclN0cmluZygpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RyaW5nIGZvciB1c2UgaW4gZXJyb3IgbWVzc2FnZXMgLSB1c2VzICcuJyBub3RhdGlvbiBmb3IgcGF0aC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBWYWxpZGF0aW9uUGF0aC5wcm90b3R5cGUudG9FcnJvclN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFydHNfLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiaW4gcHJvcGVydHkgJ1wiICsgdGhpcy5wYXJ0c18uam9pbignLicpICsgXCInXCI7XG4gICAgfTtcbiAgICByZXR1cm4gVmFsaWRhdGlvblBhdGg7XG59KCkpO1xuZXhwb3J0IHsgVmFsaWRhdGlvblBhdGggfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS91dGlsL1BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IHsgSW5kZXggfSBmcm9tICcuL0luZGV4JztcbmltcG9ydCB7IG5hbWVDb21wYXJlLCBNQVhfTkFNRSB9IGZyb20gJy4uLy4uL3V0aWwvdXRpbCc7XG5pbXBvcnQgeyBOYW1lZE5vZGUgfSBmcm9tICcuLi9Ob2RlJztcbmltcG9ydCB7IExlYWZOb2RlIH0gZnJvbSAnLi4vTGVhZk5vZGUnO1xudmFyIG5vZGVGcm9tSlNPTjtcbnZhciBNQVhfTk9ERTtcbmV4cG9ydCBmdW5jdGlvbiBzZXROb2RlRnJvbUpTT04odmFsKSB7XG4gICAgbm9kZUZyb21KU09OID0gdmFsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldE1heE5vZGUodmFsKSB7XG4gICAgTUFYX05PREUgPSB2YWw7XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0luZGV4fVxuICogQHByaXZhdGVcbiAqL1xudmFyIFByaW9yaXR5SW5kZXggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByaW9yaXR5SW5kZXgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJpb3JpdHlJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFByaW9yaXR5SW5kZXgucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgYVByaW9yaXR5ID0gYS5ub2RlLmdldFByaW9yaXR5KCk7XG4gICAgICAgIHZhciBiUHJpb3JpdHkgPSBiLm5vZGUuZ2V0UHJpb3JpdHkoKTtcbiAgICAgICAgdmFyIGluZGV4Q21wID0gYVByaW9yaXR5LmNvbXBhcmVUbyhiUHJpb3JpdHkpO1xuICAgICAgICBpZiAoaW5kZXhDbXAgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lQ29tcGFyZShhLm5hbWUsIGIubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhDbXA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUHJpb3JpdHlJbmRleC5wcm90b3R5cGUuaXNEZWZpbmVkT24gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gIW5vZGUuZ2V0UHJpb3JpdHkoKS5pc0VtcHR5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFByaW9yaXR5SW5kZXgucHJvdG90eXBlLmluZGV4ZWRWYWx1ZUNoYW5nZWQgPSBmdW5jdGlvbiAob2xkTm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICByZXR1cm4gIW9sZE5vZGUuZ2V0UHJpb3JpdHkoKS5lcXVhbHMobmV3Tm9kZS5nZXRQcmlvcml0eSgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUHJpb3JpdHlJbmRleC5wcm90b3R5cGUubWluUG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NSU47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFByaW9yaXR5SW5kZXgucHJvdG90eXBlLm1heFBvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKE1BWF9OQU1FLCBuZXcgTGVhZk5vZGUoJ1tQUklPUklUWS1QT1NUXScsIE1BWF9OT0RFKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IGluZGV4VmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm4geyFOYW1lZE5vZGV9XG4gICAgICovXG4gICAgUHJpb3JpdHlJbmRleC5wcm90b3R5cGUubWFrZVBvc3QgPSBmdW5jdGlvbiAoaW5kZXhWYWx1ZSwgbmFtZSkge1xuICAgICAgICB2YXIgcHJpb3JpdHlOb2RlID0gbm9kZUZyb21KU09OKGluZGV4VmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShuYW1lLCBuZXcgTGVhZk5vZGUoJ1tQUklPUklUWS1QT1NUXScsIHByaW9yaXR5Tm9kZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IXN0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciBpbmNsdXNpb24gaW4gYSBxdWVyeSBzcGVjXG4gICAgICovXG4gICAgUHJpb3JpdHlJbmRleC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnLnByaW9yaXR5JztcbiAgICB9O1xuICAgIHJldHVybiBQcmlvcml0eUluZGV4O1xufShJbmRleCkpO1xuZXhwb3J0IHsgUHJpb3JpdHlJbmRleCB9O1xuZXhwb3J0IHZhciBQUklPUklUWV9JTkRFWCA9IG5ldyBQcmlvcml0eUluZGV4KCk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vLyBJbXBvcnRzXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBmaXJlYmFzZSBmcm9tICdmaXJlYmFzZS9hcHAnO1xuXG5pbXBvcnQgeyBtYXRocywgbmV0IH0gZnJvbSAndmFyeWQtdXRpbHMnO1xuXG5pbXBvcnQgTG9naW5WaWV3IGZyb20gJy4vTG9naW5WaWV3JztcbmltcG9ydCBTaWRlYmFyIGZyb20gJy4vU2lkZWJhcic7XG5cbmltcG9ydCBUcmFja1ZpZXcgZnJvbSAnLi9UcmFja1ZpZXcnO1xuaW1wb3J0IEV2YWx1YXRlVmlldyBmcm9tICcuL0V2YWx1YXRlVmlldyc7XG5pbXBvcnQgQ3VzdG9taXplVmlldyBmcm9tICcuL0N1c3RvbWl6ZVZpZXcnO1xuaW1wb3J0IFNldHRpbmdzVmlldyBmcm9tICcuL1NldHRpbmdzVmlldyc7XG5cbi8vIENvbnN0YW50c1xuXG5cbi8vIENsYXNzXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFwcCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgLy8gQ29uc3RydWN0b3JcblxuICBjb25zdHJ1Y3RvcigpIHtcblxuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmhhbmRsZU1vZGVDaGFuZ2UgPSBuZXdNb2RlID0+IHtcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIG1vZGU6IG5ld01vZGVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLmhhbmRsZUdvb2dsZUxvZ2luQ2xpY2sgPSAoKSA9PiB7XG5cbiAgICAgIHZhciBwcm92aWRlciA9IG5ldyBmaXJlYmFzZS5hdXRoLkdvb2dsZUF1dGhQcm92aWRlcigpO1xuXG4gICAgICBmaXJlYmFzZS5hdXRoKCkuc2lnbkluV2l0aFJlZGlyZWN0KHByb3ZpZGVyKS50aGVuKHJlc3VsdCA9PiBjb25zb2xlLmxvZyhyZXN1bHQpKS5jYXRjaChlcnJvciA9PiBjb25zb2xlLmxvZyhlcnJvcikpO1xuICAgIH07XG5cbiAgICB0aGlzLmhhbmRsZUFub255bW91c0xvZ2luQ2xpY2sgPSAoKSA9PiB7XG5cbiAgICAgIGZpcmViYXNlLmF1dGgoKS5zaWduSW5Bbm9ueW1vdXNseSgpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuaW5pdFN0YXRlKCk7XG4gICAgdGhpcy5pbml0RmlyZWJhc2UoKTtcbiAgfVxuXG4gIGluaXRTdGF0ZSgpIHtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB1c2VyOiB1bmRlZmluZWQsXG4gICAgICBtb2RlOiAndHJhY2snXG4gICAgfTtcbiAgfVxuICBpbml0RmlyZWJhc2UoKSB7XG5cbiAgICB0aGlzLnVuc3Vic2NyaWJlQXV0aCA9IGZpcmViYXNlLmF1dGgoKS5vbkF1dGhTdGF0ZUNoYW5nZWQodXNlciA9PiB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdXNlcjogdXNlclxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBFdmVudCBoYW5kbGVyc1xuXG4gIC8vIE1ldGhvZHNcblxuXG4gIC8vIFJlYWN0XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cbiAgICBpZiAodGhpcy51bnN1YnNjcmliZUF1dGgpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmVBdXRoKCk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuXG4gICAgaWYgKCF0aGlzLnN0YXRlLnVzZXIpIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KExvZ2luVmlldywge1xuICAgICAgb25Hb29nbGVMb2dpbkNsaWNrOiB0aGlzLmhhbmRsZUdvb2dsZUxvZ2luQ2xpY2ssXG4gICAgICBvbkFub255bW91c0xvZ2luQ2xpY2s6IHRoaXMuaGFuZGxlQW5vbnltb3VzTG9naW5DbGljayB9KTtcblxuICAgIGNvbnN0IGlzVHJhY2sgPSB0aGlzLnN0YXRlLm1vZGUgPT09ICd0cmFjaycsXG4gICAgICAgICAgaXNFdmFsdWF0ZSA9IHRoaXMuc3RhdGUubW9kZSA9PT0gJ2V2YWx1YXRlJyxcbiAgICAgICAgICBpc0N1c3RvbWl6ZSA9IHRoaXMuc3RhdGUubW9kZSA9PT0gJ2N1c3RvbWl6ZScsXG4gICAgICAgICAgaXNTZXR0aW5ncyA9IHRoaXMuc3RhdGUubW9kZSA9PT0gJ3NldHRpbmdzJztcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3dyYXAtYWxsJyB9LFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTaWRlYmFyLCB7XG4gICAgICAgIG1vZGU6IHRoaXMuc3RhdGUubW9kZSxcbiAgICAgICAgb25Nb2RlQ2hhbmdlOiB0aGlzLmhhbmRsZU1vZGVDaGFuZ2UgfSksXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnbWFpbicsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGlzVHJhY2sgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChUcmFja1ZpZXcsIG51bGwpLFxuICAgICAgICBpc0V2YWx1YXRlICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRXZhbHVhdGVWaWV3LCBudWxsKSxcbiAgICAgICAgaXNDdXN0b21pemUgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChDdXN0b21pemVWaWV3LCBudWxsKSxcbiAgICAgICAgaXNTZXR0aW5ncyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFNldHRpbmdzVmlldywgbnVsbClcbiAgICAgIClcbiAgICApO1xuICB9XG5cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FwcC9zcmMvY29tcG9uZW50cy9BcHAuanN4XG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IHNoYTEsIE1BWF9OQU1FLCBNSU5fTkFNRSB9IGZyb20gJy4uL3V0aWwvdXRpbCc7XG5pbXBvcnQgeyBTb3J0ZWRNYXAgfSBmcm9tICcuLi91dGlsL1NvcnRlZE1hcCc7XG5pbXBvcnQgeyBOYW1lZE5vZGUgfSBmcm9tICcuL05vZGUnO1xuaW1wb3J0IHsgdmFsaWRhdGVQcmlvcml0eU5vZGUsIHByaW9yaXR5SGFzaFRleHQsIHNldE1heE5vZGUgfSBmcm9tICcuL3NuYXAnO1xuaW1wb3J0IHsgUFJJT1JJVFlfSU5ERVgsIHNldE1heE5vZGUgYXMgc2V0UHJpb3JpdHlNYXhOb2RlIH0gZnJvbSAnLi9pbmRleGVzL1ByaW9yaXR5SW5kZXgnO1xuaW1wb3J0IHsgS0VZX0lOREVYLCBLZXlJbmRleCB9IGZyb20gJy4vaW5kZXhlcy9LZXlJbmRleCc7XG5pbXBvcnQgeyBJbmRleE1hcCB9IGZyb20gJy4vSW5kZXhNYXAnO1xuaW1wb3J0IHsgTGVhZk5vZGUgfSBmcm9tICcuL0xlYWZOb2RlJztcbmltcG9ydCB7IE5BTUVfQ09NUEFSQVRPUiB9IGZyb20gJy4vY29tcGFyYXRvcnMnO1xuLy8gVE9ETzogRm9yIG1lbW9yeSBzYXZpbmdzLCBkb24ndCBzdG9yZSBwcmlvcml0eU5vZGVfIGlmIGl0J3MgZW1wdHkuXG52YXIgRU1QVFlfTk9ERTtcbi8qKlxuICogQ2hpbGRyZW5Ob2RlIGlzIGEgY2xhc3MgZm9yIHN0b3JpbmcgaW50ZXJuYWwgbm9kZXMgaW4gYSBEYXRhU25hcHNob3RcbiAqIChpLmUuIG5vZGVzIHdpdGggY2hpbGRyZW4pLiAgSXQgaW1wbGVtZW50cyBOb2RlIGFuZCBzdG9yZXMgdGhlXG4gKiBsaXN0IG9mIGNoaWxkcmVuIGluIHRoZSBjaGlsZHJlbiBwcm9wZXJ0eSwgc29ydGVkIGJ5IGNoaWxkIG5hbWUuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7Tm9kZX1cbiAqL1xudmFyIENoaWxkcmVuTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVNvcnRlZE1hcC48c3RyaW5nLCAhTm9kZT59IGNoaWxkcmVuXyBMaXN0IG9mIGNoaWxkcmVuXG4gICAgICogb2YgdGhpcyBub2RlLi5cbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBwcmlvcml0eU5vZGVfIFRoZSBwcmlvcml0eSBvZiB0aGlzIG5vZGUgKGFzIGEgc25hcHNob3Qgbm9kZSkuXG4gICAgICogQHBhcmFtIHshSW5kZXhNYXB9IGluZGV4TWFwX1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENoaWxkcmVuTm9kZShjaGlsZHJlbl8sIHByaW9yaXR5Tm9kZV8sIGluZGV4TWFwXykge1xuICAgICAgICB0aGlzLmNoaWxkcmVuXyA9IGNoaWxkcmVuXztcbiAgICAgICAgdGhpcy5wcmlvcml0eU5vZGVfID0gcHJpb3JpdHlOb2RlXztcbiAgICAgICAgdGhpcy5pbmRleE1hcF8gPSBpbmRleE1hcF87XG4gICAgICAgIHRoaXMubGF6eUhhc2hfID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdGU6IFRoZSBvbmx5IHJlYXNvbiB3ZSBhbGxvdyBudWxsIHByaW9yaXR5IGlzIGZvciBFTVBUWV9OT0RFLCBzaW5jZSB3ZSBjYW4ndCB1c2VcbiAgICAgICAgICogRU1QVFlfTk9ERSBhcyB0aGUgcHJpb3JpdHkgb2YgRU1QVFlfTk9ERS4gIFdlIG1pZ2h0IHdhbnQgdG8gY29uc2lkZXIgbWFraW5nIEVNUFRZX05PREUgaXRzIG93blxuICAgICAgICAgKiBjbGFzcyBpbnN0ZWFkIG9mIGFuIGVtcHR5IENoaWxkcmVuTm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLnByaW9yaXR5Tm9kZV8pIHtcbiAgICAgICAgICAgIHZhbGlkYXRlUHJpb3JpdHlOb2RlKHRoaXMucHJpb3JpdHlOb2RlXyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5fLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgYXNzZXJ0KCF0aGlzLnByaW9yaXR5Tm9kZV8gfHwgdGhpcy5wcmlvcml0eU5vZGVfLmlzRW1wdHkoKSwgJ0FuIGVtcHR5IG5vZGUgY2Fubm90IGhhdmUgYSBwcmlvcml0eScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGlsZHJlbk5vZGUsIFwiRU1QVFlfTk9ERVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIChFTVBUWV9OT0RFIHx8XG4gICAgICAgICAgICAgICAgKEVNUFRZX05PREUgPSBuZXcgQ2hpbGRyZW5Ob2RlKG5ldyBTb3J0ZWRNYXAoTkFNRV9DT01QQVJBVE9SKSwgbnVsbCwgSW5kZXhNYXAuRGVmYXVsdCkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5pc0xlYWZOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLmdldFByaW9yaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmlvcml0eU5vZGVfIHx8IEVNUFRZX05PREU7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLnVwZGF0ZVByaW9yaXR5ID0gZnVuY3Rpb24gKG5ld1ByaW9yaXR5Tm9kZSkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbl8uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBhbGxvdyBwcmlvcml0aWVzIG9uIGVtcHR5IG5vZGVzXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKHRoaXMuY2hpbGRyZW5fLCBuZXdQcmlvcml0eU5vZGUsIHRoaXMuaW5kZXhNYXBfKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5nZXRJbW1lZGlhdGVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgLy8gSGFjayB0byB0cmVhdCBwcmlvcml0eSBhcyBhIHJlZ3VsYXIgY2hpbGRcbiAgICAgICAgaWYgKGNoaWxkTmFtZSA9PT0gJy5wcmlvcml0eScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFByaW9yaXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuXy5nZXQoY2hpbGROYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZCA9PT0gbnVsbCA/IEVNUFRZX05PREUgOiBjaGlsZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBmcm9udCA9IHBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgaWYgKGZyb250ID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEltbWVkaWF0ZUNoaWxkKGZyb250KS5nZXRDaGlsZChwYXRoLnBvcEZyb250KCkpO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5oYXNDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmdldChjaGlsZE5hbWUpICE9PSBudWxsO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS51cGRhdGVJbW1lZGlhdGVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUsIG5ld0NoaWxkTm9kZSkge1xuICAgICAgICBhc3NlcnQobmV3Q2hpbGROb2RlLCAnV2Ugc2hvdWxkIGFsd2F5cyBiZSBwYXNzaW5nIHNuYXBzaG90IG5vZGVzJyk7XG4gICAgICAgIGlmIChjaGlsZE5hbWUgPT09ICcucHJpb3JpdHknKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVQcmlvcml0eShuZXdDaGlsZE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5hbWVkTm9kZSA9IG5ldyBOYW1lZE5vZGUoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpO1xuICAgICAgICAgICAgdmFyIG5ld0NoaWxkcmVuID0gdm9pZCAwLCBuZXdJbmRleE1hcCA9IHZvaWQgMCwgbmV3UHJpb3JpdHkgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGROb2RlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbl8ucmVtb3ZlKGNoaWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgbmV3SW5kZXhNYXAgPSB0aGlzLmluZGV4TWFwXy5yZW1vdmVGcm9tSW5kZXhlcyhuYW1lZE5vZGUsIHRoaXMuY2hpbGRyZW5fKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbl8uaW5zZXJ0KGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICBuZXdJbmRleE1hcCA9IHRoaXMuaW5kZXhNYXBfLmFkZFRvSW5kZXhlcyhuYW1lZE5vZGUsIHRoaXMuY2hpbGRyZW5fKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1ByaW9yaXR5ID0gbmV3Q2hpbGRyZW4uaXNFbXB0eSgpID8gRU1QVFlfTk9ERSA6IHRoaXMucHJpb3JpdHlOb2RlXztcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKG5ld0NoaWxkcmVuLCBuZXdQcmlvcml0eSwgbmV3SW5kZXhNYXApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLnVwZGF0ZUNoaWxkID0gZnVuY3Rpb24gKHBhdGgsIG5ld0NoaWxkTm9kZSkge1xuICAgICAgICB2YXIgZnJvbnQgPSBwYXRoLmdldEZyb250KCk7XG4gICAgICAgIGlmIChmcm9udCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkTm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydChwYXRoLmdldEZyb250KCkgIT09ICcucHJpb3JpdHknIHx8IHBhdGguZ2V0TGVuZ3RoKCkgPT09IDEsICcucHJpb3JpdHkgbXVzdCBiZSB0aGUgbGFzdCB0b2tlbiBpbiBhIHBhdGgnKTtcbiAgICAgICAgICAgIHZhciBuZXdJbW1lZGlhdGVDaGlsZCA9IHRoaXMuZ2V0SW1tZWRpYXRlQ2hpbGQoZnJvbnQpLnVwZGF0ZUNoaWxkKHBhdGgucG9wRnJvbnQoKSwgbmV3Q2hpbGROb2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGZyb250LCBuZXdJbW1lZGlhdGVDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmlzRW1wdHkoKTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUubnVtQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXy5jb3VudCgpO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS52YWwgPSBmdW5jdGlvbiAoZXhwb3J0Rm9ybWF0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgIHZhciBudW1LZXlzID0gMCwgbWF4S2V5ID0gMCwgYWxsSW50ZWdlcktleXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgZnVuY3Rpb24gKGtleSwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IGNoaWxkTm9kZS52YWwoZXhwb3J0Rm9ybWF0KTtcbiAgICAgICAgICAgIG51bUtleXMrKztcbiAgICAgICAgICAgIGlmIChhbGxJbnRlZ2VyS2V5cyAmJiBDaGlsZHJlbk5vZGUuSU5URUdFUl9SRUdFWFBfLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIG1heEtleSA9IE1hdGgubWF4KG1heEtleSwgTnVtYmVyKGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxsSW50ZWdlcktleXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZXhwb3J0Rm9ybWF0ICYmIGFsbEludGVnZXJLZXlzICYmIG1heEtleSA8IDIgKiBudW1LZXlzKSB7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRvIGFycmF5LlxuICAgICAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICAgICAgICAgIGFycmF5W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChleHBvcnRGb3JtYXQgJiYgIXRoaXMuZ2V0UHJpb3JpdHkoKS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBvYmpbJy5wcmlvcml0eSddID0gdGhpcy5nZXRQcmlvcml0eSgpLnZhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5sYXp5SGFzaF8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB0b0hhc2hfMSA9ICcnO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpKVxuICAgICAgICAgICAgICAgIHRvSGFzaF8xICs9XG4gICAgICAgICAgICAgICAgICAgICdwcmlvcml0eTonICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5SGFzaFRleHQodGhpcy5nZXRQcmlvcml0eSgpLnZhbCgpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnOic7XG4gICAgICAgICAgICB0aGlzLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgZnVuY3Rpb24gKGtleSwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkSGFzaCA9IGNoaWxkTm9kZS5oYXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkSGFzaCAhPT0gJycpXG4gICAgICAgICAgICAgICAgICAgIHRvSGFzaF8xICs9ICc6JyArIGtleSArICc6JyArIGNoaWxkSGFzaDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSB0b0hhc2hfMSA9PT0gJycgPyAnJyA6IHNoYTEodG9IYXNoXzEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhenlIYXNoXztcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUuZ2V0UHJlZGVjZXNzb3JDaGlsZE5hbWUgPSBmdW5jdGlvbiAoY2hpbGROYW1lLCBjaGlsZE5vZGUsIGluZGV4KSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXgpO1xuICAgICAgICBpZiAoaWR4KSB7XG4gICAgICAgICAgICB2YXIgcHJlZGVjZXNzb3IgPSBpZHguZ2V0UHJlZGVjZXNzb3JLZXkobmV3IE5hbWVkTm9kZShjaGlsZE5hbWUsIGNoaWxkTm9kZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHByZWRlY2Vzc29yID8gcHJlZGVjZXNzb3IubmFtZSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uZ2V0UHJlZGVjZXNzb3JLZXkoY2hpbGROYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4RGVmaW5pdGlvblxuICAgICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAgICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5nZXRGaXJzdENoaWxkTmFtZSA9IGZ1bmN0aW9uIChpbmRleERlZmluaXRpb24pIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xuICAgICAgICBpZiAoaWR4KSB7XG4gICAgICAgICAgICB2YXIgbWluS2V5ID0gaWR4Lm1pbktleSgpO1xuICAgICAgICAgICAgcmV0dXJuIG1pbktleSAmJiBtaW5LZXkubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXy5taW5LZXkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4RGVmaW5pdGlvblxuICAgICAqIEByZXR1cm4gez9OYW1lZE5vZGV9XG4gICAgICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5nZXRGaXJzdENoaWxkID0gZnVuY3Rpb24gKGluZGV4RGVmaW5pdGlvbikge1xuICAgICAgICB2YXIgbWluS2V5ID0gdGhpcy5nZXRGaXJzdENoaWxkTmFtZShpbmRleERlZmluaXRpb24pO1xuICAgICAgICBpZiAobWluS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShtaW5LZXksIHRoaXMuY2hpbGRyZW5fLmdldChtaW5LZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBpbmRleCwgcmV0dXJuIHRoZSBrZXkgbmFtZSBvZiB0aGUgbGFyZ2VzdCB2YWx1ZSB3ZSBoYXZlLCBhY2NvcmRpbmcgdG8gdGhhdCBpbmRleFxuICAgICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleERlZmluaXRpb25cbiAgICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUuZ2V0TGFzdENoaWxkTmFtZSA9IGZ1bmN0aW9uIChpbmRleERlZmluaXRpb24pIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xuICAgICAgICBpZiAoaWR4KSB7XG4gICAgICAgICAgICB2YXIgbWF4S2V5ID0gaWR4Lm1heEtleSgpO1xuICAgICAgICAgICAgcmV0dXJuIG1heEtleSAmJiBtYXhLZXkubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXy5tYXhLZXkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4RGVmaW5pdGlvblxuICAgICAqIEByZXR1cm4gez9OYW1lZE5vZGV9XG4gICAgICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5nZXRMYXN0Q2hpbGQgPSBmdW5jdGlvbiAoaW5kZXhEZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciBtYXhLZXkgPSB0aGlzLmdldExhc3RDaGlsZE5hbWUoaW5kZXhEZWZpbml0aW9uKTtcbiAgICAgICAgaWYgKG1heEtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobWF4S2V5LCB0aGlzLmNoaWxkcmVuXy5nZXQobWF4S2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLmZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIChpbmRleCwgYWN0aW9uKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXgpO1xuICAgICAgICBpZiAoaWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gaWR4Lmlub3JkZXJUcmF2ZXJzYWwoZnVuY3Rpb24gKHdyYXBwZWROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbih3cmFwcGVkTm9kZS5uYW1lLCB3cmFwcGVkTm9kZS5ub2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4RGVmaW5pdGlvblxuICAgICAqIEByZXR1cm4ge1NvcnRlZE1hcEl0ZXJhdG9yfVxuICAgICAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbiAoaW5kZXhEZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEl0ZXJhdG9yRnJvbShpbmRleERlZmluaXRpb24ubWluUG9zdCgpLCBpbmRleERlZmluaXRpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFOYW1lZE5vZGV9IHN0YXJ0UG9zdFxuICAgICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleERlZmluaXRpb25cbiAgICAgKiBAcmV0dXJuIHshU29ydGVkTWFwSXRlcmF0b3J9XG4gICAgICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5nZXRJdGVyYXRvckZyb20gPSBmdW5jdGlvbiAoc3RhcnRQb3N0LCBpbmRleERlZmluaXRpb24pIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xuICAgICAgICBpZiAoaWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gaWR4LmdldEl0ZXJhdG9yRnJvbShzdGFydFBvc3QsIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLmNoaWxkcmVuXy5nZXRJdGVyYXRvckZyb20oc3RhcnRQb3N0Lm5hbWUsIE5hbWVkTm9kZS5XcmFwKTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQgIT0gbnVsbCAmJiBpbmRleERlZmluaXRpb24uY29tcGFyZShuZXh0LCBzdGFydFBvc3QpIDwgMCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmdldE5leHQoKTtcbiAgICAgICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhEZWZpbml0aW9uXG4gICAgICogQHJldHVybiB7IVNvcnRlZE1hcEl0ZXJhdG9yfVxuICAgICAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUuZ2V0UmV2ZXJzZUl0ZXJhdG9yID0gZnVuY3Rpb24gKGluZGV4RGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGluZGV4RGVmaW5pdGlvbi5tYXhQb3N0KCksIGluZGV4RGVmaW5pdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFOYW1lZE5vZGV9IGVuZFBvc3RcbiAgICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhEZWZpbml0aW9uXG4gICAgICogQHJldHVybiB7IVNvcnRlZE1hcEl0ZXJhdG9yfVxuICAgICAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUuZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbSA9IGZ1bmN0aW9uIChlbmRQb3N0LCBpbmRleERlZmluaXRpb24pIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xuICAgICAgICBpZiAoaWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gaWR4LmdldFJldmVyc2VJdGVyYXRvckZyb20oZW5kUG9zdCwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuY2hpbGRyZW5fLmdldFJldmVyc2VJdGVyYXRvckZyb20oZW5kUG9zdC5uYW1lLCBOYW1lZE5vZGUuV3JhcCk7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGl0ZXJhdG9yLnBlZWsoKTtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICE9IG51bGwgJiYgaW5kZXhEZWZpbml0aW9uLmNvbXBhcmUobmV4dCwgZW5kUG9zdCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvci5wZWVrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBpZiAob3RoZXIuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIuaXNMZWFmTm9kZSgpIHx8IG90aGVyLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIgPT09IE1BWF9OT0RFKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNdXN0IGJlIGFub3RoZXIgbm9kZSB3aXRoIGNoaWxkcmVuLlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS53aXRoSW5kZXggPSBmdW5jdGlvbiAoaW5kZXhEZWZpbml0aW9uKSB7XG4gICAgICAgIGlmIChpbmRleERlZmluaXRpb24gPT09IEtFWV9JTkRFWCB8fFxuICAgICAgICAgICAgdGhpcy5pbmRleE1hcF8uaGFzSW5kZXgoaW5kZXhEZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmV3SW5kZXhNYXAgPSB0aGlzLmluZGV4TWFwXy5hZGRJbmRleChpbmRleERlZmluaXRpb24sIHRoaXMuY2hpbGRyZW5fKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKHRoaXMuY2hpbGRyZW5fLCB0aGlzLnByaW9yaXR5Tm9kZV8sIG5ld0luZGV4TWFwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLmlzSW5kZXhlZCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXggPT09IEtFWV9JTkRFWCB8fCB0aGlzLmluZGV4TWFwXy5oYXNJbmRleChpbmRleCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIuaXNMZWFmTm9kZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJDaGlsZHJlbk5vZGUgPSBvdGhlcjtcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRQcmlvcml0eSgpLmVxdWFscyhvdGhlckNoaWxkcmVuTm9kZS5nZXRQcmlvcml0eSgpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2hpbGRyZW5fLmNvdW50KCkgPT09IG90aGVyQ2hpbGRyZW5Ob2RlLmNoaWxkcmVuXy5jb3VudCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoaXNJdGVyID0gdGhpcy5nZXRJdGVyYXRvcihQUklPUklUWV9JTkRFWCk7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVySXRlciA9IG90aGVyQ2hpbGRyZW5Ob2RlLmdldEl0ZXJhdG9yKFBSSU9SSVRZX0lOREVYKTtcbiAgICAgICAgICAgICAgICB2YXIgdGhpc0N1cnJlbnQgPSB0aGlzSXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyQ3VycmVudCA9IG90aGVySXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXNDdXJyZW50ICYmIG90aGVyQ3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc0N1cnJlbnQubmFtZSAhPT0gb3RoZXJDdXJyZW50Lm5hbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzQ3VycmVudC5ub2RlLmVxdWFscyhvdGhlckN1cnJlbnQubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzQ3VycmVudCA9IHRoaXNJdGVyLmdldE5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJDdXJyZW50ID0gb3RoZXJJdGVyLmdldE5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNDdXJyZW50ID09PSBudWxsICYmIG90aGVyQ3VycmVudCA9PT0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFNvcnRlZE1hcCBvcmRlcmVkIGJ5IGluZGV4LCBvciBudWxsIGlmIHRoZSBkZWZhdWx0IChieS1rZXkpIG9yZGVyaW5nIGNhbiBiZSB1c2VkXG4gICAgICogaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4RGVmaW5pdGlvblxuICAgICAqIEByZXR1cm4gez9Tb3J0ZWRNYXAuPE5hbWVkTm9kZSwgTm9kZT59XG4gICAgICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5yZXNvbHZlSW5kZXhfID0gZnVuY3Rpb24gKGluZGV4RGVmaW5pdGlvbikge1xuICAgICAgICBpZiAoaW5kZXhEZWZpbml0aW9uID09PSBLRVlfSU5ERVgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYXBfLmdldChpbmRleERlZmluaXRpb24udG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgKi9cbiAgICBDaGlsZHJlbk5vZGUuSU5URUdFUl9SRUdFWFBfID0gL14oMHxbMS05XVxcZCopJC87XG4gICAgcmV0dXJuIENoaWxkcmVuTm9kZTtcbn0oKSk7XG5leHBvcnQgeyBDaGlsZHJlbk5vZGUgfTtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7Q2hpbGRyZW5Ob2RlfVxuICogQHByaXZhdGVcbiAqL1xudmFyIE1heE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1heE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF4Tm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5ldyBTb3J0ZWRNYXAoTkFNRV9DT01QQVJBVE9SKSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUsIEluZGV4TWFwLkRlZmF1bHQpIHx8IHRoaXM7XG4gICAgfVxuICAgIE1heE5vZGUucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1heE5vZGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAvLyBOb3QgdGhhdCB3ZSBldmVyeSBjb21wYXJlIGl0LCBidXQgTUFYX05PREUgaXMgb25seSBldmVyIGVxdWFsIHRvIGl0c2VsZlxuICAgICAgICByZXR1cm4gb3RoZXIgPT09IHRoaXM7XG4gICAgfTtcbiAgICBNYXhOb2RlLnByb3RvdHlwZS5nZXRQcmlvcml0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNYXhOb2RlLnByb3RvdHlwZS5nZXRJbW1lZGlhdGVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgIH07XG4gICAgTWF4Tm9kZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIE1heE5vZGU7XG59KENoaWxkcmVuTm9kZSkpO1xuZXhwb3J0IHsgTWF4Tm9kZSB9O1xuLyoqXG4gKiBNYXJrZXIgdGhhdCB3aWxsIHNvcnQgaGlnaGVyIHRoYW4gYW55IG90aGVyIHNuYXBzaG90LlxuICogQHR5cGUgeyFNQVhfTk9ERX1cbiAqIEBjb25zdFxuICovXG5leHBvcnQgdmFyIE1BWF9OT0RFID0gbmV3IE1heE5vZGUoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE5hbWVkTm9kZSwge1xuICAgIE1JTjoge1xuICAgICAgICB2YWx1ZTogbmV3IE5hbWVkTm9kZShNSU5fTkFNRSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpXG4gICAgfSxcbiAgICBNQVg6IHtcbiAgICAgICAgdmFsdWU6IG5ldyBOYW1lZE5vZGUoTUFYX05BTUUsIE1BWF9OT0RFKVxuICAgIH1cbn0pO1xuLyoqXG4gKiBSZWZlcmVuY2UgRXh0ZW5zaW9uc1xuICovXG5LZXlJbmRleC5fX0VNUFRZX05PREUgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbkxlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IgPSBDaGlsZHJlbk5vZGU7XG5zZXRNYXhOb2RlKE1BWF9OT0RFKTtcbnNldFByaW9yaXR5TWF4Tm9kZShNQVhfTk9ERSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvc25hcC9DaGlsZHJlbk5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVxuICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3RydWN0XG4gKi9cbnZhciBOYW1lZE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmFtZWROb2RlKG5hbWUsIG5vZGUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHJldHVybiB7TmFtZWROb2RlfVxuICAgICAqL1xuICAgIE5hbWVkTm9kZS5XcmFwID0gZnVuY3Rpb24gKG5hbWUsIG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobmFtZSwgbm9kZSk7XG4gICAgfTtcbiAgICByZXR1cm4gTmFtZWROb2RlO1xufSgpKTtcbmV4cG9ydCB7IE5hbWVkTm9kZSB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3NuYXAvTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE2IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZykpO1xuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jbGFzc25hbWVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG4vKipcbiAqXG4gKiBAZW51bVxuICovXG5leHBvcnQgdmFyIE9wZXJhdGlvblR5cGU7XG4oZnVuY3Rpb24gKE9wZXJhdGlvblR5cGUpIHtcbiAgICBPcGVyYXRpb25UeXBlW09wZXJhdGlvblR5cGVbXCJPVkVSV1JJVEVcIl0gPSAwXSA9IFwiT1ZFUldSSVRFXCI7XG4gICAgT3BlcmF0aW9uVHlwZVtPcGVyYXRpb25UeXBlW1wiTUVSR0VcIl0gPSAxXSA9IFwiTUVSR0VcIjtcbiAgICBPcGVyYXRpb25UeXBlW09wZXJhdGlvblR5cGVbXCJBQ0tfVVNFUl9XUklURVwiXSA9IDJdID0gXCJBQ0tfVVNFUl9XUklURVwiO1xuICAgIE9wZXJhdGlvblR5cGVbT3BlcmF0aW9uVHlwZVtcIkxJU1RFTl9DT01QTEVURVwiXSA9IDNdID0gXCJMSVNURU5fQ09NUExFVEVcIjtcbn0pKE9wZXJhdGlvblR5cGUgPSBPcGVyYXRpb25UeXBlIHx8IChPcGVyYXRpb25UeXBlID0ge30pKTtcbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBmcm9tVXNlclxuICogQHBhcmFtIHtib29sZWFufSBmcm9tU2VydmVyXG4gKiBAcGFyYW0gez9zdHJpbmd9IHF1ZXJ5SWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdGFnZ2VkXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE9wZXJhdGlvblNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcGVyYXRpb25Tb3VyY2UoZnJvbVVzZXIsIGZyb21TZXJ2ZXIsIHF1ZXJ5SWQsIHRhZ2dlZCkge1xuICAgICAgICB0aGlzLmZyb21Vc2VyID0gZnJvbVVzZXI7XG4gICAgICAgIHRoaXMuZnJvbVNlcnZlciA9IGZyb21TZXJ2ZXI7XG4gICAgICAgIHRoaXMucXVlcnlJZCA9IHF1ZXJ5SWQ7XG4gICAgICAgIHRoaXMudGFnZ2VkID0gdGFnZ2VkO1xuICAgICAgICBhc3NlcnQoIXRhZ2dlZCB8fCBmcm9tU2VydmVyLCAnVGFnZ2VkIHF1ZXJpZXMgbXVzdCBiZSBmcm9tIHNlcnZlci4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUgeyFPcGVyYXRpb25Tb3VyY2V9XG4gICAgICovXG4gICAgT3BlcmF0aW9uU291cmNlLlVzZXIgPSBuZXcgT3BlcmF0aW9uU291cmNlKFxuICAgIC8qZnJvbVVzZXI9Ki8gdHJ1ZSwgZmFsc2UsIG51bGwsIFxuICAgIC8qdGFnZ2VkPSovIGZhbHNlKTtcbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7IU9wZXJhdGlvblNvdXJjZX1cbiAgICAgKi9cbiAgICBPcGVyYXRpb25Tb3VyY2UuU2VydmVyID0gbmV3IE9wZXJhdGlvblNvdXJjZShmYWxzZSwgXG4gICAgLypmcm9tU2VydmVyPSovIHRydWUsIG51bGwsIFxuICAgIC8qdGFnZ2VkPSovIGZhbHNlKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnlJZFxuICAgICAqIEByZXR1cm4geyFPcGVyYXRpb25Tb3VyY2V9XG4gICAgICovXG4gICAgT3BlcmF0aW9uU291cmNlLmZvclNlcnZlclRhZ2dlZFF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPcGVyYXRpb25Tb3VyY2UoZmFsc2UsIFxuICAgICAgICAvKmZyb21TZXJ2ZXI9Ki8gdHJ1ZSwgcXVlcnlJZCwgXG4gICAgICAgIC8qdGFnZ2VkPSovIHRydWUpO1xuICAgIH07XG4gICAgcmV0dXJuIE9wZXJhdGlvblNvdXJjZTtcbn0oKSk7XG5leHBvcnQgeyBPcGVyYXRpb25Tb3VyY2UgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9vcGVyYXRpb24vT3BlcmF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBQYXRoLCBWYWxpZGF0aW9uUGF0aCB9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgeyBmb3JFYWNoLCBjb250YWlucywgc2FmZUdldCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IGlzSW52YWxpZEpTT05OdW1iZXIgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgZXJyb3JQcmVmaXggYXMgZXJyb3JQcmVmaXhGeG4gfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBzdHJpbmdMZW5ndGggfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG4vKipcbiAqIFRydWUgZm9yIGludmFsaWQgRmlyZWJhc2Uga2V5c1xuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCB2YXIgSU5WQUxJRF9LRVlfUkVHRVhfID0gL1tcXFtcXF0uIyRcXC9cXHUwMDAwLVxcdTAwMUZcXHUwMDdGXS87XG4vKipcbiAqIFRydWUgZm9yIGludmFsaWQgRmlyZWJhc2UgcGF0aHMuXG4gKiBBbGxvd3MgJy8nIGluIHBhdGhzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCB2YXIgSU5WQUxJRF9QQVRIX1JFR0VYXyA9IC9bXFxbXFxdLiMkXFx1MDAwMC1cXHUwMDFGXFx1MDA3Rl0vO1xuLyoqXG4gKiBNYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIGFsbG93IGluIGxlYWYgdmFsdWVcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgdmFyIE1BWF9MRUFGX1NJWkVfID0gMTAgKiAxMDI0ICogMTAyNDtcbi8qKlxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCB2YXIgaXNWYWxpZEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5sZW5ndGggIT09IDAgJiYgIUlOVkFMSURfS0VZX1JFR0VYXy50ZXN0KGtleSkpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmdcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCB2YXIgaXNWYWxpZFBhdGhTdHJpbmcgPSBmdW5jdGlvbiAocGF0aFN0cmluZykge1xuICAgIHJldHVybiAodHlwZW9mIHBhdGhTdHJpbmcgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIHBhdGhTdHJpbmcubGVuZ3RoICE9PSAwICYmXG4gICAgICAgICFJTlZBTElEX1BBVEhfUkVHRVhfLnRlc3QocGF0aFN0cmluZykpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmdcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCB2YXIgaXNWYWxpZFJvb3RQYXRoU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcbiAgICBpZiAocGF0aFN0cmluZykge1xuICAgICAgICAvLyBBbGxvdyAnLy5pbmZvLycgYXQgdGhlIGJlZ2lubmluZy5cbiAgICAgICAgcGF0aFN0cmluZyA9IHBhdGhTdHJpbmcucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sICcvJyk7XG4gICAgfVxuICAgIHJldHVybiBpc1ZhbGlkUGF0aFN0cmluZyhwYXRoU3RyaW5nKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7Kn0gcHJpb3JpdHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCB2YXIgaXNWYWxpZFByaW9yaXR5ID0gZnVuY3Rpb24gKHByaW9yaXR5KSB7XG4gICAgcmV0dXJuIChwcmlvcml0eSA9PT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2YgcHJpb3JpdHkgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICh0eXBlb2YgcHJpb3JpdHkgPT09ICdudW1iZXInICYmICFpc0ludmFsaWRKU09OTnVtYmVyKHByaW9yaXR5KSkgfHxcbiAgICAgICAgKHByaW9yaXR5ICYmIHR5cGVvZiBwcmlvcml0eSA9PT0gJ29iamVjdCcgJiYgY29udGFpbnMocHJpb3JpdHksICcuc3YnKSkpO1xufTtcbi8qKlxuICogUHJlLXZhbGlkYXRlIGEgZGF0dW0gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIEZpcmViYXNlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmd1bWVudE51bWJlclxuICogQHBhcmFtIHsqfSBkYXRhXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbmFsXG4gKi9cbmV4cG9ydCB2YXIgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgZGF0YSwgcGF0aCwgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgdmFsaWRhdGVGaXJlYmFzZURhdGEoZXJyb3JQcmVmaXhGeG4oZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpLCBkYXRhLCBwYXRoKTtcbn07XG4vKipcbiAqIFZhbGlkYXRlIGEgZGF0YSBvYmplY3QgY2xpZW50LXNpZGUgYmVmb3JlIHNlbmRpbmcgdG8gc2VydmVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlcnJvclByZWZpeFxuICogQHBhcmFtIHsqfSBkYXRhXG4gKiBAcGFyYW0geyFQYXRofCFWYWxpZGF0aW9uUGF0aH0gcGF0aF9cbiAqL1xuZXhwb3J0IHZhciB2YWxpZGF0ZUZpcmViYXNlRGF0YSA9IGZ1bmN0aW9uIChlcnJvclByZWZpeCwgZGF0YSwgcGF0aF8pIHtcbiAgICB2YXIgcGF0aCA9IHBhdGhfIGluc3RhbmNlb2YgUGF0aCA/IG5ldyBWYWxpZGF0aW9uUGF0aChwYXRoXywgZXJyb3JQcmVmaXgpIDogcGF0aF87XG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggKyAnY29udGFpbnMgdW5kZWZpbmVkICcgKyBwYXRoLnRvRXJyb3JTdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xuICAgICAgICAgICAgJ2NvbnRhaW5zIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICAgICBwYXRoLnRvRXJyb3JTdHJpbmcoKSArXG4gICAgICAgICAgICAnIHdpdGggY29udGVudHMgPSAnICtcbiAgICAgICAgICAgIGRhdGEudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmIChpc0ludmFsaWRKU09OTnVtYmVyKGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArICdjb250YWlucyAnICsgZGF0YS50b1N0cmluZygpICsgJyAnICsgcGF0aC50b0Vycm9yU3RyaW5nKCkpO1xuICAgIH1cbiAgICAvLyBDaGVjayBtYXggbGVhZiBzaXplLCBidXQgdHJ5IHRvIGF2b2lkIHRoZSB1dGY4IGNvbnZlcnNpb24gaWYgd2UgY2FuLlxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgZGF0YS5sZW5ndGggPiBNQVhfTEVBRl9TSVpFXyAvIDMgJiZcbiAgICAgICAgc3RyaW5nTGVuZ3RoKGRhdGEpID4gTUFYX0xFQUZfU0laRV8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcbiAgICAgICAgICAgICdjb250YWlucyBhIHN0cmluZyBncmVhdGVyIHRoYW4gJyArXG4gICAgICAgICAgICBNQVhfTEVBRl9TSVpFXyArXG4gICAgICAgICAgICAnIHV0ZjggYnl0ZXMgJyArXG4gICAgICAgICAgICBwYXRoLnRvRXJyb3JTdHJpbmcoKSArXG4gICAgICAgICAgICBcIiAoJ1wiICtcbiAgICAgICAgICAgIGRhdGEuc3Vic3RyaW5nKDAsIDUwKSArXG4gICAgICAgICAgICBcIi4uLicpXCIpO1xuICAgIH1cbiAgICAvLyBUT0RPID0gUGVyZiA9IENvbnNpZGVyIGNvbWJpbmluZyB0aGUgcmVjdXJzaXZlIHZhbGlkYXRpb24gb2Yga2V5cyBpbnRvIE5vZGVGcm9tSlNPTlxuICAgIC8vIHRvIHNhdmUgZXh0cmEgd2Fsa2luZyBvZiBsYXJnZSBvYmplY3RzLlxuICAgIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgaGFzRG90VmFsdWVfMSA9IGZhbHNlLCBoYXNBY3R1YWxDaGlsZF8xID0gZmFsc2U7XG4gICAgICAgIGZvckVhY2goZGF0YSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICcudmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgaGFzRG90VmFsdWVfMSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICcucHJpb3JpdHknICYmIGtleSAhPT0gJy5zdicpIHtcbiAgICAgICAgICAgICAgICBoYXNBY3R1YWxDaGlsZF8xID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyBjb250YWlucyBhbiBpbnZhbGlkIGtleSAoJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJykgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnRvRXJyb3JTdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnLiAgS2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FuZCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCIvXCIsIFwiW1wiLCBvciBcIl1cIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGgucHVzaChrZXkpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGEoZXJyb3JQcmVmaXgsIHZhbHVlLCBwYXRoKTtcbiAgICAgICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzRG90VmFsdWVfMSAmJiBoYXNBY3R1YWxDaGlsZF8xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xuICAgICAgICAgICAgICAgICcgY29udGFpbnMgXCIudmFsdWVcIiBjaGlsZCAnICtcbiAgICAgICAgICAgICAgICBwYXRoLnRvRXJyb3JTdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgJyBpbiBhZGRpdGlvbiB0byBhY3R1YWwgY2hpbGRyZW4uJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBQcmUtdmFsaWRhdGUgcGF0aHMgcGFzc2VkIGluIHRoZSBmaXJlYmFzZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXJyb3JQcmVmaXhcbiAqIEBwYXJhbSB7QXJyYXk8IVBhdGg+fSBtZXJnZVBhdGhzXG4gKi9cbmV4cG9ydCB2YXIgdmFsaWRhdGVGaXJlYmFzZU1lcmdlUGF0aHMgPSBmdW5jdGlvbiAoZXJyb3JQcmVmaXgsIG1lcmdlUGF0aHMpIHtcbiAgICB2YXIgaSwgY3VyUGF0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWVyZ2VQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJQYXRoID0gbWVyZ2VQYXRoc1tpXTtcbiAgICAgICAgdmFyIGtleXMgPSBjdXJQYXRoLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKGtleXNbal0gPT09ICcucHJpb3JpdHknICYmIGogPT09IGtleXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIC8vIC5wcmlvcml0eSBpcyBPS1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzVmFsaWRLZXkoa2V5c1tqXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xuICAgICAgICAgICAgICAgICAgICAnY29udGFpbnMgYW4gaW52YWxpZCBrZXkgKCcgK1xuICAgICAgICAgICAgICAgICAgICBrZXlzW2pdICtcbiAgICAgICAgICAgICAgICAgICAgJykgaW4gcGF0aCAnICtcbiAgICAgICAgICAgICAgICAgICAgY3VyUGF0aC50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgJy4gS2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzICcgK1xuICAgICAgICAgICAgICAgICAgICAnYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgdGhhdCB1cGRhdGUga2V5cyBhcmUgbm90IGRlc2NlbmRhbnRzIG9mIGVhY2ggb3RoZXIuXG4gICAgLy8gV2UgcmVseSBvbiB0aGUgcHJvcGVydHkgdGhhdCBzb3J0aW5nIGd1YXJhbnRlZXMgdGhhdCBhbmNlc3RvcnMgY29tZVxuICAgIC8vIHJpZ2h0IGJlZm9yZSBkZXNjZW5kYW50cy5cbiAgICBtZXJnZVBhdGhzLnNvcnQoUGF0aC5jb21wYXJlUGF0aHMpO1xuICAgIHZhciBwcmV2UGF0aCA9IG51bGw7XG4gICAgZm9yIChpID0gMDsgaSA8IG1lcmdlUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VyUGF0aCA9IG1lcmdlUGF0aHNbaV07XG4gICAgICAgIGlmIChwcmV2UGF0aCAhPT0gbnVsbCAmJiBwcmV2UGF0aC5jb250YWlucyhjdXJQYXRoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcbiAgICAgICAgICAgICAgICAnY29udGFpbnMgYSBwYXRoICcgK1xuICAgICAgICAgICAgICAgIHByZXZQYXRoLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICcgdGhhdCBpcyBhbmNlc3RvciBvZiBhbm90aGVyIHBhdGggJyArXG4gICAgICAgICAgICAgICAgY3VyUGF0aC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2UGF0aCA9IGN1clBhdGg7XG4gICAgfVxufTtcbi8qKlxuICogcHJlLXZhbGlkYXRlIGFuIG9iamVjdCBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gZmlyZWJhc2UgZnVuY3Rpb24gKFxuICogbXVzdCBiZSBhbiBvYmplY3QgLSBlLmcuIGZvciBmaXJlYmFzZS51cGRhdGUoKSkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3VtZW50TnVtYmVyXG4gKiBAcGFyYW0geyp9IGRhdGFcbiAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9uYWxcbiAqL1xuZXhwb3J0IHZhciB2YWxpZGF0ZUZpcmViYXNlTWVyZ2VEYXRhQXJnID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIGRhdGEsIHBhdGgsIG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsICYmIGRhdGEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBlcnJvclByZWZpeCA9IGVycm9yUHJlZml4RnhuKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKTtcbiAgICBpZiAoIShkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JykgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggKyAnIG11c3QgYmUgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNoaWxkcmVuIHRvIHJlcGxhY2UuJyk7XG4gICAgfVxuICAgIHZhciBtZXJnZVBhdGhzID0gW107XG4gICAgZm9yRWFjaChkYXRhLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgY3VyUGF0aCA9IG5ldyBQYXRoKGtleSk7XG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKGVycm9yUHJlZml4LCB2YWx1ZSwgcGF0aC5jaGlsZChjdXJQYXRoKSk7XG4gICAgICAgIGlmIChjdXJQYXRoLmdldEJhY2soKSA9PT0gJy5wcmlvcml0eScpIHtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZFByaW9yaXR5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXG4gICAgICAgICAgICAgICAgICAgIFwiY29udGFpbnMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgY3VyUGF0aC50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgXCInLCB3aGljaCBtdXN0IGJlIGEgdmFsaWQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAnRmlyZWJhc2UgcHJpb3JpdHkgKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwpLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1lcmdlUGF0aHMucHVzaChjdXJQYXRoKTtcbiAgICB9KTtcbiAgICB2YWxpZGF0ZUZpcmViYXNlTWVyZ2VQYXRocyhlcnJvclByZWZpeCwgbWVyZ2VQYXRocyk7XG59O1xuZXhwb3J0IHZhciB2YWxpZGF0ZVByaW9yaXR5ID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIHByaW9yaXR5LCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiBwcmlvcml0eSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGlzSW52YWxpZEpTT05OdW1iZXIocHJpb3JpdHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXhGeG4oZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICdpcyAnICtcbiAgICAgICAgICAgIHByaW9yaXR5LnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgJywgYnV0IG11c3QgYmUgYSB2YWxpZCBGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsICcgK1xuICAgICAgICAgICAgJ3NlcnZlciB2YWx1ZSwgb3IgbnVsbCkuJyk7XG4gICAgLy8gU3BlY2lhbCBjYXNlIHRvIGFsbG93IGltcG9ydGluZyBkYXRhIHdpdGggYSAuc3YuXG4gICAgaWYgKCFpc1ZhbGlkUHJpb3JpdHkocHJpb3JpdHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXhGeG4oZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICdtdXN0IGJlIGEgdmFsaWQgRmlyZWJhc2UgcHJpb3JpdHkgJyArXG4gICAgICAgICAgICAnKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwpLicpO1xufTtcbmV4cG9ydCB2YXIgdmFsaWRhdGVFdmVudFR5cGUgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgZXZlbnRUeXBlLCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiBldmVudFR5cGUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHN3aXRjaCAoZXZlbnRUeXBlKSB7XG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgY2FzZSAnY2hpbGRfYWRkZWQnOlxuICAgICAgICBjYXNlICdjaGlsZF9yZW1vdmVkJzpcbiAgICAgICAgY2FzZSAnY2hpbGRfY2hhbmdlZCc6XG4gICAgICAgIGNhc2UgJ2NoaWxkX21vdmVkJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4RnhuKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArXG4gICAgICAgICAgICAgICAgJ211c3QgYmUgYSB2YWxpZCBldmVudCB0eXBlID0gXCJ2YWx1ZVwiLCBcImNoaWxkX2FkZGVkXCIsIFwiY2hpbGRfcmVtb3ZlZFwiLCAnICtcbiAgICAgICAgICAgICAgICAnXCJjaGlsZF9jaGFuZ2VkXCIsIG9yIFwiY2hpbGRfbW92ZWRcIi4nKTtcbiAgICB9XG59O1xuZXhwb3J0IHZhciB2YWxpZGF0ZUtleSA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBrZXksIG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsICYmIGtleSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeEZ4bihmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvcHRpb25hbCkgK1xuICAgICAgICAgICAgJ3dhcyBhbiBpbnZhbGlkIGtleSA9IFwiJyArXG4gICAgICAgICAgICBrZXkgK1xuICAgICAgICAgICAgJ1wiLiAgRmlyZWJhc2Uga2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzIGFuZCAnICtcbiAgICAgICAgICAgICdjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCIvXCIsIFwiW1wiLCBvciBcIl1cIikuJyk7XG59O1xuZXhwb3J0IHZhciB2YWxpZGF0ZVBhdGhTdHJpbmcgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgcGF0aFN0cmluZywgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgcGF0aFN0cmluZyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCFpc1ZhbGlkUGF0aFN0cmluZyhwYXRoU3RyaW5nKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4RnhuKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArXG4gICAgICAgICAgICAnd2FzIGFuIGludmFsaWQgcGF0aCA9IFwiJyArXG4gICAgICAgICAgICBwYXRoU3RyaW5nICtcbiAgICAgICAgICAgICdcIi4gUGF0aHMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgJyArXG4gICAgICAgICAgICAnY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiW1wiLCBvciBcIl1cIicpO1xufTtcbmV4cG9ydCB2YXIgdmFsaWRhdGVSb290UGF0aFN0cmluZyA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBwYXRoU3RyaW5nLCBvcHRpb25hbCkge1xuICAgIGlmIChwYXRoU3RyaW5nKSB7XG4gICAgICAgIC8vIEFsbG93ICcvLmluZm8vJyBhdCB0aGUgYmVnaW5uaW5nLlxuICAgICAgICBwYXRoU3RyaW5nID0gcGF0aFN0cmluZy5yZXBsYWNlKC9eXFwvKlxcLmluZm8oXFwvfCQpLywgJy8nKTtcbiAgICB9XG4gICAgdmFsaWRhdGVQYXRoU3RyaW5nKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIHBhdGhTdHJpbmcsIG9wdGlvbmFsKTtcbn07XG5leHBvcnQgdmFyIHZhbGlkYXRlV3JpdGFibGVQYXRoID0gZnVuY3Rpb24gKGZuTmFtZSwgcGF0aCkge1xuICAgIGlmIChwYXRoLmdldEZyb250KCkgPT09ICcuaW5mbycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZuTmFtZSArIFwiIGZhaWxlZCA9IENhbid0IG1vZGlmeSBkYXRhIHVuZGVyIC8uaW5mby9cIik7XG4gICAgfVxufTtcbmV4cG9ydCB2YXIgdmFsaWRhdGVVcmwgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgcGFyc2VkVXJsKSB7XG4gICAgLy8gVE9ETyA9IFZhbGlkYXRlIHNlcnZlciBiZXR0ZXIuXG4gICAgdmFyIHBhdGhTdHJpbmcgPSBwYXJzZWRVcmwucGF0aC50b1N0cmluZygpO1xuICAgIGlmICghKHR5cGVvZiBwYXJzZWRVcmwucmVwb0luZm8uaG9zdCA9PT0gJ3N0cmluZycpIHx8XG4gICAgICAgIHBhcnNlZFVybC5yZXBvSW5mby5ob3N0Lmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAhaXNWYWxpZEtleShwYXJzZWRVcmwucmVwb0luZm8ubmFtZXNwYWNlKSB8fFxuICAgICAgICAocGF0aFN0cmluZy5sZW5ndGggIT09IDAgJiYgIWlzVmFsaWRSb290UGF0aFN0cmluZyhwYXRoU3RyaW5nKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4RnhuKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIGZhbHNlKSArXG4gICAgICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIGZpcmViYXNlIFVSTCBhbmQgJyArXG4gICAgICAgICAgICAndGhlIHBhdGggY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiW1wiLCBvciBcIl1cIi4nKTtcbiAgICB9XG59O1xuZXhwb3J0IHZhciB2YWxpZGF0ZUNyZWRlbnRpYWwgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgY3JlZCwgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgY3JlZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCEodHlwZW9mIGNyZWQgPT09ICdzdHJpbmcnKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4RnhuKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArXG4gICAgICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIGNyZWRlbnRpYWwgKGEgc3RyaW5nKS4nKTtcbn07XG5leHBvcnQgdmFyIHZhbGlkYXRlQm9vbGVhbiA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBib29sLCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiBib29sID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIGJvb2wgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4RnhuKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArICdtdXN0IGJlIGEgYm9vbGVhbi4nKTtcbn07XG5leHBvcnQgdmFyIHZhbGlkYXRlU3RyaW5nID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIHN0cmluZywgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgc3RyaW5nID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoISh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4RnhuKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArXG4gICAgICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIHN0cmluZy4nKTtcbiAgICB9XG59O1xuZXhwb3J0IHZhciB2YWxpZGF0ZU9iamVjdCA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvYmosIG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsICYmIG9iaiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCEob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4RnhuKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArXG4gICAgICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIG9iamVjdC4nKTtcbiAgICB9XG59O1xuZXhwb3J0IHZhciB2YWxpZGF0ZU9iamVjdENvbnRhaW5zS2V5ID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9iaiwga2V5LCBvcHRpb25hbCwgb3B0X3R5cGUpIHtcbiAgICB2YXIgb2JqZWN0Q29udGFpbnNLZXkgPSBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgY29udGFpbnMob2JqLCBrZXkpO1xuICAgIGlmICghb2JqZWN0Q29udGFpbnNLZXkpIHtcbiAgICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXhGeG4oZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICAgICAnbXVzdCBjb250YWluIHRoZSBrZXkgXCInICtcbiAgICAgICAgICAgICAgICBrZXkgK1xuICAgICAgICAgICAgICAgICdcIicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRfdHlwZSkge1xuICAgICAgICB2YXIgdmFsID0gc2FmZUdldChvYmosIGtleSk7XG4gICAgICAgIGlmICgob3B0X3R5cGUgPT09ICdudW1iZXInICYmICEodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpKSB8fFxuICAgICAgICAgICAgKG9wdF90eXBlID09PSAnc3RyaW5nJyAmJiAhKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSkgfHxcbiAgICAgICAgICAgIChvcHRfdHlwZSA9PT0gJ2Jvb2xlYW4nICYmICEodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSkgfHxcbiAgICAgICAgICAgIChvcHRfdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB8fFxuICAgICAgICAgICAgKG9wdF90eXBlID09PSAnb2JqZWN0JyAmJiAhKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSAmJiB2YWwpKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXhGeG4oZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICAgICAgICAgJ2NvbnRhaW5zIGludmFsaWQgdmFsdWUgZm9yIGtleSBcIicgK1xuICAgICAgICAgICAgICAgICAgICBrZXkgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgKG11c3QgYmUgb2YgdHlwZSBcIicgK1xuICAgICAgICAgICAgICAgICAgICBvcHRfdHlwZSArXG4gICAgICAgICAgICAgICAgICAgICdcIiknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeEZ4bihmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvcHRpb25hbCkgK1xuICAgICAgICAgICAgICAgICAgICAnbXVzdCBjb250YWluIHRoZSBrZXkgXCInICtcbiAgICAgICAgICAgICAgICAgICAga2V5ICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIHdpdGggdHlwZSBcIicgK1xuICAgICAgICAgICAgICAgICAgICBvcHRfdHlwZSArXG4gICAgICAgICAgICAgICAgICAgICdcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS91dGlsL3ZhbGlkYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbnJlcXVpcmUoJ0BmaXJlYmFzZS9wb2x5ZmlsbCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdAZmlyZWJhc2UvYXBwJykuZGVmYXVsdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9maXJlYmFzZS9hcHAvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHN0cnVjdFxuICogQHBhcmFtIHshc3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlXG4gKiBAcGFyYW0geyFOb2RlfSBzbmFwc2hvdE5vZGUgVGhlIGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nPX0gY2hpbGROYW1lIFRoZSBuYW1lIGZvciB0aGlzIGNoaWxkLCBpZiBpdCdzIGEgY2hpbGQgZXZlbnRcbiAqIEBwYXJhbSB7Tm9kZT19IG9sZFNuYXAgVXNlZCBmb3IgaW50ZXJtZWRpYXRlIHByb2Nlc3Npbmcgb2YgY2hpbGQgY2hhbmdlZCBldmVudHNcbiAqIEBwYXJhbSB7c3RyaW5nPX0gcHJldk5hbWUgVGhlIG5hbWUgZm9yIHRoZSBwcmV2aW91cyBjaGlsZCwgaWYgYXBwbGljYWJsZVxuICovXG52YXIgQ2hhbmdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYW5nZSh0eXBlLCBzbmFwc2hvdE5vZGUsIGNoaWxkTmFtZSwgb2xkU25hcCwgcHJldk5hbWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zbmFwc2hvdE5vZGUgPSBzbmFwc2hvdE5vZGU7XG4gICAgICAgIHRoaXMuY2hpbGROYW1lID0gY2hpbGROYW1lO1xuICAgICAgICB0aGlzLm9sZFNuYXAgPSBvbGRTbmFwO1xuICAgICAgICB0aGlzLnByZXZOYW1lID0gcHJldk5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IHNuYXBzaG90XG4gICAgICogQHJldHVybiB7IUNoYW5nZX1cbiAgICAgKi9cbiAgICBDaGFuZ2UudmFsdWVDaGFuZ2UgPSBmdW5jdGlvbiAoc25hcHNob3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2UoQ2hhbmdlLlZBTFVFLCBzbmFwc2hvdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hpbGRLZXlcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBzbmFwc2hvdFxuICAgICAqIEByZXR1cm4geyFDaGFuZ2V9XG4gICAgICovXG4gICAgQ2hhbmdlLmNoaWxkQWRkZWRDaGFuZ2UgPSBmdW5jdGlvbiAoY2hpbGRLZXksIHNuYXBzaG90KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlKENoYW5nZS5DSElMRF9BRERFRCwgc25hcHNob3QsIGNoaWxkS2V5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZEtleVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IHNuYXBzaG90XG4gICAgICogQHJldHVybiB7IUNoYW5nZX1cbiAgICAgKi9cbiAgICBDaGFuZ2UuY2hpbGRSZW1vdmVkQ2hhbmdlID0gZnVuY3Rpb24gKGNoaWxkS2V5LCBzbmFwc2hvdCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZShDaGFuZ2UuQ0hJTERfUkVNT1ZFRCwgc25hcHNob3QsIGNoaWxkS2V5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZEtleVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5ld1NuYXBzaG90XG4gICAgICogQHBhcmFtIHshTm9kZX0gb2xkU25hcHNob3RcbiAgICAgKiBAcmV0dXJuIHshQ2hhbmdlfVxuICAgICAqL1xuICAgIENoYW5nZS5jaGlsZENoYW5nZWRDaGFuZ2UgPSBmdW5jdGlvbiAoY2hpbGRLZXksIG5ld1NuYXBzaG90LCBvbGRTbmFwc2hvdCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZShDaGFuZ2UuQ0hJTERfQ0hBTkdFRCwgbmV3U25hcHNob3QsIGNoaWxkS2V5LCBvbGRTbmFwc2hvdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hpbGRLZXlcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBzbmFwc2hvdFxuICAgICAqIEByZXR1cm4geyFDaGFuZ2V9XG4gICAgICovXG4gICAgQ2hhbmdlLmNoaWxkTW92ZWRDaGFuZ2UgPSBmdW5jdGlvbiAoY2hpbGRLZXksIHNuYXBzaG90KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlKENoYW5nZS5DSElMRF9NT1ZFRCwgc25hcHNob3QsIGNoaWxkS2V5KTtcbiAgICB9O1xuICAgIC8vZXZlbnQgdHlwZXNcbiAgICAvKiogRXZlbnQgdHlwZSBmb3IgYSBjaGlsZCBhZGRlZCAqL1xuICAgIENoYW5nZS5DSElMRF9BRERFRCA9ICdjaGlsZF9hZGRlZCc7XG4gICAgLyoqIEV2ZW50IHR5cGUgZm9yIGEgY2hpbGQgcmVtb3ZlZCAqL1xuICAgIENoYW5nZS5DSElMRF9SRU1PVkVEID0gJ2NoaWxkX3JlbW92ZWQnO1xuICAgIC8qKiBFdmVudCB0eXBlIGZvciBhIGNoaWxkIGNoYW5nZWQgKi9cbiAgICBDaGFuZ2UuQ0hJTERfQ0hBTkdFRCA9ICdjaGlsZF9jaGFuZ2VkJztcbiAgICAvKiogRXZlbnQgdHlwZSBmb3IgYSBjaGlsZCBtb3ZlZCAqL1xuICAgIENoYW5nZS5DSElMRF9NT1ZFRCA9ICdjaGlsZF9tb3ZlZCc7XG4gICAgLyoqIEV2ZW50IHR5cGUgZm9yIGEgdmFsdWUgY2hhbmdlICovXG4gICAgQ2hhbmdlLlZBTFVFID0gJ3ZhbHVlJztcbiAgICByZXR1cm4gQ2hhbmdlO1xufSgpKTtcbmV4cG9ydCB7IENoYW5nZSB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3ZpZXcvQ2hhbmdlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8vIEdldFxuXG5leHBvcnQgZnVuY3Rpb24gbnVtKG1pbiA9IDEsIG1heCA9IE5hTikge1xuICBpZiAoaXNOYU4obWF4KSkge1xuICAgIG1heCAgPSBtaW47XG4gICAgbWluICA9IDA7XG4gIH1cbiAgcmV0dXJuIChNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikpICsgbWluO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGludChtaW4sIG1heCA9IE5hTikge1xuICBpZiAoaXNOYU4obWF4KSkge1xuICAgIG1heCAgPSBtaW47XG4gICAgbWluICA9IDA7XG4gIH1cbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBib29sZWFuKGNoYW5jZSA9IDAuNSkge1xuICByZXR1cm4gKE1hdGgucmFuZG9tKCkgPCBjaGFuY2UpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNpZ24oY2hhbmNlID0gMC41KSB7XG4gIHJldHVybiAoTWF0aC5yYW5kb20oKSA8IGNoYW5jZSkgPyAxIDogLTE7XG59XG5leHBvcnQgZnVuY3Rpb24gYml0KGNoYW5jZSA9IDAuNSkge1xuICByZXR1cm4gKE1hdGgucmFuZG9tKCkgPCBjaGFuY2UpID8gMSA6IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtKHRpbWVzID0gMikge1xuICBsZXQgc3VtICA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZXM7IGkrKykge1xuICAgIHN1bSArPSBNYXRoLnJhbmRvbSgpO1xuICB9XG4gIHJldHVybiBzdW0vdGltZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzb3J0KGEsIGIpIHtcbiAgcmV0dXJuIHNpZ24oKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdpZ2dsZShuLCBmcmVlZG9tKSB7XG4gIHJldHVybiBuICsgbnVtKC1mcmVlZG9tLCBmcmVlZG9tKTtcbn1cblxuXG4vLyBBcnJheXNcblxuZXhwb3J0IGZ1bmN0aW9uIHNodWZmbGUoYSwgdGltZXMgPSA1KSB7XG4gIGlmIChhLmxlbmd0aCA8PSAxKSByZXR1cm4gYTtcbiAgbGV0IHIgID0gYS5zbGljZSgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVzOyBpKyspIHtcbiAgICByLnNvcnQoc29ydCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmRleChhKSB7XG4gIHJldHVybiAoYS5sZW5ndGgpID8gaW50KGEubGVuZ3RoIC0gMSkgOiAtMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGl0ZW0oYSkge1xuICByZXR1cm4gYVtpbmRleChhKV07XG59XG5leHBvcnQgZnVuY3Rpb24gaXRlbXMoYSwgY291bnQpIHtcbiAgcmV0dXJuIHNodWZmbGUoYSkuc2xpY2UoMCwgY291bnQpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ZhcnlkLXV0aWxzL3JhbmRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGNyZWF0ZUZpcmViYXNlTmFtZXNwYWNlIH0gZnJvbSAnLi9zcmMvZmlyZWJhc2VBcHAnO1xuZXhwb3J0IHZhciBmaXJlYmFzZSA9IGNyZWF0ZUZpcmViYXNlTmFtZXNwYWNlKCk7XG5leHBvcnQgZGVmYXVsdCBmaXJlYmFzZTtcblxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IHsgSW5kZXggfSBmcm9tICcuL0luZGV4JztcbmltcG9ydCB7IE5hbWVkTm9kZSB9IGZyb20gJy4uL05vZGUnO1xuaW1wb3J0IHsgbmFtZUNvbXBhcmUsIE1BWF9OQU1FIH0gZnJvbSAnLi4vLi4vdXRpbC91dGlsJztcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0aW9uRXJyb3IgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG52YXIgX19FTVBUWV9OT0RFO1xudmFyIEtleUluZGV4ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhLZXlJbmRleCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBLZXlJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoS2V5SW5kZXgsIFwiX19FTVBUWV9OT0RFXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19FTVBUWV9OT0RFO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIF9fRU1QVFlfTk9ERSA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBLZXlJbmRleC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBuYW1lQ29tcGFyZShhLm5hbWUsIGIubmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIEtleUluZGV4LnByb3RvdHlwZS5pc0RlZmluZWRPbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIC8vIFdlIGNvdWxkIHByb2JhYmx5IHJldHVybiB0cnVlIGhlcmUgKHNpbmNlIGV2ZXJ5IG5vZGUgaGFzIGEga2V5KSwgYnV0IGl0J3MgbmV2ZXIgY2FsbGVkXG4gICAgICAgIC8vIHNvIGp1c3QgbGVhdmluZyB1bmltcGxlbWVudGVkIGZvciBub3cuXG4gICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKCdLZXlJbmRleC5pc0RlZmluZWRPbiBub3QgZXhwZWN0ZWQgdG8gYmUgY2FsbGVkLicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBLZXlJbmRleC5wcm90b3R5cGUuaW5kZXhlZFZhbHVlQ2hhbmdlZCA9IGZ1bmN0aW9uIChvbGROb2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gVGhlIGtleSBmb3IgYSBub2RlIG5ldmVyIGNoYW5nZXMuXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIEtleUluZGV4LnByb3RvdHlwZS5taW5Qb3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTmFtZWROb2RlLk1JTjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgS2V5SW5kZXgucHJvdG90eXBlLm1heFBvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIHJlYWxseSBiZSBjcmVhdGVkIG9uY2UgYW5kIGNhY2hlZCBpbiBhIHN0YXRpYyBwcm9wZXJ0eSwgYnV0XG4gICAgICAgIC8vIE5hbWVkTm9kZSBpc24ndCBkZWZpbmVkIHlldCwgc28gSSBjYW4ndCB1c2UgaXQgaW4gYSBzdGF0aWMuICBCbGVoLlxuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShNQVhfTkFNRSwgX19FTVBUWV9OT0RFKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gaW5kZXhWYWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7IU5hbWVkTm9kZX1cbiAgICAgKi9cbiAgICBLZXlJbmRleC5wcm90b3R5cGUubWFrZVBvc3QgPSBmdW5jdGlvbiAoaW5kZXhWYWx1ZSwgbmFtZSkge1xuICAgICAgICBhc3NlcnQodHlwZW9mIGluZGV4VmFsdWUgPT09ICdzdHJpbmcnLCAnS2V5SW5kZXggaW5kZXhWYWx1ZSBtdXN0IGFsd2F5cyBiZSBhIHN0cmluZy4nKTtcbiAgICAgICAgLy8gV2UganVzdCB1c2UgZW1wdHkgbm9kZSwgYnV0IGl0J2xsIG5ldmVyIGJlIGNvbXBhcmVkLCBzaW5jZSBvdXIgY29tcGFyYXRvciBvbmx5IGxvb2tzIGF0IG5hbWUuXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKGluZGV4VmFsdWUsIF9fRU1QVFlfTk9ERSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshc3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIGluY2x1c2lvbiBpbiBhIHF1ZXJ5IHNwZWNcbiAgICAgKi9cbiAgICBLZXlJbmRleC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnLmtleSc7XG4gICAgfTtcbiAgICByZXR1cm4gS2V5SW5kZXg7XG59KEluZGV4KSk7XG5leHBvcnQgeyBLZXlJbmRleCB9O1xuZXhwb3J0IHZhciBLRVlfSU5ERVggPSBuZXcgS2V5SW5kZXgoKTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9zbmFwL2luZGV4ZXMvS2V5SW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBDaGlsZHJlbk5vZGUgfSBmcm9tICcuL0NoaWxkcmVuTm9kZSc7XG5pbXBvcnQgeyBMZWFmTm9kZSB9IGZyb20gJy4vTGVhZk5vZGUnO1xuaW1wb3J0IHsgTmFtZWROb2RlIH0gZnJvbSAnLi9Ob2RlJztcbmltcG9ydCB7IGZvckVhY2gsIGNvbnRhaW5zIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgYnVpbGRDaGlsZFNldCB9IGZyb20gJy4vY2hpbGRTZXQnO1xuaW1wb3J0IHsgTkFNRV9DT01QQVJBVE9SLCBOQU1FX09OTFlfQ09NUEFSQVRPUiB9IGZyb20gJy4vY29tcGFyYXRvcnMnO1xuaW1wb3J0IHsgSW5kZXhNYXAgfSBmcm9tICcuL0luZGV4TWFwJztcbmltcG9ydCB7IFBSSU9SSVRZX0lOREVYLCBzZXROb2RlRnJvbUpTT04gfSBmcm9tICcuL2luZGV4ZXMvUHJpb3JpdHlJbmRleCc7XG52YXIgVVNFX0hJTlpFID0gdHJ1ZTtcbi8qKlxuICogQ29uc3RydWN0cyBhIHNuYXBzaG90IG5vZGUgcmVwcmVzZW50aW5nIHRoZSBwYXNzZWQgSlNPTiBhbmQgcmV0dXJucyBpdC5cbiAqIEBwYXJhbSB7Kn0ganNvbiBKU09OIHRvIGNyZWF0ZSBhIG5vZGUgZm9yLlxuICogQHBhcmFtIHs/c3RyaW5nfD9udW1iZXI9fSBwcmlvcml0eSBPcHRpb25hbCBwcmlvcml0eSB0byB1c2UuICBUaGlzIHdpbGwgYmUgaWdub3JlZCBpZiB0aGVcbiAqIHBhc3NlZCBKU09OIGNvbnRhaW5zIGEgLnByaW9yaXR5IHByb3BlcnR5LlxuICogQHJldHVybiB7IU5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub2RlRnJvbUpTT04oanNvbiwgcHJpb3JpdHkpIHtcbiAgICBpZiAocHJpb3JpdHkgPT09IHZvaWQgMCkgeyBwcmlvcml0eSA9IG51bGw7IH1cbiAgICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ29iamVjdCcgJiYgJy5wcmlvcml0eScgaW4ganNvbikge1xuICAgICAgICBwcmlvcml0eSA9IGpzb25bJy5wcmlvcml0eSddO1xuICAgIH1cbiAgICBhc3NlcnQocHJpb3JpdHkgPT09IG51bGwgfHxcbiAgICAgICAgdHlwZW9mIHByaW9yaXR5ID09PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2YgcHJpb3JpdHkgPT09ICdudW1iZXInIHx8XG4gICAgICAgICh0eXBlb2YgcHJpb3JpdHkgPT09ICdvYmplY3QnICYmICcuc3YnIGluIHByaW9yaXR5KSwgJ0ludmFsaWQgcHJpb3JpdHkgdHlwZSBmb3VuZDogJyArIHR5cGVvZiBwcmlvcml0eSk7XG4gICAgaWYgKHR5cGVvZiBqc29uID09PSAnb2JqZWN0JyAmJiAnLnZhbHVlJyBpbiBqc29uICYmIGpzb25bJy52YWx1ZSddICE9PSBudWxsKSB7XG4gICAgICAgIGpzb24gPSBqc29uWycudmFsdWUnXTtcbiAgICB9XG4gICAgLy8gVmFsaWQgbGVhZiBub2RlcyBpbmNsdWRlIG5vbi1vYmplY3RzIG9yIHNlcnZlci12YWx1ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAodHlwZW9mIGpzb24gIT09ICdvYmplY3QnIHx8ICcuc3YnIGluIGpzb24pIHtcbiAgICAgICAgdmFyIGpzb25MZWFmID0ganNvbjtcbiAgICAgICAgcmV0dXJuIG5ldyBMZWFmTm9kZShqc29uTGVhZiwgbm9kZUZyb21KU09OKHByaW9yaXR5KSk7XG4gICAgfVxuICAgIGlmICghKGpzb24gaW5zdGFuY2VvZiBBcnJheSkgJiYgVVNFX0hJTlpFKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbl8xID0gW107XG4gICAgICAgIHZhciBjaGlsZHJlbkhhdmVQcmlvcml0eV8xID0gZmFsc2U7XG4gICAgICAgIHZhciBoaW56ZUpzb25PYmpfMSA9IGpzb247XG4gICAgICAgIGZvckVhY2goaGluemVKc29uT2JqXzEsIGZ1bmN0aW9uIChrZXksIGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwga2V5LnN1YnN0cmluZygwLCAxKSAhPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIG1ldGFkYXRhIG5vZGVzXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IG5vZGVGcm9tSlNPTihoaW56ZUpzb25PYmpfMVtrZXldKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5IYXZlUHJpb3JpdHlfMSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkhhdmVQcmlvcml0eV8xIHx8ICFjaGlsZE5vZGUuZ2V0UHJpb3JpdHkoKS5pc0VtcHR5KCk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuXzEucHVzaChuZXcgTmFtZWROb2RlKGtleSwgY2hpbGROb2RlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNoaWxkcmVuXzEubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRTZXQgPSBidWlsZENoaWxkU2V0KGNoaWxkcmVuXzEsIE5BTUVfT05MWV9DT01QQVJBVE9SLCBmdW5jdGlvbiAobmFtZWROb2RlKSB7IHJldHVybiBuYW1lZE5vZGUubmFtZTsgfSwgTkFNRV9DT01QQVJBVE9SKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuSGF2ZVByaW9yaXR5XzEpIHtcbiAgICAgICAgICAgIHZhciBzb3J0ZWRDaGlsZFNldCA9IGJ1aWxkQ2hpbGRTZXQoY2hpbGRyZW5fMSwgUFJJT1JJVFlfSU5ERVguZ2V0Q29tcGFyZSgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKGNoaWxkU2V0LCBub2RlRnJvbUpTT04ocHJpb3JpdHkpLCBuZXcgSW5kZXhNYXAoeyAnLnByaW9yaXR5Jzogc29ydGVkQ2hpbGRTZXQgfSwgeyAnLnByaW9yaXR5JzogUFJJT1JJVFlfSU5ERVggfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGlsZHJlbk5vZGUoY2hpbGRTZXQsIG5vZGVGcm9tSlNPTihwcmlvcml0eSksIEluZGV4TWFwLkRlZmF1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgbm9kZV8xID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XG4gICAgICAgIHZhciBqc29uT2JqXzEgPSBqc29uO1xuICAgICAgICBmb3JFYWNoKGpzb25PYmpfMSwgZnVuY3Rpb24gKGtleSwgY2hpbGREYXRhKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbnMoanNvbk9ial8xLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdWJzdHJpbmcoMCwgMSkgIT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgbWV0YWRhdGEgbm9kZXMuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBub2RlRnJvbUpTT04oY2hpbGREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5pc0xlYWZOb2RlKCkgfHwgIWNoaWxkTm9kZS5pc0VtcHR5KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlXzEgPSBub2RlXzEudXBkYXRlSW1tZWRpYXRlQ2hpbGQoa2V5LCBjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBub2RlXzEudXBkYXRlUHJpb3JpdHkobm9kZUZyb21KU09OKHByaW9yaXR5KSk7XG4gICAgfVxufVxuc2V0Tm9kZUZyb21KU09OKG5vZGVGcm9tSlNPTik7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvc25hcC9ub2RlRnJvbUpTT04uanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuZXhwb3J0IGNvbnN0IFRBTyA9IE1hdGguUEkgKiAyO1xuXG5cbi8vIDAuMCAuLi4gMS4wXG5cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG1pbiwgbWF4LCB2YWwgPSAwLjUsIGRvQ2xhbXAgPSBmYWxzZSkge1xuICBpZiAoZG9DbGFtcCkge1xuICAgIHJldHVybiBjbGFtcCgobWluICogKDEgLSB2YWwpKSArIChtYXggKiB2YWwpLCBtaW4sIG1heCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChtaW4gKiAoMSAtIHZhbCkpICsgKG1heCAqIHZhbClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29zZXJwKG1pbiwgbWF4LCB2YWwgPSAwLjUsIGRvQ2xhbXAgPSBmYWxzZSkge1xuICBpZiAoZG9DbGFtcCkge1xuICAgIHJldHVybiBjbGFtcChsZXJwKG1pbiwgbWF4LCAoMSAtIE1hdGguY29zKHZhbCAqIE1hdGguUEkpKSAvIDIpLCBtaW4sIG1heCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxlcnAobWluLCBtYXgsICgxIC0gTWF0aC5jb3ModmFsICogTWF0aC5QSSkpIC8gMik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm0odmFsLCBtaW4sIG1heCwgZG9DbGFtcCA9IGZhbHNlKSB7XG4gIGlmIChkb0NsYW1wKSB7XG4gICAgcmV0dXJuIGNsYW1wKCh2YWwgLSBtaW4pIC8gKG1heCAtIG1pbiksIDAsIDEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAodmFsIC0gbWluKSAvIChtYXggLSBtaW4pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXAodmFsLCBtaW4sIG1heCwgdG1pbiwgdG1heCwgZG9DbGFtcCA9IGZhbHNlKSB7XG4gIHJldHVybiBsZXJwKHRtaW4sIHRtYXgsIG5vcm0odmFsLCBtaW4sIG1heCwgZG9DbGFtcCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5pVG9CaSh2YWwpIHtcbiAgcmV0dXJuIG1hcCh2YWwsIDAsIDEsIC0xLCAxKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpVG9VbmkodmFsKSB7XG4gIHJldHVybiBub3JtKHZhbCwgLTEsIDEpO1xufVxuXG5cbi8vIExvb3BzICYgcmFuZ2VzXG5cbmV4cG9ydCBmdW5jdGlvbiBuZXh0V2l0aGluKG51bSwgbWluLCBtYXgsIGRvQ2xhbXAgPSBmYWxzZSkge1xuICBpZiAoZG9DbGFtcCkge1xuICAgIHJldHVybiBjbGFtcChudW0gKyAxLCBtaW4sIG1heCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFkZFdpdGhpbihudW0sIDEsIG1pbiwgbWF4KTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHByZXZXaXRoaW4obnVtLCBtaW4sIG1heCwgZG9DbGFtcCA9IGZhbHNlKSB7XG4gIGlmIChkb0NsYW1wKSB7XG4gICAgcmV0dXJuIGNsYW1wKG51bSAtIDEsIG1pbiwgbWF4KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3VidHJhY3RXaXRoaW4obnVtLCAxLCBtaW4sIG1heCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFdpdGhpbihudW0sIGluYywgbWluLCBtYXgpIHtcbiAgcmV0dXJuIHdyYXAobnVtICsgaW5jLCBtaW4sIG1heCk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3RXaXRoaW4obnVtLCBzdWIsIG1pbiwgbWF4KSB7XG4gIHJldHVybiB3cmFwKG51bSAtIHN1YiwgbWluLCBtYXgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcChudW0sIG1pbiwgbWF4KSB7XG4gIGxldCByID0gbWF4IC0gbWluICsgMSxcbiAgICAgIG4gPSAoKG51bSAtIG1pbikgJSByKTtcbiAgaWYgKG4gPCAwKSB7XG4gICAgcmV0dXJuIG1heCArIG4gKyAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtaW4gKyBuO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwTnVtKG51bSwgbWluID0gMCwgbWF4ID0gMSkge1xuICBpZiAobnVtIDwgbWluKSB7XG4gICAgcmV0dXJuIG1heCAtIChtaW4gLSBudW0pICUgKG1heCAtIG1pbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1pbiArIChudW0gLSBtaW4pICUgKG1heCAtIG1pbik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKG51bSwgbWluID0gMCwgbWF4ID0gMSkge1xuICBpZiAobWluIDw9IG1heCkge1xuICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgbnVtKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE1hdGgubWluKG1heCwgTWF0aC5taW4obWluLCBudW0pKTtcbiAgfVxufVxuXG5cbi8vIE1pc2NcblxuZXhwb3J0IGZ1bmN0aW9uIHNpZ24obikge1xuICByZXR1cm4gKG4gPiAwKSA/IDEgOiAoKG4gPCAwKSA/IC0xIDogMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZFRvKG4sIGRlY2ltYWxzKSB7XG4gIGxldCBtID0gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcbiAgcmV0dXJuIE1hdGgucm91bmQobiAqIG0pIC8gbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmYoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXZnKC4uLm51bXMpIHtcbiAgcmV0dXJuIG51bXMucmVkdWNlKChhY2MsIGN1ciwgaSkgPT4gKGFjYyArIGN1cikpIC8gbnVtcy5sZW5ndGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlYXNlKHZhbCwgdHJndCwgZmFjdG9yID0gMC41LCB0aHJlc2hvbGQgPSAxKSB7XG4gIHJldHVybiAoaXNOYU4odmFsKSB8fCBkaWZmKHZhbCwgdHJndCkgPCB0aHJlc2hvbGQpID8gdHJndCA6IGxlcnAodmFsLCB0cmd0LCBmYWN0b3IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnQodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gTWF0aC5mbG9vcih2YWwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGl2aXNpYmxlQnkodmFsLCBkaXZpc29yKSB7XG4gIHJldHVybiAodmFsICUgZGl2aXNvcikgPT09IDA7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdmFyeWQtdXRpbHMvbWF0aHMuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBnZW5lcmF0ZVdpdGhWYWx1ZXMsIHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QsIHJlc29sdmVEZWZlcnJlZFZhbHVlVHJlZSB9IGZyb20gJy4vdXRpbC9TZXJ2ZXJWYWx1ZXMnO1xuaW1wb3J0IHsgbm9kZUZyb21KU09OIH0gZnJvbSAnLi9zbmFwL25vZGVGcm9tSlNPTic7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi91dGlsL1BhdGgnO1xuaW1wb3J0IHsgU3BhcnNlU25hcHNob3RUcmVlIH0gZnJvbSAnLi9TcGFyc2VTbmFwc2hvdFRyZWUnO1xuaW1wb3J0IHsgU3luY1RyZWUgfSBmcm9tICcuL1N5bmNUcmVlJztcbmltcG9ydCB7IFNuYXBzaG90SG9sZGVyIH0gZnJvbSAnLi9TbmFwc2hvdEhvbGRlcic7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBiZWluZ0NyYXdsZWQsIGVhY2gsIGV4Y2VwdGlvbkd1YXJkLCB3YXJuLCBsb2cgfSBmcm9tICcuL3V0aWwvdXRpbCc7XG5pbXBvcnQgeyBtYXAsIGZvckVhY2gsIGlzRW1wdHkgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBBdXRoVG9rZW5Qcm92aWRlciB9IGZyb20gJy4vQXV0aFRva2VuUHJvdmlkZXInO1xuaW1wb3J0IHsgU3RhdHNNYW5hZ2VyIH0gZnJvbSAnLi9zdGF0cy9TdGF0c01hbmFnZXInO1xuaW1wb3J0IHsgU3RhdHNSZXBvcnRlciB9IGZyb20gJy4vc3RhdHMvU3RhdHNSZXBvcnRlcic7XG5pbXBvcnQgeyBTdGF0c0xpc3RlbmVyIH0gZnJvbSAnLi9zdGF0cy9TdGF0c0xpc3RlbmVyJztcbmltcG9ydCB7IEV2ZW50UXVldWUgfSBmcm9tICcuL3ZpZXcvRXZlbnRRdWV1ZSc7XG5pbXBvcnQgeyBQZXJzaXN0ZW50Q29ubmVjdGlvbiB9IGZyb20gJy4vUGVyc2lzdGVudENvbm5lY3Rpb24nO1xuaW1wb3J0IHsgUmVhZG9ubHlSZXN0Q2xpZW50IH0gZnJvbSAnLi9SZWFkb25seVJlc3RDbGllbnQnO1xuaW1wb3J0IHsgRGF0YWJhc2UgfSBmcm9tICcuLi9hcGkvRGF0YWJhc2UnO1xudmFyIElOVEVSUlVQVF9SRUFTT04gPSAncmVwb19pbnRlcnJ1cHQnO1xuLyoqXG4gKiBBIGNvbm5lY3Rpb24gdG8gYSBzaW5nbGUgZGF0YSByZXBvc2l0b3J5LlxuICovXG52YXIgUmVwbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFSZXBvSW5mb30gcmVwb0luZm9fXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZVJlc3RDbGllbnRcbiAgICAgKiBAcGFyYW0geyFGaXJlYmFzZUFwcH0gYXBwXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVwbyhyZXBvSW5mb18sIGZvcmNlUmVzdENsaWVudCwgYXBwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5kYXRhVXBkYXRlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnN0YXRzTGlzdGVuZXJfID0gbnVsbDtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlXyA9IG5ldyBFdmVudFF1ZXVlKCk7XG4gICAgICAgIHRoaXMubmV4dFdyaXRlSWRfID0gMTtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRTZXJ2ZXJEYXRhQ2FsbGJhY2tfID0gbnVsbDtcbiAgICAgICAgLy8gQSBsaXN0IG9mIGRhdGEgcGllY2VzIGFuZCBwYXRocyB0byBiZSBzZXQgd2hlbiB0aGlzIGNsaWVudCBkaXNjb25uZWN0cy5cbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gbmV3IFNwYXJzZVNuYXBzaG90VHJlZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVE9ETzogVGhpcyBzaG91bGQgYmUgQHByaXZhdGUgYnV0IGl0J3MgdXNlZCBieSB0ZXN0X2FjY2Vzcy5qcyBhbmQgaW50ZXJuYWwuanNcbiAgICAgICAgICogQHR5cGUgez9QZXJzaXN0ZW50Q29ubmVjdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVyc2lzdGVudENvbm5lY3Rpb25fID0gbnVsbDtcbiAgICAgICAgLyoqIEB0eXBlIHshQXV0aFRva2VuUHJvdmlkZXJ9ICovXG4gICAgICAgIHZhciBhdXRoVG9rZW5Qcm92aWRlciA9IG5ldyBBdXRoVG9rZW5Qcm92aWRlcihhcHApO1xuICAgICAgICB0aGlzLnN0YXRzXyA9IFN0YXRzTWFuYWdlci5nZXRDb2xsZWN0aW9uKHJlcG9JbmZvXyk7XG4gICAgICAgIGlmIChmb3JjZVJlc3RDbGllbnQgfHwgYmVpbmdDcmF3bGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyXyA9IG5ldyBSZWFkb25seVJlc3RDbGllbnQodGhpcy5yZXBvSW5mb18sIHRoaXMub25EYXRhVXBkYXRlXy5iaW5kKHRoaXMpLCBhdXRoVG9rZW5Qcm92aWRlcik7XG4gICAgICAgICAgICAvLyBNaW5vciBoYWNrOiBGaXJlIG9uQ29ubmVjdCBpbW1lZGlhdGVseSwgc2luY2UgdGhlcmUncyBubyBhY3R1YWwgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5vbkNvbm5lY3RTdGF0dXNfLmJpbmQodGhpcywgdHJ1ZSksIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGF1dGhPdmVycmlkZSA9IGFwcC5vcHRpb25zWydkYXRhYmFzZUF1dGhWYXJpYWJsZU92ZXJyaWRlJ107XG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSBhdXRoT3ZlcnJpZGVcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXV0aE92ZXJyaWRlICE9PSAndW5kZWZpbmVkJyAmJiBhdXRoT3ZlcnJpZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGF1dGhPdmVycmlkZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG9iamVjdHMgYXJlIHN1cHBvcnRlZCBmb3Igb3B0aW9uIGRhdGFiYXNlQXV0aFZhcmlhYmxlT3ZlcnJpZGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5KGF1dGhPdmVycmlkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhdXRoT3ZlcnJpZGUgcHJvdmlkZWQ6ICcgKyBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBlcnNpc3RlbnRDb25uZWN0aW9uXyA9IG5ldyBQZXJzaXN0ZW50Q29ubmVjdGlvbih0aGlzLnJlcG9JbmZvXywgdGhpcy5vbkRhdGFVcGRhdGVfLmJpbmQodGhpcyksIHRoaXMub25Db25uZWN0U3RhdHVzXy5iaW5kKHRoaXMpLCB0aGlzLm9uU2VydmVySW5mb1VwZGF0ZV8uYmluZCh0aGlzKSwgYXV0aFRva2VuUHJvdmlkZXIsIGF1dGhPdmVycmlkZSk7XG4gICAgICAgICAgICB0aGlzLnNlcnZlcl8gPSB0aGlzLnBlcnNpc3RlbnRDb25uZWN0aW9uXztcbiAgICAgICAgfVxuICAgICAgICBhdXRoVG9rZW5Qcm92aWRlci5hZGRUb2tlbkNoYW5nZUxpc3RlbmVyKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgX3RoaXMuc2VydmVyXy5yZWZyZXNoQXV0aFRva2VuKHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIG11bHRpcGxlIFJlcG9zIGZvciB0aGUgc2FtZSByZXBvSW5mbyAoaS5lLiB0aGVyZSBhcmUgbXVsdGlwbGUgRmlyZWJhc2UuQ29udGV4dHMgYmVpbmcgdXNlZCksXG4gICAgICAgIC8vIHdlIG9ubHkgd2FudCB0byBjcmVhdGUgb25lIFN0YXRzUmVwb3J0ZXIuICBBcyBzdWNoLCB3ZSdsbCByZXBvcnQgc3RhdHMgb3ZlciB0aGUgZmlyc3QgUmVwbyBjcmVhdGVkLlxuICAgICAgICB0aGlzLnN0YXRzUmVwb3J0ZXJfID0gU3RhdHNNYW5hZ2VyLmdldE9yQ3JlYXRlUmVwb3J0ZXIocmVwb0luZm9fLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgU3RhdHNSZXBvcnRlcihfdGhpcy5zdGF0c18sIF90aGlzLnNlcnZlcl8pOyB9KTtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbnNfaW5pdF8oKTtcbiAgICAgICAgLy8gVXNlZCBmb3IgLmluZm8uXG4gICAgICAgIHRoaXMuaW5mb0RhdGFfID0gbmV3IFNuYXBzaG90SG9sZGVyKCk7XG4gICAgICAgIHRoaXMuaW5mb1N5bmNUcmVlXyA9IG5ldyBTeW5jVHJlZSh7XG4gICAgICAgICAgICBzdGFydExpc3RlbmluZzogZnVuY3Rpb24gKHF1ZXJ5LCB0YWcsIGN1cnJlbnRIYXNoRm4sIG9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5mb0V2ZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gX3RoaXMuaW5mb0RhdGFfLmdldE5vZGUocXVlcnkucGF0aCk7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBwb3NzaWJseSBhIGhhY2ssIGJ1dCB3ZSBoYXZlIGRpZmZlcmVudCBzZW1hbnRpY3MgZm9yIC5pbmZvIGVuZHBvaW50cy4gV2UgZG9uJ3QgcmFpc2UgbnVsbCBldmVudHNcbiAgICAgICAgICAgICAgICAvLyBvbiBpbml0aWFsIGRhdGEuLi5cbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm9FdmVudHMgPSBfdGhpcy5pbmZvU3luY1RyZWVfLmFwcGx5U2VydmVyT3ZlcndyaXRlKHF1ZXJ5LnBhdGgsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGUoJ29rJyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5mb0V2ZW50cztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdG9wTGlzdGVuaW5nOiBmdW5jdGlvbiAoKSB7IH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlSW5mb18oJ2Nvbm5lY3RlZCcsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zZXJ2ZXJTeW5jVHJlZV8gPSBuZXcgU3luY1RyZWUoe1xuICAgICAgICAgICAgc3RhcnRMaXN0ZW5pbmc6IGZ1bmN0aW9uIChxdWVyeSwgdGFnLCBjdXJyZW50SGFzaEZuLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VydmVyXy5saXN0ZW4ocXVlcnksIGN1cnJlbnRIYXNoRm4sIHRhZywgZnVuY3Rpb24gKHN0YXR1cywgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRzID0gb25Db21wbGV0ZShzdGF0dXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHF1ZXJ5LnBhdGgsIGV2ZW50cyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gTm8gc3luY2hyb25vdXMgZXZlbnRzIGZvciBuZXR3b3JrLWJhY2tlZCBzeW5jIHRyZWVzXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0b3BMaXN0ZW5pbmc6IGZ1bmN0aW9uIChxdWVyeSwgdGFnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VydmVyXy51bmxpc3RlbihxdWVyeSwgdGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gIFRoZSBVUkwgY29ycmVzcG9uZGluZyB0byB0aGUgcm9vdCBvZiB0aGlzIEZpcmViYXNlLlxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKCh0aGlzLnJlcG9JbmZvXy5zZWN1cmUgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nKSArIHRoaXMucmVwb0luZm9fLmhvc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IXN0cmluZ30gVGhlIG5hbWVzcGFjZSByZXByZXNlbnRlZCBieSB0aGUgcmVwby5cbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBvSW5mb18ubmFtZXNwYWNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IW51bWJlcn0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzLCB0YWtpbmcgdGhlIHNlcnZlciBvZmZzZXQgaW50byBhY2NvdW50IGlmIHdlIGhhdmUgb25lLlxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLnNlcnZlclRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvZmZzZXROb2RlID0gdGhpcy5pbmZvRGF0YV8uZ2V0Tm9kZShuZXcgUGF0aCgnLmluZm8vc2VydmVyVGltZU9mZnNldCcpKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldE5vZGUudmFsKCkgfHwgMDtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgb2Zmc2V0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgU2VydmVyVmFsdWVzIHVzaW5nIHNvbWUgdmFyaWFibGVzIGZyb20gdGhlIHJlcG8gb2JqZWN0LlxuICAgICAqIEByZXR1cm4geyFPYmplY3R9XG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUuZ2VuZXJhdGVTZXJ2ZXJWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVdpdGhWYWx1ZXMoe1xuICAgICAgICAgICAgdGltZXN0YW1wOiB0aGlzLnNlcnZlclRpbWUoKVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCBieSByZWFsdGltZSB3aGVuIHdlIGdldCBuZXcgbWVzc2FnZXMgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFN0cmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gZGF0YVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNNZXJnZVxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gdGFnXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUub25EYXRhVXBkYXRlXyA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBkYXRhLCBpc01lcmdlLCB0YWcpIHtcbiAgICAgICAgLy8gRm9yIHRlc3RpbmcuXG4gICAgICAgIHRoaXMuZGF0YVVwZGF0ZUNvdW50Kys7XG4gICAgICAgIHZhciBwYXRoID0gbmV3IFBhdGgocGF0aFN0cmluZyk7XG4gICAgICAgIGRhdGEgPSB0aGlzLmludGVyY2VwdFNlcnZlckRhdGFDYWxsYmFja19cbiAgICAgICAgICAgID8gdGhpcy5pbnRlcmNlcHRTZXJ2ZXJEYXRhQ2FsbGJhY2tfKHBhdGhTdHJpbmcsIGRhdGEpXG4gICAgICAgICAgICA6IGRhdGE7XG4gICAgICAgIHZhciBldmVudHMgPSBbXTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgaWYgKGlzTWVyZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnZ2VkQ2hpbGRyZW4gPSBtYXAoZGF0YSwgZnVuY3Rpb24gKHJhdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZUZyb21KU09OKHJhdyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYXBwbHlUYWdnZWRRdWVyeU1lcmdlKHBhdGgsIHRhZ2dlZENoaWxkcmVuLCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZ2dlZFNuYXAgPSBub2RlRnJvbUpTT04oZGF0YSk7XG4gICAgICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYXBwbHlUYWdnZWRRdWVyeU92ZXJ3cml0ZShwYXRoLCB0YWdnZWRTbmFwLCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTWVyZ2UpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkQ2hpbGRyZW4gPSBtYXAoZGF0YSwgZnVuY3Rpb24gKHJhdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlRnJvbUpTT04ocmF3KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYXBwbHlTZXJ2ZXJNZXJnZShwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNuYXAgPSBub2RlRnJvbUpTT04oZGF0YSk7XG4gICAgICAgICAgICBldmVudHMgPSB0aGlzLnNlcnZlclN5bmNUcmVlXy5hcHBseVNlcnZlck92ZXJ3cml0ZShwYXRoLCBzbmFwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWZmZWN0ZWRQYXRoID0gcGF0aDtcbiAgICAgICAgaWYgKGV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSBoYXZlIGEgbGlzdGVuZXIgb3V0c3RhbmRpbmcgZm9yIGVhY2ggdHJhbnNhY3Rpb24sIHJlY2VpdmluZyBhbnkgZXZlbnRzXG4gICAgICAgICAgICAvLyBpcyBhIHByb3h5IGZvciBzb21lIGNoYW5nZSBoYXZpbmcgb2NjdXJyZWQuXG4gICAgICAgICAgICBhZmZlY3RlZFBhdGggPSB0aGlzLnJlcnVuVHJhbnNhY3Rpb25zXyhwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50UXVldWVfLnJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgoYWZmZWN0ZWRQYXRoLCBldmVudHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVE9ETzogVGhpcyBzaG91bGQgYmUgQHByaXZhdGUgYnV0IGl0J3MgdXNlZCBieSB0ZXN0X2FjY2Vzcy5qcyBhbmQgaW50ZXJuYWwuanNcbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbighc3RyaW5nLCAqKToqfSBjYWxsYmFja1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUuaW50ZXJjZXB0U2VydmVyRGF0YV8gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRTZXJ2ZXJEYXRhQ2FsbGJhY2tfID0gY2FsbGJhY2s7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFib29sZWFufSBjb25uZWN0U3RhdHVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS5vbkNvbm5lY3RTdGF0dXNfID0gZnVuY3Rpb24gKGNvbm5lY3RTdGF0dXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVJbmZvXygnY29ubmVjdGVkJywgY29ubmVjdFN0YXR1cyk7XG4gICAgICAgIGlmIChjb25uZWN0U3RhdHVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5ydW5PbkRpc2Nvbm5lY3RFdmVudHNfKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gdXBkYXRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUub25TZXJ2ZXJJbmZvVXBkYXRlXyA9IGZ1bmN0aW9uICh1cGRhdGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGVhY2godXBkYXRlcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZUluZm9fKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBwYXRoU3RyaW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUudXBkYXRlSW5mb18gPSBmdW5jdGlvbiAocGF0aFN0cmluZywgdmFsdWUpIHtcbiAgICAgICAgdmFyIHBhdGggPSBuZXcgUGF0aCgnLy5pbmZvLycgKyBwYXRoU3RyaW5nKTtcbiAgICAgICAgdmFyIG5ld05vZGUgPSBub2RlRnJvbUpTT04odmFsdWUpO1xuICAgICAgICB0aGlzLmluZm9EYXRhXy51cGRhdGVTbmFwc2hvdChwYXRoLCBuZXdOb2RlKTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuaW5mb1N5bmNUcmVlXy5hcHBseVNlcnZlck92ZXJ3cml0ZShwYXRoLCBuZXdOb2RlKTtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHBhdGgsIGV2ZW50cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshbnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUuZ2V0TmV4dFdyaXRlSWRfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0V3JpdGVJZF8rKztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyp9IG5ld1ZhbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xudWxsfSBuZXdQcmlvcml0eVxuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9uKD9FcnJvciwgKj0pfSBvbkNvbXBsZXRlXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUuc2V0V2l0aFByaW9yaXR5ID0gZnVuY3Rpb24gKHBhdGgsIG5ld1ZhbCwgbmV3UHJpb3JpdHksIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5sb2dfKCdzZXQnLCB7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLnRvU3RyaW5nKCksXG4gICAgICAgICAgICB2YWx1ZTogbmV3VmFsLFxuICAgICAgICAgICAgcHJpb3JpdHk6IG5ld1ByaW9yaXR5XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUT0RPOiBPcHRpbWl6ZSB0aGlzIGJlaGF2aW9yIHRvIGVpdGhlciAoYSkgc3RvcmUgZmxhZyB0byBza2lwIHJlc29sdmluZyB3aGVyZSBwb3NzaWJsZSBhbmQgLyBvclxuICAgICAgICAvLyAoYikgc3RvcmUgdW5yZXNvbHZlZCBwYXRocyBvbiBKU09OIHBhcnNlXG4gICAgICAgIHZhciBzZXJ2ZXJWYWx1ZXMgPSB0aGlzLmdlbmVyYXRlU2VydmVyVmFsdWVzKCk7XG4gICAgICAgIHZhciBuZXdOb2RlVW5yZXNvbHZlZCA9IG5vZGVGcm9tSlNPTihuZXdWYWwsIG5ld1ByaW9yaXR5KTtcbiAgICAgICAgdmFyIG5ld05vZGUgPSByZXNvbHZlRGVmZXJyZWRWYWx1ZVNuYXBzaG90KG5ld05vZGVVbnJlc29sdmVkLCBzZXJ2ZXJWYWx1ZXMpO1xuICAgICAgICB2YXIgd3JpdGVJZCA9IHRoaXMuZ2V0TmV4dFdyaXRlSWRfKCk7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLnNlcnZlclN5bmNUcmVlXy5hcHBseVVzZXJPdmVyd3JpdGUocGF0aCwgbmV3Tm9kZSwgd3JpdGVJZCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZV8ucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgICAgICAgdGhpcy5zZXJ2ZXJfLnB1dChwYXRoLnRvU3RyaW5nKCksIG5ld05vZGVVbnJlc29sdmVkLnZhbCgvKmV4cG9ydD0qLyB0cnVlKSwgZnVuY3Rpb24gKHN0YXR1cywgZXJyb3JSZWFzb24pIHtcbiAgICAgICAgICAgIHZhciBzdWNjZXNzID0gc3RhdHVzID09PSAnb2snO1xuICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgd2Fybignc2V0IGF0ICcgKyBwYXRoICsgJyBmYWlsZWQ6ICcgKyBzdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNsZWFyRXZlbnRzID0gX3RoaXMuc2VydmVyU3luY1RyZWVfLmFja1VzZXJXcml0ZSh3cml0ZUlkLCAhc3VjY2Vzcyk7XG4gICAgICAgICAgICBfdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHBhdGgsIGNsZWFyRXZlbnRzKTtcbiAgICAgICAgICAgIF90aGlzLmNhbGxPbkNvbXBsZXRlQ2FsbGJhY2sob25Db21wbGV0ZSwgc3RhdHVzLCBlcnJvclJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYWZmZWN0ZWRQYXRoID0gdGhpcy5hYm9ydFRyYW5zYWN0aW9uc18ocGF0aCk7XG4gICAgICAgIHRoaXMucmVydW5UcmFuc2FjdGlvbnNfKGFmZmVjdGVkUGF0aCk7XG4gICAgICAgIC8vIFdlIHF1ZXVlZCB0aGUgZXZlbnRzIGFib3ZlLCBzbyBqdXN0IGZsdXNoIHRoZSBxdWV1ZSBoZXJlXG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZV8ucmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChhZmZlY3RlZFBhdGgsIFtdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IGNoaWxkcmVuVG9NZXJnZVxuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9uKD9FcnJvciwgKj0pfSBvbkNvbXBsZXRlXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHBhdGgsIGNoaWxkcmVuVG9NZXJnZSwgb25Db21wbGV0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmxvZ18oJ3VwZGF0ZScsIHsgcGF0aDogcGF0aC50b1N0cmluZygpLCB2YWx1ZTogY2hpbGRyZW5Ub01lcmdlIH0pO1xuICAgICAgICAvLyBTdGFydCB3aXRoIG91ciBleGlzdGluZyBkYXRhIGFuZCBtZXJnZSBlYWNoIGNoaWxkIGludG8gaXQuXG4gICAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICAgIHZhciBzZXJ2ZXJWYWx1ZXMgPSB0aGlzLmdlbmVyYXRlU2VydmVyVmFsdWVzKCk7XG4gICAgICAgIHZhciBjaGFuZ2VkQ2hpbGRyZW4gPSB7fTtcbiAgICAgICAgZm9yRWFjaChjaGlsZHJlblRvTWVyZ2UsIGZ1bmN0aW9uIChjaGFuZ2VkS2V5LCBjaGFuZ2VkVmFsdWUpIHtcbiAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZVVucmVzb2x2ZWQgPSBub2RlRnJvbUpTT04oY2hhbmdlZFZhbHVlKTtcbiAgICAgICAgICAgIGNoYW5nZWRDaGlsZHJlbltjaGFuZ2VkS2V5XSA9IHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QobmV3Tm9kZVVucmVzb2x2ZWQsIHNlcnZlclZhbHVlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWVtcHR5KSB7XG4gICAgICAgICAgICB2YXIgd3JpdGVJZF8xID0gdGhpcy5nZXROZXh0V3JpdGVJZF8oKTtcbiAgICAgICAgICAgIHZhciBldmVudHMgPSB0aGlzLnNlcnZlclN5bmNUcmVlXy5hcHBseVVzZXJNZXJnZShwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWRfMSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50UXVldWVfLnF1ZXVlRXZlbnRzKGV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnNlcnZlcl8ubWVyZ2UocGF0aC50b1N0cmluZygpLCBjaGlsZHJlblRvTWVyZ2UsIGZ1bmN0aW9uIChzdGF0dXMsIGVycm9yUmVhc29uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSBzdGF0dXMgPT09ICdvayc7XG4gICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ3VwZGF0ZSBhdCAnICsgcGF0aCArICcgZmFpbGVkOiAnICsgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNsZWFyRXZlbnRzID0gX3RoaXMuc2VydmVyU3luY1RyZWVfLmFja1VzZXJXcml0ZSh3cml0ZUlkXzEsICFzdWNjZXNzKTtcbiAgICAgICAgICAgICAgICB2YXIgYWZmZWN0ZWRQYXRoID0gY2xlYXJFdmVudHMubGVuZ3RoID4gMCA/IF90aGlzLnJlcnVuVHJhbnNhY3Rpb25zXyhwYXRoKSA6IHBhdGg7XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRRdWV1ZV8ucmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChhZmZlY3RlZFBhdGgsIGNsZWFyRXZlbnRzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jYWxsT25Db21wbGV0ZUNhbGxiYWNrKG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3JFYWNoKGNoaWxkcmVuVG9NZXJnZSwgZnVuY3Rpb24gKGNoYW5nZWRQYXRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFmZmVjdGVkUGF0aCA9IF90aGlzLmFib3J0VHJhbnNhY3Rpb25zXyhwYXRoLmNoaWxkKGNoYW5nZWRQYXRoKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVydW5UcmFuc2FjdGlvbnNfKGFmZmVjdGVkUGF0aCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFdlIHF1ZXVlZCB0aGUgZXZlbnRzIGFib3ZlLCBzbyBqdXN0IGZsdXNoIHRoZSBxdWV1ZSBoZXJlXG4gICAgICAgICAgICB0aGlzLmV2ZW50UXVldWVfLnJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocGF0aCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nKFwidXBkYXRlKCkgY2FsbGVkIHdpdGggZW1wdHkgZGF0YS4gIERvbid0IGRvIGFueXRoaW5nLlwiKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbE9uQ29tcGxldGVDYWxsYmFjayhvbkNvbXBsZXRlLCAnb2snKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhbGwgb2YgdGhlIGNoYW5nZXMgc3RvcmVkIHVwIGluIHRoZSBvbkRpc2Nvbm5lY3RfIHRyZWUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS5ydW5PbkRpc2Nvbm5lY3RFdmVudHNfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmxvZ18oJ29uRGlzY29ubmVjdEV2ZW50cycpO1xuICAgICAgICB2YXIgc2VydmVyVmFsdWVzID0gdGhpcy5nZW5lcmF0ZVNlcnZlclZhbHVlcygpO1xuICAgICAgICB2YXIgcmVzb2x2ZWRPbkRpc2Nvbm5lY3RUcmVlID0gcmVzb2x2ZURlZmVycmVkVmFsdWVUcmVlKHRoaXMub25EaXNjb25uZWN0Xywgc2VydmVyVmFsdWVzKTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xuICAgICAgICByZXNvbHZlZE9uRGlzY29ubmVjdFRyZWUuZm9yRWFjaFRyZWUoUGF0aC5FbXB0eSwgZnVuY3Rpb24gKHBhdGgsIHNuYXApIHtcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoX3RoaXMuc2VydmVyU3luY1RyZWVfLmFwcGx5U2VydmVyT3ZlcndyaXRlKHBhdGgsIHNuYXApKTtcbiAgICAgICAgICAgIHZhciBhZmZlY3RlZFBhdGggPSBfdGhpcy5hYm9ydFRyYW5zYWN0aW9uc18ocGF0aCk7XG4gICAgICAgICAgICBfdGhpcy5yZXJ1blRyYW5zYWN0aW9uc18oYWZmZWN0ZWRQYXRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0XyA9IG5ldyBTcGFyc2VTbmFwc2hvdFRyZWUoKTtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKFBhdGguRW1wdHksIGV2ZW50cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb24oP0Vycm9yLCAqPSl9IG9uQ29tcGxldGVcbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS5vbkRpc2Nvbm5lY3RDYW5jZWwgPSBmdW5jdGlvbiAocGF0aCwgb25Db21wbGV0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnNlcnZlcl8ub25EaXNjb25uZWN0Q2FuY2VsKHBhdGgudG9TdHJpbmcoKSwgZnVuY3Rpb24gKHN0YXR1cywgZXJyb3JSZWFzb24pIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkRpc2Nvbm5lY3RfLmZvcmdldChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmNhbGxPbkNvbXBsZXRlQ2FsbGJhY2sob25Db21wbGV0ZSwgc3RhdHVzLCBlcnJvclJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbig/RXJyb3IsICo9KX0gb25Db21wbGV0ZVxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLm9uRGlzY29ubmVjdFNldCA9IGZ1bmN0aW9uIChwYXRoLCB2YWx1ZSwgb25Db21wbGV0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbmV3Tm9kZSA9IG5vZGVGcm9tSlNPTih2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2VydmVyXy5vbkRpc2Nvbm5lY3RQdXQocGF0aC50b1N0cmluZygpLCBuZXdOb2RlLnZhbCgvKmV4cG9ydD0qLyB0cnVlKSwgZnVuY3Rpb24gKHN0YXR1cywgZXJyb3JSZWFzb24pIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkRpc2Nvbm5lY3RfLnJlbWVtYmVyKHBhdGgsIG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuY2FsbE9uQ29tcGxldGVDYWxsYmFjayhvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gcHJpb3JpdHlcbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbig/RXJyb3IsICo9KX0gb25Db21wbGV0ZVxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLm9uRGlzY29ubmVjdFNldFdpdGhQcmlvcml0eSA9IGZ1bmN0aW9uIChwYXRoLCB2YWx1ZSwgcHJpb3JpdHksIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5ld05vZGUgPSBub2RlRnJvbUpTT04odmFsdWUsIHByaW9yaXR5KTtcbiAgICAgICAgdGhpcy5zZXJ2ZXJfLm9uRGlzY29ubmVjdFB1dChwYXRoLnRvU3RyaW5nKCksIG5ld05vZGUudmFsKC8qZXhwb3J0PSovIHRydWUpLCBmdW5jdGlvbiAoc3RhdHVzLCBlcnJvclJlYXNvbikge1xuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uRGlzY29ubmVjdF8ucmVtZW1iZXIocGF0aCwgbmV3Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jYWxsT25Db21wbGV0ZUNhbGxiYWNrKG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyp9IGNoaWxkcmVuVG9NZXJnZVxuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9uKD9FcnJvciwgKj0pfSBvbkNvbXBsZXRlXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUub25EaXNjb25uZWN0VXBkYXRlID0gZnVuY3Rpb24gKHBhdGgsIGNoaWxkcmVuVG9NZXJnZSwgb25Db21wbGV0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoaXNFbXB0eShjaGlsZHJlblRvTWVyZ2UpKSB7XG4gICAgICAgICAgICBsb2coXCJvbkRpc2Nvbm5lY3QoKS51cGRhdGUoKSBjYWxsZWQgd2l0aCBlbXB0eSBkYXRhLiAgRG9uJ3QgZG8gYW55dGhpbmcuXCIpO1xuICAgICAgICAgICAgdGhpcy5jYWxsT25Db21wbGV0ZUNhbGxiYWNrKG9uQ29tcGxldGUsICdvaycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VydmVyXy5vbkRpc2Nvbm5lY3RNZXJnZShwYXRoLnRvU3RyaW5nKCksIGNoaWxkcmVuVG9NZXJnZSwgZnVuY3Rpb24gKHN0YXR1cywgZXJyb3JSZWFzb24pIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKGNoaWxkcmVuVG9NZXJnZSwgZnVuY3Rpb24gKGNoaWxkTmFtZSwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdDaGlsZE5vZGUgPSBub2RlRnJvbUpTT04oY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25EaXNjb25uZWN0Xy5yZW1lbWJlcihwYXRoLmNoaWxkKGNoaWxkTmFtZSksIG5ld0NoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jYWxsT25Db21wbGV0ZUNhbGxiYWNrKG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgICAqIEBwYXJhbSB7IUV2ZW50UmVnaXN0cmF0aW9ufSBldmVudFJlZ2lzdHJhdGlvblxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLmFkZEV2ZW50Q2FsbGJhY2tGb3JRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pIHtcbiAgICAgICAgdmFyIGV2ZW50cztcbiAgICAgICAgaWYgKHF1ZXJ5LnBhdGguZ2V0RnJvbnQoKSA9PT0gJy5pbmZvJykge1xuICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5pbmZvU3luY1RyZWVfLmFkZEV2ZW50UmVnaXN0cmF0aW9uKHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBldmVudHMgPSB0aGlzLnNlcnZlclN5bmNUcmVlXy5hZGRFdmVudFJlZ2lzdHJhdGlvbihxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZV8ucmFpc2VFdmVudHNBdFBhdGgocXVlcnkucGF0aCwgZXZlbnRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgICAqIEBwYXJhbSB7P0V2ZW50UmVnaXN0cmF0aW9ufSBldmVudFJlZ2lzdHJhdGlvblxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLnJlbW92ZUV2ZW50Q2FsbGJhY2tGb3JRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pIHtcbiAgICAgICAgLy8gVGhlc2UgYXJlIGd1YXJhbnRlZWQgbm90IHRvIHJhaXNlIGV2ZW50cywgc2luY2Ugd2UncmUgbm90IHBhc3NpbmcgaW4gYSBjYW5jZWxFcnJvci4gSG93ZXZlciwgd2UgY2FuIGZ1dHVyZS1wcm9vZlxuICAgICAgICAvLyBhIGxpdHRsZSBiaXQgYnkgaGFuZGxpbmcgdGhlIHJldHVybiB2YWx1ZXMgYW55d2F5cy5cbiAgICAgICAgdmFyIGV2ZW50cztcbiAgICAgICAgaWYgKHF1ZXJ5LnBhdGguZ2V0RnJvbnQoKSA9PT0gJy5pbmZvJykge1xuICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5pbmZvU3luY1RyZWVfLnJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBldmVudHMgPSB0aGlzLnNlcnZlclN5bmNUcmVlXy5yZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZV8ucmFpc2VFdmVudHNBdFBhdGgocXVlcnkucGF0aCwgZXZlbnRzKTtcbiAgICB9O1xuICAgIFJlcG8ucHJvdG90eXBlLmludGVycnVwdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVyc2lzdGVudENvbm5lY3Rpb25fKSB7XG4gICAgICAgICAgICB0aGlzLnBlcnNpc3RlbnRDb25uZWN0aW9uXy5pbnRlcnJ1cHQoSU5URVJSVVBUX1JFQVNPTik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlcG8ucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVyc2lzdGVudENvbm5lY3Rpb25fKSB7XG4gICAgICAgICAgICB0aGlzLnBlcnNpc3RlbnRDb25uZWN0aW9uXy5yZXN1bWUoSU5URVJSVVBUX1JFQVNPTik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlcG8ucHJvdG90eXBlLnN0YXRzID0gZnVuY3Rpb24gKHNob3dEZWx0YSkge1xuICAgICAgICBpZiAoc2hvd0RlbHRhID09PSB2b2lkIDApIHsgc2hvd0RlbHRhID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHN0YXRzO1xuICAgICAgICBpZiAoc2hvd0RlbHRhKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhdHNMaXN0ZW5lcl8pXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0c0xpc3RlbmVyXyA9IG5ldyBTdGF0c0xpc3RlbmVyKHRoaXMuc3RhdHNfKTtcbiAgICAgICAgICAgIHN0YXRzID0gdGhpcy5zdGF0c0xpc3RlbmVyXy5nZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRzID0gdGhpcy5zdGF0c18uZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvbmdlc3ROYW1lID0gT2JqZWN0LmtleXMoc3RhdHMpLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoY3VycmVudFZhbHVlLmxlbmd0aCwgcHJldmlvdXNWYWx1ZSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBmb3JFYWNoKHN0YXRzLCBmdW5jdGlvbiAoc3RhdCwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHBhZCBzdGF0IG5hbWVzIHRvIGJlIHRoZSBzYW1lIGxlbmd0aCAocGx1cyAyIGV4dHJhIHNwYWNlcykuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhdC5sZW5ndGg7IGkgPCBsb25nZXN0TmFtZSArIDI7IGkrKylcbiAgICAgICAgICAgICAgICBzdGF0ICs9ICcgJztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0YXQgKyB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVwby5wcm90b3R5cGUuc3RhdHNJbmNyZW1lbnRDb3VudGVyID0gZnVuY3Rpb24gKG1ldHJpYykge1xuICAgICAgICB0aGlzLnN0YXRzXy5pbmNyZW1lbnRDb3VudGVyKG1ldHJpYyk7XG4gICAgICAgIHRoaXMuc3RhdHNSZXBvcnRlcl8uaW5jbHVkZVN0YXQobWV0cmljKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLmxvZ18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YXJfYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyX2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJlZml4ID0gJyc7XG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbnRDb25uZWN0aW9uXykge1xuICAgICAgICAgICAgcHJlZml4ID0gdGhpcy5wZXJzaXN0ZW50Q29ubmVjdGlvbl8uaWQgKyAnOic7XG4gICAgICAgIH1cbiAgICAgICAgbG9nLmFwcGx5KHZvaWQgMCwgW3ByZWZpeF0uY29uY2F0KHZhcl9hcmdzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbig/RXJyb3IsICo9KX0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IHN0YXR1c1xuICAgICAqIEBwYXJhbSB7P3N0cmluZz19IGVycm9yUmVhc29uXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUuY2FsbE9uQ29tcGxldGVDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgc3RhdHVzLCBlcnJvclJlYXNvbikge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGV4Y2VwdGlvbkd1YXJkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09ICdvaycpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29kZSA9IChzdGF0dXMgfHwgJ2Vycm9yJykudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JSZWFzb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9ICc6ICcgKyBlcnJvclJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVwby5wcm90b3R5cGUsIFwiZGF0YWJhc2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YWJhc2UgfHwgKHRoaXMuX19kYXRhYmFzZSA9IG5ldyBEYXRhYmFzZSh0aGlzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBSZXBvO1xufSgpKTtcbmV4cG9ydCB7IFJlcG8gfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9SZXBvLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgZG91YmxlVG9JRUVFNzU0U3RyaW5nLCBzaGExIH0gZnJvbSAnLi4vdXRpbC91dGlsJztcbmltcG9ydCB7IHByaW9yaXR5SGFzaFRleHQsIHZhbGlkYXRlUHJpb3JpdHlOb2RlIH0gZnJvbSAnLi9zbmFwJztcbnZhciBfX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yO1xuLyoqXG4gKiBMZWFmTm9kZSBpcyBhIGNsYXNzIGZvciBzdG9yaW5nIGxlYWYgbm9kZXMgaW4gYSBEYXRhU25hcHNob3QuICBJdFxuICogaW1wbGVtZW50cyBOb2RlIGFuZCBzdG9yZXMgdGhlIHZhbHVlIG9mIHRoZSBub2RlIChhIHN0cmluZyxcbiAqIG51bWJlciwgb3IgYm9vbGVhbikgYWNjZXNzaWJsZSB2aWEgZ2V0VmFsdWUoKS5cbiAqL1xudmFyIExlYWZOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBpbXBsZW1lbnRzIHtOb2RlfVxuICAgICAqIEBwYXJhbSB7IShzdHJpbmd8bnVtYmVyfGJvb2xlYW58T2JqZWN0KX0gdmFsdWVfIFRoZSB2YWx1ZSB0byBzdG9yZSBpbiB0aGlzIGxlYWYgbm9kZS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9iamVjdCB0eXBlIGlzIHBvc3NpYmxlIGluIHRoZSBldmVudCBvZiBhIGRlZmVycmVkIHZhbHVlXG4gICAgICogQHBhcmFtIHshTm9kZT19IHByaW9yaXR5Tm9kZV8gVGhlIHByaW9yaXR5IG9mIHRoaXMgbm9kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMZWFmTm9kZSh2YWx1ZV8sIHByaW9yaXR5Tm9kZV8pIHtcbiAgICAgICAgaWYgKHByaW9yaXR5Tm9kZV8gPT09IHZvaWQgMCkgeyBwcmlvcml0eU5vZGVfID0gTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvci5FTVBUWV9OT0RFOyB9XG4gICAgICAgIHRoaXMudmFsdWVfID0gdmFsdWVfO1xuICAgICAgICB0aGlzLnByaW9yaXR5Tm9kZV8gPSBwcmlvcml0eU5vZGVfO1xuICAgICAgICB0aGlzLmxhenlIYXNoXyA9IG51bGw7XG4gICAgICAgIGFzc2VydCh0aGlzLnZhbHVlXyAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmFsdWVfICE9PSBudWxsLCBcIkxlYWZOb2RlIHNob3VsZG4ndCBiZSBjcmVhdGVkIHdpdGggbnVsbC91bmRlZmluZWQgdmFsdWUuXCIpO1xuICAgICAgICB2YWxpZGF0ZVByaW9yaXR5Tm9kZSh0aGlzLnByaW9yaXR5Tm9kZV8pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGVhZk5vZGUsIFwiX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvciA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmlzTGVhZk5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmdldFByaW9yaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmlvcml0eU5vZGVfO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLnVwZGF0ZVByaW9yaXR5ID0gZnVuY3Rpb24gKG5ld1ByaW9yaXR5Tm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IExlYWZOb2RlKHRoaXMudmFsdWVfLCBuZXdQcmlvcml0eU5vZGUpO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmdldEltbWVkaWF0ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkTmFtZSkge1xuICAgICAgICAvLyBIYWNrIHRvIHRyZWF0IHByaW9yaXR5IGFzIGEgcmVndWxhciBjaGlsZFxuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnLnByaW9yaXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIExlYWZOb2RlLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGF0aC5nZXRGcm9udCgpID09PSAnLnByaW9yaXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmhhc0NoaWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuZ2V0UHJlZGVjZXNzb3JDaGlsZE5hbWUgPSBmdW5jdGlvbiAoY2hpbGROYW1lLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpIHtcbiAgICAgICAgaWYgKGNoaWxkTmFtZSA9PT0gJy5wcmlvcml0eScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVByaW9yaXR5KG5ld0NoaWxkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3Q2hpbGROb2RlLmlzRW1wdHkoKSAmJiBjaGlsZE5hbWUgIT09ICcucHJpb3JpdHknKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREVcbiAgICAgICAgICAgICAgICAudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZVByaW9yaXR5KHRoaXMucHJpb3JpdHlOb2RlXyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIExlYWZOb2RlLnByb3RvdHlwZS51cGRhdGVDaGlsZCA9IGZ1bmN0aW9uIChwYXRoLCBuZXdDaGlsZE5vZGUpIHtcbiAgICAgICAgdmFyIGZyb250ID0gcGF0aC5nZXRGcm9udCgpO1xuICAgICAgICBpZiAoZnJvbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3Q2hpbGROb2RlLmlzRW1wdHkoKSAmJiBmcm9udCAhPT0gJy5wcmlvcml0eScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0KGZyb250ICE9PSAnLnByaW9yaXR5JyB8fCBwYXRoLmdldExlbmd0aCgpID09PSAxLCAnLnByaW9yaXR5IG11c3QgYmUgdGhlIGxhc3QgdG9rZW4gaW4gYSBwYXRoJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVJbW1lZGlhdGVDaGlsZChmcm9udCwgTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvci5FTVBUWV9OT0RFLnVwZGF0ZUNoaWxkKHBhdGgucG9wRnJvbnQoKSwgbmV3Q2hpbGROb2RlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIExlYWZOb2RlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUubnVtQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIChpbmRleCwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLnZhbCA9IGZ1bmN0aW9uIChleHBvcnRGb3JtYXQpIHtcbiAgICAgICAgaWYgKGV4cG9ydEZvcm1hdCAmJiAhdGhpcy5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKSlcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJy52YWx1ZSc6IHRoaXMuZ2V0VmFsdWUoKSxcbiAgICAgICAgICAgICAgICAnLnByaW9yaXR5JzogdGhpcy5nZXRQcmlvcml0eSgpLnZhbCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSgpO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxhenlIYXNoXyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHRvSGFzaCA9ICcnO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByaW9yaXR5Tm9kZV8uaXNFbXB0eSgpKVxuICAgICAgICAgICAgICAgIHRvSGFzaCArPVxuICAgICAgICAgICAgICAgICAgICAncHJpb3JpdHk6JyArXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eUhhc2hUZXh0KHRoaXMucHJpb3JpdHlOb2RlXy52YWwoKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzonO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdGhpcy52YWx1ZV87XG4gICAgICAgICAgICB0b0hhc2ggKz0gdHlwZSArICc6JztcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRvSGFzaCArPSBkb3VibGVUb0lFRUU3NTRTdHJpbmcodGhpcy52YWx1ZV8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9IYXNoICs9IHRoaXMudmFsdWVfO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSBzaGExKHRvSGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGF6eUhhc2hfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGxlYWYgbm9kZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R8c3RyaW5nfG51bWJlcnxib29sZWFufSBUaGUgdmFsdWUgb2YgdGhlIG5vZGUuXG4gICAgICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZV87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIExlYWZOb2RlLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09PSBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG90aGVyIGluc3RhbmNlb2YgTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0KG90aGVyLmlzTGVhZk5vZGUoKSwgJ1Vua25vd24gbm9kZSB0eXBlJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlVG9MZWFmTm9kZV8ob3RoZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wYXJpc29uIHNwZWNpZmljYWxseSBmb3IgdHdvIGxlYWYgbm9kZXNcbiAgICAgKiBAcGFyYW0geyFMZWFmTm9kZX0gb3RoZXJMZWFmXG4gICAgICogQHJldHVybiB7IW51bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIExlYWZOb2RlLnByb3RvdHlwZS5jb21wYXJlVG9MZWFmTm9kZV8gPSBmdW5jdGlvbiAob3RoZXJMZWFmKSB7XG4gICAgICAgIHZhciBvdGhlckxlYWZUeXBlID0gdHlwZW9mIG90aGVyTGVhZi52YWx1ZV87XG4gICAgICAgIHZhciB0aGlzTGVhZlR5cGUgPSB0eXBlb2YgdGhpcy52YWx1ZV87XG4gICAgICAgIHZhciBvdGhlckluZGV4ID0gTGVhZk5vZGUuVkFMVUVfVFlQRV9PUkRFUi5pbmRleE9mKG90aGVyTGVhZlR5cGUpO1xuICAgICAgICB2YXIgdGhpc0luZGV4ID0gTGVhZk5vZGUuVkFMVUVfVFlQRV9PUkRFUi5pbmRleE9mKHRoaXNMZWFmVHlwZSk7XG4gICAgICAgIGFzc2VydChvdGhlckluZGV4ID49IDAsICdVbmtub3duIGxlYWYgdHlwZTogJyArIG90aGVyTGVhZlR5cGUpO1xuICAgICAgICBhc3NlcnQodGhpc0luZGV4ID49IDAsICdVbmtub3duIGxlYWYgdHlwZTogJyArIHRoaXNMZWFmVHlwZSk7XG4gICAgICAgIGlmIChvdGhlckluZGV4ID09PSB0aGlzSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIFNhbWUgdHlwZSwgY29tcGFyZSB2YWx1ZXNcbiAgICAgICAgICAgIGlmICh0aGlzTGVhZlR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVmZXJyZWQgdmFsdWUgbm9kZXMgYXJlIGFsbCBlcXVhbCwgYnV0IHdlIHNob3VsZCBhbHNvIG5ldmVyIGdldCB0byB0aGlzIHBvaW50Li4uXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyB3b3JrcyBiZWNhdXNlIHRydWUgPiBmYWxzZSwgYWxsIG90aGVycyBhcmUgbnVtYmVyIG9yIHN0cmluZyBjb21wYXJpc29uc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlXyA8IG90aGVyTGVhZi52YWx1ZV8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnZhbHVlXyA9PT0gb3RoZXJMZWFmLnZhbHVlXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzSW5kZXggLSBvdGhlckluZGV4O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIExlYWZOb2RlLnByb3RvdHlwZS53aXRoSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuaXNJbmRleGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGluaGVyaXREb2NcbiAgICAgICAgICovXG4gICAgICAgIGlmIChvdGhlciA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIuaXNMZWFmTm9kZSgpKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJMZWFmID0gb3RoZXI7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMudmFsdWVfID09PSBvdGhlckxlYWYudmFsdWVfICYmXG4gICAgICAgICAgICAgICAgdGhpcy5wcmlvcml0eU5vZGVfLmVxdWFscyhvdGhlckxlYWYucHJpb3JpdHlOb2RlXykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgc29ydCBvcmRlciBmb3IgY29tcGFyaW5nIGxlYWYgbm9kZXMgb2YgZGlmZmVyZW50IHR5cGVzLiBJZiB0d28gbGVhZiBub2RlcyBoYXZlXG4gICAgICogdGhlIHNhbWUgdHlwZSwgdGhlIGNvbXBhcmlzb24gZmFsbHMgYmFjayB0byB0aGVpciB2YWx1ZVxuICAgICAqIEB0eXBlIHtBcnJheS48IXN0cmluZz59XG4gICAgICogQGNvbnN0XG4gICAgICovXG4gICAgTGVhZk5vZGUuVkFMVUVfVFlQRV9PUkRFUiA9IFsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ3N0cmluZyddO1xuICAgIHJldHVybiBMZWFmTm9kZTtcbn0oKSk7XG5leHBvcnQgeyBMZWFmTm9kZSB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3NuYXAvTGVhZk5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBOYW1lZE5vZGUgfSBmcm9tICcuLi9Ob2RlJztcbmltcG9ydCB7IE1JTl9OQU1FIH0gZnJvbSAnLi4vLi4vdXRpbC91dGlsJztcbi8qKlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgSW5kZXggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5kZXgoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9uKCFOYW1lZE5vZGUsICFOYW1lZE5vZGUpOm51bWJlcn0gQSBzdGFuZGFsb25lIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yXG4gICAgICogdGhpcyBpbmRleFxuICAgICAqL1xuICAgIEluZGV4LnByb3RvdHlwZS5nZXRDb21wYXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlLmJpbmQodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGJlZm9yZSBhbmQgYWZ0ZXIgdmFsdWUgZm9yIGEgbm9kZSwgZGV0ZXJtaW5lIGlmIHRoZSBpbmRleGVkIHZhbHVlIGhhcyBjaGFuZ2VkLiBFdmVuIGlmIHRoZXkgYXJlIGRpZmZlcmVudCxcbiAgICAgKiBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGNoYW5nZXMgYXJlIGlzb2xhdGVkIHRvIHBhcnRzIG9mIHRoZSBzbmFwc2hvdCB0aGF0IGFyZSBub3QgaW5kZXhlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG9sZE5vZGVcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBuZXdOb2RlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcG9ydGlvbiBvZiB0aGUgc25hcHNob3QgYmVpbmcgaW5kZXhlZCBjaGFuZ2VkIGJldHdlZW4gb2xkTm9kZSBhbmQgbmV3Tm9kZVxuICAgICAqL1xuICAgIEluZGV4LnByb3RvdHlwZS5pbmRleGVkVmFsdWVDaGFuZ2VkID0gZnVuY3Rpb24gKG9sZE5vZGUsIG5ld05vZGUpIHtcbiAgICAgICAgdmFyIG9sZFdyYXBwZWQgPSBuZXcgTmFtZWROb2RlKE1JTl9OQU1FLCBvbGROb2RlKTtcbiAgICAgICAgdmFyIG5ld1dyYXBwZWQgPSBuZXcgTmFtZWROb2RlKE1JTl9OQU1FLCBuZXdOb2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShvbGRXcmFwcGVkLCBuZXdXcmFwcGVkKSAhPT0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFOYW1lZE5vZGV9IGEgbm9kZSB3cmFwcGVyIHRoYXQgd2lsbCBzb3J0IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxuICAgICAqIGFueSBvdGhlciBub2RlIHdyYXBwZXIsIHVzaW5nIHRoaXMgaW5kZXhcbiAgICAgKi9cbiAgICBJbmRleC5wcm90b3R5cGUubWluUG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NSU47XG4gICAgfTtcbiAgICByZXR1cm4gSW5kZXg7XG59KCkpO1xuZXhwb3J0IHsgSW5kZXggfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9zbmFwL2luZGV4ZXMvSW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBET01TdG9yYWdlV3JhcHBlciB9IGZyb20gJy4vRE9NU3RvcmFnZVdyYXBwZXInO1xuaW1wb3J0IHsgTWVtb3J5U3RvcmFnZSB9IGZyb20gJy4vTWVtb3J5U3RvcmFnZSc7XG4vKipcbiAqIEhlbHBlciB0byBjcmVhdGUgYSBET01TdG9yYWdlV3JhcHBlciBvciBlbHNlIGZhbGwgYmFjayB0byBNZW1vcnlTdG9yYWdlLlxuICogVE9ETzogT25jZSBNZW1vcnlTdG9yYWdlIGFuZCBET01TdG9yYWdlV3JhcHBlciBoYXZlIGEgc2hhcmVkIGludGVyZmFjZSB0aGlzIG1ldGhvZCBhbm5vdGF0aW9uIHNob3VsZCBjaGFuZ2VcbiAqIHRvIHJlZmxlY3QgdGhpcyB0eXBlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRvbVN0b3JhZ2VOYW1lIE5hbWUgb2YgdGhlIHVuZGVybHlpbmcgc3RvcmFnZSBvYmplY3RcbiAqICAgKGUuZy4gJ2xvY2FsU3RvcmFnZScgb3IgJ3Nlc3Npb25TdG9yYWdlJykuXG4gKiBAcmV0dXJuIHs/fSBUdXJuaW5nIG9mZiB0eXBlIGluZm9ybWF0aW9uIHVudGlsIGEgY29tbW9uIGludGVyZmFjZSBpcyBkZWZpbmVkLlxuICovXG52YXIgY3JlYXRlU3RvcmFnZWZvciA9IGZ1bmN0aW9uIChkb21TdG9yYWdlTmFtZSkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIE5PVEU6IGp1c3QgYWNjZXNzaW5nIFwibG9jYWxTdG9yYWdlXCIgb3IgXCJ3aW5kb3dbJ2xvY2FsU3RvcmFnZSddXCIgbWF5IHRocm93IGEgc2VjdXJpdHkgZXhjZXB0aW9uLFxuICAgICAgICAvLyBzbyBpdCBtdXN0IGJlIGluc2lkZSB0aGUgdHJ5L2NhdGNoLlxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3dbZG9tU3RvcmFnZU5hbWVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gTmVlZCB0byB0ZXN0IGNhY2hlLiBKdXN0IGJlY2F1c2UgaXQncyBoZXJlIGRvZXNuJ3QgbWVhbiBpdCB3b3Jrc1xuICAgICAgICAgICAgdmFyIGRvbVN0b3JhZ2UgPSB3aW5kb3dbZG9tU3RvcmFnZU5hbWVdO1xuICAgICAgICAgICAgZG9tU3RvcmFnZS5zZXRJdGVtKCdmaXJlYmFzZTpzZW50aW5lbCcsICdjYWNoZScpO1xuICAgICAgICAgICAgZG9tU3RvcmFnZS5yZW1vdmVJdGVtKCdmaXJlYmFzZTpzZW50aW5lbCcpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBET01TdG9yYWdlV3JhcHBlcihkb21TdG9yYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgLy8gRmFpbGVkIHRvIGNyZWF0ZSB3cmFwcGVyLiAgSnVzdCByZXR1cm4gaW4tbWVtb3J5IHN0b3JhZ2UuXG4gICAgLy8gVE9ETzogbG9nP1xuICAgIHJldHVybiBuZXcgTWVtb3J5U3RvcmFnZSgpO1xufTtcbi8qKiBBIHN0b3JhZ2Ugb2JqZWN0IHRoYXQgbGFzdHMgYWNyb3NzIHNlc3Npb25zICovXG5leHBvcnQgdmFyIFBlcnNpc3RlbnRTdG9yYWdlID0gY3JlYXRlU3RvcmFnZWZvcignbG9jYWxTdG9yYWdlJyk7XG4vKiogQSBzdG9yYWdlIG9iamVjdCB0aGF0IG9ubHkgbGFzdHMgb25lIHNlc3Npb24gKi9cbmV4cG9ydCB2YXIgU2Vzc2lvblN0b3JhZ2UgPSBjcmVhdGVTdG9yYWdlZm9yKCdzZXNzaW9uU3RvcmFnZScpO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3N0b3JhZ2Uvc3RvcmFnZS5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQW4gaXRlcmF0b3Igb3ZlciBhbiBMTFJCTm9kZS5cbiAqL1xudmFyIFNvcnRlZE1hcEl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBLLCBWLCBUXG4gICAgICogQHBhcmFtIHtMTFJCTm9kZXxMTFJCRW1wdHlOb2RlfSBub2RlIE5vZGUgdG8gaXRlcmF0ZS5cbiAgICAgKiBAcGFyYW0gez9LfSBzdGFydEtleVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oSywgSyk6IG51bWJlcn0gY29tcGFyYXRvclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSZXZlcnNlXyBXaGV0aGVyIG9yIG5vdCB0byBpdGVyYXRlIGluIHJldmVyc2VcbiAgICAgKiBAcGFyYW0geyhmdW5jdGlvbihLLCBWKTpUKT19IHJlc3VsdEdlbmVyYXRvcl9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTb3J0ZWRNYXBJdGVyYXRvcihub2RlLCBzdGFydEtleSwgY29tcGFyYXRvciwgaXNSZXZlcnNlXywgcmVzdWx0R2VuZXJhdG9yXykge1xuICAgICAgICBpZiAocmVzdWx0R2VuZXJhdG9yXyA9PT0gdm9pZCAwKSB7IHJlc3VsdEdlbmVyYXRvcl8gPSBudWxsOyB9XG4gICAgICAgIHRoaXMuaXNSZXZlcnNlXyA9IGlzUmV2ZXJzZV87XG4gICAgICAgIHRoaXMucmVzdWx0R2VuZXJhdG9yXyA9IHJlc3VsdEdlbmVyYXRvcl87XG4gICAgICAgIC8qKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPCFMTFJCTm9kZT59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vZGVTdGFja18gPSBbXTtcbiAgICAgICAgdmFyIGNtcCA9IDE7XG4gICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlO1xuICAgICAgICAgICAgY21wID0gc3RhcnRLZXkgPyBjb21wYXJhdG9yKG5vZGUua2V5LCBzdGFydEtleSkgOiAxO1xuICAgICAgICAgICAgLy8gZmxpcCB0aGUgY29tcGFyaXNvbiBpZiB3ZSdyZSBnb2luZyBpbiByZXZlcnNlXG4gICAgICAgICAgICBpZiAoaXNSZXZlcnNlXylcbiAgICAgICAgICAgICAgICBjbXAgKj0gLTE7XG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBsZXNzIHRoYW4gb3VyIHN0YXJ0IGtleS4gaWdub3JlIGl0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXZlcnNlXykge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGV4YWN0bHkgZXF1YWwgdG8gb3VyIHN0YXJ0IGtleS4gUHVzaCBpdCBvbiB0aGUgc3RhY2ssIGJ1dCBzdG9wIGl0ZXJhdGluZztcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFja18ucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBncmVhdGVyIHRoYW4gb3VyIHN0YXJ0IGtleSwgYWRkIGl0IHRvIHRoZSBzdGFjayBhbmQgbW92ZSB0byB0aGUgbmV4dCBvbmVcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFja18ucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1JldmVyc2VfKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgU29ydGVkTWFwSXRlcmF0b3IucHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVTdGFja18ubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlU3RhY2tfLnBvcCgpO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAodGhpcy5yZXN1bHRHZW5lcmF0b3JfKVxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5yZXN1bHRHZW5lcmF0b3JfKG5vZGUua2V5LCBub2RlLnZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzdWx0ID0geyBrZXk6IG5vZGUua2V5LCB2YWx1ZTogbm9kZS52YWx1ZSB9O1xuICAgICAgICBpZiAodGhpcy5pc1JldmVyc2VfKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrXy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2tfLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgU29ydGVkTWFwSXRlcmF0b3IucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVTdGFja18ubGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIFNvcnRlZE1hcEl0ZXJhdG9yLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlU3RhY2tfLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZVN0YWNrX1t0aGlzLm5vZGVTdGFja18ubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdEdlbmVyYXRvcl8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdEdlbmVyYXRvcl8obm9kZS5rZXksIG5vZGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBub2RlLmtleSwgdmFsdWU6IG5vZGUudmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNvcnRlZE1hcEl0ZXJhdG9yO1xufSgpKTtcbmV4cG9ydCB7IFNvcnRlZE1hcEl0ZXJhdG9yIH07XG4vKipcbiAqIFJlcHJlc2VudHMgYSBub2RlIGluIGEgTGVmdC1sZWFuaW5nIFJlZC1CbGFjayB0cmVlLlxuICovXG52YXIgTExSQk5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIEssIFZcbiAgICAgKiBAcGFyYW0geyFLfSBrZXkgS2V5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUuXG4gICAgICogQHBhcmFtIHshVn0gdmFsdWUgVmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZS5cbiAgICAgKiBAcGFyYW0gez9ib29sZWFufSBjb2xvciBXaGV0aGVyIHRoaXMgbm9kZSBpcyByZWQuXG4gICAgICogQHBhcmFtIHs/KExMUkJOb2RlfExMUkJFbXB0eU5vZGUpPX0gbGVmdCBMZWZ0IGNoaWxkLlxuICAgICAqIEBwYXJhbSB7PyhMTFJCTm9kZXxMTFJCRW1wdHlOb2RlKT19IHJpZ2h0IFJpZ2h0IGNoaWxkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExMUkJOb2RlKGtleSwgdmFsdWUsIGNvbG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3IgIT0gbnVsbCA/IGNvbG9yIDogTExSQk5vZGUuUkVEO1xuICAgICAgICB0aGlzLmxlZnQgPVxuICAgICAgICAgICAgbGVmdCAhPSBudWxsID8gbGVmdCA6IFNvcnRlZE1hcC5FTVBUWV9OT0RFO1xuICAgICAgICB0aGlzLnJpZ2h0ID1cbiAgICAgICAgICAgIHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IFNvcnRlZE1hcC5FTVBUWV9OT0RFO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBub2RlLCBvcHRpb25hbGx5IHJlcGxhY2luZyBwaWVjZXMgb2YgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9LfSBrZXkgTmV3IGtleSBmb3IgdGhlIG5vZGUsIG9yIG51bGwuXG4gICAgICogQHBhcmFtIHs/Vn0gdmFsdWUgTmV3IHZhbHVlIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cbiAgICAgKiBAcGFyYW0gez9ib29sZWFufSBjb2xvciBOZXcgY29sb3IgZm9yIHRoZSBub2RlLCBvciBudWxsLlxuICAgICAqIEBwYXJhbSB7P0xMUkJOb2RlfExMUkJFbXB0eU5vZGV9IGxlZnQgTmV3IGxlZnQgY2hpbGQgZm9yIHRoZSBub2RlLCBvciBudWxsLlxuICAgICAqIEBwYXJhbSB7P0xMUkJOb2RlfExMUkJFbXB0eU5vZGV9IHJpZ2h0IE5ldyByaWdodCBjaGlsZCBmb3IgdGhlIG5vZGUsIG9yIG51bGwuXG4gICAgICogQHJldHVybiB7IUxMUkJOb2RlfSBUaGUgbm9kZSBjb3B5LlxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGNvbG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gbmV3IExMUkJOb2RlKGtleSAhPSBudWxsID8ga2V5IDogdGhpcy5rZXksIHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHRoaXMudmFsdWUsIGNvbG9yICE9IG51bGwgPyBjb2xvciA6IHRoaXMuY29sb3IsIGxlZnQgIT0gbnVsbCA/IGxlZnQgOiB0aGlzLmxlZnQsIHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IHRoaXMucmlnaHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdG90YWwgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSB0cmVlLlxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5jb3VudCgpICsgMSArIHRoaXMucmlnaHQuY291bnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHRyZWUgaXMgZW1wdHkuXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXG4gICAgICogZm9yIGVhY2ggbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUssICFWKToqfSBhY3Rpb24gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoXG4gICAgICogICBub2RlLiAgSWYgaXQgcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XG4gICAgICogICB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb25cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUuaW5vcmRlclRyYXZlcnNhbCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxlZnQuaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHx8XG4gICAgICAgICAgICBhY3Rpb24odGhpcy5rZXksIHRoaXMudmFsdWUpIHx8XG4gICAgICAgICAgICB0aGlzLnJpZ2h0Lmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXG4gICAgICogZm9yIGVhY2ggbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIU9iamVjdCwgIU9iamVjdCl9IGFjdGlvbiBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcbiAgICAgKiBub2RlLiAgSWYgaXQgcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cbiAgICAgKiBAcmV0dXJuIHsqfSBUcnVlIGlmIHRyYXZlcnNhbCB3YXMgYWJvcnRlZC5cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUucmV2ZXJzZVRyYXZlcnNhbCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnJpZ2h0LnJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB8fFxuICAgICAgICAgICAgYWN0aW9uKHRoaXMua2V5LCB0aGlzLnZhbHVlKSB8fFxuICAgICAgICAgICAgdGhpcy5sZWZ0LnJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshT2JqZWN0fSBUaGUgbWluaW11bSBub2RlIGluIHRoZSB0cmVlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLm1pbl8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxlZnQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQubWluXygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshS30gVGhlIG1heGltdW0ga2V5IGluIHRoZSB0cmVlLlxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5taW5LZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbl8oKS5rZXk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshS30gVGhlIG1heGltdW0ga2V5IGluIHRoZSB0cmVlLlxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5tYXhLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJpZ2h0LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQubWF4S2V5KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBrZXkgS2V5IHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IHZhbHVlIFZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0ge0NvbXBhcmF0b3J9IGNvbXBhcmF0b3IgQ29tcGFyYXRvci5cbiAgICAgKiBAcmV0dXJuIHshTExSQk5vZGV9IE5ldyB0cmVlLCB3aXRoIHRoZSBrZXkvdmFsdWUgYWRkZWQuXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gICAgICAgIHZhciBjbXAsIG47XG4gICAgICAgIG4gPSB0aGlzO1xuICAgICAgICBjbXAgPSBjb21wYXJhdG9yKGtleSwgbi5rZXkpO1xuICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBuLmxlZnQuaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgdmFsdWUsIG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0Lmluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG4uZml4VXBfKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4geyFMTFJCTm9kZXxMTFJCRW1wdHlOb2RlfSBOZXcgdHJlZSwgd2l0aCB0aGUgbWluaW11bSBrZXkgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUucmVtb3ZlTWluXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVmdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBTb3J0ZWRNYXAuRU1QVFlfTk9ERTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbiA9IHRoaXM7XG4gICAgICAgIGlmICghbi5sZWZ0LmlzUmVkXygpICYmICFuLmxlZnQubGVmdC5pc1JlZF8oKSlcbiAgICAgICAgICAgIG4gPSBuLm1vdmVSZWRMZWZ0XygpO1xuICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmVNaW5fKCksIG51bGwpO1xuICAgICAgICByZXR1cm4gbi5maXhVcF8oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0ga2V5IFRoZSBrZXkgb2YgdGhlIGl0ZW0gdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7Q29tcGFyYXRvcn0gY29tcGFyYXRvciBDb21wYXJhdG9yLlxuICAgICAqIEByZXR1cm4geyFMTFJCTm9kZXxMTFJCRW1wdHlOb2RlfSBOZXcgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGl0ZW0gcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSwgY29tcGFyYXRvcikge1xuICAgICAgICB2YXIgbiwgc21hbGxlc3Q7XG4gICAgICAgIG4gPSB0aGlzO1xuICAgICAgICBpZiAoY29tcGFyYXRvcihrZXksIG4ua2V5KSA8IDApIHtcbiAgICAgICAgICAgIGlmICghbi5sZWZ0LmlzRW1wdHkoKSAmJiAhbi5sZWZ0LmlzUmVkXygpICYmICFuLmxlZnQubGVmdC5pc1JlZF8oKSkge1xuICAgICAgICAgICAgICAgIG4gPSBuLm1vdmVSZWRMZWZ0XygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBuLmxlZnQucmVtb3ZlKGtleSwgY29tcGFyYXRvciksIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG4ubGVmdC5pc1JlZF8oKSlcbiAgICAgICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodF8oKTtcbiAgICAgICAgICAgIGlmICghbi5yaWdodC5pc0VtcHR5KCkgJiYgIW4ucmlnaHQuaXNSZWRfKCkgJiYgIW4ucmlnaHQubGVmdC5pc1JlZF8oKSkge1xuICAgICAgICAgICAgICAgIG4gPSBuLm1vdmVSZWRSaWdodF8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKGtleSwgbi5rZXkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4ucmlnaHQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTb3J0ZWRNYXAuRU1QVFlfTk9ERTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXN0ID0gbi5yaWdodC5taW5fKCk7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBuLmNvcHkoc21hbGxlc3Qua2V5LCBzbWFsbGVzdC52YWx1ZSwgbnVsbCwgbnVsbCwgbi5yaWdodC5yZW1vdmVNaW5fKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5yZW1vdmUoa2V5LCBjb21wYXJhdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG4uZml4VXBfKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBpcyBhIFJFRCBub2RlLlxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5pc1JlZF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHshTExSQk5vZGV9IE5ldyB0cmVlIGFmdGVyIHBlcmZvcm1pbmcgYW55IG5lZWRlZCByb3RhdGlvbnMuXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLmZpeFVwXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzO1xuICAgICAgICBpZiAobi5yaWdodC5pc1JlZF8oKSAmJiAhbi5sZWZ0LmlzUmVkXygpKVxuICAgICAgICAgICAgbiA9IG4ucm90YXRlTGVmdF8oKTtcbiAgICAgICAgaWYgKG4ubGVmdC5pc1JlZF8oKSAmJiBuLmxlZnQubGVmdC5pc1JlZF8oKSlcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0XygpO1xuICAgICAgICBpZiAobi5sZWZ0LmlzUmVkXygpICYmIG4ucmlnaHQuaXNSZWRfKCkpXG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXBfKCk7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHshTExSQk5vZGV9IE5ldyB0cmVlLCBhZnRlciBtb3ZlUmVkTGVmdC5cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUubW92ZVJlZExlZnRfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuY29sb3JGbGlwXygpO1xuICAgICAgICBpZiAobi5yaWdodC5sZWZ0LmlzUmVkXygpKSB7XG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG4ucmlnaHQucm90YXRlUmlnaHRfKCkpO1xuICAgICAgICAgICAgbiA9IG4ucm90YXRlTGVmdF8oKTtcbiAgICAgICAgICAgIG4gPSBuLmNvbG9yRmxpcF8oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7IUxMUkJOb2RlfSBOZXcgdHJlZSwgYWZ0ZXIgbW92ZVJlZFJpZ2h0LlxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5tb3ZlUmVkUmlnaHRfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuY29sb3JGbGlwXygpO1xuICAgICAgICBpZiAobi5sZWZ0LmxlZnQuaXNSZWRfKCkpIHtcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0XygpO1xuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwXygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHshTExSQk5vZGV9IE5ldyB0cmVlLCBhZnRlciByb3RhdGVMZWZ0LlxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5yb3RhdGVMZWZ0XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5sID0gdGhpcy5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLlJFRCwgbnVsbCwgdGhpcy5yaWdodC5sZWZ0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQuY29weShudWxsLCBudWxsLCB0aGlzLmNvbG9yLCBubCwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4geyFMTFJCTm9kZX0gTmV3IHRyZWUsIGFmdGVyIHJvdGF0ZVJpZ2h0LlxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5yb3RhdGVSaWdodF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuciA9IHRoaXMuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5SRUQsIHRoaXMubGVmdC5yaWdodCwgbnVsbCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuY29weShudWxsLCBudWxsLCB0aGlzLmNvbG9yLCBudWxsLCBucik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4geyFMTFJCTm9kZX0gTmV3IHRyZWUsIGFmdGVyIGNvbG9yRmxpcC5cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUuY29sb3JGbGlwXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmxlZnQuY29weShudWxsLCBudWxsLCAhdGhpcy5sZWZ0LmNvbG9yLCBudWxsLCBudWxsKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsICF0aGlzLnJpZ2h0LmNvbG9yLCBudWxsLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weShudWxsLCBudWxsLCAhdGhpcy5jb2xvciwgbGVmdCwgcmlnaHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9yIHRlc3RpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYWxsIGlzIHdlbGwuXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLmNoZWNrTWF4RGVwdGhfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmxhY2tEZXB0aCA9IHRoaXMuY2hlY2tfKCk7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdygyLjAsIGJsYWNrRGVwdGgpIDw9IHRoaXMuY291bnQoKSArIDE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gTm90IHN1cmUgd2hhdCB0aGlzIHJldHVybnMgZXhhY3RseS4gOi0pLlxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5jaGVja18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBibGFja0RlcHRoO1xuICAgICAgICBpZiAodGhpcy5pc1JlZF8oKSAmJiB0aGlzLmxlZnQuaXNSZWRfKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVkIG5vZGUgaGFzIHJlZCBjaGlsZCgnICsgdGhpcy5rZXkgKyAnLCcgKyB0aGlzLnZhbHVlICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yaWdodC5pc1JlZF8oKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSaWdodCBjaGlsZCBvZiAoJyArIHRoaXMua2V5ICsgJywnICsgdGhpcy52YWx1ZSArICcpIGlzIHJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGJsYWNrRGVwdGggPSB0aGlzLmxlZnQuY2hlY2tfKCk7XG4gICAgICAgIGlmIChibGFja0RlcHRoICE9PSB0aGlzLnJpZ2h0LmNoZWNrXygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JsYWNrIGRlcHRocyBkaWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBibGFja0RlcHRoICsgKHRoaXMuaXNSZWRfKCkgPyAwIDogMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExMUkJOb2RlLlJFRCA9IHRydWU7XG4gICAgTExSQk5vZGUuQkxBQ0sgPSBmYWxzZTtcbiAgICByZXR1cm4gTExSQk5vZGU7XG59KCkpO1xuZXhwb3J0IHsgTExSQk5vZGUgfTtcbi8qKlxuICogUmVwcmVzZW50cyBhbiBlbXB0eSBub2RlIChhIGxlYWYgbm9kZSBpbiB0aGUgUmVkLUJsYWNrIFRyZWUpLlxuICovXG52YXIgTExSQkVtcHR5Tm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMTFJCRW1wdHlOb2RlKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBub2RlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IUxMUkJFbXB0eU5vZGV9IFRoZSBub2RlIGNvcHkuXG4gICAgICovXG4gICAgTExSQkVtcHR5Tm9kZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS92YWx1ZSBhZGRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUt9IGtleSBLZXkgdG8gYmUgYWRkZWQuXG4gICAgICogQHBhcmFtIHshVn0gdmFsdWUgVmFsdWUgdG8gYmUgYWRkZWQuXG4gICAgICogQHBhcmFtIHtDb21wYXJhdG9yfSBjb21wYXJhdG9yIENvbXBhcmF0b3IuXG4gICAgICogQHJldHVybiB7IUxMUkJOb2RlfSBOZXcgdHJlZSwgd2l0aCBpdGVtIGFkZGVkLlxuICAgICAqL1xuICAgIExMUkJFbXB0eU5vZGUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5LCB2YWx1ZSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSByZW1vdmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshS30ga2V5IFRoZSBrZXkgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7Q29tcGFyYXRvcn0gY29tcGFyYXRvciBDb21wYXJhdG9yLlxuICAgICAqIEByZXR1cm4geyFMTFJCRW1wdHlOb2RlfSBOZXcgdHJlZSwgd2l0aCBpdGVtIHJlbW92ZWQuXG4gICAgICovXG4gICAgTExSQkVtcHR5Tm9kZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSwgY29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBpbiB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBMTFJCRW1wdHlOb2RlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB0cmVlIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIExMUkJFbXB0eU5vZGUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhdmVyc2VzIHRoZSB0cmVlIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cbiAgICAgKiBmb3IgZWFjaCBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbighSywgIVYpOip9IGFjdGlvbiBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcbiAgICAgKiBub2RlLiAgSWYgaXQgcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRyYXZlcnNhbCB3YXMgYWJvcnRlZC5cbiAgICAgKi9cbiAgICBMTFJCRW1wdHlOb2RlLnByb3RvdHlwZS5pbm9yZGVyVHJhdmVyc2FsID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXG4gICAgICogZm9yIGVhY2ggbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUssICFWKX0gYWN0aW9uIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaFxuICAgICAqIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdHJhdmVyc2FsIHdhcyBhYm9ydGVkLlxuICAgICAqL1xuICAgIExMUkJFbXB0eU5vZGUucHJvdG90eXBlLnJldmVyc2VUcmF2ZXJzYWwgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bGx9XG4gICAgICovXG4gICAgTExSQkVtcHR5Tm9kZS5wcm90b3R5cGUubWluS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bGx9XG4gICAgICovXG4gICAgTExSQkVtcHR5Tm9kZS5wcm90b3R5cGUubWF4S2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBOb3Qgc3VyZSB3aGF0IHRoaXMgcmV0dXJucyBleGFjdGx5LiA6LSkuXG4gICAgICovXG4gICAgTExSQkVtcHR5Tm9kZS5wcm90b3R5cGUuY2hlY2tfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIG5vZGUgaXMgcmVkLlxuICAgICAqL1xuICAgIExMUkJFbXB0eU5vZGUucHJvdG90eXBlLmlzUmVkXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIExMUkJFbXB0eU5vZGU7XG59KCkpO1xuZXhwb3J0IHsgTExSQkVtcHR5Tm9kZSB9O1xuLyoqXG4gKiBBbiBpbW11dGFibGUgc29ydGVkIG1hcCBpbXBsZW1lbnRhdGlvbiwgYmFzZWQgb24gYSBMZWZ0LWxlYW5pbmcgUmVkLUJsYWNrXG4gKiB0cmVlLlxuICovXG52YXIgU29ydGVkTWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBLLCBWXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihLLCBLKTpudW1iZXJ9IGNvbXBhcmF0b3JfIEtleSBjb21wYXJhdG9yLlxuICAgICAqIEBwYXJhbSB7TExSQk5vZGU9fSByb290XyAoT3B0aW9uYWwpIFJvb3Qgbm9kZSBmb3IgdGhlIG1hcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTb3J0ZWRNYXAoY29tcGFyYXRvcl8sIHJvb3RfKSB7XG4gICAgICAgIGlmIChyb290XyA9PT0gdm9pZCAwKSB7IHJvb3RfID0gU29ydGVkTWFwLkVNUFRZX05PREU7IH1cbiAgICAgICAgdGhpcy5jb21wYXJhdG9yXyA9IGNvbXBhcmF0b3JfO1xuICAgICAgICB0aGlzLnJvb3RfID0gcm9vdF87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXAsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgYWRkZWQgb3IgcmVwbGFjZWQuXG4gICAgICogKFRPRE86IFdlIHNob3VsZCBwZXJoYXBzIHJlbmFtZSB0aGlzIG1ldGhvZCB0byAncHV0JylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUt9IGtleSBLZXkgdG8gYmUgYWRkZWQuXG4gICAgICogQHBhcmFtIHshVn0gdmFsdWUgVmFsdWUgdG8gYmUgYWRkZWQuXG4gICAgICogQHJldHVybiB7IVNvcnRlZE1hcC48SywgVj59IE5ldyBtYXAsIHdpdGggaXRlbSBhZGRlZC5cbiAgICAgKi9cbiAgICBTb3J0ZWRNYXAucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwKHRoaXMuY29tcGFyYXRvcl8sIHRoaXMucm9vdF9cbiAgICAgICAgICAgIC5pbnNlcnQoa2V5LCB2YWx1ZSwgdGhpcy5jb21wYXJhdG9yXylcbiAgICAgICAgICAgIC5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLkJMQUNLLCBudWxsLCBudWxsKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgbWFwLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFLfSBrZXkgVGhlIGtleSB0byByZW1vdmUuXG4gICAgICogQHJldHVybiB7IVNvcnRlZE1hcC48SywgVj59IE5ldyBtYXAsIHdpdGggaXRlbSByZW1vdmVkLlxuICAgICAqL1xuICAgIFNvcnRlZE1hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3JfLCB0aGlzLnJvb3RfXG4gICAgICAgICAgICAucmVtb3ZlKGtleSwgdGhpcy5jb21wYXJhdG9yXylcbiAgICAgICAgICAgIC5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLkJMQUNLLCBudWxsLCBudWxsKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZSB3aXRoIHRoZSBnaXZlbiBrZXksIG9yIG51bGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFLfSBrZXkgVGhlIGtleSB0byBsb29rIHVwLlxuICAgICAqIEByZXR1cm4gez9WfSBUaGUgdmFsdWUgb2YgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4ga2V5LCBvciBudWxsIGlmIHRoZVxuICAgICAqIGtleSBkb2Vzbid0IGV4aXN0LlxuICAgICAqL1xuICAgIFNvcnRlZE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgY21wO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucm9vdF87XG4gICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGNtcCA9IHRoaXMuY29tcGFyYXRvcl8oa2V5LCBub2RlLmtleSk7XG4gICAgICAgICAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGtleSBvZiB0aGUgaXRlbSAqYmVmb3JlKiB0aGUgc3BlY2lmaWVkIGtleSwgb3IgbnVsbCBpZiBrZXkgaXMgdGhlIGZpcnN0IGl0ZW0uXG4gICAgICogQHBhcmFtIHtLfSBrZXkgVGhlIGtleSB0byBmaW5kIHRoZSBwcmVkZWNlc3NvciBvZlxuICAgICAqIEByZXR1cm4gez9LfSBUaGUgcHJlZGVjZXNzb3Iga2V5LlxuICAgICAqL1xuICAgIFNvcnRlZE1hcC5wcm90b3R5cGUuZ2V0UHJlZGVjZXNzb3JLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBjbXAsIG5vZGUgPSB0aGlzLnJvb3RfLCByaWdodFBhcmVudCA9IG51bGw7XG4gICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGNtcCA9IHRoaXMuY29tcGFyYXRvcl8oa2V5LCBub2RlLmtleSk7XG4gICAgICAgICAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmxlZnQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICghbm9kZS5yaWdodC5pc0VtcHR5KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUua2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyaWdodFBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHRQYXJlbnQua2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGZpcnN0IGl0ZW0uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRQYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGZpbmQgcHJlZGVjZXNzb3Iga2V5IGZvciBhIG5vbmV4aXN0ZW50IGtleS4gIFdoYXQgZ2l2ZXM/Jyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBtYXAgaXMgZW1wdHkuXG4gICAgICovXG4gICAgU29ydGVkTWFwLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Xy5pc0VtcHR5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB0b3RhbCBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIG1hcC5cbiAgICAgKi9cbiAgICBTb3J0ZWRNYXAucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Xy5jb3VudCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P0t9IFRoZSBtaW5pbXVtIGtleSBpbiB0aGUgbWFwLlxuICAgICAqL1xuICAgIFNvcnRlZE1hcC5wcm90b3R5cGUubWluS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Xy5taW5LZXkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez9LfSBUaGUgbWF4aW11bSBrZXkgaW4gdGhlIG1hcC5cbiAgICAgKi9cbiAgICBTb3J0ZWRNYXAucHJvdG90eXBlLm1heEtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8ubWF4S2V5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIG1hcCBpbiBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXG4gICAgICogZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFLLCAhVik6Kn0gYWN0aW9uIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLiAgSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXG4gICAgICogQHJldHVybiB7Kn0gVGhlIGZpcnN0IHRydXRoeSB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24sIG9yIHRoZSBsYXN0IGZhbHNleVxuICAgICAqICAgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uXG4gICAgICovXG4gICAgU29ydGVkTWFwLnByb3RvdHlwZS5pbm9yZGVyVHJhdmVyc2FsID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Xy5pbm9yZGVyVHJhdmVyc2FsKGFjdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIG1hcCBpbiByZXZlcnNlIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cbiAgICAgKiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIU9iamVjdCwgIU9iamVjdCl9IGFjdGlvbiBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICAgKiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci4gIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxuICAgICAqIEByZXR1cm4geyp9IFRydWUgaWYgdGhlIHRyYXZlcnNhbCB3YXMgYWJvcnRlZC5cbiAgICAgKi9cbiAgICBTb3J0ZWRNYXAucHJvdG90eXBlLnJldmVyc2VUcmF2ZXJzYWwgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfLnJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciB0aGUgU29ydGVkTWFwLlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHsoZnVuY3Rpb24oSywgVik6VCk9fSByZXN1bHRHZW5lcmF0b3JcbiAgICAgKiBAcmV0dXJuIHtTb3J0ZWRNYXBJdGVyYXRvci48SywgViwgVD59IFRoZSBpdGVyYXRvci5cbiAgICAgKi9cbiAgICBTb3J0ZWRNYXAucHJvdG90eXBlLmdldEl0ZXJhdG9yID0gZnVuY3Rpb24gKHJlc3VsdEdlbmVyYXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdF8sIG51bGwsIHRoaXMuY29tcGFyYXRvcl8sIGZhbHNlLCByZXN1bHRHZW5lcmF0b3IpO1xuICAgIH07XG4gICAgU29ydGVkTWFwLnByb3RvdHlwZS5nZXRJdGVyYXRvckZyb20gPSBmdW5jdGlvbiAoa2V5LCByZXN1bHRHZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3RfLCBrZXksIHRoaXMuY29tcGFyYXRvcl8sIGZhbHNlLCByZXN1bHRHZW5lcmF0b3IpO1xuICAgIH07XG4gICAgU29ydGVkTWFwLnByb3RvdHlwZS5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tID0gZnVuY3Rpb24gKGtleSwgcmVzdWx0R2VuZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290Xywga2V5LCB0aGlzLmNvbXBhcmF0b3JfLCB0cnVlLCByZXN1bHRHZW5lcmF0b3IpO1xuICAgIH07XG4gICAgU29ydGVkTWFwLnByb3RvdHlwZS5nZXRSZXZlcnNlSXRlcmF0b3IgPSBmdW5jdGlvbiAocmVzdWx0R2VuZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290XywgbnVsbCwgdGhpcy5jb21wYXJhdG9yXywgdHJ1ZSwgcmVzdWx0R2VuZXJhdG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFsd2F5cyB1c2UgdGhlIHNhbWUgZW1wdHkgbm9kZSwgdG8gcmVkdWNlIG1lbW9yeS5cbiAgICAgKiBAY29uc3RcbiAgICAgKi9cbiAgICBTb3J0ZWRNYXAuRU1QVFlfTk9ERSA9IG5ldyBMTFJCRW1wdHlOb2RlKCk7XG4gICAgcmV0dXJuIFNvcnRlZE1hcDtcbn0oKSk7XG5leHBvcnQgeyBTb3J0ZWRNYXAgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS91dGlsL1NvcnRlZE1hcC5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBjYWNoZSBub2RlIG9ubHkgc3RvcmVzIGNvbXBsZXRlIGNoaWxkcmVuLiBBZGRpdGlvbmFsbHkgaXQgaG9sZHMgYSBmbGFnIHdoZXRoZXIgdGhlIG5vZGUgY2FuIGJlIGNvbnNpZGVyZWQgZnVsbHlcbiAqIGluaXRpYWxpemVkIGluIHRoZSBzZW5zZSB0aGF0IHdlIGtub3cgYXQgb25lIHBvaW50IGluIHRpbWUgdGhpcyByZXByZXNlbnRlZCBhIHZhbGlkIHN0YXRlIG9mIHRoZSB3b3JsZCwgZS5nLlxuICogaW5pdGlhbGl6ZWQgd2l0aCBkYXRhIGZyb20gdGhlIHNlcnZlciwgb3IgYSBjb21wbGV0ZSBvdmVyd3JpdGUgYnkgdGhlIGNsaWVudC4gVGhlIGZpbHRlcmVkIGZsYWcgYWxzbyB0cmFja3NcbiAqIHdoZXRoZXIgYSBub2RlIHBvdGVudGlhbGx5IGhhZCBjaGlsZHJlbiByZW1vdmVkIGR1ZSB0byBhIGZpbHRlci5cbiAqL1xudmFyIENhY2hlTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlX1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZnVsbHlJbml0aWFsaXplZF9cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpbHRlcmVkX1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENhY2hlTm9kZShub2RlXywgZnVsbHlJbml0aWFsaXplZF8sIGZpbHRlcmVkXykge1xuICAgICAgICB0aGlzLm5vZGVfID0gbm9kZV87XG4gICAgICAgIHRoaXMuZnVsbHlJbml0aWFsaXplZF8gPSBmdWxseUluaXRpYWxpemVkXztcbiAgICAgICAgdGhpcy5maWx0ZXJlZF8gPSBmaWx0ZXJlZF87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIG5vZGUgd2FzIGZ1bGx5IGluaXRpYWxpemVkIHdpdGggZWl0aGVyIHNlcnZlciBkYXRhIG9yIGEgY29tcGxldGUgb3ZlcndyaXRlIGJ5IHRoZSBjbGllbnRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIENhY2hlTm9kZS5wcm90b3R5cGUuaXNGdWxseUluaXRpYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mdWxseUluaXRpYWxpemVkXztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIG5vZGUgaXMgcG90ZW50aWFsbHkgbWlzc2luZyBjaGlsZHJlbiBkdWUgdG8gYSBmaWx0ZXIgYXBwbGllZCB0byB0aGUgbm9kZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgQ2FjaGVOb2RlLnByb3RvdHlwZS5pc0ZpbHRlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJlZF87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBDYWNoZU5vZGUucHJvdG90eXBlLmlzQ29tcGxldGVGb3JQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSAmJiAhdGhpcy5maWx0ZXJlZF87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoaWxkS2V5ID0gcGF0aC5nZXRGcm9udCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIENhY2hlTm9kZS5wcm90b3R5cGUuaXNDb21wbGV0ZUZvckNoaWxkID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gKCh0aGlzLmlzRnVsbHlJbml0aWFsaXplZCgpICYmICF0aGlzLmZpbHRlcmVkXykgfHwgdGhpcy5ub2RlXy5oYXNDaGlsZChrZXkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFOb2RlfVxuICAgICAqL1xuICAgIENhY2hlTm9kZS5wcm90b3R5cGUuZ2V0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZV87XG4gICAgfTtcbiAgICByZXR1cm4gQ2FjaGVOb2RlO1xufSgpKTtcbmV4cG9ydCB7IENhY2hlTm9kZSB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3ZpZXcvQ2FjaGVOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZXhwb3J0IHZhciBQUk9UT0NPTF9WRVJTSU9OID0gJzUnO1xuZXhwb3J0IHZhciBWRVJTSU9OX1BBUkFNID0gJ3YnO1xuZXhwb3J0IHZhciBUUkFOU1BPUlRfU0VTU0lPTl9QQVJBTSA9ICdzJztcbmV4cG9ydCB2YXIgUkVGRVJFUl9QQVJBTSA9ICdyJztcbmV4cG9ydCB2YXIgRk9SR0VfUkVGID0gJ2YnO1xuZXhwb3J0IHZhciBGT1JHRV9ET01BSU4gPSAnZmlyZWJhc2Vpby5jb20nO1xuZXhwb3J0IHZhciBMQVNUX1NFU1NJT05fUEFSQU0gPSAnbHMnO1xuZXhwb3J0IHZhciBXRUJTT0NLRVQgPSAnd2Vic29ja2V0JztcbmV4cG9ydCB2YXIgTE9OR19QT0xMSU5HID0gJ2xvbmdfcG9sbGluZyc7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL3JlYWx0aW1lL0NvbnN0YW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IHsgT25EaXNjb25uZWN0IH0gZnJvbSAnLi9vbkRpc2Nvbm5lY3QnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25SZXN1bHQgfSBmcm9tICcuL1RyYW5zYWN0aW9uUmVzdWx0JztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi9jb3JlL3V0aWwvdXRpbCc7XG5pbXBvcnQgeyBuZXh0UHVzaElkIH0gZnJvbSAnLi4vY29yZS91dGlsL05leHRQdXNoSWQnO1xuaW1wb3J0IHsgUXVlcnkgfSBmcm9tICcuL1F1ZXJ5JztcbmltcG9ydCB7IFJlcG8gfSBmcm9tICcuLi9jb3JlL1JlcG8nO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4uL2NvcmUvdXRpbC9QYXRoJztcbmltcG9ydCB7IFF1ZXJ5UGFyYW1zIH0gZnJvbSAnLi4vY29yZS92aWV3L1F1ZXJ5UGFyYW1zJztcbmltcG9ydCB7IHZhbGlkYXRlUm9vdFBhdGhTdHJpbmcsIHZhbGlkYXRlUGF0aFN0cmluZywgdmFsaWRhdGVGaXJlYmFzZU1lcmdlRGF0YUFyZywgdmFsaWRhdGVCb29sZWFuLCB2YWxpZGF0ZVByaW9yaXR5LCB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZywgdmFsaWRhdGVXcml0YWJsZVBhdGggfSBmcm9tICcuLi9jb3JlL3V0aWwvdmFsaWRhdGlvbic7XG5pbXBvcnQgeyB2YWxpZGF0ZUFyZ0NvdW50LCB2YWxpZGF0ZUNhbGxiYWNrIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgRGVmZXJyZWQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBTeW5jUG9pbnQgfSBmcm9tICcuLi9jb3JlL1N5bmNQb2ludCc7XG52YXIgUmVmZXJlbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWZlcmVuY2UsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ2FsbCBvcHRpb25zOlxuICAgICAqICAgbmV3IFJlZmVyZW5jZShSZXBvLCBQYXRoKSBvclxuICAgICAqICAgbmV3IFJlZmVyZW5jZSh1cmw6IHN0cmluZywgc3RyaW5nfFJlcG9NYW5hZ2VyKVxuICAgICAqXG4gICAgICogRXh0ZXJuYWxseSAtIHRoaXMgaXMgdGhlIGZpcmViYXNlLmRhdGFiYXNlLlJlZmVyZW5jZSB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUmVwb30gcmVwb1xuICAgICAqIEBwYXJhbSB7KCFQYXRoKX0gcGF0aFxuICAgICAqIEBleHRlbmRzIHtRdWVyeX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZWZlcmVuY2UocmVwbywgcGF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIShyZXBvIGluc3RhbmNlb2YgUmVwbykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmV3IFJlZmVyZW5jZSgpIG5vIGxvbmdlciBzdXBwb3J0ZWQgLSB1c2UgYXBwLmRhdGFiYXNlKCkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsbCBRdWVyeSdzIGNvbnN0cnVjdG9yLCBwYXNzaW5nIGluIHRoZSByZXBvIGFuZCBwYXRoLlxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJlcG8sIHBhdGgsIFF1ZXJ5UGFyYW1zLkRFRkFVTFQsIGZhbHNlKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBAcmV0dXJuIHs/c3RyaW5nfSAqL1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdSZWZlcmVuY2Uua2V5JywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGlmICh0aGlzLnBhdGguaXNFbXB0eSgpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGguZ2V0QmFjaygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshKHN0cmluZ3xQYXRoKX0gcGF0aFN0cmluZ1xuICAgICAqIEByZXR1cm4geyFSZWZlcmVuY2V9XG4gICAgICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nKSB7XG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ1JlZmVyZW5jZS5jaGlsZCcsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGhTdHJpbmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBwYXRoU3RyaW5nID0gU3RyaW5nKHBhdGhTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEocGF0aFN0cmluZyBpbnN0YW5jZW9mIFBhdGgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXRoLmdldEZyb250KCkgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVSb290UGF0aFN0cmluZygnUmVmZXJlbmNlLmNoaWxkJywgMSwgcGF0aFN0cmluZywgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHZhbGlkYXRlUGF0aFN0cmluZygnUmVmZXJlbmNlLmNoaWxkJywgMSwgcGF0aFN0cmluZywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVmZXJlbmNlKHRoaXMucmVwbywgdGhpcy5wYXRoLmNoaWxkKHBhdGhTdHJpbmcpKTtcbiAgICB9O1xuICAgIC8qKiBAcmV0dXJuIHs/UmVmZXJlbmNlfSAqL1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdSZWZlcmVuY2UucGFyZW50JywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhciBwYXJlbnRQYXRoID0gdGhpcy5wYXRoLnBhcmVudCgpO1xuICAgICAgICByZXR1cm4gcGFyZW50UGF0aCA9PT0gbnVsbCA/IG51bGwgOiBuZXcgUmVmZXJlbmNlKHRoaXMucmVwbywgcGFyZW50UGF0aCk7XG4gICAgfTtcbiAgICAvKiogQHJldHVybiB7IVJlZmVyZW5jZX0gKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLmdldFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ1JlZmVyZW5jZS5yb290JywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICB3aGlsZSAocmVmLmdldFBhcmVudCgpICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZWYgPSByZWYuZ2V0UGFyZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZjtcbiAgICB9O1xuICAgIC8qKiBAcmV0dXJuIHshRGF0YWJhc2V9ICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5kYXRhYmFzZVByb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcG8uZGF0YWJhc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IG5ld1ZhbFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yKT19IG9uQ29tcGxldGVcbiAgICAgKiBAcmV0dXJuIHshUHJvbWlzZX1cbiAgICAgKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChuZXdWYWwsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnNldCcsIDEsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnUmVmZXJlbmNlLnNldCcsIHRoaXMucGF0aCk7XG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdSZWZlcmVuY2Uuc2V0JywgMSwgbmV3VmFsLCB0aGlzLnBhdGgsIGZhbHNlKTtcbiAgICAgICAgdmFsaWRhdGVDYWxsYmFjaygnUmVmZXJlbmNlLnNldCcsIDIsIG9uQ29tcGxldGUsIHRydWUpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5yZXBvLnNldFdpdGhQcmlvcml0eSh0aGlzLnBhdGgsIG5ld1ZhbCwgXG4gICAgICAgIC8qcHJpb3JpdHk9Ki8gbnVsbCwgZGVmZXJyZWQud3JhcENhbGxiYWNrKG9uQ29tcGxldGUpKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IG9iamVjdFRvTWVyZ2VcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvcik9fSBvbkNvbXBsZXRlXG4gICAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAgICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAob2JqZWN0VG9NZXJnZSwgb25Db21wbGV0ZSkge1xuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdSZWZlcmVuY2UudXBkYXRlJywgMSwgMiwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdSZWZlcmVuY2UudXBkYXRlJywgdGhpcy5wYXRoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0VG9NZXJnZSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdPYmplY3RUb01lcmdlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdFRvTWVyZ2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBuZXdPYmplY3RUb01lcmdlWycnICsgaV0gPSBvYmplY3RUb01lcmdlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0VG9NZXJnZSA9IG5ld09iamVjdFRvTWVyZ2U7XG4gICAgICAgICAgICB3YXJuKCdQYXNzaW5nIGFuIEFycmF5IHRvIEZpcmViYXNlLnVwZGF0ZSgpIGlzIGRlcHJlY2F0ZWQuICcgK1xuICAgICAgICAgICAgICAgICdVc2Ugc2V0KCkgaWYgeW91IHdhbnQgdG8gb3ZlcndyaXRlIHRoZSBleGlzdGluZyBkYXRhLCBvciAnICtcbiAgICAgICAgICAgICAgICAnYW4gT2JqZWN0IHdpdGggaW50ZWdlciBrZXlzIGlmIHlvdSByZWFsbHkgZG8gd2FudCB0byAnICtcbiAgICAgICAgICAgICAgICAnb25seSB1cGRhdGUgc29tZSBvZiB0aGUgY2hpbGRyZW4uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZU1lcmdlRGF0YUFyZygnUmVmZXJlbmNlLnVwZGF0ZScsIDEsIG9iamVjdFRvTWVyZ2UsIHRoaXMucGF0aCwgZmFsc2UpO1xuICAgICAgICB2YWxpZGF0ZUNhbGxiYWNrKCdSZWZlcmVuY2UudXBkYXRlJywgMiwgb25Db21wbGV0ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnJlcG8udXBkYXRlKHRoaXMucGF0aCwgb2JqZWN0VG9NZXJnZSwgZGVmZXJyZWQud3JhcENhbGxiYWNrKG9uQ29tcGxldGUpKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IG5ld1ZhbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxudWxsfSBuZXdQcmlvcml0eVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yKT19IG9uQ29tcGxldGVcbiAgICAgKiBAcmV0dXJuIHshUHJvbWlzZX1cbiAgICAgKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLnNldFdpdGhQcmlvcml0eSA9IGZ1bmN0aW9uIChuZXdWYWwsIG5ld1ByaW9yaXR5LCBvbkNvbXBsZXRlKSB7XG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ1JlZmVyZW5jZS5zZXRXaXRoUHJpb3JpdHknLCAyLCAzLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ1JlZmVyZW5jZS5zZXRXaXRoUHJpb3JpdHknLCB0aGlzLnBhdGgpO1xuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnUmVmZXJlbmNlLnNldFdpdGhQcmlvcml0eScsIDEsIG5ld1ZhbCwgdGhpcy5wYXRoLCBmYWxzZSk7XG4gICAgICAgIHZhbGlkYXRlUHJpb3JpdHkoJ1JlZmVyZW5jZS5zZXRXaXRoUHJpb3JpdHknLCAyLCBuZXdQcmlvcml0eSwgZmFsc2UpO1xuICAgICAgICB2YWxpZGF0ZUNhbGxiYWNrKCdSZWZlcmVuY2Uuc2V0V2l0aFByaW9yaXR5JywgMywgb25Db21wbGV0ZSwgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLmdldEtleSgpID09PSAnLmxlbmd0aCcgfHwgdGhpcy5nZXRLZXkoKSA9PT0gJy5rZXlzJylcbiAgICAgICAgICAgIHRocm93ICdSZWZlcmVuY2Uuc2V0V2l0aFByaW9yaXR5IGZhaWxlZDogJyArXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRLZXkoKSArXG4gICAgICAgICAgICAgICAgJyBpcyBhIHJlYWQtb25seSBvYmplY3QuJztcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMucmVwby5zZXRXaXRoUHJpb3JpdHkodGhpcy5wYXRoLCBuZXdWYWwsIG5ld1ByaW9yaXR5LCBkZWZlcnJlZC53cmFwQ2FsbGJhY2sob25Db21wbGV0ZSkpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yKT19IG9uQ29tcGxldGVcbiAgICAgKiBAcmV0dXJuIHshUHJvbWlzZX1cbiAgICAgKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChvbkNvbXBsZXRlKSB7XG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ1JlZmVyZW5jZS5yZW1vdmUnLCAwLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ1JlZmVyZW5jZS5yZW1vdmUnLCB0aGlzLnBhdGgpO1xuICAgICAgICB2YWxpZGF0ZUNhbGxiYWNrKCdSZWZlcmVuY2UucmVtb3ZlJywgMSwgb25Db21wbGV0ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNldChudWxsLCBvbkNvbXBsZXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKik6Kn0gdHJhbnNhY3Rpb25VcGRhdGVcbiAgICAgKiBAcGFyYW0geyhmdW5jdGlvbig/RXJyb3IsIGJvb2xlYW4sID9EYXRhU25hcHNob3QpKT19IG9uQ29tcGxldGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBhcHBseUxvY2FsbHlcbiAgICAgKiBAcmV0dXJuIHshUHJvbWlzZX1cbiAgICAgKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLnRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uVXBkYXRlLCBvbkNvbXBsZXRlLCBhcHBseUxvY2FsbHkpIHtcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnRyYW5zYWN0aW9uJywgMSwgMywgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdSZWZlcmVuY2UudHJhbnNhY3Rpb24nLCB0aGlzLnBhdGgpO1xuICAgICAgICB2YWxpZGF0ZUNhbGxiYWNrKCdSZWZlcmVuY2UudHJhbnNhY3Rpb24nLCAxLCB0cmFuc2FjdGlvblVwZGF0ZSwgZmFsc2UpO1xuICAgICAgICB2YWxpZGF0ZUNhbGxiYWNrKCdSZWZlcmVuY2UudHJhbnNhY3Rpb24nLCAyLCBvbkNvbXBsZXRlLCB0cnVlKTtcbiAgICAgICAgLy8gTk9URTogYXBwbHlMb2NhbGx5IGlzIGFuIGludGVybmFsLW9ubHkgb3B0aW9uIGZvciBub3cuICBXZSBuZWVkIHRvIGRlY2lkZSBpZiB3ZSB3YW50IHRvIGtlZXAgaXQgYW5kIGhvd1xuICAgICAgICAvLyB0byBleHBvc2UgaXQuXG4gICAgICAgIHZhbGlkYXRlQm9vbGVhbignUmVmZXJlbmNlLnRyYW5zYWN0aW9uJywgMywgYXBwbHlMb2NhbGx5LCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0S2V5KCkgPT09ICcubGVuZ3RoJyB8fCB0aGlzLmdldEtleSgpID09PSAnLmtleXMnKVxuICAgICAgICAgICAgdGhyb3cgJ1JlZmVyZW5jZS50cmFuc2FjdGlvbiBmYWlsZWQ6ICcgK1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0S2V5KCkgK1xuICAgICAgICAgICAgICAgICcgaXMgYSByZWFkLW9ubHkgb2JqZWN0Lic7XG4gICAgICAgIGlmIChhcHBseUxvY2FsbHkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGFwcGx5TG9jYWxseSA9IHRydWU7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICBpZiAodHlwZW9mIG9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvbWlzZUNvbXBsZXRlID0gZnVuY3Rpb24gKGVycm9yLCBjb21taXR0ZWQsIHNuYXBzaG90KSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShuZXcgVHJhbnNhY3Rpb25SZXN1bHQoY29tbWl0dGVkLCBzbmFwc2hvdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZShlcnJvciwgY29tbWl0dGVkLCBzbmFwc2hvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVwby5zdGFydFRyYW5zYWN0aW9uKHRoaXMucGF0aCwgdHJhbnNhY3Rpb25VcGRhdGUsIHByb21pc2VDb21wbGV0ZSwgYXBwbHlMb2NhbGx5KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8bnVsbH0gcHJpb3JpdHlcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvcik9fSBvbkNvbXBsZXRlXG4gICAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAgICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5zZXRQcmlvcml0eSA9IGZ1bmN0aW9uIChwcmlvcml0eSwgb25Db21wbGV0ZSkge1xuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdSZWZlcmVuY2Uuc2V0UHJpb3JpdHknLCAxLCAyLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ1JlZmVyZW5jZS5zZXRQcmlvcml0eScsIHRoaXMucGF0aCk7XG4gICAgICAgIHZhbGlkYXRlUHJpb3JpdHkoJ1JlZmVyZW5jZS5zZXRQcmlvcml0eScsIDEsIHByaW9yaXR5LCBmYWxzZSk7XG4gICAgICAgIHZhbGlkYXRlQ2FsbGJhY2soJ1JlZmVyZW5jZS5zZXRQcmlvcml0eScsIDIsIG9uQ29tcGxldGUsIHRydWUpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5yZXBvLnNldFdpdGhQcmlvcml0eSh0aGlzLnBhdGguY2hpbGQoJy5wcmlvcml0eScpLCBwcmlvcml0eSwgbnVsbCwgZGVmZXJyZWQud3JhcENhbGxiYWNrKG9uQ29tcGxldGUpKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyo9fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yKT19IG9uQ29tcGxldGVcbiAgICAgKiBAcmV0dXJuIHshUmVmZXJlbmNlfVxuICAgICAqL1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2YWx1ZSwgb25Db21wbGV0ZSkge1xuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdSZWZlcmVuY2UucHVzaCcsIDAsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnUmVmZXJlbmNlLnB1c2gnLCB0aGlzLnBhdGgpO1xuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnUmVmZXJlbmNlLnB1c2gnLCAxLCB2YWx1ZSwgdGhpcy5wYXRoLCB0cnVlKTtcbiAgICAgICAgdmFsaWRhdGVDYWxsYmFjaygnUmVmZXJlbmNlLnB1c2gnLCAyLCBvbkNvbXBsZXRlLCB0cnVlKTtcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMucmVwby5zZXJ2ZXJUaW1lKCk7XG4gICAgICAgIHZhciBuYW1lID0gbmV4dFB1c2hJZChub3cpO1xuICAgICAgICAvLyBwdXNoKCkgcmV0dXJucyBhIFRoZW5uYWJsZVJlZmVyZW5jZSB3aG9zZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCB3aXRoIGEgcmVndWxhciBSZWZlcmVuY2UuXG4gICAgICAgIC8vIFdlIHVzZSBjaGlsZCgpIHRvIGNyZWF0ZSBoYW5kbGVzIHRvIHR3byBkaWZmZXJlbnQgcmVmZXJlbmNlcy4gVGhlIGZpcnN0IGlzIHR1cm5lZCBpbnRvIGFcbiAgICAgICAgLy8gVGhlbm5hYmxlUmVmZXJlbmNlIGJlbG93IGJ5IGFkZGluZyB0aGVuKCkgYW5kIGNhdGNoKCkgbWV0aG9kcyBhbmQgaXMgdXNlZCBhcyB0aGVcbiAgICAgICAgLy8gcmV0dXJuIHZhbHVlIG9mIHB1c2goKS4gVGhlIHNlY29uZCByZW1haW5zIGEgcmVndWxhciBSZWZlcmVuY2UgYW5kIGlzIHVzZWQgYXMgdGhlIGZ1bGZpbGxlZFxuICAgICAgICAvLyB2YWx1ZSBvZiB0aGUgZmlyc3QgVGhlbm5hYmxlUmVmZXJlbmNlLlxuICAgICAgICB2YXIgdGhlbm5hYmxlUHVzaFJlZiA9IHRoaXMuY2hpbGQobmFtZSk7XG4gICAgICAgIHZhciBwdXNoUmVmID0gdGhpcy5jaGlsZChuYW1lKTtcbiAgICAgICAgdmFyIHByb21pc2U7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gdGhlbm5hYmxlUHVzaFJlZi5zZXQodmFsdWUsIG9uQ29tcGxldGUpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcHVzaFJlZjsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHB1c2hSZWYpO1xuICAgICAgICB9XG4gICAgICAgIHRoZW5uYWJsZVB1c2hSZWYudGhlbiA9IHByb21pc2UudGhlbi5iaW5kKHByb21pc2UpO1xuICAgICAgICB0aGVubmFibGVQdXNoUmVmLmNhdGNoID0gcHJvbWlzZS50aGVuLmJpbmQocHJvbWlzZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoZW5uYWJsZVB1c2hSZWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshT25EaXNjb25uZWN0fVxuICAgICAqL1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUub25EaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnUmVmZXJlbmNlLm9uRGlzY29ubmVjdCcsIHRoaXMucGF0aCk7XG4gICAgICAgIHJldHVybiBuZXcgT25EaXNjb25uZWN0KHRoaXMucmVwbywgdGhpcy5wYXRoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZlcmVuY2UucHJvdG90eXBlLCBcImRhdGFiYXNlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhYmFzZVByb3AoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmVyZW5jZS5wcm90b3R5cGUsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmVyZW5jZS5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmVyZW5jZS5wcm90b3R5cGUsIFwicm9vdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Um9vdCgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gUmVmZXJlbmNlO1xufShRdWVyeSkpO1xuZXhwb3J0IHsgUmVmZXJlbmNlIH07XG4vKipcbiAqIERlZmluZSByZWZlcmVuY2UgY29uc3RydWN0b3IgaW4gdmFyaW91cyBtb2R1bGVzXG4gKlxuICogV2UgYXJlIGRvaW5nIHRoaXMgaGVyZSB0byBhdm9pZCBzZXZlcmFsIGNpcmN1bGFyXG4gKiBkZXBlbmRlbmN5IGlzc3Vlc1xuICovXG5RdWVyeS5fX3JlZmVyZW5jZUNvbnN0cnVjdG9yID0gUmVmZXJlbmNlO1xuU3luY1BvaW50Ll9fcmVmZXJlbmNlQ29uc3RydWN0b3IgPSBSZWZlcmVuY2U7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2FwaS9SZWZlcmVuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBzYWZlR2V0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgUmVwbyB9IGZyb20gJy4vUmVwbyc7XG5pbXBvcnQgeyBmYXRhbCB9IGZyb20gJy4vdXRpbC91dGlsJztcbmltcG9ydCB7IHBhcnNlUmVwb0luZm8gfSBmcm9tICcuL3V0aWwvbGlicy9wYXJzZXInO1xuaW1wb3J0IHsgdmFsaWRhdGVVcmwgfSBmcm9tICcuL3V0aWwvdmFsaWRhdGlvbic7XG5pbXBvcnQgJy4vUmVwb190cmFuc2FjdGlvbic7XG4vKiogQGNvbnN0IHtzdHJpbmd9ICovXG52YXIgREFUQUJBU0VfVVJMX09QVElPTiA9ICdkYXRhYmFzZVVSTCc7XG52YXIgX3N0YXRpY0luc3RhbmNlO1xuLyoqXG4gKiBDcmVhdGVzIGFuZCBjYWNoZXMgUmVwbyBpbnN0YW5jZXMuXG4gKi9cbnZhciBSZXBvTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXBvTWFuYWdlcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlIHshT2JqZWN0LjxzdHJpbmcsIE9iamVjdDxzdHJpbmcsICFmYi5jb3JlLlJlcG8+Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVwb3NfID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCBuZXcgUmVwb3Mgd2lsbCBiZSBjcmVhdGVkIHRvIHVzZSBSZWFkb25seVJlc3RDbGllbnQgKGZvciB0ZXN0aW5nIHB1cnBvc2VzKS5cbiAgICAgICAgICogQHByaXZhdGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVzZVJlc3RDbGllbnRfID0gZmFsc2U7XG4gICAgfVxuICAgIFJlcG9NYW5hZ2VyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIV9zdGF0aWNJbnN0YW5jZSkge1xuICAgICAgICAgICAgX3N0YXRpY0luc3RhbmNlID0gbmV3IFJlcG9NYW5hZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdGF0aWNJbnN0YW5jZTtcbiAgICB9O1xuICAgIC8vIFRPRE8oa29zcyk6IFJlbW92ZSB0aGVzZSBmdW5jdGlvbnMgdW5sZXNzIHVzZWQgaW4gdGVzdHM/XG4gICAgUmVwb01hbmFnZXIucHJvdG90eXBlLmludGVycnVwdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgYXBwTmFtZSBpbiB0aGlzLnJlcG9zXykge1xuICAgICAgICAgICAgZm9yICh2YXIgZGJVcmwgaW4gdGhpcy5yZXBvc19bYXBwTmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9zX1thcHBOYW1lXVtkYlVybF0uaW50ZXJydXB0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlcG9NYW5hZ2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGFwcE5hbWUgaW4gdGhpcy5yZXBvc18pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGRiVXJsIGluIHRoaXMucmVwb3NfW2FwcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvc19bYXBwTmFtZV1bZGJVcmxdLnJlc3VtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGV2ZXIgYmUgY2FsbGVkIHRvIENSRUFURSBhIG5ldyBkYXRhYmFzZSBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUZpcmViYXNlQXBwfSBhcHBcbiAgICAgKiBAcmV0dXJuIHshRGF0YWJhc2V9XG4gICAgICovXG4gICAgUmVwb01hbmFnZXIucHJvdG90eXBlLmRhdGFiYXNlRnJvbUFwcCA9IGZ1bmN0aW9uIChhcHAsIHVybCkge1xuICAgICAgICB2YXIgZGJVcmwgPSB1cmwgfHwgYXBwLm9wdGlvbnNbREFUQUJBU0VfVVJMX09QVElPTl07XG4gICAgICAgIGlmIChkYlVybCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmYXRhbChcIkNhbid0IGRldGVybWluZSBGaXJlYmFzZSBEYXRhYmFzZSBVUkwuICBCZSBzdXJlIHRvIGluY2x1ZGUgXCIgK1xuICAgICAgICAgICAgICAgIERBVEFCQVNFX1VSTF9PUFRJT04gK1xuICAgICAgICAgICAgICAgICcgb3B0aW9uIHdoZW4gY2FsbGluZyBmaXJlYmFzZS5pbnRpYWxpemVBcHAoKS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyc2VkVXJsID0gcGFyc2VSZXBvSW5mbyhkYlVybCk7XG4gICAgICAgIHZhciByZXBvSW5mbyA9IHBhcnNlZFVybC5yZXBvSW5mbztcbiAgICAgICAgdmFsaWRhdGVVcmwoJ0ludmFsaWQgRmlyZWJhc2UgRGF0YWJhc2UgVVJMJywgMSwgcGFyc2VkVXJsKTtcbiAgICAgICAgaWYgKCFwYXJzZWRVcmwucGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGZhdGFsKCdEYXRhYmFzZSBVUkwgbXVzdCBwb2ludCB0byB0aGUgcm9vdCBvZiBhIEZpcmViYXNlIERhdGFiYXNlICcgK1xuICAgICAgICAgICAgICAgICcobm90IGluY2x1ZGluZyBhIGNoaWxkIHBhdGgpLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXBvID0gdGhpcy5jcmVhdGVSZXBvKHJlcG9JbmZvLCBhcHApO1xuICAgICAgICByZXR1cm4gcmVwby5kYXRhYmFzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgcmVwbyBhbmQgbWFrZSBzdXJlIGl0IGlzIGRpc2Nvbm5lY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVJlcG99IHJlcG9cbiAgICAgKi9cbiAgICBSZXBvTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlUmVwbyA9IGZ1bmN0aW9uIChyZXBvKSB7XG4gICAgICAgIHZhciBhcHBSZXBvcyA9IHNhZmVHZXQodGhpcy5yZXBvc18sIHJlcG8uYXBwLm5hbWUpO1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uLi5cbiAgICAgICAgaWYgKCFhcHBSZXBvcyB8fCBzYWZlR2V0KGFwcFJlcG9zLCByZXBvLnJlcG9JbmZvXy50b1VSTFN0cmluZygpKSAhPT0gcmVwbykge1xuICAgICAgICAgICAgZmF0YWwoXCJEYXRhYmFzZSBcIiArIHJlcG8uYXBwLm5hbWUgKyBcIihcIiArIHJlcG8ucmVwb0luZm9fICsgXCIpIGhhcyBhbHJlYWR5IGJlZW4gZGVsZXRlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVwby5pbnRlcnJ1cHQoKTtcbiAgICAgICAgZGVsZXRlIGFwcFJlcG9zW3JlcG8ucmVwb0luZm9fLnRvVVJMU3RyaW5nKCldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5zdXJlcyBhIHJlcG8gZG9lc24ndCBhbHJlYWR5IGV4aXN0IGFuZCB0aGVuIGNyZWF0ZXMgb25lIHVzaW5nIHRoZVxuICAgICAqIHByb3ZpZGVkIGFwcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVJlcG9JbmZvfSByZXBvSW5mbyBUaGUgbWV0YWRhdGEgYWJvdXQgdGhlIFJlcG9cbiAgICAgKiBAcGFyYW0geyFGaXJlYmFzZUFwcH0gYXBwXG4gICAgICogQHJldHVybiB7IVJlcG99IFRoZSBSZXBvIG9iamVjdCBmb3IgdGhlIHNwZWNpZmllZCBzZXJ2ZXIgLyByZXBvTmFtZS5cbiAgICAgKi9cbiAgICBSZXBvTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlUmVwbyA9IGZ1bmN0aW9uIChyZXBvSW5mbywgYXBwKSB7XG4gICAgICAgIHZhciBhcHBSZXBvcyA9IHNhZmVHZXQodGhpcy5yZXBvc18sIGFwcC5uYW1lKTtcbiAgICAgICAgaWYgKCFhcHBSZXBvcykge1xuICAgICAgICAgICAgYXBwUmVwb3MgPSB7fTtcbiAgICAgICAgICAgIHRoaXMucmVwb3NfW2FwcC5uYW1lXSA9IGFwcFJlcG9zO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXBvID0gc2FmZUdldChhcHBSZXBvcywgcmVwb0luZm8udG9VUkxTdHJpbmcoKSk7XG4gICAgICAgIGlmIChyZXBvKSB7XG4gICAgICAgICAgICBmYXRhbCgnRGF0YWJhc2UgaW5pdGlhbGl6ZWQgbXVsdGlwbGUgdGltZXMuIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGZvcm1hdCBvZiB0aGUgZGF0YWJhc2UgVVJMIG1hdGNoZXMgd2l0aCBlYWNoIGRhdGFiYXNlKCkgY2FsbC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXBvID0gbmV3IFJlcG8ocmVwb0luZm8sIHRoaXMudXNlUmVzdENsaWVudF8sIGFwcCk7XG4gICAgICAgIGFwcFJlcG9zW3JlcG9JbmZvLnRvVVJMU3RyaW5nKCldID0gcmVwbztcbiAgICAgICAgcmV0dXJuIHJlcG87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdXMgdG8gdXNlIFJlYWRvbmx5UmVzdENsaWVudCBpbnN0ZWFkIG9mIFBlcnNpc3RlbnRDb25uZWN0aW9uIGZvciBuZXcgUmVwb3MuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZVJlc3RDbGllbnRcbiAgICAgKi9cbiAgICBSZXBvTWFuYWdlci5wcm90b3R5cGUuZm9yY2VSZXN0Q2xpZW50ID0gZnVuY3Rpb24gKGZvcmNlUmVzdENsaWVudCkge1xuICAgICAgICB0aGlzLnVzZVJlc3RDbGllbnRfID0gZm9yY2VSZXN0Q2xpZW50O1xuICAgIH07XG4gICAgcmV0dXJuIFJlcG9NYW5hZ2VyO1xufSgpKTtcbmV4cG9ydCB7IFJlcG9NYW5hZ2VyIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvUmVwb01hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBTdGF0c0NvbGxlY3Rpb24gfSBmcm9tICcuL1N0YXRzQ29sbGVjdGlvbic7XG52YXIgU3RhdHNNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRzTWFuYWdlcigpIHtcbiAgICB9XG4gICAgU3RhdHNNYW5hZ2VyLmdldENvbGxlY3Rpb24gPSBmdW5jdGlvbiAocmVwb0luZm8pIHtcbiAgICAgICAgdmFyIGhhc2hTdHJpbmcgPSByZXBvSW5mby50b1N0cmluZygpO1xuICAgICAgICBpZiAoIXRoaXMuY29sbGVjdGlvbnNfW2hhc2hTdHJpbmddKSB7XG4gICAgICAgICAgICB0aGlzLmNvbGxlY3Rpb25zX1toYXNoU3RyaW5nXSA9IG5ldyBTdGF0c0NvbGxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uc19baGFzaFN0cmluZ107XG4gICAgfTtcbiAgICBTdGF0c01hbmFnZXIuZ2V0T3JDcmVhdGVSZXBvcnRlciA9IGZ1bmN0aW9uIChyZXBvSW5mbywgY3JlYXRvckZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBoYXNoU3RyaW5nID0gcmVwb0luZm8udG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKCF0aGlzLnJlcG9ydGVyc19baGFzaFN0cmluZ10pIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0ZXJzX1toYXNoU3RyaW5nXSA9IGNyZWF0b3JGdW5jdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyc19baGFzaFN0cmluZ107XG4gICAgfTtcbiAgICBTdGF0c01hbmFnZXIuY29sbGVjdGlvbnNfID0ge307XG4gICAgU3RhdHNNYW5hZ2VyLnJlcG9ydGVyc18gPSB7fTtcbiAgICByZXR1cm4gU3RhdHNNYW5hZ2VyO1xufSgpKTtcbmV4cG9ydCB7IFN0YXRzTWFuYWdlciB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3N0YXRzL1N0YXRzTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IFNvcnRlZE1hcCB9IGZyb20gJy4vU29ydGVkTWFwJztcbmltcG9ydCB7IFBhdGggfSBmcm9tICcuL1BhdGgnO1xuaW1wb3J0IHsgc3RyaW5nQ29tcGFyZSB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBmb3JFYWNoIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xudmFyIGVtcHR5Q2hpbGRyZW5TaW5nbGV0b247XG4vKipcbiAqIFNpbmdsZXRvbiBlbXB0eSBjaGlsZHJlbiBjb2xsZWN0aW9uLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUgeyFTb3J0ZWRNYXAuPHN0cmluZywgIUltbXV0YWJsZVRyZWUuPD8+Pn1cbiAqL1xudmFyIEVtcHR5Q2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFlbXB0eUNoaWxkcmVuU2luZ2xldG9uKSB7XG4gICAgICAgIGVtcHR5Q2hpbGRyZW5TaW5nbGV0b24gPSBuZXcgU29ydGVkTWFwKHN0cmluZ0NvbXBhcmUpO1xuICAgIH1cbiAgICByZXR1cm4gZW1wdHlDaGlsZHJlblNpbmdsZXRvbjtcbn07XG4vKipcbiAqIEEgdHJlZSB3aXRoIGltbXV0YWJsZSBlbGVtZW50cy5cbiAqL1xudmFyIEltbXV0YWJsZVRyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez9UfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U29ydGVkTWFwLjxzdHJpbmcsICFJbW11dGFibGVUcmVlLjxUPj49fSBjaGlsZHJlblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEltbXV0YWJsZVRyZWUodmFsdWUsIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7IGNoaWxkcmVuID0gRW1wdHlDaGlsZHJlbigpOyB9XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCAhVD59IG9ialxuICAgICAqIEByZXR1cm4geyFJbW11dGFibGVUcmVlLjwhVD59XG4gICAgICovXG4gICAgSW1tdXRhYmxlVHJlZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgdHJlZSA9IEltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICAgIGZvckVhY2gob2JqLCBmdW5jdGlvbiAoY2hpbGRQYXRoLCBjaGlsZFNuYXApIHtcbiAgICAgICAgICAgIHRyZWUgPSB0cmVlLnNldChuZXcgUGF0aChjaGlsZFBhdGgpLCBjaGlsZFNuYXApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBlbXB0eSBhbmQgdGhlcmUgYXJlIG5vIGNoaWxkcmVuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBJbW11dGFibGVUcmVlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gbnVsbCAmJiB0aGlzLmNoaWxkcmVuLmlzRW1wdHkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgcGF0aCBhbmQgcHJlZGljYXRlLCByZXR1cm4gdGhlIGZpcnN0IG5vZGUgYW5kIHRoZSBwYXRoIHRvIHRoYXQgbm9kZVxuICAgICAqIHdoZXJlIHRoZSBwcmVkaWNhdGUgcmV0dXJucyB0cnVlLlxuICAgICAqXG4gICAgICogVE9ETyBEbyBhIHBlcmYgdGVzdCAtLSBJZiB3ZSdyZSBjcmVhdGluZyBhIGJ1bmNoIG9mIHtwYXRoOiB2YWx1ZTp9IG9iamVjdHNcbiAgICAgKiBvbiB0aGUgd2F5IGJhY2sgb3V0LCBpdCBtYXkgYmUgYmV0dGVyIHRvIHBhc3MgZG93biBhIHBhdGhTb0ZhciBvYmouXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSByZWxhdGl2ZVBhdGggVGhlIHJlbWFpbmRlciBvZiB0aGUgcGF0aFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6Ym9vbGVhbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gc2F0aXNmeSB0byByZXR1cm4gYVxuICAgICAqICAgbm9kZVxuICAgICAqIEByZXR1cm4gez97cGF0aDohUGF0aCwgdmFsdWU6IVR9fVxuICAgICAqL1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLmZpbmRSb290TW9zdE1hdGNoaW5nUGF0aEFuZFZhbHVlID0gZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgcHJlZGljYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9IG51bGwgJiYgcHJlZGljYXRlKHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwYXRoOiBQYXRoLkVtcHR5LCB2YWx1ZTogdGhpcy52YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlUGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmcm9udCA9IHJlbGF0aXZlUGF0aC5nZXRGcm9udCgpO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkRXhpc3RpbmdQYXRoQW5kVmFsdWUgPSBjaGlsZC5maW5kUm9vdE1vc3RNYXRjaGluZ1BhdGhBbmRWYWx1ZShyZWxhdGl2ZVBhdGgucG9wRnJvbnQoKSwgcHJlZGljYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkRXhpc3RpbmdQYXRoQW5kVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bGxQYXRoID0gbmV3IFBhdGgoZnJvbnQpLmNoaWxkKGNoaWxkRXhpc3RpbmdQYXRoQW5kVmFsdWUucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBwYXRoOiBmdWxsUGF0aCwgdmFsdWU6IGNoaWxkRXhpc3RpbmdQYXRoQW5kVmFsdWUudmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmQsIGlmIGl0IGV4aXN0cywgdGhlIHNob3J0ZXN0IHN1YnBhdGggb2YgdGhlIGdpdmVuIHBhdGggdGhhdCBwb2ludHMgYSBkZWZpbmVkXG4gICAgICogdmFsdWUgaW4gdGhlIHRyZWVcbiAgICAgKiBAcGFyYW0geyFQYXRofSByZWxhdGl2ZVBhdGhcbiAgICAgKiBAcmV0dXJuIHs/e3BhdGg6ICFQYXRoLCB2YWx1ZTogIVR9fVxuICAgICAqL1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLmZpbmRSb290TW9zdFZhbHVlQW5kUGF0aCA9IGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFJvb3RNb3N0TWF0Y2hpbmdQYXRoQW5kVmFsdWUocmVsYXRpdmVQYXRoLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHJlbGF0aXZlUGF0aFxuICAgICAqIEByZXR1cm4geyFJbW11dGFibGVUcmVlLjxUPn0gVGhlIHN1YnRyZWUgYXQgdGhlIGdpdmVuIHBhdGhcbiAgICAgKi9cbiAgICBJbW11dGFibGVUcmVlLnByb3RvdHlwZS5zdWJ0cmVlID0gZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCkge1xuICAgICAgICBpZiAocmVsYXRpdmVQYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZnJvbnQgPSByZWxhdGl2ZVBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgIHZhciBjaGlsZFRyZWUgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XG4gICAgICAgICAgICBpZiAoY2hpbGRUcmVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkVHJlZS5zdWJ0cmVlKHJlbGF0aXZlUGF0aC5wb3BGcm9udCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBJbW11dGFibGVUcmVlLkVtcHR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcmVsYXRpdmVQYXRoIFBhdGggdG8gc2V0IHZhbHVlIGF0LlxuICAgICAqIEBwYXJhbSB7P1R9IHRvU2V0IFZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJuIHshSW1tdXRhYmxlVHJlZS48VD59IFJlc3VsdGluZyB0cmVlLlxuICAgICAqL1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIHRvU2V0KSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUodG9TZXQsIHRoaXMuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZyb250ID0gcmVsYXRpdmVQYXRoLmdldEZyb250KCk7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCkgfHwgSW1tdXRhYmxlVHJlZS5FbXB0eTtcbiAgICAgICAgICAgIHZhciBuZXdDaGlsZCA9IGNoaWxkLnNldChyZWxhdGl2ZVBhdGgucG9wRnJvbnQoKSwgdG9TZXQpO1xuICAgICAgICAgICAgdmFyIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5pbnNlcnQoZnJvbnQsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZSh0aGlzLnZhbHVlLCBuZXdDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHJlbGF0aXZlUGF0aCBQYXRoIHRvIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJuIHshSW1tdXRhYmxlVHJlZS48VD59IFJlc3VsdGluZyB0cmVlLlxuICAgICAqL1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgpIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlUGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJbW11dGFibGVUcmVlLkVtcHR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKG51bGwsIHRoaXMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZyb250ID0gcmVsYXRpdmVQYXRoLmdldEZyb250KCk7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q2hpbGQgPSBjaGlsZC5yZW1vdmUocmVsYXRpdmVQYXRoLnBvcEZyb250KCkpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5yZW1vdmUoZnJvbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmluc2VydChmcm9udCwgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbCAmJiBuZXdDaGlsZHJlbi5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUodGhpcy52YWx1ZSwgbmV3Q2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIGEgdmFsdWUgZnJvbSB0aGUgdHJlZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHJlbGF0aXZlUGF0aCBQYXRoIHRvIGdldCB2YWx1ZSBmb3IuXG4gICAgICogQHJldHVybiB7P1R9IFZhbHVlIGF0IHBhdGgsIG9yIG51bGwuXG4gICAgICovXG4gICAgSW1tdXRhYmxlVHJlZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCkge1xuICAgICAgICBpZiAocmVsYXRpdmVQYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZnJvbnQgPSByZWxhdGl2ZVBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcbiAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5nZXQocmVsYXRpdmVQYXRoLnBvcEZyb250KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgdGhlIHN1YnRyZWUgYXQgdGhlIHNwZWNpZmllZCBwYXRoIHdpdGggdGhlIGdpdmVuIG5ldyB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcmVsYXRpdmVQYXRoIFBhdGggdG8gcmVwbGFjZSBzdWJ0cmVlIGZvci5cbiAgICAgKiBAcGFyYW0geyFJbW11dGFibGVUcmVlfSBuZXdUcmVlIE5ldyB0cmVlLlxuICAgICAqIEByZXR1cm4geyFJbW11dGFibGVUcmVlfSBSZXN1bHRpbmcgdHJlZS5cbiAgICAgKi9cbiAgICBJbW11dGFibGVUcmVlLnByb3RvdHlwZS5zZXRUcmVlID0gZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgbmV3VHJlZSkge1xuICAgICAgICBpZiAocmVsYXRpdmVQYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld1RyZWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZnJvbnQgPSByZWxhdGl2ZVBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KSB8fCBJbW11dGFibGVUcmVlLkVtcHR5O1xuICAgICAgICAgICAgdmFyIG5ld0NoaWxkID0gY2hpbGQuc2V0VHJlZShyZWxhdGl2ZVBhdGgucG9wRnJvbnQoKSwgbmV3VHJlZSk7XG4gICAgICAgICAgICB2YXIgbmV3Q2hpbGRyZW4gPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnJlbW92ZShmcm9udCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uaW5zZXJ0KGZyb250LCBuZXdDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUodGhpcy52YWx1ZSwgbmV3Q2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlcHRoIGZpcnN0IGZvbGQgb24gdGhpcyB0cmVlLiBUcmFuc2Zvcm1zIGEgdHJlZSBpbnRvIGEgc2luZ2xlXG4gICAgICogdmFsdWUsIGdpdmVuIGEgZnVuY3Rpb24gdGhhdCBvcGVyYXRlcyBvbiB0aGUgcGF0aCB0byBhIG5vZGUsIGFuIG9wdGlvbmFsXG4gICAgICogY3VycmVudCB2YWx1ZSwgYW5kIGEgbWFwIG9mIGNoaWxkIG5hbWVzIHRvIGZvbGRlZCBzdWJ0cmVlc1xuICAgICAqIEB0ZW1wbGF0ZSBWXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihQYXRoLCA/VCwgT2JqZWN0LjxzdHJpbmcsIFY+KTpWfSBmblxuICAgICAqIEByZXR1cm4ge1Z9XG4gICAgICovXG4gICAgSW1tdXRhYmxlVHJlZS5wcm90b3R5cGUuZm9sZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gdGhpcy5mb2xkXyhQYXRoLkVtcHR5LCBmbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmUgaGVscGVyIGZvciBwdWJsaWMtZmFjaW5nIGZvbGQoKSBtZXRob2RcbiAgICAgKiBAdGVtcGxhdGUgVlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhTb0ZhclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oUGF0aCwgP1QsIE9iamVjdC48c3RyaW5nLCBWPik6Vn0gZm5cbiAgICAgKiBAcmV0dXJuIHtWfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSW1tdXRhYmxlVHJlZS5wcm90b3R5cGUuZm9sZF8gPSBmdW5jdGlvbiAocGF0aFNvRmFyLCBmbikge1xuICAgICAgICB2YXIgYWNjdW0gPSB7fTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uIChjaGlsZEtleSwgY2hpbGRUcmVlKSB7XG4gICAgICAgICAgICBhY2N1bVtjaGlsZEtleV0gPSBjaGlsZFRyZWUuZm9sZF8ocGF0aFNvRmFyLmNoaWxkKGNoaWxkS2V5KSwgZm4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZuKHBhdGhTb0ZhciwgdGhpcy52YWx1ZSwgYWNjdW0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgZmlyc3QgbWF0Y2hpbmcgdmFsdWUgb24gdGhlIGdpdmVuIHBhdGguIFJldHVybiB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGYgdG8gaXQuXG4gICAgICogQHRlbXBsYXRlIFZcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshZnVuY3Rpb24oIVBhdGgsICFUKTo/Vn0gZlxuICAgICAqIEByZXR1cm4gez9WfVxuICAgICAqL1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLmZpbmRPblBhdGggPSBmdW5jdGlvbiAocGF0aCwgZikge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kT25QYXRoXyhwYXRoLCBQYXRoLkVtcHR5LCBmKTtcbiAgICB9O1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLmZpbmRPblBhdGhfID0gZnVuY3Rpb24gKHBhdGhUb0ZvbGxvdywgcGF0aFNvRmFyLCBmKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnZhbHVlID8gZihwYXRoU29GYXIsIHRoaXMudmFsdWUpIDogZmFsc2U7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocGF0aFRvRm9sbG93LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb250ID0gcGF0aFRvRm9sbG93LmdldEZyb250KCk7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRDaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0Q2hpbGQuZmluZE9uUGF0aF8ocGF0aFRvRm9sbG93LnBvcEZyb250KCksIHBhdGhTb0Zhci5jaGlsZChmcm9udCksIGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyFmdW5jdGlvbighUGF0aCwgIVQpfSBmXG4gICAgICogQHJldHVybnMgeyFJbW11dGFibGVUcmVlLjxUPn1cbiAgICAgKi9cbiAgICBJbW11dGFibGVUcmVlLnByb3RvdHlwZS5mb3JlYWNoT25QYXRoID0gZnVuY3Rpb24gKHBhdGgsIGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yZWFjaE9uUGF0aF8ocGF0aCwgUGF0aC5FbXB0eSwgZik7XG4gICAgfTtcbiAgICBJbW11dGFibGVUcmVlLnByb3RvdHlwZS5mb3JlYWNoT25QYXRoXyA9IGZ1bmN0aW9uIChwYXRoVG9Gb2xsb3csIGN1cnJlbnRSZWxhdGl2ZVBhdGgsIGYpIHtcbiAgICAgICAgaWYgKHBhdGhUb0ZvbGxvdy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZyb250ID0gcGF0aFRvRm9sbG93LmdldEZyb250KCk7XG4gICAgICAgICAgICB2YXIgbmV4dENoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpO1xuICAgICAgICAgICAgaWYgKG5leHRDaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0Q2hpbGQuZm9yZWFjaE9uUGF0aF8ocGF0aFRvRm9sbG93LnBvcEZyb250KCksIGN1cnJlbnRSZWxhdGl2ZVBhdGguY2hpbGQoZnJvbnQpLCBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBJbW11dGFibGVUcmVlLkVtcHR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggbm9kZSBpbiB0aGUgdHJlZSB0aGF0IGhhcyBhIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbighUGF0aCwgIVQpfSBmIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGhcbiAgICAgKiAgIHRoZSBwYXRoIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHRyZWUgdG8gYSBub2RlLCBhbmQgdGhlIHZhbHVlIGF0IHRoYXQgbm9kZS5cbiAgICAgKiAgIENhbGxlZCBpbiBkZXB0aC1maXJzdCBvcmRlci5cbiAgICAgKi9cbiAgICBJbW11dGFibGVUcmVlLnByb3RvdHlwZS5mb3JlYWNoID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdGhpcy5mb3JlYWNoXyhQYXRoLkVtcHR5LCBmKTtcbiAgICB9O1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLmZvcmVhY2hfID0gZnVuY3Rpb24gKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIGYpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uIChjaGlsZE5hbWUsIGNoaWxkVHJlZSkge1xuICAgICAgICAgICAgY2hpbGRUcmVlLmZvcmVhY2hfKGN1cnJlbnRSZWxhdGl2ZVBhdGguY2hpbGQoY2hpbGROYW1lKSwgZik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgZihjdXJyZW50UmVsYXRpdmVQYXRoLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgIVQpfSBmXG4gICAgICovXG4gICAgSW1tdXRhYmxlVHJlZS5wcm90b3R5cGUuZm9yZWFjaENoaWxkID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uIChjaGlsZE5hbWUsIGNoaWxkVHJlZSkge1xuICAgICAgICAgICAgaWYgKGNoaWxkVHJlZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGYoY2hpbGROYW1lLCBjaGlsZFRyZWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEltbXV0YWJsZVRyZWUuRW1wdHkgPSBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcbiAgICByZXR1cm4gSW1tdXRhYmxlVHJlZTtcbn0oKSk7XG5leHBvcnQgeyBJbW11dGFibGVUcmVlIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvdXRpbC9JbW11dGFibGVUcmVlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgQ2hhbmdlIH0gZnJvbSAnLi4vQ2hhbmdlJztcbmltcG9ydCB7IENoaWxkcmVuTm9kZSB9IGZyb20gJy4uLy4uL3NuYXAvQ2hpbGRyZW5Ob2RlJztcbmltcG9ydCB7IFBSSU9SSVRZX0lOREVYIH0gZnJvbSAnLi4vLi4vc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXgnO1xuLyoqXG4gKiBEb2Vzbid0IHJlYWxseSBmaWx0ZXIgbm9kZXMgYnV0IGFwcGxpZXMgYW4gaW5kZXggdG8gdGhlIG5vZGUgYW5kIGtlZXBzIHRyYWNrIG9mIGFueSBjaGFuZ2VzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7Tm9kZUZpbHRlcn1cbiAqIEBwYXJhbSB7IUluZGV4fSBpbmRleFxuICovXG52YXIgSW5kZXhlZEZpbHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbmRleGVkRmlsdGVyKGluZGV4Xykge1xuICAgICAgICB0aGlzLmluZGV4XyA9IGluZGV4XztcbiAgICB9XG4gICAgSW5kZXhlZEZpbHRlci5wcm90b3R5cGUudXBkYXRlQ2hpbGQgPSBmdW5jdGlvbiAoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XG4gICAgICAgIGFzc2VydChzbmFwLmlzSW5kZXhlZCh0aGlzLmluZGV4XyksICdBIG5vZGUgbXVzdCBiZSBpbmRleGVkIGlmIG9ubHkgYSBjaGlsZCBpcyB1cGRhdGVkJyk7XG4gICAgICAgIHZhciBvbGRDaGlsZCA9IHNuYXAuZ2V0SW1tZWRpYXRlQ2hpbGQoa2V5KTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55dGhpbmcgYWN0dWFsbHkgY2hhbmdlZC5cbiAgICAgICAgaWYgKG9sZENoaWxkLmdldENoaWxkKGFmZmVjdGVkUGF0aCkuZXF1YWxzKG5ld0NoaWxkLmdldENoaWxkKGFmZmVjdGVkUGF0aCkpKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSdzIGFuIGVkZ2UgY2FzZSB3aGVyZSBhIGNoaWxkIGNhbiBlbnRlciBvciBsZWF2ZSB0aGUgdmlldyBiZWNhdXNlIGFmZmVjdGVkUGF0aCB3YXMgc2V0IHRvIG51bGwuXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIGFmZmVjdGVkUGF0aCB3aWxsIGFwcGVhciBudWxsIGluIGJvdGggdGhlIG9sZCBhbmQgbmV3IHNuYXBzaG90cy4gIFNvIHdlIG5lZWRcbiAgICAgICAgICAgIC8vIHRvIGF2b2lkIHRyZWF0aW5nIHRoZXNlIGNhc2VzIGFzIFwibm90aGluZyBjaGFuZ2VkLlwiXG4gICAgICAgICAgICBpZiAob2xkQ2hpbGQuaXNFbXB0eSgpID09IG5ld0NoaWxkLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFzc2VydCBzaG91bGQgYmUgdmFsaWQsIGJ1dCBpdCdzIGV4cGVuc2l2ZSAoY2FuIGRvbWluYXRlIHBlcmYgdGVzdGluZykgc28gZG9uJ3QgYWN0dWFsbHkgZG8gaXQuXG4gICAgICAgICAgICAgICAgLy9hc3NlcnQob2xkQ2hpbGQuZXF1YWxzKG5ld0NoaWxkKSwgJ09sZCBhbmQgbmV3IHNuYXBzaG90cyBzaG91bGQgYmUgZXF1YWwuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdENoYW5nZUFjY3VtdWxhdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc25hcC5oYXNDaGlsZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdENoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoQ2hhbmdlLmNoaWxkUmVtb3ZlZENoYW5nZShrZXksIG9sZENoaWxkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc25hcC5pc0xlYWZOb2RlKCksICdBIGNoaWxkIHJlbW92ZSB3aXRob3V0IGFuIG9sZCBjaGlsZCBvbmx5IG1ha2VzIHNlbnNlIG9uIGEgbGVhZiBub2RlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob2xkQ2hpbGQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShDaGFuZ2UuY2hpbGRBZGRlZENoYW5nZShrZXksIG5ld0NoaWxkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKENoYW5nZS5jaGlsZENoYW5nZWRDaGFuZ2Uoa2V5LCBuZXdDaGlsZCwgb2xkQ2hpbGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc25hcC5pc0xlYWZOb2RlKCkgJiYgbmV3Q2hpbGQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gc25hcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgbm9kZSBpcyBpbmRleGVkXG4gICAgICAgICAgICByZXR1cm4gc25hcC51cGRhdGVJbW1lZGlhdGVDaGlsZChrZXksIG5ld0NoaWxkKS53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIEluZGV4ZWRGaWx0ZXIucHJvdG90eXBlLnVwZGF0ZUZ1bGxOb2RlID0gZnVuY3Rpb24gKG9sZFNuYXAsIG5ld1NuYXAsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XG4gICAgICAgIGlmIChvcHRDaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIW9sZFNuYXAuaXNMZWFmTm9kZSgpKSB7XG4gICAgICAgICAgICAgICAgb2xkU25hcC5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIGZ1bmN0aW9uIChrZXksIGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1NuYXAuaGFzQ2hpbGQoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShDaGFuZ2UuY2hpbGRSZW1vdmVkQ2hhbmdlKGtleSwgY2hpbGROb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV3U25hcC5pc0xlYWZOb2RlKCkpIHtcbiAgICAgICAgICAgICAgICBuZXdTbmFwLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgZnVuY3Rpb24gKGtleSwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRTbmFwLmhhc0NoaWxkKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRDaGlsZCA9IG9sZFNuYXAuZ2V0SW1tZWRpYXRlQ2hpbGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2xkQ2hpbGQuZXF1YWxzKGNoaWxkTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKENoYW5nZS5jaGlsZENoYW5nZWRDaGFuZ2Uoa2V5LCBjaGlsZE5vZGUsIG9sZENoaWxkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKENoYW5nZS5jaGlsZEFkZGVkQ2hhbmdlKGtleSwgY2hpbGROb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U25hcC53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBJbmRleGVkRmlsdGVyLnByb3RvdHlwZS51cGRhdGVQcmlvcml0eSA9IGZ1bmN0aW9uIChvbGRTbmFwLCBuZXdQcmlvcml0eSkge1xuICAgICAgICBpZiAob2xkU25hcC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvbGRTbmFwLnVwZGF0ZVByaW9yaXR5KG5ld1ByaW9yaXR5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBJbmRleGVkRmlsdGVyLnByb3RvdHlwZS5maWx0ZXJzTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgSW5kZXhlZEZpbHRlci5wcm90b3R5cGUuZ2V0SW5kZXhlZEZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIEluZGV4ZWRGaWx0ZXIucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleF87XG4gICAgfTtcbiAgICByZXR1cm4gSW5kZXhlZEZpbHRlcjtcbn0oKSk7XG5leHBvcnQgeyBJbmRleGVkRmlsdGVyIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvdmlldy9maWx0ZXIvSW5kZXhlZEZpbHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBGaXJlYmFzZSBjb25zdGFudHMuICBTb21lIG9mIHRoZXNlIChAZGVmaW5lcykgY2FuIGJlIG92ZXJyaWRkZW4gYXQgY29tcGlsZS10aW1lLlxuICovXG5leHBvcnQgdmFyIENPTlNUQU5UUyA9IHtcbiAgICAvKipcbiAgICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIGNsaWVudCBOb2RlLmpzIFNESy5cbiAgICAgKi9cbiAgICBOT0RFX0NMSUVOVDogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGlzIHRoZSBBZG1pbiBOb2RlLmpzIFNESy5cbiAgICAgKi9cbiAgICBOT0RFX0FETUlOOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBGaXJlYmFzZSBTREsgVmVyc2lvblxuICAgICAqL1xuICAgIFNES19WRVJTSU9OOiAnJHtKU0NPUkVfVkVSU0lPTn0nXG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL3V0aWwvZGlzdC9lc20vc3JjL2NvbnN0YW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5pbXBvcnQgKiBhcyBtYXRocyBmcm9tIFwiLi9tYXRoc1wiO1xuaW1wb3J0ICogYXMgcmFuZG9tIGZyb20gXCIuL3JhbmRvbVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYW5nZSB7XG5cbiAgLy8gQ29uc3RydWN0b3JcblxuICBjb25zdHJ1Y3RvcihtaW4gPSBOYU4sIG1heCA9IE5hTikge1xuXG4gICAgaWYgKGlzTmFOKG1heCkgJiYgaXNOYU4obWF4KSkge1xuICAgICAgdGhpcy5taW4gID0gMDtcbiAgICAgIHRoaXMubWF4ICA9IDE7XG4gICAgfSBlbHNlIGlmIChpc05hTihtYXgpKSB7XG4gICAgICB0aGlzLm1pbiAgPSAwO1xuICAgICAgdGhpcy5tYXggID0gbWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1pbiAgPSBtaW47XG4gICAgICB0aGlzLm1heCAgPSBtYXg7XG4gICAgfVxuXG4gIH1cblxuICAvLyBHZXQvc2V0XG5cbiAgZ2V0IG1pZGRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXJwKDAuNSk7XG4gIH1cbiAgZ2V0IGNlbnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5sZXJwKDAuNSk7XG4gIH1cblxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLm1heCAtIHRoaXMubWluO1xuICB9XG4gIGdldCByYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXggLSB0aGlzLm1pbjtcbiAgfVxuXG4gIGdldCByYW5kb20oKSB7XG4gICAgcmV0dXJuIHJhbmRvbS5udW0odGhpcy5taW4sIHRoaXMubWF4KTtcbiAgfVxuICBnZXQgcmFuZG9tSW50KCkge1xuICAgIHJldHVybiByYW5kb20uaW50KHRoaXMubWluLCB0aGlzLm1heCk7XG4gIH1cblxuICBnZXQgaXNJbnRSYW5nZSgpIHtcbiAgICByZXR1cm4gbWF0aHMuaXNJbnQodGhpcy5taW4pICYmIG1hdGhzLmlzSW50KHRoaXMubWF4KTtcbiAgfVxuXG5cbiAgLy8gTWV0aG9kc1xuXG4gIGxlcnAodmFsLCBjbGFtcCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIG1hdGhzLmxlcnAodGhpcy5taW4sIHRoaXMubWF4LCB2YWwsIGNsYW1wKTtcbiAgfVxuICBub3JtKHZhbCwgY2xhbXAgPSBmYWxzZSkge1xuICAgIHJldHVybiBtYXRocy5ub3JtKHZhbCwgdGhpcy5taW4sIHRoaXMubWF4LCBjbGFtcCk7XG4gIH1cblxuICBtYXBGcm9tKHZhbCwgZnJvbU1pbiwgZnJvbU1heCkge1xuICAgIHJldHVybiBtYXRocy5tYXAodmFsLCBmcm9tTWluLCBmcm9tTWF4LCB0aGlzLm1pbiwgdGhpcy5tYXgpO1xuICB9XG4gIG1hcFRvKHZhbCwgdG9NaW4sIHRvTWF4KSB7XG4gICAgcmV0dXJuIG1hdGhzLm1hcCh2YWwsIHRoaXMubWluLCB0aGlzLm1heCwgdG9NaW4sIHRvTWF4KTtcbiAgfVxuXG4gIG1hcEZyb21SYW5nZSh2YWwsIGZyb21SYW5nZSwgY2xhbXAgPSBmYWxzZSkge1xuICAgIHJldHVybiBtYXRocy5tYXAodmFsLCBmcm9tUmFuZ2UubWluLCBmcm9tUmFuZ2UubWF4LCB0aGlzLm1pbiwgdGhpcy5tYXgsIGNsYW1wKTtcbiAgfVxuICBtYXBUb1JhbmdlKHZhbCwgdG9SYW5nZSwgY2xhbXAgPSBmYWxzZSkge1xuICAgIHJldHVybiBtYXRocy5tYXAodmFsLCB0aGlzLm1pbiwgdGhpcy5tYXgsIHRvUmFuZ2UubWluLCB0b1JhbmdlLm1heCwgY2xhbXApO1xuICB9XG5cbiAgY2xhbXAodmFsKSB7XG4gICAgcmV0dXJuIG1hdGhzLmNsYW1wKHZhbCwgdGhpcy5taW4sIHRoaXMubWF4KTtcbiAgfVxuICB3cmFwKHZhbCkge1xuICAgIGlmIChtYXRocy5pc0ludCh2YWwpICYmIGlzSW50UmFuZ2UpIHtcbiAgICAgIHJldHVybiBtYXRocy53cmFwKHZhbCwgdGhpcy5taW4sIHRoaXMubWF4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1hdGhzLndyYXBOdW0odmFsLCB0aGlzLm1pbiwgdGhpcy5tYXgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnRhaW5zKHZhbCkge1xuICAgIHJldHVybiAodmFsID49IHRoaXMubWluKSAmJiAodmFsIDw9IHRoaXMubWF4KTtcbiAgfVxuXG4gIGludmVydCgpIHtcbiAgICBsZXQgdGVtcCA9IHRoaXMubWluO1xuICAgIHRoaXMubWluID0gdGhpcy5tYXg7XG4gICAgdGhpcy5tYXggPSB0ZW1wO1xuICB9XG5cbiAgdHJpbSh0cmltTWluLCB0cmltTWF4KSB7XG4gICAgdGhpcy5taW4gPSBtYXRocy5jbGFtcCh0aGlzLm1pbiwgdHJpbU1pbiwgdHJpbU1heCk7XG4gICAgdGhpcy5tYXggPSBtYXRocy5jbGFtcCh0aGlzLm1heCwgdHJpbU1pbiwgdHJpbU1heCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJbXCIgKyB0aGlzLm1pbiArIFwiLi5cIiArIHRoaXMubWF4ICsgXCJdXCI7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLm1pbiwgdGhpcy5tYXgpO1xuICB9XG5cbiAgZW52ZWxvcCh2YWwpIHtcbiAgICB0aGlzLm1pbiAgPSBNYXRoLm1pbih0aGlzLm1pbiwgdmFsKTtcbiAgICB0aGlzLm1heCAgPSBNYXRoLm1pbih0aGlzLm1heCwgdmFsKTtcbiAgfVxuXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdmFyeWQtdXRpbHMvUmFuZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLy8gSW1wb3J0c1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuXG5pbXBvcnQgZmlyZWJhc2UgZnJvbSAnZmlyZWJhc2UvYXBwJztcblxuaW1wb3J0IEFwcCBmcm9tICcuL0FwcCc7XG5cbi8vIENvbnN0YW50c1xuXG5cbi8vIENvbXBvbmVudFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXN0b21pemVBY3Rpdml0eUZvcm0gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8vIENvbnN0cnVjdG9yXG5cbiAgY29uc3RydWN0b3IoKSB7XG5cbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5oYW5kbGVJbnB1dENoYW5nZSA9IGUgPT4ge1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgW2UuY3VycmVudFRhcmdldC5uYW1lXTogZS5jdXJyZW50VGFyZ2V0LnZhbHVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVTdWJtaXQgPSBlID0+IHtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpZiAodGhpcy52YWxpZGF0ZSgpKSB7XG5cbiAgICAgICAgY29uc3QgYWN0aXZpdHkgPSB7XG4gICAgICAgICAgbGFiZWw6IHRoaXMuc3RhdGUudmFsTGFiZWxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmFjdGl2aXRpZXNSZWYucHVzaChhY3Rpdml0eSwgZXJyb3IgPT4ge1xuXG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5jbGVhcklucHV0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pbml0U3RhdGUoKTtcbiAgfVxuXG4gIGluaXRTdGF0ZSgpIHtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB2YWxMYWJlbDogJydcbiAgICB9O1xuICB9XG5cbiAgLy8gRXZlbnQgaGFuZGxlcnNcblxuICAvLyBNZXRob2RzXG5cbiAgY2xlYXJJbnB1dCgpIHtcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdmFsTGFiZWw6ICcnXG4gICAgfSk7XG4gIH1cblxuICB2YWxpZGF0ZSgpIHtcblxuICAgIGNvbnN0IGhhc0xhYmVsID0gdGhpcy5zdGF0ZS52YWxMYWJlbCAmJiB0aGlzLnN0YXRlLnZhbExhYmVsLmxlbmd0aDtcblxuICAgIHJldHVybiBoYXNMYWJlbDtcbiAgfVxuXG4gIC8vIFJlYWN0XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG5cbiAgICBjb25zdCB1c2VySWQgPSBmaXJlYmFzZS5hdXRoKCkuY3VycmVudFVzZXIudWlkO1xuXG4gICAgdGhpcy5hY3Rpdml0aWVzUmVmID0gZmlyZWJhc2UuZGF0YWJhc2UoKS5yZWYoYGFjdGl2aXRpZXMvJHt1c2VySWR9YCk7XG4gIH1cblxuICByZW5kZXIoKSB7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdmb3JtJyxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYWN0aXZpdHktaW5wdXQnLFxuICAgICAgICBvblN1Ym1pdDogdGhpcy5oYW5kbGVTdWJtaXQgfSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdoMycsXG4gICAgICAgIG51bGwsXG4gICAgICAgICdBZGQgQWN0aXZpdHknXG4gICAgICApLFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3AnLFxuICAgICAgICBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaHRtbEZvcjogJ2FjdGl2aXR5LWlucHV0LWxhYmVsJyB9LFxuICAgICAgICAgICdMYWJlbCdcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdwJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaW5wdXQnLCB7XG4gICAgICAgICAgaWQ6ICdhY3Rpdml0eS1pbnB1dC1sYWJlbCcsXG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIG5hbWU6ICd2YWxMYWJlbCcsXG4gICAgICAgICAgdmFsdWU6IHRoaXMuc3RhdGUudmFsTGFiZWwsXG4gICAgICAgICAgb25DaGFuZ2U6IHRoaXMuaGFuZGxlSW5wdXRDaGFuZ2UgfSlcbiAgICAgICksXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAncCcsXG4gICAgICAgIG51bGwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jywge1xuICAgICAgICAgIGlkOiAnYWN0aXZpdHktaW5wdXQtc3VibWl0JyxcbiAgICAgICAgICB0eXBlOiAnc3VibWl0JyxcbiAgICAgICAgICBkaXNhYmxlZDogIXRoaXMudmFsaWRhdGUoKSB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cblxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL3NyYy9jb21wb25lbnRzL0N1c3RvbWl6ZUFjdGl2aXR5Rm9ybS5qc3hcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLy8gSW1wb3J0c1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBmaXJlYmFzZSBmcm9tICdmaXJlYmFzZS9hcHAnO1xuXG5pbXBvcnQgQXBwIGZyb20gJy4vQXBwJztcbmltcG9ydCBDdXN0b21pemVUYWJsZUNlbGwgZnJvbSAnLi9DdXN0b21pemVUYWJsZUNlbGwnO1xuXG4vLyBDb25zdGFudHNcblxuXG4vLyBDb21wb25lbnRcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3VzdG9taXplVGFibGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8vIENvbnN0cnVjdG9yXG5cbiAgY29uc3RydWN0b3IoKSB7XG5cbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5oYW5kbGVDYXRlZ29yaWVzVmFsdWUgPSBkYXRhID0+IHtcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGNhdGVnb3JpZXM6IGRhdGEudmFsKCkgPyBkYXRhLnZhbCgpIDoge31cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLmhhbmRsZVZhbHVlc1ZhbHVlID0gZGF0YSA9PiB7XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB2YWx1ZXM6IGRhdGEudmFsKCkgPyBkYXRhLnZhbCgpIDoge31cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLmhhbmRsZUFjdGl2aXRpZXNWYWx1ZSA9IGRhdGEgPT4ge1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYWN0aXZpdGllczogZGF0YS52YWwoKSA/IGRhdGEudmFsKCkgOiB7fVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuaGFuZGxlV2VpZ2h0Q2hhbmdlID0gKGFjdEtleSwgdmFsTGlua0tleSwgd2VpZ2h0KSA9PiB7XG5cbiAgICAgIHdlaWdodCA9IE1hdGgubWluKDMsIE1hdGgubWF4KDAsIHdlaWdodCkpO1xuXG4gICAgICB0aGlzLmFjdGl2aXRpZXNSZWYuY2hpbGQoYWN0S2V5ICsgJy92YWx1ZXMvJyArIHZhbExpbmtLZXkpLnVwZGF0ZSh7XG4gICAgICAgIHdlaWdodDogd2VpZ2h0XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5pbml0U3RhdGUoKTtcbiAgfVxuXG4gIGluaXRTdGF0ZSgpIHtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBjYXRlZ29yaWVzOiB1bmRlZmluZWQsXG4gICAgICB2YWx1ZXM6IHVuZGVmaW5lZCxcbiAgICAgIGFjdGl2aXRpZXM6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxuICAvLyBFdmVudCBoYW5kbGVyc1xuXG4gIC8vIE1ldGhvZHNcblxuICBkZWxldGVBY3Rpdml0eShhY3RLZXkpIHtcblxuICAgIHRoaXMuYWN0aXZpdGllc1JlZi5jaGlsZChhY3RLZXkpLnJlbW92ZSgpO1xuICB9XG4gIGRlbGV0ZVZhbHVlKHZhbEtleSkge1xuXG4gICAgdGhpcy52YWx1ZXNSZWYuY2hpbGQodmFsS2V5KS5yZW1vdmUoKTtcbiAgfVxuXG4gIGdldFZhbHVlc0J5Q2F0ZWdvcnlLZXkoY2F0S2V5LCB2YWx1ZXMpIHtcblxuICAgIGNvbnN0IG9iaiA9IHt9O1xuXG4gICAgXy5lYWNoKHZhbHVlcywgKHZhbHVlLCB2YWxLZXkpID0+IHtcblxuICAgICAgaWYgKHZhbHVlLmNhdGVnb3J5X2tleSA9PT0gY2F0S2V5KSB7XG4gICAgICAgIG9ialt2YWxLZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgLy8gUmVhY3RcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcblxuICAgIGNvbnN0IHVzZXJJZCA9IGZpcmViYXNlLmF1dGgoKS5jdXJyZW50VXNlci51aWQ7XG5cbiAgICB0aGlzLmNhdGVnb3JpZXNSZWYgPSBmaXJlYmFzZS5kYXRhYmFzZSgpLnJlZihgY2F0ZWdvcmllcy8ke3VzZXJJZH1gKTtcbiAgICB0aGlzLnZhbHVlc1JlZiA9IGZpcmViYXNlLmRhdGFiYXNlKCkucmVmKGB2YWx1ZXMvJHt1c2VySWR9YCk7XG4gICAgdGhpcy5hY3Rpdml0aWVzUmVmID0gZmlyZWJhc2UuZGF0YWJhc2UoKS5yZWYoYGFjdGl2aXRpZXMvJHt1c2VySWR9YCk7XG5cbiAgICB0aGlzLmNhdGVnb3JpZXNSZWYub24oJ3ZhbHVlJywgdGhpcy5oYW5kbGVDYXRlZ29yaWVzVmFsdWUpO1xuICAgIHRoaXMudmFsdWVzUmVmLm9uKCd2YWx1ZScsIHRoaXMuaGFuZGxlVmFsdWVzVmFsdWUpO1xuICAgIHRoaXMuYWN0aXZpdGllc1JlZi5vbigndmFsdWUnLCB0aGlzLmhhbmRsZUFjdGl2aXRpZXNWYWx1ZSk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblxuICAgIGlmICh0aGlzLmNhdGVnb3JpZXNSZWYpIHRoaXMuY2F0ZWdvcmllc1JlZi5vZmYoJ3ZhbHVlJywgdGhpcy5oYW5kbGVDYXRlZ29yaWVzVmFsdWUpO1xuICAgIGlmICh0aGlzLnZhbHVlc1JlZikgdGhpcy52YWx1ZXNSZWYub2ZmKCd2YWx1ZScsIHRoaXMuaGFuZGxlVmFsdWVzVmFsdWUpO1xuICAgIGlmICh0aGlzLmFjdGl2aXRpZXNSZWYpIHRoaXMuYWN0aXZpdGllc1JlZi5vZmYoJ3ZhbHVlJywgdGhpcy5oYW5kbGVBY3Rpdml0aWVzVmFsdWUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuXG4gICAgY29uc3QgY2F0ZWdvcmllcyA9IHRoaXMuc3RhdGUuY2F0ZWdvcmllcyxcbiAgICAgICAgICB2YWx1ZXMgPSB0aGlzLnN0YXRlLnZhbHVlcyxcbiAgICAgICAgICBhY3Rpdml0aWVzID0gdGhpcy5zdGF0ZS5hY3Rpdml0aWVzO1xuXG4gICAgY29uc3QgZGF0YUxvYWRlZCA9IGNhdGVnb3JpZXMgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZXMgIT09IHVuZGVmaW5lZCAmJiBhY3Rpdml0aWVzICE9PSB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCBub0RhdGEgPSBfLmlzRW1wdHkoY2F0ZWdvcmllcykgJiYgXy5pc0VtcHR5KHZhbHVlcykgJiYgXy5pc0VtcHR5KGFjdGl2aXRpZXMpO1xuXG4gICAgaWYgKCFkYXRhTG9hZGVkKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3AnLFxuICAgICAgICBudWxsLFxuICAgICAgICAnTG9hZGluZy4uLidcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChub0RhdGEpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAncCcsXG4gICAgICAgIG51bGwsXG4gICAgICAgICdObyBkYXRhJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICd0YWJsZScsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2N1c3RvbWl6ZS10YWJsZScgfSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICd0aGVhZCcsXG4gICAgICAgIG51bGwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3RyJyxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3RoJywgbnVsbCksXG4gICAgICAgICAgXy5tYXAoY2F0ZWdvcmllcywgKGNhdGVnb3J5LCBrZXkpID0+IHtcblxuICAgICAgICAgICAgaWYgKCFjYXRlZ29yeSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIGxldCBjYXRWYWxzID0gdGhpcy5nZXRWYWx1ZXNCeUNhdGVnb3J5S2V5KGtleSwgdmFsdWVzKSxcbiAgICAgICAgICAgICAgICBjb3VudCA9IF8uc2l6ZShjYXRWYWxzKTtcblxuICAgICAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICd0aCcsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICBjb2xTcGFuOiBjb3VudCB9LFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5LmxhYmVsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAndHInLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgndGgnLCBudWxsKSxcbiAgICAgICAgICBfLm1hcChjYXRlZ29yaWVzLCAoY2F0ZWdvcnksIGNhdEtleSkgPT4ge1xuXG4gICAgICAgICAgICBsZXQgY2F0VmFscyA9IHRoaXMuZ2V0VmFsdWVzQnlDYXRlZ29yeUtleShjYXRLZXksIHZhbHVlcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBfLm1hcChjYXRWYWxzLCAodmFsdWUsIHZhbEtleSkgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ3RoJyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGtleTogdmFsS2V5IH0sXG4gICAgICAgICAgICAgIHZhbHVlLmxhYmVsLFxuICAgICAgICAgICAgICAnXFx4QTAnLFxuICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdyZW1vdmUtYnRuJyxcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHRoaXMuZGVsZXRlVmFsdWUodmFsS2V5KSB9LFxuICAgICAgICAgICAgICAgICdcXHhENydcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICd0Ym9keScsXG4gICAgICAgIG51bGwsXG4gICAgICAgIF8ubWFwKGFjdGl2aXRpZXMsIChhY3Rpdml0eSwgYWN0S2V5KSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICd0cicsXG4gICAgICAgICAgeyBrZXk6IGFjdEtleSB9LFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAndGgnLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGFjdGl2aXR5LmxhYmVsLFxuICAgICAgICAgICAgJ1xceEEwJyxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3JlbW92ZS1idG4nLFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHRoaXMuZGVsZXRlQWN0aXZpdHkoYWN0S2V5KSB9LFxuICAgICAgICAgICAgICAnXFx4RDcnXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSxcbiAgICAgICAgICBfLm1hcChjYXRlZ29yaWVzLCAoY2F0ZWdvcnksIGNhdEtleSkgPT4ge1xuXG4gICAgICAgICAgICBsZXQgY2F0VmFscyA9IHRoaXMuZ2V0VmFsdWVzQnlDYXRlZ29yeUtleShjYXRLZXksIHZhbHVlcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBfLm1hcChjYXRWYWxzLCAodmFsdWUsIHZhbEtleSkgPT4ge1xuXG4gICAgICAgICAgICAgIGNvbnN0IHZhbExpbmsgPSBfLmZpbmQoYWN0aXZpdHkudmFsdWVzLCB2YWxMaW5rID0+IHZhbExpbmsudmFsdWVfa2V5ID09PSB2YWxLZXkpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEN1c3RvbWl6ZVRhYmxlQ2VsbCwge1xuICAgICAgICAgICAgICAgIGtleTogdmFsS2V5LFxuICAgICAgICAgICAgICAgIGFjdEtleTogYWN0S2V5LFxuICAgICAgICAgICAgICAgIGFjdGl2aXR5OiBhY3Rpdml0eSxcbiAgICAgICAgICAgICAgICB2YWxMaW5rS2V5OiB2YWxLZXksXG4gICAgICAgICAgICAgICAgb25XZWlnaHRDaGFuZ2U6IHRoaXMuaGFuZGxlV2VpZ2h0Q2hhbmdlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKSlcbiAgICAgIClcbiAgICApO1xuICB9XG5cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FwcC9zcmMvY29tcG9uZW50cy9DdXN0b21pemVUYWJsZS5qc3hcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLy8gSW1wb3J0c1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuXG5pbXBvcnQgZmlyZWJhc2UgZnJvbSAnZmlyZWJhc2UvYXBwJztcblxuaW1wb3J0IEFwcCBmcm9tICcuL0FwcCc7XG5cbi8vIENvbnN0YW50c1xuXG5cbi8vIENvbXBvbmVudFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXN0b21pemVWYWx1ZUZvcm0gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8vIENvbnN0cnVjdG9yXG5cbiAgY29uc3RydWN0b3IoKSB7XG5cbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5oYW5kbGVDYXRlZ29yaWVzVmFsdWUgPSBkYXRhID0+IHtcblxuICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IGRhdGEudmFsKCkgPyBkYXRhLnZhbCgpIDoge30sXG4gICAgICAgICAgICBoYXNWYWxDYXRlZ29yeSA9IHRoaXMuc3RhdGUudmFsQ2F0ZWdvcnkgJiYgdGhpcy5zdGF0ZS52YWxDYXRlZ29yeS5sZW5ndGgsXG4gICAgICAgICAgICB2YWxDYXRlZ29yeSA9IGhhc1ZhbENhdGVnb3J5ID8gdGhpcy5zdGF0ZS52YWxDYXRlZ29yeSA6IF8ua2V5cyhjYXRlZ29yaWVzKVswXTtcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGNhdGVnb3JpZXM6IGNhdGVnb3JpZXMsXG4gICAgICAgIHZhbENhdGVnb3J5OiB2YWxDYXRlZ29yeVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuaGFuZGxlSW5wdXRDaGFuZ2UgPSBlID0+IHtcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIFtlLmN1cnJlbnRUYXJnZXQubmFtZV06IGUuY3VycmVudFRhcmdldC52YWx1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuaGFuZGxlU3VibWl0ID0gZSA9PiB7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKHRoaXMudmFsaWRhdGUoKSkge1xuXG4gICAgICAgIGNvbnN0IHZhbHVlID0ge1xuICAgICAgICAgIGNhdGVnb3J5X2tleTogdGhpcy5zdGF0ZS52YWxDYXRlZ29yeSxcbiAgICAgICAgICBsYWJlbDogdGhpcy5zdGF0ZS52YWxMYWJlbFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudmFsdWVzUmVmLnB1c2godmFsdWUsIGVycm9yID0+IHtcblxuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJJbnB1dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaW5pdFN0YXRlKCk7XG4gIH1cblxuICBpbml0U3RhdGUoKSB7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgY2F0ZWdvcmllczogdW5kZWZpbmVkLFxuICAgICAgdmFsQ2F0ZWdvcnk6ICcnLFxuICAgICAgdmFsTGFiZWw6ICcnXG4gICAgfTtcbiAgfVxuXG4gIC8vIEV2ZW50IGhhbmRsZXJzXG5cbiAgLy8gTWV0aG9kc1xuXG4gIGNsZWFySW5wdXQoKSB7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHZhbExhYmVsOiAnJ1xuICAgIH0pO1xuICB9XG5cbiAgdmFsaWRhdGUoKSB7XG5cbiAgICBjb25zdCBoYXNDYXRlZ29yeSA9IHRoaXMuc3RhdGUudmFsQ2F0ZWdvcnkgJiYgdGhpcy5zdGF0ZS52YWxDYXRlZ29yeS5sZW5ndGg7XG5cbiAgICBjb25zdCBoYXNMYWJlbCA9IHRoaXMuc3RhdGUudmFsTGFiZWwgJiYgdGhpcy5zdGF0ZS52YWxMYWJlbC5sZW5ndGg7XG5cbiAgICByZXR1cm4gaGFzQ2F0ZWdvcnkgJiYgaGFzTGFiZWw7XG4gIH1cblxuICAvLyBSZWFjdFxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuXG4gICAgY29uc3QgdXNlcklkID0gZmlyZWJhc2UuYXV0aCgpLmN1cnJlbnRVc2VyLnVpZDtcblxuICAgIHRoaXMuY2F0ZWdvcmllc1JlZiA9IGZpcmViYXNlLmRhdGFiYXNlKCkucmVmKGBjYXRlZ29yaWVzLyR7dXNlcklkfWApO1xuICAgIHRoaXMudmFsdWVzUmVmID0gZmlyZWJhc2UuZGF0YWJhc2UoKS5yZWYoYHZhbHVlcy8ke3VzZXJJZH1gKTtcblxuICAgIHRoaXMuY2F0ZWdvcmllc1JlZi5vbigndmFsdWUnLCB0aGlzLmhhbmRsZUNhdGVnb3JpZXNWYWx1ZSk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblxuICAgIGlmICh0aGlzLmNhdGVnb3JpZXNSZWYpIHRoaXMuY2F0ZWdvcmllc1JlZi5vZmYoJ3ZhbHVlJywgdGhpcy5oYW5kbGVDYXRlZ29yaWVzVmFsdWUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZm9ybScsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3ZhbHVlLWlucHV0JyxcbiAgICAgICAgb25TdWJtaXQ6IHRoaXMuaGFuZGxlU3VibWl0IH0sXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnaDMnLFxuICAgICAgICBudWxsLFxuICAgICAgICAnQWRkIFZhbHVlJ1xuICAgICAgKSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdwJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnbGFiZWwnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGh0bWxGb3I6ICd2YWx1ZS1zZWxlY3QtY2F0ZWdvcnknIH0sXG4gICAgICAgICAgJ0NhdGVnb3J5J1xuICAgICAgICApXG4gICAgICApLFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3AnLFxuICAgICAgICBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdzZWxlY3QnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiAndmFsdWUtc2VsZWN0LWNhdGVnb3J5JyxcbiAgICAgICAgICAgIG5hbWU6ICd2YWxDYXRlZ29yeScsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5zdGF0ZS52YWxDYXRlZ29yeSxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLmhhbmRsZUlucHV0Q2hhbmdlIH0sXG4gICAgICAgICAgXy5tYXAodGhpcy5zdGF0ZS5jYXRlZ29yaWVzLCAoY2F0ZWdvcnksIGNhdEtleSkgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdvcHRpb24nLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBrZXk6IGNhdEtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IGNhdEtleSB9LFxuICAgICAgICAgICAgY2F0ZWdvcnkubGFiZWxcbiAgICAgICAgICApKVxuICAgICAgICApXG4gICAgICApLFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3AnLFxuICAgICAgICBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaHRtbEZvcjogJ3ZhbHVlLWlucHV0LWxhYmVsJyB9LFxuICAgICAgICAgICdMYWJlbCdcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdwJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaW5wdXQnLCB7XG4gICAgICAgICAgaWQ6ICd2YWx1ZS1pbnB1dC1sYWJlbCcsXG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIG5hbWU6ICd2YWxMYWJlbCcsXG4gICAgICAgICAgdmFsdWU6IHRoaXMuc3RhdGUudmFsTGFiZWwsXG4gICAgICAgICAgb25DaGFuZ2U6IHRoaXMuaGFuZGxlSW5wdXRDaGFuZ2UgfSlcbiAgICAgICksXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAncCcsXG4gICAgICAgIG51bGwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jywge1xuICAgICAgICAgIGlkOiAndmFsdWUtaW5wdXQtc3VibWl0JyxcbiAgICAgICAgICB0eXBlOiAnc3VibWl0JyxcbiAgICAgICAgICBkaXNhYmxlZDogIXRoaXMudmFsaWRhdGUoKSB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cblxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL3NyYy9jb21wb25lbnRzL0N1c3RvbWl6ZVZhbHVlRm9ybS5qc3hcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyB2YWxpZGF0ZUFyZ0NvdW50LCB2YWxpZGF0ZUNhbGxiYWNrIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgdmFsaWRhdGVQYXRoU3RyaW5nIH0gZnJvbSAnLi4vY29yZS91dGlsL3ZhbGlkYXRpb24nO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4uL2NvcmUvdXRpbC9QYXRoJztcbmltcG9ydCB7IFBSSU9SSVRZX0lOREVYIH0gZnJvbSAnLi4vY29yZS9zbmFwL2luZGV4ZXMvUHJpb3JpdHlJbmRleCc7XG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGZpcmViYXNlIGRhdGEgc25hcHNob3QuICBJdCB3cmFwcyBhIFNuYXBzaG90Tm9kZSBhbmRcbiAqIHN1cmZhY2VzIHRoZSBwdWJsaWMgbWV0aG9kcyAodmFsLCBmb3JFYWNoLCBldGMuKSB3ZSB3YW50IHRvIGV4cG9zZS5cbiAqL1xudmFyIERhdGFTbmFwc2hvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXyBBIFNuYXBzaG90Tm9kZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7IVJlZmVyZW5jZX0gcmVmXyBUaGUgcmVmIG9mIHRoZSBsb2NhdGlvbiB0aGlzIHNuYXBzaG90IGNhbWUgZnJvbS5cbiAgICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhfIFRoZSBpdGVyYXRpb24gb3JkZXIgZm9yIHRoaXMgc25hcHNob3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEYXRhU25hcHNob3Qobm9kZV8sIHJlZl8sIGluZGV4Xykge1xuICAgICAgICB0aGlzLm5vZGVfID0gbm9kZV87XG4gICAgICAgIHRoaXMucmVmXyA9IHJlZl87XG4gICAgICAgIHRoaXMuaW5kZXhfID0gaW5kZXhfO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHNuYXBzaG90IGNvbnRlbnRzIGFzIEpTT04uICBSZXR1cm5zIG51bGwgaWYgdGhlIHNuYXBzaG90IGlzXG4gICAgICogZW1wdHkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsqfSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBEYXRhU25hcHNob3QgY29udGVudHMsIG9yIG51bGwgaWYgZW1wdHkuXG4gICAgICovXG4gICAgRGF0YVNuYXBzaG90LnByb3RvdHlwZS52YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ0RhdGFTbmFwc2hvdC52YWwnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZV8udmFsKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzbmFwc2hvdCBjb250ZW50cyBhcyBKU09OLCBpbmNsdWRpbmcgcHJpb3JpdGllcyBvZiBub2RlLiAgU3VpdGFibGUgZm9yIGV4cG9ydGluZ1xuICAgICAqIHRoZSBlbnRpcmUgbm9kZSBjb250ZW50cy5cbiAgICAgKiBAcmV0dXJuIHsqfSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBEYXRhU25hcHNob3QgY29udGVudHMsIG9yIG51bGwgaWYgZW1wdHkuXG4gICAgICovXG4gICAgRGF0YVNuYXBzaG90LnByb3RvdHlwZS5leHBvcnRWYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ0RhdGFTbmFwc2hvdC5leHBvcnRWYWwnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZV8udmFsKHRydWUpO1xuICAgIH07XG4gICAgLy8gRG8gbm90IGNyZWF0ZSBwdWJsaWMgZG9jdW1lbnRhdGlvbi4gVGhpcyBpcyBpbnRlbmRlZCB0byBtYWtlIEpTT04gc2VyaWFsaXphdGlvbiB3b3JrIGJ1dCBpcyBvdGhlcndpc2UgdW5uZWNlc3NhcnlcbiAgICAvLyBmb3IgZW5kLXVzZXJzXG4gICAgRGF0YVNuYXBzaG90LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE9wdGlvbmFsIHNwYWNlciBhcmd1bWVudCBpcyB1bm5lY2Vzc2FyeSBiZWNhdXNlIHdlJ3JlIGRlcGVuZGluZyBvbiByZWN1cnNpb24gcmF0aGVyIHRoYW4gc3RyaW5naWZ5aW5nIHRoZSBjb250ZW50XG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ0RhdGFTbmFwc2hvdC50b0pTT04nLCAwLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwb3J0VmFsKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHNuYXBzaG90IGNvbnRhaW5zIGEgbm9uLW51bGwgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBzbmFwc2hvdCBjb250YWlucyBhIG5vbi1udWxsIHZhbHVlLCBvciBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBEYXRhU25hcHNob3QucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90LmV4aXN0cycsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gIXRoaXMubm9kZV8uaXNFbXB0eSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIERhdGFTbmFwc2hvdCBvZiB0aGUgc3BlY2lmaWVkIGNoaWxkIG5vZGUncyBjb250ZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gY2hpbGRQYXRoU3RyaW5nIFBhdGggdG8gYSBjaGlsZC5cbiAgICAgKiBAcmV0dXJuIHshRGF0YVNuYXBzaG90fSBEYXRhU25hcHNob3QgZm9yIGNoaWxkIG5vZGUuXG4gICAgICovXG4gICAgRGF0YVNuYXBzaG90LnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uIChjaGlsZFBhdGhTdHJpbmcpIHtcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90LmNoaWxkJywgMCwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgY2hpbGRQYXRoIGlzIGEgc3RyaW5nIChjYW4gYmUgYSBudW1iZXIpXG4gICAgICAgIGNoaWxkUGF0aFN0cmluZyA9IFN0cmluZyhjaGlsZFBhdGhTdHJpbmcpO1xuICAgICAgICB2YWxpZGF0ZVBhdGhTdHJpbmcoJ0RhdGFTbmFwc2hvdC5jaGlsZCcsIDEsIGNoaWxkUGF0aFN0cmluZywgZmFsc2UpO1xuICAgICAgICB2YXIgY2hpbGRQYXRoID0gbmV3IFBhdGgoY2hpbGRQYXRoU3RyaW5nKTtcbiAgICAgICAgdmFyIGNoaWxkUmVmID0gdGhpcy5yZWZfLmNoaWxkKGNoaWxkUGF0aCk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVNuYXBzaG90KHRoaXMubm9kZV8uZ2V0Q2hpbGQoY2hpbGRQYXRoKSwgY2hpbGRSZWYsIFBSSU9SSVRZX0lOREVYKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgc25hcHNob3QgY29udGFpbnMgYSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGNoaWxkUGF0aFN0cmluZyBQYXRoIHRvIGEgY2hpbGQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgY2hpbGQgZXhpc3RzLlxuICAgICAqL1xuICAgIERhdGFTbmFwc2hvdC5wcm90b3R5cGUuaGFzQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGRQYXRoU3RyaW5nKSB7XG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ0RhdGFTbmFwc2hvdC5oYXNDaGlsZCcsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0ZVBhdGhTdHJpbmcoJ0RhdGFTbmFwc2hvdC5oYXNDaGlsZCcsIDEsIGNoaWxkUGF0aFN0cmluZywgZmFsc2UpO1xuICAgICAgICB2YXIgY2hpbGRQYXRoID0gbmV3IFBhdGgoY2hpbGRQYXRoU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuICF0aGlzLm5vZGVfLmdldENoaWxkKGNoaWxkUGF0aCkuaXNFbXB0eSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJpb3JpdHkgb2YgdGhlIG9iamVjdCwgb3IgbnVsbCBpZiBubyBwcmlvcml0eSB3YXMgc2V0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfG51bWJlcnxudWxsfSBUaGUgcHJpb3JpdHkuXG4gICAgICovXG4gICAgRGF0YVNuYXBzaG90LnByb3RvdHlwZS5nZXRQcmlvcml0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90LmdldFByaW9yaXR5JywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIC8vIHR5cGVjYXN0IGhlcmUgYmVjYXVzZSB3ZSBuZXZlciByZXR1cm4gZGVmZXJyZWQgdmFsdWVzIG9yIGludGVybmFsIHByaW9yaXRpZXMgKE1BWF9QUklPUklUWSlcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZV8uZ2V0UHJpb3JpdHkoKS52YWwoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGQgbm9kZXMgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZvciBlYWNoIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIURhdGFTbmFwc2hvdCl9IGFjdGlvbiBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICAgKiBmb3IgZWFjaCBjaGlsZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGZvckVhY2ggd2FzIGNhbmNlbGVkIGJ5IGFjdGlvbiByZXR1cm5pbmcgdHJ1ZSBmb3JcbiAgICAgKiBvbmUgb2YgdGhlIGNoaWxkIG5vZGVzLlxuICAgICAqL1xuICAgIERhdGFTbmFwc2hvdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90LmZvckVhY2gnLCAxLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFsaWRhdGVDYWxsYmFjaygnRGF0YVNuYXBzaG90LmZvckVhY2gnLCAxLCBhY3Rpb24sIGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMubm9kZV8uaXNMZWFmTm9kZSgpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgY2hpbGRyZW5Ob2RlID0gdGhpcy5ub2RlXztcbiAgICAgICAgLy8gU2FuaXRpemUgdGhlIHJldHVybiB2YWx1ZSB0byBhIGJvb2xlYW4uIENoaWxkcmVuTm9kZS5mb3JFYWNoQ2hpbGQgaGFzIGEgd2VpcmQgcmV0dXJuIHR5cGUuLi5cbiAgICAgICAgcmV0dXJuICEhY2hpbGRyZW5Ob2RlLmZvckVhY2hDaGlsZCh0aGlzLmluZGV4XywgZnVuY3Rpb24gKGtleSwgbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbihuZXcgRGF0YVNuYXBzaG90KG5vZGUsIF90aGlzLnJlZl8uY2hpbGQoa2V5KSwgUFJJT1JJVFlfSU5ERVgpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBEYXRhU25hcHNob3QgaGFzIGNoaWxkcmVuLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERhdGFTbmFwc2hvdCBjb250YWlucyAxIG9yIG1vcmUgY2hpbGQgbm9kZXMuXG4gICAgICovXG4gICAgRGF0YVNuYXBzaG90LnByb3RvdHlwZS5oYXNDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90Lmhhc0NoaWxkcmVuJywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGlmICh0aGlzLm5vZGVfLmlzTGVhZk5vZGUoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLm5vZGVfLmlzRW1wdHkoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhU25hcHNob3QucHJvdG90eXBlLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmXy5nZXRLZXkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGZvciB0aGlzIERhdGFTbmFwc2hvdC5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCB0aGlzIERhdGFTbmFwc2hvdCBjb250YWlucy5cbiAgICAgKi9cbiAgICBEYXRhU25hcHNob3QucHJvdG90eXBlLm51bUNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdEYXRhU25hcHNob3QubnVtQ2hpbGRyZW4nLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZV8ubnVtQ2hpbGRyZW4oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1JlZmVyZW5jZX0gVGhlIEZpcmViYXNlIHJlZmVyZW5jZSBmb3IgdGhlIGxvY2F0aW9uIHRoaXMgc25hcHNob3QncyBkYXRhIGNhbWUgZnJvbS5cbiAgICAgKi9cbiAgICBEYXRhU25hcHNob3QucHJvdG90eXBlLmdldFJlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90LnJlZicsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZfO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFTbmFwc2hvdC5wcm90b3R5cGUsIFwicmVmXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSZWYoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIERhdGFTbmFwc2hvdDtcbn0oKSk7XG5leHBvcnQgeyBEYXRhU25hcHNob3QgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvYXBpL0RhdGFTbmFwc2hvdC5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGZhdGFsIH0gZnJvbSAnLi4vY29yZS91dGlsL3V0aWwnO1xuaW1wb3J0IHsgcGFyc2VSZXBvSW5mbyB9IGZyb20gJy4uL2NvcmUvdXRpbC9saWJzL3BhcnNlcic7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi4vY29yZS91dGlsL1BhdGgnO1xuaW1wb3J0IHsgUmVmZXJlbmNlIH0gZnJvbSAnLi9SZWZlcmVuY2UnO1xuaW1wb3J0IHsgUmVwbyB9IGZyb20gJy4uL2NvcmUvUmVwbyc7XG5pbXBvcnQgeyBSZXBvTWFuYWdlciB9IGZyb20gJy4uL2NvcmUvUmVwb01hbmFnZXInO1xuaW1wb3J0IHsgdmFsaWRhdGVBcmdDb3VudCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IHZhbGlkYXRlVXJsIH0gZnJvbSAnLi4vY29yZS91dGlsL3ZhbGlkYXRpb24nO1xuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBmaXJlYmFzZSBkYXRhYmFzZS5cbiAqIEBpbXBsZW1lbnRzIHtGaXJlYmFzZVNlcnZpY2V9XG4gKi9cbnZhciBEYXRhYmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY29uc3RydWN0b3Igc2hvdWxkIG5vdCBiZSBjYWxsZWQgYnkgdXNlcnMgb2Ygb3VyIHB1YmxpYyBBUEkuXG4gICAgICogQHBhcmFtIHshUmVwb30gcmVwb19cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEYXRhYmFzZShyZXBvXykge1xuICAgICAgICB0aGlzLnJlcG9fID0gcmVwb187XG4gICAgICAgIGlmICghKHJlcG9fIGluc3RhbmNlb2YgUmVwbykpIHtcbiAgICAgICAgICAgIGZhdGFsKFwiRG9uJ3QgY2FsbCBuZXcgRGF0YWJhc2UoKSBkaXJlY3RseSAtIHBsZWFzZSB1c2UgZmlyZWJhc2UuZGF0YWJhc2UoKS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEB0eXBlIHtSZWZlcmVuY2V9ICovXG4gICAgICAgIHRoaXMucm9vdF8gPSBuZXcgUmVmZXJlbmNlKHJlcG9fLCBQYXRoLkVtcHR5KTtcbiAgICAgICAgdGhpcy5JTlRFUk5BTCA9IG5ldyBEYXRhYmFzZUludGVybmFscyh0aGlzKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFiYXNlLnByb3RvdHlwZSwgXCJhcHBcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcG9fLmFwcDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBvciB0aGUgcGF0aCBzcGVjaWZpZWQgaW4gb3B0X3BhdGhTdHJpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBwYXRoU3RyaW5nXG4gICAgICogQHJldHVybiB7IVJlZmVyZW5jZX0gRmlyZWJhc2UgcmVmZXJlbmNlLlxuICAgICAqL1xuICAgIERhdGFiYXNlLnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbiAocGF0aFN0cmluZykge1xuICAgICAgICB0aGlzLmNoZWNrRGVsZXRlZF8oJ3JlZicpO1xuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdkYXRhYmFzZS5yZWYnLCAwLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHBhdGhTdHJpbmcgIT09IHVuZGVmaW5lZCA/IHRoaXMucm9vdF8uY2hpbGQocGF0aFN0cmluZykgOiB0aGlzLnJvb3RfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBvciB0aGUgcGF0aCBzcGVjaWZpZWQgaW4gdXJsLlxuICAgICAqIFdlIHRocm93IGEgZXhjZXB0aW9uIGlmIHRoZSB1cmwgaXMgbm90IGluIHRoZSBzYW1lIGRvbWFpbiBhcyB0aGVcbiAgICAgKiBjdXJyZW50IHJlcG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEByZXR1cm4geyFSZWZlcmVuY2V9IEZpcmViYXNlIHJlZmVyZW5jZS5cbiAgICAgKi9cbiAgICBEYXRhYmFzZS5wcm90b3R5cGUucmVmRnJvbVVSTCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgLyoqIEBjb25zdCB7c3RyaW5nfSAqL1xuICAgICAgICB2YXIgYXBpTmFtZSA9ICdkYXRhYmFzZS5yZWZGcm9tVVJMJztcbiAgICAgICAgdGhpcy5jaGVja0RlbGV0ZWRfKGFwaU5hbWUpO1xuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KGFwaU5hbWUsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YXIgcGFyc2VkVVJMID0gcGFyc2VSZXBvSW5mbyh1cmwpO1xuICAgICAgICB2YWxpZGF0ZVVybChhcGlOYW1lLCAxLCBwYXJzZWRVUkwpO1xuICAgICAgICB2YXIgcmVwb0luZm8gPSBwYXJzZWRVUkwucmVwb0luZm87XG4gICAgICAgIGlmIChyZXBvSW5mby5ob3N0ICE9PSB0aGlzLnJlcG9fLnJlcG9JbmZvXy5ob3N0KSB7XG4gICAgICAgICAgICBmYXRhbChhcGlOYW1lICtcbiAgICAgICAgICAgICAgICAnOiBIb3N0IG5hbWUgZG9lcyBub3QgbWF0Y2ggdGhlIGN1cnJlbnQgZGF0YWJhc2U6ICcgK1xuICAgICAgICAgICAgICAgICcoZm91bmQgJyArXG4gICAgICAgICAgICAgICAgcmVwb0luZm8uaG9zdCArXG4gICAgICAgICAgICAgICAgJyBidXQgZXhwZWN0ZWQgJyArXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvXy5yZXBvSW5mb18uaG9zdCArXG4gICAgICAgICAgICAgICAgJyknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWYocGFyc2VkVVJMLnBhdGgudG9TdHJpbmcoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXBpTmFtZVxuICAgICAqL1xuICAgIERhdGFiYXNlLnByb3RvdHlwZS5jaGVja0RlbGV0ZWRfID0gZnVuY3Rpb24gKGFwaU5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMucmVwb18gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGZhdGFsKCdDYW5ub3QgY2FsbCAnICsgYXBpTmFtZSArICcgb24gYSBkZWxldGVkIGRhdGFiYXNlLicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBNYWtlIGluZGl2aWR1YWwgcmVwbyBnbyBvZmZsaW5lLlxuICAgIERhdGFiYXNlLnByb3RvdHlwZS5nb09mZmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ2RhdGFiYXNlLmdvT2ZmbGluZScsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB0aGlzLmNoZWNrRGVsZXRlZF8oJ2dvT2ZmbGluZScpO1xuICAgICAgICB0aGlzLnJlcG9fLmludGVycnVwdCgpO1xuICAgIH07XG4gICAgRGF0YWJhc2UucHJvdG90eXBlLmdvT25saW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdkYXRhYmFzZS5nb09ubGluZScsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB0aGlzLmNoZWNrRGVsZXRlZF8oJ2dvT25saW5lJyk7XG4gICAgICAgIHRoaXMucmVwb18ucmVzdW1lKCk7XG4gICAgfTtcbiAgICBEYXRhYmFzZS5TZXJ2ZXJWYWx1ZSA9IHtcbiAgICAgICAgVElNRVNUQU1QOiB7XG4gICAgICAgICAgICAnLnN2JzogJ3RpbWVzdGFtcCdcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERhdGFiYXNlO1xufSgpKTtcbmV4cG9ydCB7IERhdGFiYXNlIH07XG52YXIgRGF0YWJhc2VJbnRlcm5hbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwYXJhbSB7IURhdGFiYXNlfSBkYXRhYmFzZSAqL1xuICAgIGZ1bmN0aW9uIERhdGFiYXNlSW50ZXJuYWxzKGRhdGFiYXNlKSB7XG4gICAgICAgIHRoaXMuZGF0YWJhc2UgPSBkYXRhYmFzZTtcbiAgICB9XG4gICAgLyoqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59ICovXG4gICAgRGF0YWJhc2VJbnRlcm5hbHMucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kYXRhYmFzZS5jaGVja0RlbGV0ZWRfKCdkZWxldGUnKTtcbiAgICAgICAgUmVwb01hbmFnZXIuZ2V0SW5zdGFuY2UoKS5kZWxldGVSZXBvKHRoaXMuZGF0YWJhc2UucmVwb18pO1xuICAgICAgICB0aGlzLmRhdGFiYXNlLnJlcG9fID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhYmFzZS5yb290XyA9IG51bGw7XG4gICAgICAgIHRoaXMuZGF0YWJhc2UuSU5URVJOQUwgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGFiYXNlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGFiYXNlSW50ZXJuYWxzO1xufSgpKTtcbmV4cG9ydCB7IERhdGFiYXNlSW50ZXJuYWxzIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2FwaS9EYXRhYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IEtFWV9JTkRFWCB9IGZyb20gJy4uL2NvcmUvc25hcC9pbmRleGVzL0tleUluZGV4JztcbmltcG9ydCB7IFBSSU9SSVRZX0lOREVYIH0gZnJvbSAnLi4vY29yZS9zbmFwL2luZGV4ZXMvUHJpb3JpdHlJbmRleCc7XG5pbXBvcnQgeyBWQUxVRV9JTkRFWCB9IGZyb20gJy4uL2NvcmUvc25hcC9pbmRleGVzL1ZhbHVlSW5kZXgnO1xuaW1wb3J0IHsgUGF0aEluZGV4IH0gZnJvbSAnLi4vY29yZS9zbmFwL2luZGV4ZXMvUGF0aEluZGV4JztcbmltcG9ydCB7IE1JTl9OQU1FLCBNQVhfTkFNRSwgT2JqZWN0VG9VbmlxdWVLZXkgfSBmcm9tICcuLi9jb3JlL3V0aWwvdXRpbCc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi4vY29yZS91dGlsL1BhdGgnO1xuaW1wb3J0IHsgaXNWYWxpZFByaW9yaXR5LCB2YWxpZGF0ZUV2ZW50VHlwZSwgdmFsaWRhdGVQYXRoU3RyaW5nLCB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZywgdmFsaWRhdGVLZXkgfSBmcm9tICcuLi9jb3JlL3V0aWwvdmFsaWRhdGlvbic7XG5pbXBvcnQgeyBlcnJvclByZWZpeCwgdmFsaWRhdGVBcmdDb3VudCwgdmFsaWRhdGVDYWxsYmFjaywgdmFsaWRhdGVDb250ZXh0T2JqZWN0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbiwgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbiB9IGZyb20gJy4uL2NvcmUvdmlldy9FdmVudFJlZ2lzdHJhdGlvbic7XG5pbXBvcnQgeyBEZWZlcnJlZCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbnZhciBfX3JlZmVyZW5jZUNvbnN0cnVjdG9yO1xuLyoqXG4gKiBBIFF1ZXJ5IHJlcHJlc2VudHMgYSBmaWx0ZXIgdG8gYmUgYXBwbGllZCB0byBhIGZpcmViYXNlIGxvY2F0aW9uLiAgVGhpcyBvYmplY3QgcHVyZWx5IHJlcHJlc2VudHMgdGhlXG4gKiBxdWVyeSBleHByZXNzaW9uIChhbmQgZXhwb3NlcyBvdXIgcHVibGljIEFQSSB0byBidWlsZCB0aGUgcXVlcnkpLiAgVGhlIGFjdHVhbCBxdWVyeSBsb2dpYyBpcyBpbiBWaWV3QmFzZS5qcy5cbiAqXG4gKiBTaW5jZSBldmVyeSBGaXJlYmFzZSByZWZlcmVuY2UgaXMgYSBxdWVyeSwgRmlyZWJhc2UgaW5oZXJpdHMgZnJvbSB0aGlzIG9iamVjdC5cbiAqL1xudmFyIFF1ZXJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFF1ZXJ5KHJlcG8sIHBhdGgsIHF1ZXJ5UGFyYW1zXywgb3JkZXJCeUNhbGxlZF8pIHtcbiAgICAgICAgdGhpcy5yZXBvID0gcmVwbztcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5xdWVyeVBhcmFtc18gPSBxdWVyeVBhcmFtc187XG4gICAgICAgIHRoaXMub3JkZXJCeUNhbGxlZF8gPSBvcmRlckJ5Q2FsbGVkXztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5LCBcIl9fcmVmZXJlbmNlQ29uc3RydWN0b3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydChfX3JlZmVyZW5jZUNvbnN0cnVjdG9yLCAnUmVmZXJlbmNlLnRzIGhhcyBub3QgYmVlbiBsb2FkZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBfX3JlZmVyZW5jZUNvbnN0cnVjdG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIF9fcmVmZXJlbmNlQ29uc3RydWN0b3IgPSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBzdGFydC9lbmQgdmFsdWVzIGZvciBxdWVyaWVzLlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5UGFyYW1zfSBwYXJhbXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFF1ZXJ5LnZhbGlkYXRlUXVlcnlFbmRwb2ludHNfID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgc3RhcnROb2RlID0gbnVsbDtcbiAgICAgICAgdmFyIGVuZE5vZGUgPSBudWxsO1xuICAgICAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkpIHtcbiAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IHBhcmFtcy5nZXRJbmRleFN0YXJ0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLmhhc0VuZCgpKSB7XG4gICAgICAgICAgICBlbmROb2RlID0gcGFyYW1zLmdldEluZGV4RW5kVmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLmdldEluZGV4KCkgPT09IEtFWV9JTkRFWCkge1xuICAgICAgICAgICAgdmFyIHRvb01hbnlBcmdzRXJyb3IgPSAnUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB5b3UgbWF5IG9ubHkgcGFzcyBvbmUgYXJndW1lbnQgdG8gJyArXG4gICAgICAgICAgICAgICAgJ3N0YXJ0QXQoKSwgZW5kQXQoKSwgb3IgZXF1YWxUbygpLic7XG4gICAgICAgICAgICB2YXIgd3JvbmdBcmdUeXBlRXJyb3IgPSAnUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSwnICtcbiAgICAgICAgICAgICAgICAnb3IgZXF1YWxUbygpIG11c3QgYmUgYSBzdHJpbmcuJztcbiAgICAgICAgICAgIGlmIChwYXJhbXMuaGFzU3RhcnQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydE5hbWUgPSBwYXJhbXMuZ2V0SW5kZXhTdGFydE5hbWUoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnROYW1lICE9IE1JTl9OQU1FKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0b29NYW55QXJnc0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN0YXJ0Tm9kZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHdyb25nQXJnVHlwZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW1zLmhhc0VuZCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZE5hbWUgPSBwYXJhbXMuZ2V0SW5kZXhFbmROYW1lKCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZE5hbWUgIT0gTUFYX05BTUUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRvb01hbnlBcmdzRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZW5kTm9kZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHdyb25nQXJnVHlwZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1zLmdldEluZGV4KCkgPT09IFBSSU9SSVRZX0lOREVYKSB7XG4gICAgICAgICAgICBpZiAoKHN0YXJ0Tm9kZSAhPSBudWxsICYmICFpc1ZhbGlkUHJpb3JpdHkoc3RhcnROb2RlKSkgfHxcbiAgICAgICAgICAgICAgICAoZW5kTm9kZSAhPSBudWxsICYmICFpc1ZhbGlkUHJpb3JpdHkoZW5kTm9kZSkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeTogV2hlbiBvcmRlcmluZyBieSBwcmlvcml0eSwgdGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksICcgK1xuICAgICAgICAgICAgICAgICAgICAnZW5kQXQoKSwgb3IgZXF1YWxUbygpIG11c3QgYmUgYSB2YWxpZCBwcmlvcml0eSB2YWx1ZSAobnVsbCwgYSBudW1iZXIsIG9yIGEgc3RyaW5nKS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydChwYXJhbXMuZ2V0SW5kZXgoKSBpbnN0YW5jZW9mIFBhdGhJbmRleCB8fFxuICAgICAgICAgICAgICAgIHBhcmFtcy5nZXRJbmRleCgpID09PSBWQUxVRV9JTkRFWCwgJ3Vua25vd24gaW5kZXggdHlwZS4nKTtcbiAgICAgICAgICAgIGlmICgoc3RhcnROb2RlICE9IG51bGwgJiYgdHlwZW9mIHN0YXJ0Tm9kZSA9PT0gJ29iamVjdCcpIHx8XG4gICAgICAgICAgICAgICAgKGVuZE5vZGUgIT0gbnVsbCAmJiB0eXBlb2YgZW5kTm9kZSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeTogRmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSwgb3IgZXF1YWxUbygpIGNhbm5vdCBiZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2FuIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoYXQgbGltaXQqIGhhcyBiZWVuIGNhbGxlZCB3aXRoIHRoZSBjb3JyZWN0IGNvbWJpbmF0aW9uIG9mIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0geyFRdWVyeVBhcmFtc30gcGFyYW1zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBRdWVyeS52YWxpZGF0ZUxpbWl0XyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5oYXNTdGFydCgpICYmXG4gICAgICAgICAgICBwYXJhbXMuaGFzRW5kKCkgJiZcbiAgICAgICAgICAgIHBhcmFtcy5oYXNMaW1pdCgpICYmXG4gICAgICAgICAgICAhcGFyYW1zLmhhc0FuY2hvcmVkTGltaXQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVlcnk6IENhbid0IGNvbWJpbmUgc3RhcnRBdCgpLCBlbmRBdCgpLCBhbmQgbGltaXQoKS4gVXNlIGxpbWl0VG9GaXJzdCgpIG9yIGxpbWl0VG9MYXN0KCkgaW5zdGVhZC5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGF0IG5vIG90aGVyIG9yZGVyIGJ5IGNhbGwgaGFzIGJlZW4gbWFkZVxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gZm5OYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUudmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGxfID0gZnVuY3Rpb24gKGZuTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5vcmRlckJ5Q2FsbGVkXyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZuTmFtZSArIFwiOiBZb3UgY2FuJ3QgY29tYmluZSBtdWx0aXBsZSBvcmRlckJ5IGNhbGxzLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IVF1ZXJ5UGFyYW1zfVxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5nZXRRdWVyeVBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlQYXJhbXNfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IVJlZmVyZW5jZX1cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUuZ2V0UmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5yZWYnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNsaWdodCBoYWNrLiBXZSBjYW5ub3QgZ29vZy5yZXF1aXJlKCdmYi5hcGkuRmlyZWJhc2UnKSwgc2luY2UgRmlyZWJhc2UgcmVxdWlyZXMgZmIuYXBpLlF1ZXJ5LlxuICAgICAgICAvLyBIb3dldmVyLCB3ZSB3aWxsIGFsd2F5cyBleHBvcnQgJ0ZpcmViYXNlJyB0byB0aGUgZ2xvYmFsIG5hbWVzcGFjZSwgc28gaXQncyBndWFyYW50ZWVkIHRvIGV4aXN0IGJ5IHRoZSB0aW1lIHRoaXNcbiAgICAgICAgLy8gbWV0aG9kIGdldHMgY2FsbGVkLlxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5Ll9fcmVmZXJlbmNlQ29uc3RydWN0b3IodGhpcy5yZXBvLCB0aGlzLnBhdGgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBldmVudFR5cGVcbiAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihEYXRhU25hcHNob3QsIHN0cmluZz0pfSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9uKEVycm9yKXxPYmplY3QpPX0gY2FuY2VsQ2FsbGJhY2tPckNvbnRleHRcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oRGF0YVNuYXBzaG90LCBzdHJpbmc9KX1cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckNvbnRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkub24nLCAyLCA0LCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFsaWRhdGVFdmVudFR5cGUoJ1F1ZXJ5Lm9uJywgMSwgZXZlbnRUeXBlLCBmYWxzZSk7XG4gICAgICAgIHZhbGlkYXRlQ2FsbGJhY2soJ1F1ZXJ5Lm9uJywgMiwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgdmFyIHJldCA9IFF1ZXJ5LmdldENhbmNlbEFuZENvbnRleHRBcmdzXygnUXVlcnkub24nLCBjYW5jZWxDYWxsYmFja09yQ29udGV4dCwgY29udGV4dCk7XG4gICAgICAgIGlmIChldmVudFR5cGUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIHRoaXMub25WYWx1ZUV2ZW50KGNhbGxiYWNrLCByZXQuY2FuY2VsLCByZXQuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0ge307XG4gICAgICAgICAgICBjYWxsYmFja3NbZXZlbnRUeXBlXSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgdGhpcy5vbkNoaWxkRXZlbnQoY2FsbGJhY2tzLCByZXQuY2FuY2VsLCByZXQuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshZnVuY3Rpb24oIURhdGFTbmFwc2hvdCl9IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb24oRXJyb3IpfSBjYW5jZWxDYWxsYmFja1xuICAgICAqIEBwYXJhbSB7P09iamVjdH0gY29udGV4dFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUub25WYWx1ZUV2ZW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbmV3IFZhbHVlRXZlbnRSZWdpc3RyYXRpb24oY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrIHx8IG51bGwsIGNvbnRleHQgfHwgbnVsbCk7XG4gICAgICAgIHRoaXMucmVwby5hZGRFdmVudENhbGxiYWNrRm9yUXVlcnkodGhpcywgY29udGFpbmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCAhZnVuY3Rpb24oIURhdGFTbmFwc2hvdCwgP3N0cmluZyk+fSBjYWxsYmFja3NcbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbihFcnJvcil9IGNhbmNlbENhbGxiYWNrXG4gICAgICogQHBhcmFtIHs/T2JqZWN0fSBjb250ZXh0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5vbkNoaWxkRXZlbnQgPSBmdW5jdGlvbiAoY2FsbGJhY2tzLCBjYW5jZWxDYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbmV3IENoaWxkRXZlbnRSZWdpc3RyYXRpb24oY2FsbGJhY2tzLCBjYW5jZWxDYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIHRoaXMucmVwby5hZGRFdmVudENhbGxiYWNrRm9yUXVlcnkodGhpcywgY29udGFpbmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gZXZlbnRUeXBlXG4gICAgICogQHBhcmFtIHsoZnVuY3Rpb24oIURhdGFTbmFwc2hvdCwgP3N0cmluZz0pKT19IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBjb250ZXh0XG4gICAgICovXG4gICAgUXVlcnkucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5Lm9mZicsIDAsIDMsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0ZUV2ZW50VHlwZSgnUXVlcnkub2ZmJywgMSwgZXZlbnRUeXBlLCB0cnVlKTtcbiAgICAgICAgdmFsaWRhdGVDYWxsYmFjaygnUXVlcnkub2ZmJywgMiwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB2YWxpZGF0ZUNvbnRleHRPYmplY3QoJ1F1ZXJ5Lm9mZicsIDMsIGNvbnRleHQsIHRydWUpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IG51bGw7XG4gICAgICAgIGlmIChldmVudFR5cGUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZUNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbnVsbDtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IG5ldyBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uKHZhbHVlQ2FsbGJhY2ssIG51bGwsIGNvbnRleHQgfHwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MgPSB7fTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3NbZXZlbnRUeXBlXSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyID0gbmV3IENoaWxkRXZlbnRSZWdpc3RyYXRpb24oY2FsbGJhY2tzLCBudWxsLCBjb250ZXh0IHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVwby5yZW1vdmVFdmVudENhbGxiYWNrRm9yUXVlcnkodGhpcywgY29udGFpbmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGEgbGlzdGVuZXIsIHdhaXRzIGZvciB0aGUgZmlyc3QgZXZlbnQsIGFuZCB0aGVuIHJlbW92ZXMgdGhlIGxpc3RlbmVyXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBldmVudFR5cGVcbiAgICAgKiBAcGFyYW0geyFmdW5jdGlvbighRGF0YVNuYXBzaG90LCBzdHJpbmc9KX0gdXNlckNhbGxiYWNrXG4gICAgICogQHBhcmFtIGNhbmNlbE9yQ29udGV4dFxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHJldHVybiB7IWZpcmViYXNlLlByb21pc2V9XG4gICAgICovXG4gICAgUXVlcnkucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCB1c2VyQ2FsbGJhY2ssIGNhbmNlbE9yQ29udGV4dCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5vbmNlJywgMSwgNCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhbGlkYXRlRXZlbnRUeXBlKCdRdWVyeS5vbmNlJywgMSwgZXZlbnRUeXBlLCBmYWxzZSk7XG4gICAgICAgIHZhbGlkYXRlQ2FsbGJhY2soJ1F1ZXJ5Lm9uY2UnLCAyLCB1c2VyQ2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB2YXIgcmV0ID0gUXVlcnkuZ2V0Q2FuY2VsQW5kQ29udGV4dEFyZ3NfKCdRdWVyeS5vbmNlJywgY2FuY2VsT3JDb250ZXh0LCBjb250ZXh0KTtcbiAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IHRoaXMgbW9yZSBlZmZpY2llbnRseSAoaW4gcGFydGljdWxhciwgdXNlICdnZXQnIHdpcmUgcHJvdG9jb2wgZm9yICd2YWx1ZScgZXZlbnQpXG4gICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGFjdHVhbGx5IHdpcmluZyB0aGUgY2FsbGJhY2tzIGludG8gdGhlIHByb21pc2UuIFdlIGNhbm5vdCBkbyB0aGlzIHdpdGhvdXQgYSBicmVha2luZyBjaGFuZ2VcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgQVBJIGN1cnJlbnRseSBleHBlY3RzIGNhbGxiYWNrcyB3aWxsIGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5IGlmIHRoZSBkYXRhIGlzIGNhY2hlZCwgYnV0IHRoaXMgaXNcbiAgICAgICAgLy8gYWdhaW5zdCB0aGUgUHJvbWlzZSBzcGVjaWZpY2F0aW9uLlxuICAgICAgICB2YXIgZmlyc3RDYWxsID0gdHJ1ZTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIC8vIEEgZHVtbXkgZXJyb3IgaGFuZGxlciBpbiBjYXNlIGEgdXNlciB3YXNuJ3QgZXhwZWN0aW5nIHByb21pc2VzXG4gICAgICAgIGRlZmVycmVkLnByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgdmFyIG9uY2VDYWxsYmFjayA9IGZ1bmN0aW9uIChzbmFwc2hvdCkge1xuICAgICAgICAgICAgLy8gTk9URTogRXZlbiB0aG91Z2ggd2UgdW5zdWJzY3JpYmUsIHdlIG1heSBnZXQgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGlmIGEgc2luZ2xlIGFjdGlvbiAoZS5nLiBzZXQoKSB3aXRoIEpTT04pXG4gICAgICAgICAgICAvLyB0cmlnZ2VycyBtdWx0aXBsZSBldmVudHMgKGUuZy4gY2hpbGRfYWRkZWQgb3IgY2hpbGRfY2hhbmdlZCkuXG4gICAgICAgICAgICBpZiAoZmlyc3RDYWxsKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RDYWxsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3RoaXMub2ZmKGV2ZW50VHlwZSwgb25jZUNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBpZiAodXNlckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJDYWxsYmFjay5iaW5kKHJldC5jb250ZXh0KShzbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoc25hcHNob3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uKGV2ZW50VHlwZSwgb25jZUNhbGxiYWNrLCBcbiAgICAgICAgLypjYW5jZWw9Ki8gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgX3RoaXMub2ZmKGV2ZW50VHlwZSwgb25jZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChyZXQuY2FuY2VsKVxuICAgICAgICAgICAgICAgIHJldC5jYW5jZWwuYmluZChyZXQuY29udGV4dCkoZXJyKTtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgYSBsaW1pdCBhbmQgYW5jaG9yIGl0IHRvIHRoZSBzdGFydCBvZiB0aGUgd2luZG93LlxuICAgICAqIEBwYXJhbSB7IW51bWJlcn0gbGltaXRcbiAgICAgKiBAcmV0dXJuIHshUXVlcnl9XG4gICAgICovXG4gICAgUXVlcnkucHJvdG90eXBlLmxpbWl0VG9GaXJzdCA9IGZ1bmN0aW9uIChsaW1pdCkge1xuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5saW1pdFRvRmlyc3QnLCAxLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsaW1pdCAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIE1hdGguZmxvb3IobGltaXQpICE9PSBsaW1pdCB8fFxuICAgICAgICAgICAgbGltaXQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeS5saW1pdFRvRmlyc3Q6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5UGFyYW1zXy5oYXNMaW1pdCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5LmxpbWl0VG9GaXJzdDogTGltaXQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gbGltaXQsICcgK1xuICAgICAgICAgICAgICAgICdsaW1pdFRvRmlyc3QsIG9yIGxpbWl0VG9MYXN0KS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMucmVwbywgdGhpcy5wYXRoLCB0aGlzLnF1ZXJ5UGFyYW1zXy5saW1pdFRvRmlyc3QobGltaXQpLCB0aGlzLm9yZGVyQnlDYWxsZWRfKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBhIGxpbWl0IGFuZCBhbmNob3IgaXQgdG8gdGhlIGVuZCBvZiB0aGUgd2luZG93LlxuICAgICAqIEBwYXJhbSB7IW51bWJlcn0gbGltaXRcbiAgICAgKiBAcmV0dXJuIHshUXVlcnl9XG4gICAgICovXG4gICAgUXVlcnkucHJvdG90eXBlLmxpbWl0VG9MYXN0ID0gZnVuY3Rpb24gKGxpbWl0KSB7XG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5LmxpbWl0VG9MYXN0JywgMSwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGlmICh0eXBlb2YgbGltaXQgIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICBNYXRoLmZsb29yKGxpbWl0KSAhPT0gbGltaXQgfHxcbiAgICAgICAgICAgIGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkubGltaXRUb0xhc3Q6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5UGFyYW1zXy5oYXNMaW1pdCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5LmxpbWl0VG9MYXN0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdCwgJyArXG4gICAgICAgICAgICAgICAgJ2xpbWl0VG9GaXJzdCwgb3IgbGltaXRUb0xhc3QpLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkodGhpcy5yZXBvLCB0aGlzLnBhdGgsIHRoaXMucXVlcnlQYXJhbXNfLmxpbWl0VG9MYXN0KGxpbWl0KSwgdGhpcy5vcmRlckJ5Q2FsbGVkXyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGNoaWxkIHBhdGgsIHJldHVybiBhIG5ldyBxdWVyeSBvcmRlcmVkIGJ5IHRoZSBzcGVjaWZpZWQgZ3JhbmRjaGlsZCBwYXRoLlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gcGF0aFxuICAgICAqIEByZXR1cm4geyFRdWVyeX1cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUub3JkZXJCeUNoaWxkID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkub3JkZXJCeUNoaWxkJywgMSwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGlmIChwYXRoID09PSAnJGtleScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkub3JkZXJCeUNoaWxkOiBcIiRrZXlcIiBpcyBpbnZhbGlkLiAgVXNlIFF1ZXJ5Lm9yZGVyQnlLZXkoKSBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhdGggPT09ICckcHJpb3JpdHknKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5Lm9yZGVyQnlDaGlsZDogXCIkcHJpb3JpdHlcIiBpcyBpbnZhbGlkLiAgVXNlIFF1ZXJ5Lm9yZGVyQnlQcmlvcml0eSgpIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGF0aCA9PT0gJyR2YWx1ZScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkub3JkZXJCeUNoaWxkOiBcIiR2YWx1ZVwiIGlzIGludmFsaWQuICBVc2UgUXVlcnkub3JkZXJCeVZhbHVlKCkgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZVBhdGhTdHJpbmcoJ1F1ZXJ5Lm9yZGVyQnlDaGlsZCcsIDEsIHBhdGgsIGZhbHNlKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbF8oJ1F1ZXJ5Lm9yZGVyQnlDaGlsZCcpO1xuICAgICAgICB2YXIgcGFyc2VkUGF0aCA9IG5ldyBQYXRoKHBhdGgpO1xuICAgICAgICBpZiAocGFyc2VkUGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkub3JkZXJCeUNoaWxkOiBjYW5ub3QgcGFzcyBpbiBlbXB0eSBwYXRoLiAgVXNlIFF1ZXJ5Lm9yZGVyQnlWYWx1ZSgpIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gbmV3IFBhdGhJbmRleChwYXJzZWRQYXRoKTtcbiAgICAgICAgdmFyIG5ld1BhcmFtcyA9IHRoaXMucXVlcnlQYXJhbXNfLm9yZGVyQnkoaW5kZXgpO1xuICAgICAgICBRdWVyeS52YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzXyhuZXdQYXJhbXMpO1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMucmVwbywgdGhpcy5wYXRoLCBuZXdQYXJhbXMsIC8qb3JkZXJCeUNhbGxlZD0qLyB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBxdWVyeSBvcmRlcmVkIGJ5IHRoZSBLZXlJbmRleFxuICAgICAqIEByZXR1cm4geyFRdWVyeX1cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUub3JkZXJCeUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkub3JkZXJCeUtleScsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlTm9QcmV2aW91c09yZGVyQnlDYWxsXygnUXVlcnkub3JkZXJCeUtleScpO1xuICAgICAgICB2YXIgbmV3UGFyYW1zID0gdGhpcy5xdWVyeVBhcmFtc18ub3JkZXJCeShLRVlfSU5ERVgpO1xuICAgICAgICBRdWVyeS52YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzXyhuZXdQYXJhbXMpO1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMucmVwbywgdGhpcy5wYXRoLCBuZXdQYXJhbXMsIC8qb3JkZXJCeUNhbGxlZD0qLyB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBxdWVyeSBvcmRlcmVkIGJ5IHRoZSBQcmlvcml0eUluZGV4XG4gICAgICogQHJldHVybiB7IVF1ZXJ5fVxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5vcmRlckJ5UHJpb3JpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5Lm9yZGVyQnlQcmlvcml0eScsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlTm9QcmV2aW91c09yZGVyQnlDYWxsXygnUXVlcnkub3JkZXJCeVByaW9yaXR5Jyk7XG4gICAgICAgIHZhciBuZXdQYXJhbXMgPSB0aGlzLnF1ZXJ5UGFyYW1zXy5vcmRlckJ5KFBSSU9SSVRZX0lOREVYKTtcbiAgICAgICAgUXVlcnkudmFsaWRhdGVRdWVyeUVuZHBvaW50c18obmV3UGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLnJlcG8sIHRoaXMucGF0aCwgbmV3UGFyYW1zLCAvKm9yZGVyQnlDYWxsZWQ9Ki8gdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgcXVlcnkgb3JkZXJlZCBieSB0aGUgVmFsdWVJbmRleFxuICAgICAqIEByZXR1cm4geyFRdWVyeX1cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUub3JkZXJCeVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5vcmRlckJ5VmFsdWUnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbF8oJ1F1ZXJ5Lm9yZGVyQnlWYWx1ZScpO1xuICAgICAgICB2YXIgbmV3UGFyYW1zID0gdGhpcy5xdWVyeVBhcmFtc18ub3JkZXJCeShWQUxVRV9JTkRFWCk7XG4gICAgICAgIFF1ZXJ5LnZhbGlkYXRlUXVlcnlFbmRwb2ludHNfKG5ld1BhcmFtcyk7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkodGhpcy5yZXBvLCB0aGlzLnBhdGgsIG5ld1BhcmFtcywgLypvcmRlckJ5Q2FsbGVkPSovIHRydWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfGJvb2xlYW58bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0gez9zdHJpbmc9fSBuYW1lXG4gICAgICogQHJldHVybiB7IVF1ZXJ5fVxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5zdGFydEF0ID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gbnVsbDsgfVxuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5zdGFydEF0JywgMCwgMiwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdRdWVyeS5zdGFydEF0JywgMSwgdmFsdWUsIHRoaXMucGF0aCwgdHJ1ZSk7XG4gICAgICAgIHZhbGlkYXRlS2V5KCdRdWVyeS5zdGFydEF0JywgMiwgbmFtZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBuZXdQYXJhbXMgPSB0aGlzLnF1ZXJ5UGFyYW1zXy5zdGFydEF0KHZhbHVlLCBuYW1lKTtcbiAgICAgICAgUXVlcnkudmFsaWRhdGVMaW1pdF8obmV3UGFyYW1zKTtcbiAgICAgICAgUXVlcnkudmFsaWRhdGVRdWVyeUVuZHBvaW50c18obmV3UGFyYW1zKTtcbiAgICAgICAgaWYgKHRoaXMucXVlcnlQYXJhbXNfLmhhc1N0YXJ0KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkuc3RhcnRBdDogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gc3RhcnRBdCAnICtcbiAgICAgICAgICAgICAgICAnb3IgZXF1YWxUbykuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsbGluZyB3aXRoIG5vIHBhcmFtcyB0ZWxscyB1cyB0byBzdGFydCBhdCB0aGUgYmVnaW5uaW5nLlxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgbmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLnJlcG8sIHRoaXMucGF0aCwgbmV3UGFyYW1zLCB0aGlzLm9yZGVyQnlDYWxsZWRfKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xib29sZWFufG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHs/c3RyaW5nPX0gbmFtZVxuICAgICAqIEByZXR1cm4geyFRdWVyeX1cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUuZW5kQXQgPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSBudWxsOyB9XG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5LmVuZEF0JywgMCwgMiwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdRdWVyeS5lbmRBdCcsIDEsIHZhbHVlLCB0aGlzLnBhdGgsIHRydWUpO1xuICAgICAgICB2YWxpZGF0ZUtleSgnUXVlcnkuZW5kQXQnLCAyLCBuYW1lLCB0cnVlKTtcbiAgICAgICAgdmFyIG5ld1BhcmFtcyA9IHRoaXMucXVlcnlQYXJhbXNfLmVuZEF0KHZhbHVlLCBuYW1lKTtcbiAgICAgICAgUXVlcnkudmFsaWRhdGVMaW1pdF8obmV3UGFyYW1zKTtcbiAgICAgICAgUXVlcnkudmFsaWRhdGVRdWVyeUVuZHBvaW50c18obmV3UGFyYW1zKTtcbiAgICAgICAgaWYgKHRoaXMucXVlcnlQYXJhbXNfLmhhc0VuZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5LmVuZEF0OiBFbmRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQgb3IgJyArXG4gICAgICAgICAgICAgICAgJ2VxdWFsVG8pLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkodGhpcy5yZXBvLCB0aGlzLnBhdGgsIG5ld1BhcmFtcywgdGhpcy5vcmRlckJ5Q2FsbGVkXyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBzZWxlY3Rpb24gb2YgY2hpbGRyZW4gd2l0aCBleGFjdGx5IHRoZSBzcGVjaWZpZWQgdmFsdWUsIGFuZCwgb3B0aW9uYWxseSxcbiAgICAgKiB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfGJvb2xlYW58bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IG5hbWVcbiAgICAgKiBAcmV0dXJuIHshUXVlcnl9XG4gICAgICovXG4gICAgUXVlcnkucHJvdG90eXBlLmVxdWFsVG8gPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkuZXF1YWxUbycsIDEsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnUXVlcnkuZXF1YWxUbycsIDEsIHZhbHVlLCB0aGlzLnBhdGgsIGZhbHNlKTtcbiAgICAgICAgdmFsaWRhdGVLZXkoJ1F1ZXJ5LmVxdWFsVG8nLCAyLCBuYW1lLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMucXVlcnlQYXJhbXNfLmhhc1N0YXJ0KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkuZXF1YWxUbzogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gc3RhcnRBdCBvciAnICtcbiAgICAgICAgICAgICAgICAnZXF1YWxUbykuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucXVlcnlQYXJhbXNfLmhhc0VuZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5LmVxdWFsVG86IEVuZGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBlbmRBdCBvciAnICtcbiAgICAgICAgICAgICAgICAnZXF1YWxUbykuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRBdCh2YWx1ZSwgbmFtZSkuZW5kQXQodmFsdWUsIG5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IXN0cmluZ30gVVJMIGZvciB0aGlzIGxvY2F0aW9uLlxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkudG9TdHJpbmcnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwby50b1N0cmluZygpICsgdGhpcy5wYXRoLnRvVXJsRW5jb2RlZFN0cmluZygpO1xuICAgIH07XG4gICAgLy8gRG8gbm90IGNyZWF0ZSBwdWJsaWMgZG9jdW1lbnRhdGlvbi4gVGhpcyBpcyBpbnRlbmRlZCB0byBtYWtlIEpTT04gc2VyaWFsaXphdGlvbiB3b3JrIGJ1dCBpcyBvdGhlcndpc2UgdW5uZWNlc3NhcnlcbiAgICAvLyBmb3IgZW5kLXVzZXJzLlxuICAgIFF1ZXJ5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEFuIG9wdGlvbmFsIHNwYWNlciBhcmd1bWVudCBpcyB1bm5lY2Vzc2FyeSBmb3IgYSBzdHJpbmcuXG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5LnRvSlNPTicsIDAsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBxdWVyeSBwYXJhbWV0ZXJzIHVzZWQgYnkgdGhpcyBRdWVyeS5cbiAgICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5xdWVyeU9iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlQYXJhbXNfLmdldFF1ZXJ5T2JqZWN0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshc3RyaW5nfVxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5xdWVyeUlkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLnF1ZXJ5T2JqZWN0KCk7XG4gICAgICAgIHZhciBpZCA9IE9iamVjdFRvVW5pcXVlS2V5KG9iaik7XG4gICAgICAgIHJldHVybiBpZCA9PT0gJ3t9JyA/ICdkZWZhdWx0JyA6IGlkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhpcyBxdWVyeSBhbmQgdGhlIHByb3ZpZGVkIHF1ZXJ5IGFyZSBlcXVpdmFsZW50OyBvdGhlcndpc2UsIHJldHVybiBmYWxzZS5cbiAgICAgKiBAcGFyYW0ge1F1ZXJ5fSBvdGhlclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgUXVlcnkucHJvdG90eXBlLmlzRXF1YWwgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkuaXNFcXVhbCcsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFF1ZXJ5KSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gJ1F1ZXJ5LmlzRXF1YWwgZmFpbGVkOiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIGZpcmViYXNlLmRhdGFiYXNlLlF1ZXJ5Lic7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzYW1lUmVwbyA9IHRoaXMucmVwbyA9PT0gb3RoZXIucmVwbztcbiAgICAgICAgdmFyIHNhbWVQYXRoID0gdGhpcy5wYXRoLmVxdWFscyhvdGhlci5wYXRoKTtcbiAgICAgICAgdmFyIHNhbWVRdWVyeUlkZW50aWZpZXIgPSB0aGlzLnF1ZXJ5SWRlbnRpZmllcigpID09PSBvdGhlci5xdWVyeUlkZW50aWZpZXIoKTtcbiAgICAgICAgcmV0dXJuIHNhbWVSZXBvICYmIHNhbWVQYXRoICYmIHNhbWVRdWVyeUlkZW50aWZpZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIZWxwZXIgdXNlZCBieSAub24gYW5kIC5vbmNlIHRvIGV4dHJhY3QgdGhlIGNvbnRleHQgYW5kIG9yIGNhbmNlbCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWUgKG9uIG9yIG9uY2UpXG4gICAgICogQHBhcmFtIHsoZnVuY3Rpb24oRXJyb3IpfE9iamVjdCk9fSBjYW5jZWxPckNvbnRleHRcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHt7Y2FuY2VsOiA/ZnVuY3Rpb24oRXJyb3IpLCBjb250ZXh0OiA/T2JqZWN0fX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFF1ZXJ5LmdldENhbmNlbEFuZENvbnRleHRBcmdzXyA9IGZ1bmN0aW9uIChmbk5hbWUsIGNhbmNlbE9yQ29udGV4dCwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmV0ID0geyBjYW5jZWw6IG51bGwsIGNvbnRleHQ6IG51bGwgfTtcbiAgICAgICAgaWYgKGNhbmNlbE9yQ29udGV4dCAmJiBjb250ZXh0KSB7XG4gICAgICAgICAgICByZXQuY2FuY2VsID0gY2FuY2VsT3JDb250ZXh0O1xuICAgICAgICAgICAgdmFsaWRhdGVDYWxsYmFjayhmbk5hbWUsIDMsIHJldC5jYW5jZWwsIHRydWUpO1xuICAgICAgICAgICAgcmV0LmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgdmFsaWRhdGVDb250ZXh0T2JqZWN0KGZuTmFtZSwgNCwgcmV0LmNvbnRleHQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhbmNlbE9yQ29udGV4dCkge1xuICAgICAgICAgICAgLy8gd2UgaGF2ZSBlaXRoZXIgYSBjYW5jZWwgY2FsbGJhY2sgb3IgYSBjb250ZXh0LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYW5jZWxPckNvbnRleHQgPT09ICdvYmplY3QnICYmIGNhbmNlbE9yQ29udGV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGl0J3MgYSBjb250ZXh0IVxuICAgICAgICAgICAgICAgIHJldC5jb250ZXh0ID0gY2FuY2VsT3JDb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNhbmNlbE9yQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldC5jYW5jZWwgPSBjYW5jZWxPckNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCAzLCB0cnVlKSArXG4gICAgICAgICAgICAgICAgICAgICcgbXVzdCBlaXRoZXIgYmUgYSBjYW5jZWwgY2FsbGJhY2sgb3IgYSBjb250ZXh0IG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5LnByb3RvdHlwZSwgXCJyZWZcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJlZigpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gUXVlcnk7XG59KCkpO1xuZXhwb3J0IHsgUXVlcnkgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvYXBpL1F1ZXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgZmlyZWJhc2UgZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBmb3JFYWNoLCBjb250YWlucywgaXNFbXB0eSwgZ2V0Q291bnQsIHNhZmVHZXQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBlcnJvciwgbG9nLCBsb2dXcmFwcGVyLCB3YXJuLCBPYmplY3RUb1VuaXF1ZUtleSB9IGZyb20gJy4vdXRpbC91dGlsJztcbmltcG9ydCB7IFBhdGggfSBmcm9tICcuL3V0aWwvUGF0aCc7XG5pbXBvcnQgeyBWaXNpYmlsaXR5TW9uaXRvciB9IGZyb20gJy4vdXRpbC9WaXNpYmlsaXR5TW9uaXRvcic7XG5pbXBvcnQgeyBPbmxpbmVNb25pdG9yIH0gZnJvbSAnLi91dGlsL09ubGluZU1vbml0b3InO1xuaW1wb3J0IHsgaXNBZG1pbiwgaXNWYWxpZEZvcm1hdCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tICcuLi9yZWFsdGltZS9Db25uZWN0aW9uJztcbmltcG9ydCB7IENPTlNUQU5UUyB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IGlzTW9iaWxlQ29yZG92YSwgaXNSZWFjdE5hdGl2ZSwgaXNOb2RlU2RrIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgU2VydmVyQWN0aW9ucyB9IGZyb20gJy4vU2VydmVyQWN0aW9ucyc7XG52YXIgUkVDT05ORUNUX01JTl9ERUxBWSA9IDEwMDA7XG52YXIgUkVDT05ORUNUX01BWF9ERUxBWV9ERUZBVUxUID0gNjAgKiA1ICogMTAwMDsgLy8gNSBtaW51dGVzIGluIG1pbGxpc2Vjb25kcyAoQ2FzZTogMTg1OClcbnZhciBSRUNPTk5FQ1RfTUFYX0RFTEFZX0ZPUl9BRE1JTlMgPSAzMCAqIDEwMDA7IC8vIDMwIHNlY29uZHMgZm9yIGFkbWluIGNsaWVudHMgKGxpa2VseSB0byBiZSBhIGJhY2tlbmQgc2VydmVyKVxudmFyIFJFQ09OTkVDVF9ERUxBWV9NVUxUSVBMSUVSID0gMS4zO1xudmFyIFJFQ09OTkVDVF9ERUxBWV9SRVNFVF9USU1FT1VUID0gMzAwMDA7IC8vIFJlc2V0IGRlbGF5IGJhY2sgdG8gTUlOX0RFTEFZIGFmdGVyIGJlaW5nIGNvbm5lY3RlZCBmb3IgMzBzZWMuXG52YXIgU0VSVkVSX0tJTExfSU5URVJSVVBUX1JFQVNPTiA9ICdzZXJ2ZXJfa2lsbCc7XG4vLyBJZiBhdXRoIGZhaWxzIHJlcGVhdGVkbHksIHdlJ2xsIGFzc3VtZSBzb21ldGhpbmcgaXMgd3JvbmcgYW5kIGxvZyBhIHdhcm5pbmcgLyBiYWNrIG9mZi5cbnZhciBJTlZBTElEX0FVVEhfVE9LRU5fVEhSRVNIT0xEID0gMztcbi8qKlxuICogRmlyZWJhc2UgY29ubmVjdGlvbi4gIEFic3RyYWN0cyB3aXJlIHByb3RvY29sIGFuZCBoYW5kbGVzIHJlY29ubmVjdGluZy5cbiAqXG4gKiBOT1RFOiBBbGwgSlNPTiBvYmplY3RzIHNlbnQgdG8gdGhlIHJlYWx0aW1lIGNvbm5lY3Rpb24gbXVzdCBoYXZlIHByb3BlcnR5IG5hbWVzIGVuY2xvc2VkXG4gKiBpbiBxdW90ZXMgdG8gbWFrZSBzdXJlIHRoZSBjbG9zdXJlIGNvbXBpbGVyIGRvZXMgbm90IG1pbmlmeSB0aGVtLlxuICovXG52YXIgUGVyc2lzdGVudENvbm5lY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBlcnNpc3RlbnRDb25uZWN0aW9uLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBpbXBsZW1lbnRzIHtTZXJ2ZXJBY3Rpb25zfVxuICAgICAqIEBwYXJhbSB7IVJlcG9JbmZvfSByZXBvSW5mb18gRGF0YSBhYm91dCB0aGUgbmFtZXNwYWNlIHdlIGFyZSBjb25uZWN0aW5nIHRvXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsICosIGJvb2xlYW4sID9udW1iZXIpfSBvbkRhdGFVcGRhdGVfIEEgY2FsbGJhY2sgZm9yIG5ldyBkYXRhIGZyb20gdGhlIHNlcnZlclxuICAgICAqIEBwYXJhbSBvbkNvbm5lY3RTdGF0dXNfXG4gICAgICogQHBhcmFtIG9uU2VydmVySW5mb1VwZGF0ZV9cbiAgICAgKiBAcGFyYW0gYXV0aFRva2VuUHJvdmlkZXJfXG4gICAgICogQHBhcmFtIGF1dGhPdmVycmlkZV9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQZXJzaXN0ZW50Q29ubmVjdGlvbihyZXBvSW5mb18sIG9uRGF0YVVwZGF0ZV8sIG9uQ29ubmVjdFN0YXR1c18sIG9uU2VydmVySW5mb1VwZGF0ZV8sIGF1dGhUb2tlblByb3ZpZGVyXywgYXV0aE92ZXJyaWRlXykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZXBvSW5mb18gPSByZXBvSW5mb187XG4gICAgICAgIF90aGlzLm9uRGF0YVVwZGF0ZV8gPSBvbkRhdGFVcGRhdGVfO1xuICAgICAgICBfdGhpcy5vbkNvbm5lY3RTdGF0dXNfID0gb25Db25uZWN0U3RhdHVzXztcbiAgICAgICAgX3RoaXMub25TZXJ2ZXJJbmZvVXBkYXRlXyA9IG9uU2VydmVySW5mb1VwZGF0ZV87XG4gICAgICAgIF90aGlzLmF1dGhUb2tlblByb3ZpZGVyXyA9IGF1dGhUb2tlblByb3ZpZGVyXztcbiAgICAgICAgX3RoaXMuYXV0aE92ZXJyaWRlXyA9IGF1dGhPdmVycmlkZV87XG4gICAgICAgIC8vIFVzZWQgZm9yIGRpYWdub3N0aWMgbG9nZ2luZy5cbiAgICAgICAgX3RoaXMuaWQgPSBQZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0UGVyc2lzdGVudENvbm5lY3Rpb25JZF8rKztcbiAgICAgICAgX3RoaXMubG9nXyA9IGxvZ1dyYXBwZXIoJ3A6JyArIF90aGlzLmlkICsgJzonKTtcbiAgICAgICAgLyoqIEBwcml2YXRlIHtPYmplY3R9ICovXG4gICAgICAgIF90aGlzLmludGVycnVwdFJlYXNvbnNfID0ge307XG4gICAgICAgIF90aGlzLmxpc3RlbnNfID0ge307XG4gICAgICAgIF90aGlzLm91dHN0YW5kaW5nUHV0c18gPSBbXTtcbiAgICAgICAgX3RoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8gPSAwO1xuICAgICAgICBfdGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfID0gW107XG4gICAgICAgIF90aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcbiAgICAgICAgX3RoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01JTl9ERUxBWTtcbiAgICAgICAgX3RoaXMubWF4UmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01BWF9ERUxBWV9ERUZBVUxUO1xuICAgICAgICBfdGhpcy5zZWN1cml0eURlYnVnQ2FsbGJhY2tfID0gbnVsbDtcbiAgICAgICAgX3RoaXMubGFzdFNlc3Npb25JZCA9IG51bGw7XG4gICAgICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfG51bGx9ICovXG4gICAgICAgIF90aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8gPSBudWxsO1xuICAgICAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgICAgIF90aGlzLnZpc2libGVfID0gZmFsc2U7XG4gICAgICAgIC8vIEJlZm9yZSB3ZSBnZXQgY29ubmVjdGVkLCB3ZSBrZWVwIGEgcXVldWUgb2YgcGVuZGluZyBtZXNzYWdlcyB0byBzZW5kLlxuICAgICAgICBfdGhpcy5yZXF1ZXN0Q0JIYXNoXyA9IHt9O1xuICAgICAgICBfdGhpcy5yZXF1ZXN0TnVtYmVyXyA9IDA7XG4gICAgICAgIC8qKiBAcHJpdmF0ZSB7P3tcbiAgICAgICAgICogICBzZW5kUmVxdWVzdChPYmplY3QpLFxuICAgICAgICAgKiAgIGNsb3NlKClcbiAgICAgICAgICogfX0gKi9cbiAgICAgICAgX3RoaXMucmVhbHRpbWVfID0gbnVsbDtcbiAgICAgICAgLyoqIEBwcml2YXRlIHtzdHJpbmd8bnVsbH0gKi9cbiAgICAgICAgX3RoaXMuYXV0aFRva2VuXyA9IG51bGw7XG4gICAgICAgIF90aGlzLmZvcmNlVG9rZW5SZWZyZXNoXyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID0gMDtcbiAgICAgICAgX3RoaXMuZmlyc3RDb25uZWN0aW9uXyA9IHRydWU7XG4gICAgICAgIF90aGlzLmxhc3RDb25uZWN0aW9uQXR0ZW1wdFRpbWVfID0gbnVsbDtcbiAgICAgICAgX3RoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfID0gbnVsbDtcbiAgICAgICAgaWYgKGF1dGhPdmVycmlkZV8gJiYgIWlzTm9kZVNkaygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGggb3ZlcnJpZGUgc3BlY2lmaWVkIGluIG9wdGlvbnMsIGJ1dCBub3Qgc3VwcG9ydGVkIG9uIG5vbiBOb2RlLmpzIHBsYXRmb3JtcycpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnNjaGVkdWxlQ29ubmVjdF8oMCk7XG4gICAgICAgIFZpc2liaWxpdHlNb25pdG9yLmdldEluc3RhbmNlKCkub24oJ3Zpc2libGUnLCBfdGhpcy5vblZpc2libGVfLCBfdGhpcyk7XG4gICAgICAgIGlmIChyZXBvSW5mb18uaG9zdC5pbmRleE9mKCdmYmxvY2FsJykgPT09IC0xKSB7XG4gICAgICAgICAgICBPbmxpbmVNb25pdG9yLmdldEluc3RhbmNlKCkub24oJ29ubGluZScsIF90aGlzLm9uT25saW5lXywgX3RoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBhY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IGJvZHlcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCopPX0gb25SZXNwb25zZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiAoYWN0aW9uLCBib2R5LCBvblJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBjdXJSZXFOdW0gPSArK3RoaXMucmVxdWVzdE51bWJlcl87XG4gICAgICAgIHZhciBtc2cgPSB7IHI6IGN1clJlcU51bSwgYTogYWN0aW9uLCBiOiBib2R5IH07XG4gICAgICAgIHRoaXMubG9nXyhzdHJpbmdpZnkobXNnKSk7XG4gICAgICAgIGFzc2VydCh0aGlzLmNvbm5lY3RlZF8sIFwic2VuZFJlcXVlc3QgY2FsbCB3aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWQgbm90IGFsbG93ZWQuXCIpO1xuICAgICAgICB0aGlzLnJlYWx0aW1lXy5zZW5kUmVxdWVzdChtc2cpO1xuICAgICAgICBpZiAob25SZXNwb25zZSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Q0JIYXNoX1tjdXJSZXFOdW1dID0gb25SZXNwb25zZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKHF1ZXJ5LCBjdXJyZW50SGFzaEZuLCB0YWcsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdmFyIHF1ZXJ5SWQgPSBxdWVyeS5xdWVyeUlkZW50aWZpZXIoKTtcbiAgICAgICAgdmFyIHBhdGhTdHJpbmcgPSBxdWVyeS5wYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMubG9nXygnTGlzdGVuIGNhbGxlZCBmb3IgJyArIHBhdGhTdHJpbmcgKyAnICcgKyBxdWVyeUlkKTtcbiAgICAgICAgdGhpcy5saXN0ZW5zX1twYXRoU3RyaW5nXSA9IHRoaXMubGlzdGVuc19bcGF0aFN0cmluZ10gfHwge307XG4gICAgICAgIGFzc2VydChxdWVyeS5nZXRRdWVyeVBhcmFtcygpLmlzRGVmYXVsdCgpIHx8XG4gICAgICAgICAgICAhcXVlcnkuZ2V0UXVlcnlQYXJhbXMoKS5sb2Fkc0FsbERhdGEoKSwgJ2xpc3RlbigpIGNhbGxlZCBmb3Igbm9uLWRlZmF1bHQgYnV0IGNvbXBsZXRlIHF1ZXJ5Jyk7XG4gICAgICAgIGFzc2VydCghdGhpcy5saXN0ZW5zX1twYXRoU3RyaW5nXVtxdWVyeUlkXSwgJ2xpc3RlbigpIGNhbGxlZCB0d2ljZSBmb3Igc2FtZSBwYXRoL3F1ZXJ5SWQuJyk7XG4gICAgICAgIHZhciBsaXN0ZW5TcGVjID0ge1xuICAgICAgICAgICAgb25Db21wbGV0ZTogb25Db21wbGV0ZSxcbiAgICAgICAgICAgIGhhc2hGbjogY3VycmVudEhhc2hGbixcbiAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgIHRhZzogdGFnXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdGVuc19bcGF0aFN0cmluZ11bcXVlcnlJZF0gPSBsaXN0ZW5TcGVjO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRMaXN0ZW5fKGxpc3RlblNwZWMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyF7b25Db21wbGV0ZSgpLFxuICAgICAqICAgICAgICAgICBoYXNoRm4oKTohc3RyaW5nLFxuICAgICAqICAgICAgICAgICBxdWVyeTogIVF1ZXJ5LFxuICAgICAqICAgICAgICAgICB0YWc6ID9udW1iZXJ9fSBsaXN0ZW5TcGVjXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZExpc3Rlbl8gPSBmdW5jdGlvbiAobGlzdGVuU3BlYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcXVlcnkgPSBsaXN0ZW5TcGVjLnF1ZXJ5O1xuICAgICAgICB2YXIgcGF0aFN0cmluZyA9IHF1ZXJ5LnBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIHF1ZXJ5SWQgPSBxdWVyeS5xdWVyeUlkZW50aWZpZXIoKTtcbiAgICAgICAgdGhpcy5sb2dfKCdMaXN0ZW4gb24gJyArIHBhdGhTdHJpbmcgKyAnIGZvciAnICsgcXVlcnlJZCk7XG4gICAgICAgIHZhciByZXEgPSB7IC8qcGF0aCovIHA6IHBhdGhTdHJpbmcgfTtcbiAgICAgICAgdmFyIGFjdGlvbiA9ICdxJztcbiAgICAgICAgLy8gT25seSBib3RoZXIgdG8gc2VuZCBxdWVyeSBpZiBpdCdzIG5vbi1kZWZhdWx0LlxuICAgICAgICBpZiAobGlzdGVuU3BlYy50YWcpIHtcbiAgICAgICAgICAgIHJlcVsncSddID0gcXVlcnkucXVlcnlPYmplY3QoKTtcbiAgICAgICAgICAgIHJlcVsndCddID0gbGlzdGVuU3BlYy50YWc7XG4gICAgICAgIH1cbiAgICAgICAgcmVxWydoJ10gPSBsaXN0ZW5TcGVjLmhhc2hGbigpO1xuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGFjdGlvbiwgcmVxLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBtZXNzYWdlWydkJ107XG4gICAgICAgICAgICB2YXIgc3RhdHVzID0gbWVzc2FnZVsncyddO1xuICAgICAgICAgICAgLy8gcHJpbnQgd2FybmluZ3MgaW4gYW55IGNhc2UuLi5cbiAgICAgICAgICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLndhcm5Pbkxpc3Rlbldhcm5pbmdzXyhwYXlsb2FkLCBxdWVyeSk7XG4gICAgICAgICAgICB2YXIgY3VycmVudExpc3RlblNwZWMgPSBfdGhpcy5saXN0ZW5zX1twYXRoU3RyaW5nXSAmJiBfdGhpcy5saXN0ZW5zX1twYXRoU3RyaW5nXVtxdWVyeUlkXTtcbiAgICAgICAgICAgIC8vIG9ubHkgdHJpZ2dlciBhY3Rpb25zIGlmIHRoZSBsaXN0ZW4gaGFzbid0IGJlZW4gcmVtb3ZlZCBhbmQgcmVhZGRlZFxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaXN0ZW5TcGVjID09PSBsaXN0ZW5TcGVjKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nXygnbGlzdGVuIHJlc3BvbnNlJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gJ29rJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuU3BlYy5vbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlblNwZWMub25Db21wbGV0ZShzdGF0dXMsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHBheWxvYWRcbiAgICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLndhcm5Pbkxpc3Rlbldhcm5pbmdzXyA9IGZ1bmN0aW9uIChwYXlsb2FkLCBxdWVyeSkge1xuICAgICAgICBpZiAocGF5bG9hZCAmJiB0eXBlb2YgcGF5bG9hZCA9PT0gJ29iamVjdCcgJiYgY29udGFpbnMocGF5bG9hZCwgJ3cnKSkge1xuICAgICAgICAgICAgdmFyIHdhcm5pbmdzID0gc2FmZUdldChwYXlsb2FkLCAndycpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkod2FybmluZ3MpICYmIH53YXJuaW5ncy5pbmRleE9mKCdub19pbmRleCcpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4U3BlYyA9ICdcIi5pbmRleE9uXCI6IFwiJyArXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0UXVlcnlQYXJhbXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldEluZGV4KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiJztcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhQYXRoID0gcXVlcnkucGF0aC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHdhcm4oXCJVc2luZyBhbiB1bnNwZWNpZmllZCBpbmRleC4gWW91ciBkYXRhIHdpbGwgYmUgZG93bmxvYWRlZCBhbmQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJmaWx0ZXJlZCBvbiB0aGUgY2xpZW50LiBDb25zaWRlciBhZGRpbmcgXCIgKyBpbmRleFNwZWMgKyBcIiBhdCBcIikgK1xuICAgICAgICAgICAgICAgICAgICAoaW5kZXhQYXRoICsgXCIgdG8geW91ciBzZWN1cml0eSBydWxlcyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnJlZnJlc2hBdXRoVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5fID0gdG9rZW47XG4gICAgICAgIHRoaXMubG9nXygnQXV0aCB0b2tlbiByZWZyZXNoZWQnKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0aFRva2VuXykge1xuICAgICAgICAgICAgdGhpcy50cnlBdXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvL0lmIHdlJ3JlIGNvbm5lY3RlZCB3ZSB3YW50IHRvIGxldCB0aGUgc2VydmVyIGtub3cgdG8gdW5hdXRoZW50aWNhdGUgdXMuIElmIHdlJ3JlIG5vdCBjb25uZWN0ZWQsIHNpbXBseSBkZWxldGVcbiAgICAgICAgICAgIC8vdGhlIGNyZWRlbnRpYWwgc28gd2UgZG9udCBiZWNvbWUgYXV0aGVudGljYXRlZCBuZXh0IHRpbWUgd2UgY29ubmVjdC5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KCd1bmF1dGgnLCB7fSwgZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZHVjZVJlY29ubmVjdERlbGF5SWZBZG1pbkNyZWRlbnRpYWxfKHRva2VuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gY3JlZGVudGlhbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnJlZHVjZVJlY29ubmVjdERlbGF5SWZBZG1pbkNyZWRlbnRpYWxfID0gZnVuY3Rpb24gKGNyZWRlbnRpYWwpIHtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpc24ndCBpbnRlbmRlZCB0byBiZSBidWxsZXRwcm9vZiAoYSBtYWxpY2lvdXMgZGV2ZWxvcGVyIGNhbiBhbHdheXMganVzdCBtb2RpZnkgdGhlIGNsaWVudCkuXG4gICAgICAgIC8vIEFkZGl0aW9uYWxseSwgd2UgZG9uJ3QgYm90aGVyIHJlc2V0dGluZyB0aGUgbWF4IGRlbGF5IGJhY2sgdG8gdGhlIGRlZmF1bHQgaWYgYXV0aCBmYWlscyAvIGV4cGlyZXMuXG4gICAgICAgIHZhciBpc0ZpcmViYXNlU2VjcmV0ID0gY3JlZGVudGlhbCAmJiBjcmVkZW50aWFsLmxlbmd0aCA9PT0gNDA7XG4gICAgICAgIGlmIChpc0ZpcmViYXNlU2VjcmV0IHx8IGlzQWRtaW4oY3JlZGVudGlhbCkpIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnQWRtaW4gYXV0aCBjcmVkZW50aWFsIGRldGVjdGVkLiAgUmVkdWNpbmcgbWF4IHJlY29ubmVjdCB0aW1lLicpO1xuICAgICAgICAgICAgdGhpcy5tYXhSZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUFYX0RFTEFZX0ZPUl9BRE1JTlM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGF1dGhlbnRpY2F0ZSB3aXRoIHRoZSBnaXZlbiBjcmVkZW50aWFscy4gSWYgdGhlIGF1dGhlbnRpY2F0aW9uIGF0dGVtcHQgZmFpbHMsIGl0J3MgdHJpZ2dlcmVkIGxpa2VcbiAgICAgKiBhIGF1dGggcmV2b2tlZCAodGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkKS5cbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUudHJ5QXV0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXyAmJiB0aGlzLmF1dGhUb2tlbl8pIHtcbiAgICAgICAgICAgIHZhciB0b2tlbl8xID0gdGhpcy5hdXRoVG9rZW5fO1xuICAgICAgICAgICAgdmFyIGF1dGhNZXRob2QgPSBpc1ZhbGlkRm9ybWF0KHRva2VuXzEpID8gJ2F1dGgnIDogJ2dhdXRoJztcbiAgICAgICAgICAgIHZhciByZXF1ZXN0RGF0YSA9IHsgY3JlZDogdG9rZW5fMSB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0aE92ZXJyaWRlXyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3REYXRhWydub2F1dGgnXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5hdXRoT3ZlcnJpZGVfID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3REYXRhWydhdXRodmFyJ10gPSB0aGlzLmF1dGhPdmVycmlkZV87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGF1dGhNZXRob2QsIHJlcXVlc3REYXRhLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHJlc1sncyddO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gcmVzWydkJ10gfHwgJ2Vycm9yJztcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXV0aFRva2VuXyA9PT0gdG9rZW5fMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXJzIHJlY29ubmVjdCBhbmQgZm9yY2UgcmVmcmVzaCBmb3IgYXV0aCB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25BdXRoUmV2b2tlZF8oc3RhdHVzLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS51bmxpc3RlbiA9IGZ1bmN0aW9uIChxdWVyeSwgdGFnKSB7XG4gICAgICAgIHZhciBwYXRoU3RyaW5nID0gcXVlcnkucGF0aC50b1N0cmluZygpO1xuICAgICAgICB2YXIgcXVlcnlJZCA9IHF1ZXJ5LnF1ZXJ5SWRlbnRpZmllcigpO1xuICAgICAgICB0aGlzLmxvZ18oJ1VubGlzdGVuIGNhbGxlZCBmb3IgJyArIHBhdGhTdHJpbmcgKyAnICcgKyBxdWVyeUlkKTtcbiAgICAgICAgYXNzZXJ0KHF1ZXJ5LmdldFF1ZXJ5UGFyYW1zKCkuaXNEZWZhdWx0KCkgfHxcbiAgICAgICAgICAgICFxdWVyeS5nZXRRdWVyeVBhcmFtcygpLmxvYWRzQWxsRGF0YSgpLCAndW5saXN0ZW4oKSBjYWxsZWQgZm9yIG5vbi1kZWZhdWx0IGJ1dCBjb21wbGV0ZSBxdWVyeScpO1xuICAgICAgICB2YXIgbGlzdGVuID0gdGhpcy5yZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpO1xuICAgICAgICBpZiAobGlzdGVuICYmIHRoaXMuY29ubmVjdGVkXykge1xuICAgICAgICAgICAgdGhpcy5zZW5kVW5saXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQsIHF1ZXJ5LnF1ZXJ5T2JqZWN0KCksIHRhZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kVW5saXN0ZW5fID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIHF1ZXJ5SWQsIHF1ZXJ5T2JqLCB0YWcpIHtcbiAgICAgICAgdGhpcy5sb2dfKCdVbmxpc3RlbiBvbiAnICsgcGF0aFN0cmluZyArICcgZm9yICcgKyBxdWVyeUlkKTtcbiAgICAgICAgdmFyIHJlcSA9IHsgLypwYXRoKi8gcDogcGF0aFN0cmluZyB9O1xuICAgICAgICB2YXIgYWN0aW9uID0gJ24nO1xuICAgICAgICAvLyBPbmx5IGJvdGhlciBzZW5kaW5nIHF1ZXJ5SWQgaWYgaXQncyBub24tZGVmYXVsdC5cbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgcmVxWydxJ10gPSBxdWVyeU9iajtcbiAgICAgICAgICAgIHJlcVsndCddID0gdGFnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoYWN0aW9uLCByZXEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUub25EaXNjb25uZWN0UHV0ID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xuICAgICAgICAgICAgdGhpcy5zZW5kT25EaXNjb25uZWN0XygnbycsIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhdGhTdHJpbmc6IHBhdGhTdHJpbmcsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnbycsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUub25EaXNjb25uZWN0TWVyZ2UgPSBmdW5jdGlvbiAocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRPbkRpc2Nvbm5lY3RfKCdvbScsIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhdGhTdHJpbmc6IHBhdGhTdHJpbmcsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnb20nLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZTogb25Db21wbGV0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLm9uRGlzY29ubmVjdENhbmNlbCA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uRGlzY29ubmVjdF8oJ29jJywgcGF0aFN0cmluZywgbnVsbCwgb25Db21wbGV0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdFJlcXVlc3RRdWV1ZV8ucHVzaCh7XG4gICAgICAgICAgICAgICAgcGF0aFN0cmluZzogcGF0aFN0cmluZyxcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdvYycsXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRPbkRpc2Nvbm5lY3RfID0gZnVuY3Rpb24gKGFjdGlvbiwgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHsgLypwYXRoKi8gcDogcGF0aFN0cmluZywgLypkYXRhKi8gZDogZGF0YSB9O1xuICAgICAgICB0aGlzLmxvZ18oJ29uRGlzY29ubmVjdCAnICsgYWN0aW9uLCByZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcXVlc3QsIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKG9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZShyZXNwb25zZVsncyddLCByZXNwb25zZVsnZCddKTtcbiAgICAgICAgICAgICAgICB9LCBNYXRoLmZsb29yKDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCkge1xuICAgICAgICB0aGlzLnB1dEludGVybmFsKCdwJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7XG4gICAgICAgIHRoaXMucHV0SW50ZXJuYWwoJ20nLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKTtcbiAgICB9O1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5wdXRJbnRlcm5hbCA9IGZ1bmN0aW9uIChhY3Rpb24sIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAvKnBhdGgqLyBwOiBwYXRoU3RyaW5nLFxuICAgICAgICAgICAgLypkYXRhKi8gZDogZGF0YVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGFzaCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVxdWVzdFsnaCddID0gaGFzaDtcbiAgICAgICAgLy8gVE9ETzogT25seSBrZWVwIHRyYWNrIG9mIHRoZSBtb3N0IHJlY2VudCBwdXQgZm9yIGEgZ2l2ZW4gcGF0aD9cbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dHNfLnB1c2goe1xuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LFxuICAgICAgICAgICAgb25Db21wbGV0ZTogb25Db21wbGV0ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dENvdW50XysrO1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLm91dHN0YW5kaW5nUHV0c18ubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xuICAgICAgICAgICAgdGhpcy5zZW5kUHV0XyhpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0J1ZmZlcmluZyBwdXQ6ICcgKyBwYXRoU3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRQdXRfID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLmFjdGlvbjtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLnJlcXVlc3Q7XG4gICAgICAgIHZhciBvbkNvbXBsZXRlID0gdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2luZGV4XS5vbkNvbXBsZXRlO1xuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLnF1ZXVlZCA9IHRoaXMuY29ubmVjdGVkXztcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcXVlc3QsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBfdGhpcy5sb2dfKGFjdGlvbiArICcgcmVzcG9uc2UnLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2luZGV4XTtcbiAgICAgICAgICAgIF90aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfLS07XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBhcnJheSBvY2Nhc2lvbmFsbHkuXG4gICAgICAgICAgICBpZiAoX3RoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8gPT09IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vdXRzdGFuZGluZ1B1dHNfID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Db21wbGV0ZSlcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKG1lc3NhZ2VbJ3MnXSwgbWVzc2FnZVsnZCddKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5yZXBvcnRTdGF0cyA9IGZ1bmN0aW9uIChzdGF0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBJZiB3ZSdyZSBub3QgY29ubmVjdGVkLCB3ZSBqdXN0IGRyb3AgdGhlIHN0YXRzLlxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHsgLypjb3VudGVycyovIGM6IHN0YXRzIH07XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ3JlcG9ydFN0YXRzJywgcmVxdWVzdCk7XG4gICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KC8qc3RhdHMqLyAncycsIHJlcXVlc3QsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gcmVzdWx0WydzJ107XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gJ29rJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JSZWFzb24gPSByZXN1bHRbJ2QnXTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nXygncmVwb3J0U3RhdHMnLCAnRXJyb3Igc2VuZGluZyBzdGF0czogJyArIGVycm9yUmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBtZXNzYWdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUub25EYXRhTWVzc2FnZV8gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAoJ3InIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSByZXNwb25zZVxuICAgICAgICAgICAgdGhpcy5sb2dfKCdmcm9tIHNlcnZlcjogJyArIHN0cmluZ2lmeShtZXNzYWdlKSk7XG4gICAgICAgICAgICB2YXIgcmVxTnVtID0gbWVzc2FnZVsnciddO1xuICAgICAgICAgICAgdmFyIG9uUmVzcG9uc2UgPSB0aGlzLnJlcXVlc3RDQkhhc2hfW3JlcU51bV07XG4gICAgICAgICAgICBpZiAob25SZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlcXVlc3RDQkhhc2hfW3JlcU51bV07XG4gICAgICAgICAgICAgICAgb25SZXNwb25zZShtZXNzYWdlWydiJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdlcnJvcicgaW4gbWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgJ0Egc2VydmVyLXNpZGUgZXJyb3IgaGFzIG9jY3VycmVkOiAnICsgbWVzc2FnZVsnZXJyb3InXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnYScgaW4gbWVzc2FnZSkge1xuICAgICAgICAgICAgLy8gYSBhbmQgYiBhcmUgYWN0aW9uIGFuZCBib2R5LCByZXNwZWN0aXZlbHlcbiAgICAgICAgICAgIHRoaXMub25EYXRhUHVzaF8obWVzc2FnZVsnYSddLCBtZXNzYWdlWydiJ10pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUub25EYXRhUHVzaF8gPSBmdW5jdGlvbiAoYWN0aW9uLCBib2R5KSB7XG4gICAgICAgIHRoaXMubG9nXygnaGFuZGxlU2VydmVyTWVzc2FnZScsIGFjdGlvbiwgYm9keSk7XG4gICAgICAgIGlmIChhY3Rpb24gPT09ICdkJylcbiAgICAgICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyhib2R5WydwJ10sIGJvZHlbJ2QnXSwgXG4gICAgICAgICAgICAvKmlzTWVyZ2UqLyBmYWxzZSwgYm9keVsndCddKTtcbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnbScpXG4gICAgICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8oYm9keVsncCddLCBib2R5WydkJ10sIFxuICAgICAgICAgICAgLyppc01lcmdlPSovIHRydWUsIGJvZHlbJ3QnXSk7XG4gICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ2MnKVxuICAgICAgICAgICAgdGhpcy5vbkxpc3RlblJldm9rZWRfKGJvZHlbJ3AnXSwgYm9keVsncSddKTtcbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnYWMnKVxuICAgICAgICAgICAgdGhpcy5vbkF1dGhSZXZva2VkXyhib2R5WydzJ10sIGJvZHlbJ2QnXSk7XG4gICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ3NkJylcbiAgICAgICAgICAgIHRoaXMub25TZWN1cml0eURlYnVnUGFja2V0Xyhib2R5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZXJyb3IoJ1VucmVjb2duaXplZCBhY3Rpb24gcmVjZWl2ZWQgZnJvbSBzZXJ2ZXI6ICcgK1xuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShhY3Rpb24pICtcbiAgICAgICAgICAgICAgICAnXFxuQXJlIHlvdSB1c2luZyB0aGUgbGF0ZXN0IGNsaWVudD8nKTtcbiAgICB9O1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5vblJlYWR5XyA9IGZ1bmN0aW9uICh0aW1lc3RhbXAsIHNlc3Npb25JZCkge1xuICAgICAgICB0aGlzLmxvZ18oJ2Nvbm5lY3Rpb24gcmVhZHknKTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVUaW1lc3RhbXBfKHRpbWVzdGFtcCk7XG4gICAgICAgIHRoaXMubGFzdFNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RDb25uZWN0aW9uXykge1xuICAgICAgICAgICAgdGhpcy5zZW5kQ29ubmVjdFN0YXRzXygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzdG9yZVN0YXRlXygpO1xuICAgICAgICB0aGlzLmZpcnN0Q29ubmVjdGlvbl8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkNvbm5lY3RTdGF0dXNfKHRydWUpO1xuICAgIH07XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlQ29ubmVjdF8gPSBmdW5jdGlvbiAodGltZW91dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBhc3NlcnQoIXRoaXMucmVhbHRpbWVfLCBcIlNjaGVkdWxpbmcgYSBjb25uZWN0IHdoZW4gd2UncmUgYWxyZWFkeSBjb25uZWN0ZWQvaW5nP1wiKTtcbiAgICAgICAgaWYgKHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXykge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URTogRXZlbiB3aGVuIHRpbWVvdXQgaXMgMCwgaXQncyBpbXBvcnRhbnQgdG8gZG8gYSBzZXRUaW1lb3V0IHRvIHdvcmsgYXJvdW5kIGFuIGluZnVyaWF0aW5nIFwiU2VjdXJpdHkgRXJyb3JcIiBpblxuICAgICAgICAvLyBGaXJlZm94IHdoZW4gdHJ5aW5nIHRvIHdyaXRlIHRvIG91ciBsb25nLXBvbGxpbmcgaWZyYW1lIGluIHNvbWUgc2NlbmFyaW9zIChlLmcuIEZvcmdlIG9yIG91ciB1bml0IHRlc3RzKS5cbiAgICAgICAgdGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLmVzdGFibGlzaENvbm5lY3Rpb25fKCk7XG4gICAgICAgIH0sIE1hdGguZmxvb3IodGltZW91dCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2aXNpYmxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUub25WaXNpYmxlXyA9IGZ1bmN0aW9uICh2aXNpYmxlKSB7XG4gICAgICAgIC8vIE5PVEU6IFRhYmJpbmcgYXdheSBhbmQgYmFjayB0byBhIHdpbmRvdyB3aWxsIGRlZmVhdCBvdXIgcmVjb25uZWN0IGJhY2tvZmYsIGJ1dCBJIHRoaW5rIHRoYXQncyBmaW5lLlxuICAgICAgICBpZiAodmlzaWJsZSAmJlxuICAgICAgICAgICAgIXRoaXMudmlzaWJsZV8gJiZcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID09PSB0aGlzLm1heFJlY29ubmVjdERlbGF5Xykge1xuICAgICAgICAgICAgdGhpcy5sb2dfKCdXaW5kb3cgYmVjYW1lIHZpc2libGUuICBSZWR1Y2luZyBkZWxheS4nKTtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01JTl9ERUxBWTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFsdGltZV8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8oMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpYmxlXyA9IHZpc2libGU7XG4gICAgfTtcbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUub25PbmxpbmVfID0gZnVuY3Rpb24gKG9ubGluZSkge1xuICAgICAgICBpZiAob25saW5lKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0Jyb3dzZXIgd2VudCBvbmxpbmUuJyk7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVhbHRpbWVfKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUNvbm5lY3RfKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2dfKCdCcm93c2VyIHdlbnQgb2ZmbGluZS4gIEtpbGxpbmcgY29ubmVjdGlvbi4nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWx0aW1lXykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWVfLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5vblJlYWx0aW1lRGlzY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nXygnZGF0YSBjbGllbnQgZGlzY29ubmVjdGVkJyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlYWx0aW1lXyA9IG51bGw7XG4gICAgICAgIC8vIFNpbmNlIHdlIGRvbid0IGtub3cgaWYgb3VyIHNlbnQgdHJhbnNhY3Rpb25zIHN1Y2NlZWRlZCBvciBub3QsIHdlIG5lZWQgdG8gY2FuY2VsIHRoZW0uXG4gICAgICAgIHRoaXMuY2FuY2VsU2VudFRyYW5zYWN0aW9uc18oKTtcbiAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBwZW5kaW5nIHJlcXVlc3RzLlxuICAgICAgICB0aGlzLnJlcXVlc3RDQkhhc2hfID0ge307XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFJlY29ubmVjdF8oKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnZpc2libGVfKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKFwiV2luZG93IGlzbid0IHZpc2libGUuICBEZWxheWluZyByZWNvbm5lY3QuXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gdGhpcy5tYXhSZWNvbm5lY3REZWxheV87XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkF0dGVtcHRUaW1lXyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8pIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBiZWVuIGNvbm5lY3RlZCBsb25nIGVub3VnaCwgcmVzZXQgcmVjb25uZWN0IGRlbGF5IHRvIG1pbmltdW0uXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDb25uZWN0U3VjY2VlZGVkID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXztcbiAgICAgICAgICAgICAgICBpZiAodGltZVNpbmNlTGFzdENvbm5lY3RTdWNjZWVkZWQgPiBSRUNPTk5FQ1RfREVMQVlfUkVTRVRfVElNRU9VVClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q29ubmVjdEF0dGVtcHQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMubGFzdENvbm5lY3Rpb25BdHRlbXB0VGltZV87XG4gICAgICAgICAgICB2YXIgcmVjb25uZWN0RGVsYXkgPSBNYXRoLm1heCgwLCB0aGlzLnJlY29ubmVjdERlbGF5XyAtIHRpbWVTaW5jZUxhc3RDb25uZWN0QXR0ZW1wdCk7XG4gICAgICAgICAgICByZWNvbm5lY3REZWxheSA9IE1hdGgucmFuZG9tKCkgKiByZWNvbm5lY3REZWxheTtcbiAgICAgICAgICAgIHRoaXMubG9nXygnVHJ5aW5nIHRvIHJlY29ubmVjdCBpbiAnICsgcmVjb25uZWN0RGVsYXkgKyAnbXMnKTtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XyhyZWNvbm5lY3REZWxheSk7XG4gICAgICAgICAgICAvLyBBZGp1c3QgcmVjb25uZWN0IGRlbGF5IGZvciBuZXh0IHRpbWUuXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IE1hdGgubWluKHRoaXMubWF4UmVjb25uZWN0RGVsYXlfLCB0aGlzLnJlY29ubmVjdERlbGF5XyAqIFJFQ09OTkVDVF9ERUxBWV9NVUxUSVBMSUVSKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uQ29ubmVjdFN0YXR1c18oZmFsc2UpO1xuICAgIH07XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLmVzdGFibGlzaENvbm5lY3Rpb25fID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRSZWNvbm5lY3RfKCkpIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnTWFraW5nIGEgY29ubmVjdGlvbiBhdHRlbXB0Jyk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uQXR0ZW1wdFRpbWVfID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXyA9IG51bGw7XG4gICAgICAgICAgICB2YXIgb25EYXRhTWVzc2FnZV8xID0gdGhpcy5vbkRhdGFNZXNzYWdlXy5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdmFyIG9uUmVhZHlfMSA9IHRoaXMub25SZWFkeV8uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBvbkRpc2Nvbm5lY3RfMSA9IHRoaXMub25SZWFsdGltZURpc2Nvbm5lY3RfLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB2YXIgY29ubklkXzEgPSB0aGlzLmlkICsgJzonICsgUGVyc2lzdGVudENvbm5lY3Rpb24ubmV4dENvbm5lY3Rpb25JZF8rKztcbiAgICAgICAgICAgIHZhciBzZWxmXzEgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGxhc3RTZXNzaW9uSWRfMSA9IHRoaXMubGFzdFNlc3Npb25JZDtcbiAgICAgICAgICAgIHZhciBjYW5jZWxlZF8xID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbl8xID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBjbG9zZUZuXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25fMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uXzEuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGVkXzEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvbkRpc2Nvbm5lY3RfMSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc2VuZFJlcXVlc3RGbiA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQoY29ubmVjdGlvbl8xLCBcInNlbmRSZXF1ZXN0IGNhbGwgd2hlbiB3ZSdyZSBub3QgY29ubmVjdGVkIG5vdCBhbGxvd2VkLlwiKTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uXzEuc2VuZFJlcXVlc3QobXNnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lXyA9IHtcbiAgICAgICAgICAgICAgICBjbG9zZTogY2xvc2VGbl8xLFxuICAgICAgICAgICAgICAgIHNlbmRSZXF1ZXN0OiBzZW5kUmVxdWVzdEZuXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGZvcmNlUmVmcmVzaCA9IHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfO1xuICAgICAgICAgICAgdGhpcy5mb3JjZVRva2VuUmVmcmVzaF8gPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIEZpcnN0IGZldGNoIGF1dGggdG9rZW4sIGFuZCBlc3RhYmxpc2ggY29ubmVjdGlvbiBhZnRlciBmZXRjaGluZyB0aGUgdG9rZW4gd2FzIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgIHRoaXMuYXV0aFRva2VuUHJvdmlkZXJfXG4gICAgICAgICAgICAgICAgLmdldFRva2VuKGZvcmNlUmVmcmVzaClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZF8xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZygnZ2V0VG9rZW4oKSBjb21wbGV0ZWQuIENyZWF0aW5nIGNvbm5lY3Rpb24uJyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGZfMS5hdXRoVG9rZW5fID0gcmVzdWx0ICYmIHJlc3VsdC5hY2Nlc3NUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbl8xID0gbmV3IENvbm5lY3Rpb24oY29ubklkXzEsIHNlbGZfMS5yZXBvSW5mb18sIG9uRGF0YU1lc3NhZ2VfMSwgb25SZWFkeV8xLCBvbkRpc2Nvbm5lY3RfMSwgXG4gICAgICAgICAgICAgICAgICAgIC8qIG9uS2lsbD0gKi8gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihyZWFzb24gKyAnICgnICsgc2VsZl8xLnJlcG9JbmZvXy50b1N0cmluZygpICsgJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGZfMS5pbnRlcnJ1cHQoU0VSVkVSX0tJTExfSU5URVJSVVBUX1JFQVNPTik7XG4gICAgICAgICAgICAgICAgICAgIH0sIGxhc3RTZXNzaW9uSWRfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2coJ2dldFRva2VuKCkgY29tcGxldGVkIGJ1dCB3YXMgY2FuY2VsZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHNlbGZfMS5sb2dfKCdGYWlsZWQgdG8gZ2V0IHRva2VuOiAnICsgZXJyb3IpO1xuICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWRfMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQ09OU1RBTlRTLk5PREVfQURNSU4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWF5IGJlIGEgY3JpdGljYWwgZXJyb3IgZm9yIHRoZSBBZG1pbiBOb2RlLmpzIFNESywgc28gbG9nIGEgd2FybmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBnZXRUb2tlbigpIG1heSBhbHNvIGp1c3QgaGF2ZSB0ZW1wb3JhcmlseSBmYWlsZWQsIHNvIHdlIHN0aWxsIHdhbnQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIHJldHJ5aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2xvc2VGbl8xKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb25cbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuaW50ZXJydXB0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBsb2coJ0ludGVycnVwdGluZyBjb25uZWN0aW9uIGZvciByZWFzb246ICcgKyByZWFzb24pO1xuICAgICAgICB0aGlzLmludGVycnVwdFJlYXNvbnNfW3JlYXNvbl0gPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5yZWFsdGltZV8pIHtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWVfLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVhbHRpbWVEaXNjb25uZWN0XygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgbG9nKCdSZXN1bWluZyBjb25uZWN0aW9uIGZvciByZWFzb246ICcgKyByZWFzb24pO1xuICAgICAgICBkZWxldGUgdGhpcy5pbnRlcnJ1cHRSZWFzb25zX1tyZWFzb25dO1xuICAgICAgICBpZiAoaXNFbXB0eSh0aGlzLmludGVycnVwdFJlYXNvbnNfKSkge1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlYWx0aW1lXykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XygwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZVRpbWVzdGFtcF8gPSBmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gICAgICAgIHZhciBkZWx0YSA9IHRpbWVzdGFtcCAtIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB0aGlzLm9uU2VydmVySW5mb1VwZGF0ZV8oeyBzZXJ2ZXJUaW1lT2Zmc2V0OiBkZWx0YSB9KTtcbiAgICB9O1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5jYW5jZWxTZW50VHJhbnNhY3Rpb25zXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHN0YW5kaW5nUHV0c18ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwdXQgPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baV07XG4gICAgICAgICAgICBpZiAocHV0ICYmIC8qaGFzaCovICdoJyBpbiBwdXQucmVxdWVzdCAmJiBwdXQucXVldWVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHB1dC5vbkNvbXBsZXRlKVxuICAgICAgICAgICAgICAgICAgICBwdXQub25Db21wbGV0ZSgnZGlzY29ubmVjdCcpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm91dHN0YW5kaW5nUHV0c19baV07XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dENvdW50Xy0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFuIHVwIGFycmF5IG9jY2FzaW9uYWxseS5cbiAgICAgICAgaWYgKHRoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8gPT09IDApXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0c18gPSBbXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gcGF0aFN0cmluZ1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPCo+PX0gcXVlcnlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5vbkxpc3RlblJldm9rZWRfID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIHF1ZXJ5KSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdGVuIGFuZCBtYW51ZmFjdHVyZSBhIFwicGVybWlzc2lvbl9kZW5pZWRcIiBlcnJvciBmb3IgdGhlIGZhaWxlZCBsaXN0ZW4uXG4gICAgICAgIHZhciBxdWVyeUlkO1xuICAgICAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgICAgICBxdWVyeUlkID0gJ2RlZmF1bHQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcXVlcnlJZCA9IHF1ZXJ5Lm1hcChmdW5jdGlvbiAocSkgeyByZXR1cm4gT2JqZWN0VG9VbmlxdWVLZXkocSk7IH0pLmpvaW4oJyQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGVuID0gdGhpcy5yZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpO1xuICAgICAgICBpZiAobGlzdGVuICYmIGxpc3Rlbi5vbkNvbXBsZXRlKVxuICAgICAgICAgICAgbGlzdGVuLm9uQ29tcGxldGUoJ3Blcm1pc3Npb25fZGVuaWVkJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IHBhdGhTdHJpbmdcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IHF1ZXJ5SWRcbiAgICAgKiBAcmV0dXJuIHt7cXVlcmllczpBcnJheS48UXVlcnk+LCBvbkNvbXBsZXRlOmZ1bmN0aW9uKHN0cmluZyl9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZUxpc3Rlbl8gPSBmdW5jdGlvbiAocGF0aFN0cmluZywgcXVlcnlJZCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZFBhdGhTdHJpbmcgPSBuZXcgUGF0aChwYXRoU3RyaW5nKS50b1N0cmluZygpOyAvLyBub3JtYWxpemUgcGF0aC5cbiAgICAgICAgdmFyIGxpc3RlbjtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuc19bbm9ybWFsaXplZFBhdGhTdHJpbmddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxpc3RlbiA9IHRoaXMubGlzdGVuc19bbm9ybWFsaXplZFBhdGhTdHJpbmddW3F1ZXJ5SWRdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuc19bbm9ybWFsaXplZFBhdGhTdHJpbmddW3F1ZXJ5SWRdO1xuICAgICAgICAgICAgaWYgKGdldENvdW50KHRoaXMubGlzdGVuc19bbm9ybWFsaXplZFBhdGhTdHJpbmddKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpc3RlbnNfW25vcm1hbGl6ZWRQYXRoU3RyaW5nXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFsbCBsaXN0ZW5zIGZvciB0aGlzIHBhdGggaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkXG4gICAgICAgICAgICBsaXN0ZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3RlbjtcbiAgICB9O1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5vbkF1dGhSZXZva2VkXyA9IGZ1bmN0aW9uIChzdGF0dXNDb2RlLCBleHBsYW5hdGlvbikge1xuICAgICAgICBsb2coJ0F1dGggdG9rZW4gcmV2b2tlZDogJyArIHN0YXR1c0NvZGUgKyAnLycgKyBleHBsYW5hdGlvbik7XG4gICAgICAgIHRoaXMuYXV0aFRva2VuXyA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWFsdGltZV8uY2xvc2UoKTtcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09ICdpbnZhbGlkX3Rva2VuJyB8fCBzdGF0dXNDb2RlID09PSAncGVybWlzc2lvbl9kZW5pZWQnKSB7XG4gICAgICAgICAgICAvLyBXZSdsbCB3YWl0IGEgY291cGxlIHRpbWVzIGJlZm9yZSBsb2dnaW5nIHRoZSB3YXJuaW5nIC8gaW5jcmVhc2luZyB0aGVcbiAgICAgICAgICAgIC8vIHJldHJ5IHBlcmlvZCBzaW5jZSBvYXV0aCB0b2tlbnMgd2lsbCByZXBvcnQgYXMgXCJpbnZhbGlkXCIgaWYgdGhleSdyZVxuICAgICAgICAgICAgLy8ganVzdCBleHBpcmVkLiBQbHVzIHRoZXJlIG1heSBiZSB0cmFuc2llbnQgaXNzdWVzIHRoYXQgcmVzb2x2ZSB0aGVtc2VsdmVzLlxuICAgICAgICAgICAgdGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfKys7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID49IElOVkFMSURfQVVUSF9UT0tFTl9USFJFU0hPTEQpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgYSBsb25nIHJlY29ubmVjdCBkZWxheSBiZWNhdXNlIHJlY292ZXJ5IGlzIHVubGlrZWx5XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUFYX0RFTEFZX0ZPUl9BRE1JTlM7XG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5IHRoZSBhdXRoIHRva2VuIHByb3ZpZGVyIHRoYXQgdGhlIHRva2VuIGlzIGludmFsaWQsIHdoaWNoIHdpbGwgbG9nXG4gICAgICAgICAgICAgICAgLy8gYSB3YXJuaW5nXG4gICAgICAgICAgICAgICAgdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl8ubm90aWZ5Rm9ySW52YWxpZFRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5vblNlY3VyaXR5RGVidWdQYWNrZXRfID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VjdXJpdHlEZWJ1Z0NhbGxiYWNrXykge1xuICAgICAgICAgICAgdGhpcy5zZWN1cml0eURlYnVnQ2FsbGJhY2tfKGJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCdtc2cnIGluIGJvZHkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZJUkVCQVNFOiAnICsgYm9keVsnbXNnJ10ucmVwbGFjZSgnXFxuJywgJ1xcbkZJUkVCQVNFOiAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5yZXN0b3JlU3RhdGVfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvL1JlLWF1dGhlbnRpY2F0ZSBvdXJzZWx2ZXMgaWYgd2UgaGF2ZSBhIGNyZWRlbnRpYWwgc3RvcmVkLlxuICAgICAgICB0aGlzLnRyeUF1dGgoKTtcbiAgICAgICAgLy8gUHV0cyBkZXBlbmQgb24gaGF2aW5nIHJlY2VpdmVkIHRoZSBjb3JyZXNwb25kaW5nIGRhdGEgdXBkYXRlIGZyb20gdGhlIHNlcnZlciBiZWZvcmUgdGhleSBjb21wbGV0ZSwgc28gd2UgbXVzdFxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gc2VuZCBsaXN0ZW5zIGJlZm9yZSBwdXRzLlxuICAgICAgICBmb3JFYWNoKHRoaXMubGlzdGVuc18sIGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBxdWVyaWVzKSB7XG4gICAgICAgICAgICBmb3JFYWNoKHF1ZXJpZXMsIGZ1bmN0aW9uIChrZXksIGxpc3RlblNwZWMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZW5kTGlzdGVuXyhsaXN0ZW5TcGVjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHN0YW5kaW5nUHV0c18ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHN0YW5kaW5nUHV0c19baV0pXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kUHV0XyhpKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLm9uRGlzY29ubmVjdFJlcXVlc3RRdWV1ZV8uc2hpZnQoKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uRGlzY29ubmVjdF8ocmVxdWVzdC5hY3Rpb24sIHJlcXVlc3QucGF0aFN0cmluZywgcmVxdWVzdC5kYXRhLCByZXF1ZXN0Lm9uQ29tcGxldGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kcyBjbGllbnQgc3RhdHMgZm9yIGZpcnN0IGNvbm5lY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kQ29ubmVjdFN0YXRzXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRzID0ge307XG4gICAgICAgIHZhciBjbGllbnROYW1lID0gJ2pzJztcbiAgICAgICAgaWYgKENPTlNUQU5UUy5OT0RFX0FETUlOKSB7XG4gICAgICAgICAgICBjbGllbnROYW1lID0gJ2FkbWluX25vZGUnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENPTlNUQU5UUy5OT0RFX0NMSUVOVCkge1xuICAgICAgICAgICAgY2xpZW50TmFtZSA9ICdub2RlJztcbiAgICAgICAgfVxuICAgICAgICBzdGF0c1snc2RrLicgKyBjbGllbnROYW1lICsgJy4nICsgZmlyZWJhc2UuU0RLX1ZFUlNJT04ucmVwbGFjZSgvXFwuL2csICctJyldID0gMTtcbiAgICAgICAgaWYgKGlzTW9iaWxlQ29yZG92YSgpKSB7XG4gICAgICAgICAgICBzdGF0c1snZnJhbWV3b3JrLmNvcmRvdmEnXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAgICAgICBzdGF0c1snZnJhbWV3b3JrLnJlYWN0bmF0aXZlJ10gPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVwb3J0U3RhdHMoc3RhdHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5zaG91bGRSZWNvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb25saW5lID0gT25saW5lTW9uaXRvci5nZXRJbnN0YW5jZSgpLmN1cnJlbnRseU9ubGluZSgpO1xuICAgICAgICByZXR1cm4gaXNFbXB0eSh0aGlzLmludGVycnVwdFJlYXNvbnNfKSAmJiBvbmxpbmU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLm5leHRQZXJzaXN0ZW50Q29ubmVjdGlvbklkXyA9IDA7XG4gICAgLyoqXG4gICAgICogQ291bnRlciBmb3IgbnVtYmVyIG9mIGNvbm5lY3Rpb25zIGNyZWF0ZWQuIE1haW5seSB1c2VkIGZvciB0YWdnaW5nIGluIHRoZSBsb2dzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLm5leHRDb25uZWN0aW9uSWRfID0gMDtcbiAgICByZXR1cm4gUGVyc2lzdGVudENvbm5lY3Rpb247XG59KFNlcnZlckFjdGlvbnMpKTtcbmV4cG9ydCB7IFBlcnNpc3RlbnRDb25uZWN0aW9uIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvUGVyc2lzdGVudENvbm5lY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBmb3JFYWNoIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgUGVyc2lzdGVudFN0b3JhZ2UgfSBmcm9tICcuL3N0b3JhZ2Uvc3RvcmFnZSc7XG5pbXBvcnQgeyBMT05HX1BPTExJTkcsIFdFQlNPQ0tFVCB9IGZyb20gJy4uL3JlYWx0aW1lL0NvbnN0YW50cyc7XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBob2xkcyBtZXRhZGF0YSBhYm91dCBhIFJlcG8gb2JqZWN0XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBSZXBvSW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaG9zdCBIb3N0bmFtZSBwb3J0aW9uIG9mIHRoZSB1cmwgZm9yIHRoZSByZXBvXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWN1cmUgV2hldGhlciBvciBub3QgdGhpcyByZXBvIGlzIGFjY2Vzc2VkIG92ZXIgc3NsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHJlcHJlc2VudGVkIGJ5IHRoZSByZXBvXG4gICAgICogQHBhcmFtIHtib29sZWFufSB3ZWJTb2NrZXRPbmx5IFdoZXRoZXIgdG8gcHJlZmVyIHdlYnNvY2tldHMgb3ZlciBhbGwgb3RoZXIgdHJhbnNwb3J0cyAodXNlZCBieSBOZXN0KS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHBlcnNpc3RlbmNlS2V5IE92ZXJyaWRlIHRoZSBkZWZhdWx0IHNlc3Npb24gcGVyc2lzdGVuY2Ugc3RvcmFnZSBrZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZXBvSW5mbyhob3N0LCBzZWN1cmUsIG5hbWVzcGFjZSwgd2ViU29ja2V0T25seSwgcGVyc2lzdGVuY2VLZXkpIHtcbiAgICAgICAgaWYgKHBlcnNpc3RlbmNlS2V5ID09PSB2b2lkIDApIHsgcGVyc2lzdGVuY2VLZXkgPSAnJzsgfVxuICAgICAgICB0aGlzLnNlY3VyZSA9IHNlY3VyZTtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgICAgIHRoaXMud2ViU29ja2V0T25seSA9IHdlYlNvY2tldE9ubHk7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2VLZXkgPSBwZXJzaXN0ZW5jZUtleTtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0aGlzLmRvbWFpbiA9IHRoaXMuaG9zdC5zdWJzdHIodGhpcy5ob3N0LmluZGV4T2YoJy4nKSArIDEpO1xuICAgICAgICB0aGlzLmludGVybmFsSG9zdCA9IFBlcnNpc3RlbnRTdG9yYWdlLmdldCgnaG9zdDonICsgaG9zdCkgfHwgdGhpcy5ob3N0O1xuICAgIH1cbiAgICBSZXBvSW5mby5wcm90b3R5cGUubmVlZHNRdWVyeVBhcmFtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3N0ICE9PSB0aGlzLmludGVybmFsSG9zdDtcbiAgICB9O1xuICAgIFJlcG9JbmZvLnByb3RvdHlwZS5pc0NhY2hlYWJsZUhvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsSG9zdC5zdWJzdHIoMCwgMikgPT09ICdzLSc7XG4gICAgfTtcbiAgICBSZXBvSW5mby5wcm90b3R5cGUuaXNEZW1vSG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tYWluID09PSAnZmlyZWJhc2Vpby1kZW1vLmNvbSc7XG4gICAgfTtcbiAgICBSZXBvSW5mby5wcm90b3R5cGUuaXNDdXN0b21Ib3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZG9tYWluICE9PSAnZmlyZWJhc2Vpby5jb20nICYmIHRoaXMuZG9tYWluICE9PSAnZmlyZWJhc2Vpby1kZW1vLmNvbScpO1xuICAgIH07XG4gICAgUmVwb0luZm8ucHJvdG90eXBlLnVwZGF0ZUhvc3QgPSBmdW5jdGlvbiAobmV3SG9zdCkge1xuICAgICAgICBpZiAobmV3SG9zdCAhPT0gdGhpcy5pbnRlcm5hbEhvc3QpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxIb3N0ID0gbmV3SG9zdDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2FjaGVhYmxlSG9zdCgpKSB7XG4gICAgICAgICAgICAgICAgUGVyc2lzdGVudFN0b3JhZ2Uuc2V0KCdob3N0OicgKyB0aGlzLmhvc3QsIHRoaXMuaW50ZXJuYWxIb3N0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2Vic29ja2V0IFVSTCBmb3IgdGhpcyByZXBvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgb2YgY29ubmVjdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgbGlzdFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVSTCBmb3IgdGhpcyByZXBvXG4gICAgICovXG4gICAgUmVwb0luZm8ucHJvdG90eXBlLmNvbm5lY3Rpb25VUkwgPSBmdW5jdGlvbiAodHlwZSwgcGFyYW1zKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycsICd0eXBlb2YgdHlwZSBtdXN0ID09IHN0cmluZycpO1xuICAgICAgICBhc3NlcnQodHlwZW9mIHBhcmFtcyA9PT0gJ29iamVjdCcsICd0eXBlb2YgcGFyYW1zIG11c3QgPT0gb2JqZWN0Jyk7XG4gICAgICAgIHZhciBjb25uVVJMO1xuICAgICAgICBpZiAodHlwZSA9PT0gV0VCU09DS0VUKSB7XG4gICAgICAgICAgICBjb25uVVJMID1cbiAgICAgICAgICAgICAgICAodGhpcy5zZWN1cmUgPyAnd3NzOi8vJyA6ICd3czovLycpICsgdGhpcy5pbnRlcm5hbEhvc3QgKyAnLy53cz8nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IExPTkdfUE9MTElORykge1xuICAgICAgICAgICAgY29ublVSTCA9XG4gICAgICAgICAgICAgICAgKHRoaXMuc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJykgKyB0aGlzLmludGVybmFsSG9zdCArICcvLmxwPyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY29ubmVjdGlvbiB0eXBlOiAnICsgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmVlZHNRdWVyeVBhcmFtKCkpIHtcbiAgICAgICAgICAgIHBhcmFtc1snbnMnXSA9IHRoaXMubmFtZXNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYWlycyA9IFtdO1xuICAgICAgICBmb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goa2V5ICsgJz0nICsgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbm5VUkwgKyBwYWlycy5qb2luKCcmJyk7XG4gICAgfTtcbiAgICAvKiogQHJldHVybiB7c3RyaW5nfSAqL1xuICAgIFJlcG9JbmZvLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMudG9VUkxTdHJpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMucGVyc2lzdGVuY2VLZXkpIHtcbiAgICAgICAgICAgIHN0ciArPSAnPCcgKyB0aGlzLnBlcnNpc3RlbmNlS2V5ICsgJz4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgICAvKiogQHJldHVybiB7c3RyaW5nfSAqL1xuICAgIFJlcG9JbmZvLnByb3RvdHlwZS50b1VSTFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLycpICsgdGhpcy5ob3N0O1xuICAgIH07XG4gICAgcmV0dXJuIFJlcG9JbmZvO1xufSgpKTtcbmV4cG9ydCB7IFJlcG9JbmZvIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvUmVwb0luZm8uanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEludGVyZmFjZSBkZWZpbmluZyB0aGUgc2V0IG9mIGFjdGlvbnMgdGhhdCBjYW4gYmUgcGVyZm9ybWVkIGFnYWluc3QgdGhlIEZpcmViYXNlIHNlcnZlclxuICogKGJhc2ljYWxseSBjb3JyZXNwb25kcyB0byBvdXIgd2lyZSBwcm90b2NvbCkuXG4gKlxuICogQGludGVyZmFjZVxuICovXG52YXIgU2VydmVyQWN0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXJ2ZXJBY3Rpb25zKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFN0cmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gZGF0YVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nLCBzdHJpbmcpPX0gb25Db21wbGV0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gaGFzaFxuICAgICAqL1xuICAgIFNlcnZlckFjdGlvbnMucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmdcbiAgICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgP3N0cmluZyl9IG9uQ29tcGxldGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGhhc2hcbiAgICAgKi9cbiAgICBTZXJ2ZXJBY3Rpb25zLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7IH07XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBhdXRoIHRva2VuIGZvciB0aGUgY3VycmVudCBjb25uZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUaGUgYXV0aGVudGljYXRpb24gdG9rZW5cbiAgICAgKi9cbiAgICBTZXJ2ZXJBY3Rpb25zLnByb3RvdHlwZS5yZWZyZXNoQXV0aFRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmdcbiAgICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgc3RyaW5nKT19IG9uQ29tcGxldGVcbiAgICAgKi9cbiAgICBTZXJ2ZXJBY3Rpb25zLnByb3RvdHlwZS5vbkRpc2Nvbm5lY3RQdXQgPSBmdW5jdGlvbiAocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoU3RyaW5nXG4gICAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIHN0cmluZyk9fSBvbkNvbXBsZXRlXG4gICAgICovXG4gICAgU2VydmVyQWN0aW9ucy5wcm90b3R5cGUub25EaXNjb25uZWN0TWVyZ2UgPSBmdW5jdGlvbiAocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoU3RyaW5nXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIHN0cmluZyk9fSBvbkNvbXBsZXRlXG4gICAgICovXG4gICAgU2VydmVyQWN0aW9ucy5wcm90b3R5cGUub25EaXNjb25uZWN0Q2FuY2VsID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIG9uQ29tcGxldGUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCAqPn0gc3RhdHNcbiAgICAgKi9cbiAgICBTZXJ2ZXJBY3Rpb25zLnByb3RvdHlwZS5yZXBvcnRTdGF0cyA9IGZ1bmN0aW9uIChzdGF0cykgeyB9O1xuICAgIHJldHVybiBTZXJ2ZXJBY3Rpb25zO1xufSgpKTtcbmV4cG9ydCB7IFNlcnZlckFjdGlvbnMgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9TZXJ2ZXJBY3Rpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4vdXRpbC9QYXRoJztcbmltcG9ydCB7IFBSSU9SSVRZX0lOREVYIH0gZnJvbSAnLi9zbmFwL2luZGV4ZXMvUHJpb3JpdHlJbmRleCc7XG5pbXBvcnQgeyBDb3VudGVkU2V0IH0gZnJvbSAnLi91dGlsL0NvdW50ZWRTZXQnO1xuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gc3RvcmUgYSBzcGFyc2Ugc2V0IG9mIHNuYXBzaG90cy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFNwYXJzZVNuYXBzaG90VHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcGFyc2VTbmFwc2hvdFRyZWUoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7Tm9kZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVfID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtDb3VudGVkU2V0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGlsZHJlbl8gPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBub2RlIHN0b3JlZCBhdCB0aGUgZ2l2ZW4gcGF0aCBpZiBvbmUgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aCBQYXRoIHRvIGxvb2sgdXAgc25hcHNob3QgZm9yLlxuICAgICAqIEByZXR1cm4gez9Ob2RlfSBUaGUgcmV0cmlldmVkIG5vZGUsIG9yIG51bGwuXG4gICAgICovXG4gICAgU3BhcnNlU25hcHNob3RUcmVlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVfICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlXy5nZXRDaGlsZChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcGF0aC5pc0VtcHR5KCkgJiYgdGhpcy5jaGlsZHJlbl8gIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkS2V5ID0gcGF0aC5nZXRGcm9udCgpO1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgucG9wRnJvbnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuXy5jb250YWlucyhjaGlsZEtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRUcmVlID0gdGhpcy5jaGlsZHJlbl8uZ2V0KGNoaWxkS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRUcmVlLmZpbmQocGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIGdpdmVuIG5vZGUgYXQgdGhlIHNwZWNpZmllZCBwYXRoLiBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgbm9kZVxuICAgICAqIGF0IGEgc2hhbGxvd2VyIHBhdGgsIGl0IG1lcmdlcyB0aGUgbmV3IGRhdGEgaW50byB0aGF0IHNuYXBzaG90IG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoIFBhdGggdG8gbG9vayB1cCBzbmFwc2hvdCBmb3IuXG4gICAgICogQHBhcmFtIHshTm9kZX0gZGF0YSBUaGUgbmV3IGRhdGEsIG9yIG51bGwuXG4gICAgICovXG4gICAgU3BhcnNlU25hcHNob3RUcmVlLnByb3RvdHlwZS5yZW1lbWJlciA9IGZ1bmN0aW9uIChwYXRoLCBkYXRhKSB7XG4gICAgICAgIGlmIChwYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZV8gPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbl8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudmFsdWVfICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlXyA9IHRoaXMudmFsdWVfLnVwZGF0ZUNoaWxkKHBhdGgsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5fID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuXyA9IG5ldyBDb3VudGVkU2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hpbGRLZXkgPSBwYXRoLmdldEZyb250KCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW5fLmNvbnRhaW5zKGNoaWxkS2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5fLmFkZChjaGlsZEtleSwgbmV3IFNwYXJzZVNuYXBzaG90VHJlZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5fLmdldChjaGlsZEtleSk7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5wb3BGcm9udCgpO1xuICAgICAgICAgICAgY2hpbGQucmVtZW1iZXIocGF0aCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1cmdlIHRoZSBkYXRhIGF0IHBhdGggZnJvbSB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoIFBhdGggdG8gbG9vayB1cCBzbmFwc2hvdCBmb3IuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIG5vZGUgc2hvdWxkIG5vdyBiZSByZW1vdmVkLlxuICAgICAqL1xuICAgIFNwYXJzZVNuYXBzaG90VHJlZS5wcm90b3R5cGUuZm9yZ2V0ID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlXyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuXyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlXyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlXy5pc0xlYWZOb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgdHJ5aW5nIHRvIGZvcmdldCBhIG5vZGUgdGhhdCBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWVfO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlXyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxmXzEgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIGZ1bmN0aW9uIChrZXksIHRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGZfMS5yZW1lbWJlcihuZXcgUGF0aChrZXkpLCB0cmVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcmdldChwYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNoaWxkcmVuXyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZEtleSA9IHBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5wb3BGcm9udCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuXy5jb250YWlucyhjaGlsZEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhZmVUb1JlbW92ZSA9IHRoaXMuY2hpbGRyZW5fLmdldChjaGlsZEtleSkuZm9yZ2V0KHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2FmZVRvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuXy5yZW1vdmUoY2hpbGRLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuXy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbl8gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgaXRlcmF0ZXMgdGhyb3VnaCBhbGwgb2YgdGhlIHN0b3JlZCB0cmVlIGFuZCBjYWxscyB0aGVcbiAgICAgKiBjYWxsYmFjayBvbiBlYWNoIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHByZWZpeFBhdGggUGF0aCB0byBsb29rIHVwIG5vZGUgZm9yLlxuICAgICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggdHJlZS5cbiAgICAgKi9cbiAgICBTcGFyc2VTbmFwc2hvdFRyZWUucHJvdG90eXBlLmZvckVhY2hUcmVlID0gZnVuY3Rpb24gKHByZWZpeFBhdGgsIGZ1bmMpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVfICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmdW5jKHByZWZpeFBhdGgsIHRoaXMudmFsdWVfKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChrZXksIHRyZWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IG5ldyBQYXRoKHByZWZpeFBhdGgudG9TdHJpbmcoKSArICcvJyArIGtleSk7XG4gICAgICAgICAgICAgICAgdHJlZS5mb3JFYWNoVHJlZShwYXRoLCBmdW5jKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyB0aHJvdWdoIGVhY2ggaW1tZWRpYXRlIGNoaWxkIGFuZCB0cmlnZ2VycyB0aGUgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIGNoaWxkLlxuICAgICAqL1xuICAgIFNwYXJzZVNuYXBzaG90VHJlZS5wcm90b3R5cGUuZm9yRWFjaENoaWxkID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5fICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuXy5lYWNoKGZ1bmN0aW9uIChrZXksIHRyZWUpIHtcbiAgICAgICAgICAgICAgICBmdW5jKGtleSwgdHJlZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNwYXJzZVNuYXBzaG90VHJlZTtcbn0oKSk7XG5leHBvcnQgeyBTcGFyc2VTbmFwc2hvdFRyZWUgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9TcGFyc2VTbmFwc2hvdFRyZWUuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBDYWNoZU5vZGUgfSBmcm9tICcuL3ZpZXcvQ2FjaGVOb2RlJztcbmltcG9ydCB7IENoaWxkcmVuTm9kZSB9IGZyb20gJy4vc25hcC9DaGlsZHJlbk5vZGUnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgaXNFbXB0eSwgZm9yRWFjaCwgZmluZFZhbHVlLCBzYWZlR2V0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgVmlld0NhY2hlIH0gZnJvbSAnLi92aWV3L1ZpZXdDYWNoZSc7XG5pbXBvcnQgeyBWaWV3IH0gZnJvbSAnLi92aWV3L1ZpZXcnO1xudmFyIF9fcmVmZXJlbmNlQ29uc3RydWN0b3I7XG4vKipcbiAqIFN5bmNQb2ludCByZXByZXNlbnRzIGEgc2luZ2xlIGxvY2F0aW9uIGluIGEgU3luY1RyZWUgd2l0aCAxIG9yIG1vcmUgZXZlbnQgcmVnaXN0cmF0aW9ucywgbWVhbmluZyB3ZSBuZWVkIHRvXG4gKiBtYWludGFpbiAxIG9yIG1vcmUgVmlld3MgYXQgdGhpcyBsb2NhdGlvbiB0byBjYWNoZSBzZXJ2ZXIgZGF0YSBhbmQgcmFpc2UgYXBwcm9wcmlhdGUgZXZlbnRzIGZvciBzZXJ2ZXIgY2hhbmdlc1xuICogYW5kIHVzZXIgd3JpdGVzIChzZXQsIHRyYW5zYWN0aW9uLCB1cGRhdGUpLlxuICpcbiAqIEl0J3MgcmVzcG9uc2libGUgZm9yOlxuICogIC0gTWFpbnRhaW5pbmcgdGhlIHNldCBvZiAxIG9yIG1vcmUgdmlld3MgbmVjZXNzYXJ5IGF0IHRoaXMgbG9jYXRpb24gKGEgU3luY1BvaW50IHdpdGggMCB2aWV3cyBzaG91bGQgYmUgcmVtb3ZlZCkuXG4gKiAgLSBQcm94eWluZyB1c2VyIC8gc2VydmVyIG9wZXJhdGlvbnMgdG8gdGhlIHZpZXdzIGFzIGFwcHJvcHJpYXRlIChpLmUuIGFwcGx5U2VydmVyT3ZlcndyaXRlLFxuICogICAgYXBwbHlVc2VyT3ZlcndyaXRlLCBldGMuKVxuICovXG52YXIgU3luY1BvaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN5bmNQb2ludCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBWaWV3cyBiZWluZyB0cmFja2VkIGF0IHRoaXMgbG9jYXRpb24gaW4gdGhlIHRyZWUsIHN0b3JlZCBhcyBhIG1hcCB3aGVyZSB0aGUga2V5IGlzIGFcbiAgICAgICAgICogcXVlcnlJZCBhbmQgdGhlIHZhbHVlIGlzIHRoZSBWaWV3IGZvciB0aGF0IHF1ZXJ5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBOT1RFOiBUaGlzIGxpc3Qgd2lsbCBiZSBxdWl0ZSBzbWFsbCAodXN1YWxseSAxLCBidXQgcGVyaGFwcyAyIG9yIDM7IGFueSBtb3JlIGlzIGFuIG9kZCB1c2UgY2FzZSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHshT2JqZWN0Ljwhc3RyaW5nLCAhVmlldz59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpZXdzXyA9IHt9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3luY1BvaW50LCBcIl9fcmVmZXJlbmNlQ29uc3RydWN0b3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydChfX3JlZmVyZW5jZUNvbnN0cnVjdG9yLCAnUmVmZXJlbmNlLnRzIGhhcyBub3QgYmVlbiBsb2FkZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBfX3JlZmVyZW5jZUNvbnN0cnVjdG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGFzc2VydCghX19yZWZlcmVuY2VDb25zdHJ1Y3RvciwgJ19fcmVmZXJlbmNlQ29uc3RydWN0b3IgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkJyk7XG4gICAgICAgICAgICBfX3JlZmVyZW5jZUNvbnN0cnVjdG9yID0gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIFN5bmNQb2ludC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlzRW1wdHkodGhpcy52aWV3c18pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFPcGVyYXRpb259IG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzQ2FjaGVcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBvcHRDb21wbGV0ZVNlcnZlckNhY2hlXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fVxuICAgICAqL1xuICAgIFN5bmNQb2ludC5wcm90b3R5cGUuYXBwbHlPcGVyYXRpb24gPSBmdW5jdGlvbiAob3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZSkge1xuICAgICAgICB2YXIgcXVlcnlJZCA9IG9wZXJhdGlvbi5zb3VyY2UucXVlcnlJZDtcbiAgICAgICAgaWYgKHF1ZXJ5SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gc2FmZUdldCh0aGlzLnZpZXdzXywgcXVlcnlJZCk7XG4gICAgICAgICAgICBhc3NlcnQodmlldyAhPSBudWxsLCAnU3luY1RyZWUgZ2F2ZSB1cyBhbiBvcCBmb3IgYW4gaW52YWxpZCBxdWVyeS4nKTtcbiAgICAgICAgICAgIHJldHVybiB2aWV3LmFwcGx5T3BlcmF0aW9uKG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIG9wdENvbXBsZXRlU2VydmVyQ2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV2ZW50c18xID0gW107XG4gICAgICAgICAgICBmb3JFYWNoKHRoaXMudmlld3NfLCBmdW5jdGlvbiAoa2V5LCB2aWV3KSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzXzEgPSBldmVudHNfMS5jb25jYXQodmlldy5hcHBseU9wZXJhdGlvbihvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBvcHRDb21wbGV0ZVNlcnZlckNhY2hlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBldmVudHNfMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGFuIGV2ZW50IGNhbGxiYWNrIGZvciB0aGUgc3BlY2lmaWVkIHF1ZXJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAgICogQHBhcmFtIHshRXZlbnRSZWdpc3RyYXRpb259IGV2ZW50UmVnaXN0cmF0aW9uXG4gICAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgICAqIEBwYXJhbSB7P05vZGV9IHNlcnZlckNhY2hlIENvbXBsZXRlIHNlcnZlciBjYWNoZSwgaWYgd2UgaGF2ZSBpdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlcnZlckNhY2hlQ29tcGxldGVcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICAgKi9cbiAgICBTeW5jUG9pbnQucHJvdG90eXBlLmFkZEV2ZW50UmVnaXN0cmF0aW9uID0gZnVuY3Rpb24gKHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBxdWVyeUlkID0gcXVlcnkucXVlcnlJZGVudGlmaWVyKCk7XG4gICAgICAgIHZhciB2aWV3ID0gc2FmZUdldCh0aGlzLnZpZXdzXywgcXVlcnlJZCk7XG4gICAgICAgIGlmICghdmlldykge1xuICAgICAgICAgICAgLy8gVE9ETzogbWFrZSB3cml0ZXNDYWNoZSB0YWtlIGZsYWcgZm9yIGNvbXBsZXRlIHNlcnZlciBub2RlXG4gICAgICAgICAgICB2YXIgZXZlbnRDYWNoZSA9IHdyaXRlc0NhY2hlLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUoc2VydmVyQ2FjaGVDb21wbGV0ZSA/IHNlcnZlckNhY2hlIDogbnVsbCk7XG4gICAgICAgICAgICB2YXIgZXZlbnRDYWNoZUNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXZlbnRDYWNoZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50Q2FjaGVDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZXJ2ZXJDYWNoZSBpbnN0YW5jZW9mIENoaWxkcmVuTm9kZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50Q2FjaGUgPSB3cml0ZXNDYWNoZS5jYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKHNlcnZlckNhY2hlKTtcbiAgICAgICAgICAgICAgICBldmVudENhY2hlQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50Q2FjaGUgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgICAgICAgICBldmVudENhY2hlQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2aWV3Q2FjaGUgPSBuZXcgVmlld0NhY2hlKG5ldyBDYWNoZU5vZGUoXG4gICAgICAgICAgICAvKiogQHR5cGUgeyFOb2RlfSAqLyAoZXZlbnRDYWNoZSksIGV2ZW50Q2FjaGVDb21wbGV0ZSwgZmFsc2UpLCBuZXcgQ2FjaGVOb2RlKFxuICAgICAgICAgICAgLyoqIEB0eXBlIHshTm9kZX0gKi8gKHNlcnZlckNhY2hlKSwgc2VydmVyQ2FjaGVDb21wbGV0ZSwgZmFsc2UpKTtcbiAgICAgICAgICAgIHZpZXcgPSBuZXcgVmlldyhxdWVyeSwgdmlld0NhY2hlKTtcbiAgICAgICAgICAgIHRoaXMudmlld3NfW3F1ZXJ5SWRdID0gdmlldztcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8gZXhpc3Qgbm93LCB3ZSBqdXN0IGNyZWF0ZWQgYW55dGhpbmcgdGhhdCB3YXMgbWlzc2luZ1xuICAgICAgICB2aWV3LmFkZEV2ZW50UmVnaXN0cmF0aW9uKGV2ZW50UmVnaXN0cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHZpZXcuZ2V0SW5pdGlhbEV2ZW50cyhldmVudFJlZ2lzdHJhdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXZlbnQgY2FsbGJhY2socykuICBSZXR1cm4gY2FuY2VsRXZlbnRzIGlmIGEgY2FuY2VsRXJyb3IgaXMgc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogSWYgcXVlcnkgaXMgdGhlIGRlZmF1bHQgcXVlcnksIHdlJ2xsIGNoZWNrIGFsbCB2aWV3cyBmb3IgdGhlIHNwZWNpZmllZCBldmVudFJlZ2lzdHJhdGlvbi5cbiAgICAgKiBJZiBldmVudFJlZ2lzdHJhdGlvbiBpcyBudWxsLCB3ZSdsbCByZW1vdmUgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIHNwZWNpZmllZCB2aWV3KHMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAgICogQHBhcmFtIHs/RXZlbnRSZWdpc3RyYXRpb259IGV2ZW50UmVnaXN0cmF0aW9uIElmIG51bGwsIHJlbW92ZSBhbGwgY2FsbGJhY2tzLlxuICAgICAqIEBwYXJhbSB7RXJyb3I9fSBjYW5jZWxFcnJvciBJZiBhIGNhbmNlbEVycm9yIGlzIHByb3ZpZGVkLCBhcHByb3ByaWF0ZSBjYW5jZWwgZXZlbnRzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogQHJldHVybiB7e3JlbW92ZWQ6IUFycmF5LjwhUXVlcnk+LCBldmVudHM6IUFycmF5LjwhRXZlbnQ+fX0gcmVtb3ZlZCBxdWVyaWVzIGFuZCBhbnkgY2FuY2VsIGV2ZW50c1xuICAgICAqL1xuICAgIFN5bmNQb2ludC5wcm90b3R5cGUucmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24gPSBmdW5jdGlvbiAocXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCBjYW5jZWxFcnJvcikge1xuICAgICAgICB2YXIgcXVlcnlJZCA9IHF1ZXJ5LnF1ZXJ5SWRlbnRpZmllcigpO1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgICB2YXIgY2FuY2VsRXZlbnRzID0gW107XG4gICAgICAgIHZhciBoYWRDb21wbGV0ZVZpZXcgPSB0aGlzLmhhc0NvbXBsZXRlVmlldygpO1xuICAgICAgICBpZiAocXVlcnlJZCA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHlvdSBkbyByZWYub2ZmKC4uLiksIHdlIHNlYXJjaCBhbGwgdmlld3MgZm9yIHRoZSByZWdpc3RyYXRpb24gdG8gcmVtb3ZlLlxuICAgICAgICAgICAgdmFyIHNlbGZfMSA9IHRoaXM7XG4gICAgICAgICAgICBmb3JFYWNoKHRoaXMudmlld3NfLCBmdW5jdGlvbiAodmlld1F1ZXJ5SWQsIHZpZXcpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxFdmVudHMgPSBjYW5jZWxFdmVudHMuY29uY2F0KHZpZXcucmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24oZXZlbnRSZWdpc3RyYXRpb24sIGNhbmNlbEVycm9yKSk7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXcuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmXzEudmlld3NfW3ZpZXdRdWVyeUlkXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UnbGwgZGVhbCB3aXRoIGNvbXBsZXRlIHZpZXdzIGxhdGVyLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRRdWVyeSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0UXVlcnlQYXJhbXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmxvYWRzQWxsRGF0YSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkLnB1c2godmlldy5nZXRRdWVyeSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIHRoZSBzcGVjaWZpYyB2aWV3LlxuICAgICAgICAgICAgdmFyIHZpZXcgPSBzYWZlR2V0KHRoaXMudmlld3NfLCBxdWVyeUlkKTtcbiAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsRXZlbnRzID0gY2FuY2VsRXZlbnRzLmNvbmNhdCh2aWV3LnJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKGV2ZW50UmVnaXN0cmF0aW9uLCBjYW5jZWxFcnJvcikpO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy52aWV3c19bcXVlcnlJZF07XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ2xsIGRlYWwgd2l0aCBjb21wbGV0ZSB2aWV3cyBsYXRlci5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aWV3XG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0UXVlcnkoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldFF1ZXJ5UGFyYW1zKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5sb2Fkc0FsbERhdGEoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKHZpZXcuZ2V0UXVlcnkoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhZENvbXBsZXRlVmlldyAmJiAhdGhpcy5oYXNDb21wbGV0ZVZpZXcoKSkge1xuICAgICAgICAgICAgLy8gV2UgcmVtb3ZlZCBvdXIgbGFzdCBjb21wbGV0ZSB2aWV3LlxuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKG5ldyBTeW5jUG9pbnQuX19yZWZlcmVuY2VDb25zdHJ1Y3RvcihxdWVyeS5yZXBvLCBxdWVyeS5wYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmVtb3ZlZDogcmVtb3ZlZCwgZXZlbnRzOiBjYW5jZWxFdmVudHMgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFBcnJheS48IVZpZXc+fVxuICAgICAqL1xuICAgIFN5bmNQb2ludC5wcm90b3R5cGUuZ2V0UXVlcnlWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHZhbHVlcyA9IE9iamVjdC5rZXlzKHRoaXMudmlld3NfKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gX3RoaXMudmlld3NfW2tleV07IH0pO1xuICAgICAgICByZXR1cm4gdmFsdWVzLmZpbHRlcihmdW5jdGlvbiAodmlldykge1xuICAgICAgICAgICAgcmV0dXJuICF2aWV3XG4gICAgICAgICAgICAgICAgLmdldFF1ZXJ5KClcbiAgICAgICAgICAgICAgICAuZ2V0UXVlcnlQYXJhbXMoKVxuICAgICAgICAgICAgICAgIC5sb2Fkc0FsbERhdGEoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGggVGhlIHBhdGggdG8gdGhlIGRlc2lyZWQgY29tcGxldGUgc25hcHNob3RcbiAgICAgKiBAcmV0dXJuIHs/Tm9kZX0gQSBjb21wbGV0ZSBjYWNoZSwgaWYgaXQgZXhpc3RzXG4gICAgICovXG4gICAgU3luY1BvaW50LnByb3RvdHlwZS5nZXRDb21wbGV0ZVNlcnZlckNhY2hlID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHNlcnZlckNhY2hlID0gbnVsbDtcbiAgICAgICAgZm9yRWFjaCh0aGlzLnZpZXdzXywgZnVuY3Rpb24gKGtleSwgdmlldykge1xuICAgICAgICAgICAgc2VydmVyQ2FjaGUgPSBzZXJ2ZXJDYWNoZSB8fCB2aWV3LmdldENvbXBsZXRlU2VydmVyQ2FjaGUocGF0aCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VydmVyQ2FjaGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICAgKiBAcmV0dXJuIHs/Vmlld31cbiAgICAgKi9cbiAgICBTeW5jUG9pbnQucHJvdG90eXBlLnZpZXdGb3JRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICB2YXIgcGFyYW1zID0gcXVlcnkuZ2V0UXVlcnlQYXJhbXMoKTtcbiAgICAgICAgaWYgKHBhcmFtcy5sb2Fkc0FsbERhdGEoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcGxldGVWaWV3KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcXVlcnlJZCA9IHF1ZXJ5LnF1ZXJ5SWRlbnRpZmllcigpO1xuICAgICAgICAgICAgcmV0dXJuIHNhZmVHZXQodGhpcy52aWV3c18sIHF1ZXJ5SWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIFN5bmNQb2ludC5wcm90b3R5cGUudmlld0V4aXN0c0ZvclF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdGb3JRdWVyeShxdWVyeSkgIT0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgU3luY1BvaW50LnByb3RvdHlwZS5oYXNDb21wbGV0ZVZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBsZXRlVmlldygpICE9IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/Vmlld31cbiAgICAgKi9cbiAgICBTeW5jUG9pbnQucHJvdG90eXBlLmdldENvbXBsZXRlVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBsZXRlVmlldyA9IGZpbmRWYWx1ZSh0aGlzLnZpZXdzXywgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3XG4gICAgICAgICAgICAgICAgLmdldFF1ZXJ5KClcbiAgICAgICAgICAgICAgICAuZ2V0UXVlcnlQYXJhbXMoKVxuICAgICAgICAgICAgICAgIC5sb2Fkc0FsbERhdGEoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZVZpZXcgfHwgbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBTeW5jUG9pbnQ7XG59KCkpO1xuZXhwb3J0IHsgU3luY1BvaW50IH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvU3luY1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgT3BlcmF0aW9uVHlwZSB9IGZyb20gJy4vT3BlcmF0aW9uJztcbmltcG9ydCB7IFBhdGggfSBmcm9tICcuLi91dGlsL1BhdGgnO1xuLyoqXG4gKiBAcGFyYW0geyFPcGVyYXRpb25Tb3VyY2V9IHNvdXJjZVxuICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICogQHBhcmFtIHshTm9kZX0gc25hcFxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7T3BlcmF0aW9ufVxuICovXG52YXIgT3ZlcndyaXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE92ZXJ3cml0ZShzb3VyY2UsIHBhdGgsIHNuYXApIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuc25hcCA9IHNuYXA7XG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBPcGVyYXRpb25UeXBlLk9WRVJXUklURTtcbiAgICB9XG4gICAgT3ZlcndyaXRlLnByb3RvdHlwZS5vcGVyYXRpb25Gb3JDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT3ZlcndyaXRlKHRoaXMuc291cmNlLCBQYXRoLkVtcHR5LCB0aGlzLnNuYXAuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE92ZXJ3cml0ZSh0aGlzLnNvdXJjZSwgdGhpcy5wYXRoLnBvcEZyb250KCksIHRoaXMuc25hcCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBPdmVyd3JpdGU7XG59KCkpO1xuZXhwb3J0IHsgT3ZlcndyaXRlIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvb3BlcmF0aW9uL092ZXJ3cml0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IGJ1aWxkQ2hpbGRTZXQgfSBmcm9tICcuL2NoaWxkU2V0JztcbmltcG9ydCB7IGNvbnRhaW5zLCBjbG9uZSwgbWFwLCBzYWZlR2V0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgTmFtZWROb2RlIH0gZnJvbSAnLi9Ob2RlJztcbmltcG9ydCB7IFBSSU9SSVRZX0lOREVYIH0gZnJvbSAnLi9pbmRleGVzL1ByaW9yaXR5SW5kZXgnO1xuaW1wb3J0IHsgS0VZX0lOREVYIH0gZnJvbSAnLi9pbmRleGVzL0tleUluZGV4JztcbnZhciBfZGVmYXVsdEluZGV4TWFwO1xudmFyIGZhbGxiYWNrT2JqZWN0ID0ge307XG4vKipcbiAqXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBGYWxsYmFja1R5cGV8U29ydGVkTWFwLjxOYW1lZE5vZGUsIE5vZGU+Pn0gaW5kZXhlc1xuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgSW5kZXg+fSBpbmRleFNldFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBJbmRleE1hcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbmRleE1hcChpbmRleGVzXywgaW5kZXhTZXRfKSB7XG4gICAgICAgIHRoaXMuaW5kZXhlc18gPSBpbmRleGVzXztcbiAgICAgICAgdGhpcy5pbmRleFNldF8gPSBpbmRleFNldF87XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbmRleE1hcCwgXCJEZWZhdWx0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IEluZGV4TWFwIGZvciBub2RlcyB3aXRob3V0IGEgcHJpb3JpdHlcbiAgICAgICAgICogQHR5cGUgeyFJbmRleE1hcH1cbiAgICAgICAgICogQGNvbnN0XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxsYmFja09iamVjdCAmJiBQUklPUklUWV9JTkRFWCwgJ0NoaWxkcmVuTm9kZS50cyBoYXMgbm90IGJlZW4gbG9hZGVkJyk7XG4gICAgICAgICAgICBfZGVmYXVsdEluZGV4TWFwID1cbiAgICAgICAgICAgICAgICBfZGVmYXVsdEluZGV4TWFwIHx8XG4gICAgICAgICAgICAgICAgICAgIG5ldyBJbmRleE1hcCh7ICcucHJpb3JpdHknOiBmYWxsYmFja09iamVjdCB9LCB7ICcucHJpb3JpdHknOiBQUklPUklUWV9JTkRFWCB9KTtcbiAgICAgICAgICAgIHJldHVybiBfZGVmYXVsdEluZGV4TWFwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gaW5kZXhLZXlcbiAgICAgKiBAcmV0dXJuIHs/U29ydGVkTWFwLjxOYW1lZE5vZGUsIE5vZGU+fVxuICAgICAqL1xuICAgIEluZGV4TWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXhLZXkpIHtcbiAgICAgICAgdmFyIHNvcnRlZE1hcCA9IHNhZmVHZXQodGhpcy5pbmRleGVzXywgaW5kZXhLZXkpO1xuICAgICAgICBpZiAoIXNvcnRlZE1hcClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5kZXggZGVmaW5lZCBmb3IgJyArIGluZGV4S2V5KTtcbiAgICAgICAgaWYgKHNvcnRlZE1hcCA9PT0gZmFsbGJhY2tPYmplY3QpIHtcbiAgICAgICAgICAgIC8vIFRoZSBpbmRleCBleGlzdHMsIGJ1dCBpdCBmYWxscyBiYWNrIHRvIGp1c3QgbmFtZSBjb21wYXJpc29uLiBSZXR1cm4gbnVsbCBzbyB0aGF0IHRoZSBjYWxsaW5nIGNvZGUgdXNlcyB0aGVcbiAgICAgICAgICAgIC8vIHJlZ3VsYXIgY2hpbGQgbWFwXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWRNYXA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleERlZmluaXRpb25cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIEluZGV4TWFwLnByb3RvdHlwZS5oYXNJbmRleCA9IGZ1bmN0aW9uIChpbmRleERlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zKHRoaXMuaW5kZXhTZXRfLCBpbmRleERlZmluaXRpb24udG9TdHJpbmcoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhEZWZpbml0aW9uXG4gICAgICogQHBhcmFtIHshU29ydGVkTWFwLjxzdHJpbmcsICFOb2RlPn0gZXhpc3RpbmdDaGlsZHJlblxuICAgICAqIEByZXR1cm4geyFJbmRleE1hcH1cbiAgICAgKi9cbiAgICBJbmRleE1hcC5wcm90b3R5cGUuYWRkSW5kZXggPSBmdW5jdGlvbiAoaW5kZXhEZWZpbml0aW9uLCBleGlzdGluZ0NoaWxkcmVuKSB7XG4gICAgICAgIGFzc2VydChpbmRleERlZmluaXRpb24gIT09IEtFWV9JTkRFWCwgXCJLZXlJbmRleCBhbHdheXMgZXhpc3RzIGFuZCBpc24ndCBtZWFudCB0byBiZSBhZGRlZCB0byB0aGUgSW5kZXhNYXAuXCIpO1xuICAgICAgICB2YXIgY2hpbGRMaXN0ID0gW107XG4gICAgICAgIHZhciBzYXdJbmRleGVkVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGl0ZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldEl0ZXJhdG9yKE5hbWVkTm9kZS5XcmFwKTtcbiAgICAgICAgdmFyIG5leHQgPSBpdGVyLmdldE5leHQoKTtcbiAgICAgICAgd2hpbGUgKG5leHQpIHtcbiAgICAgICAgICAgIHNhd0luZGV4ZWRWYWx1ZSA9XG4gICAgICAgICAgICAgICAgc2F3SW5kZXhlZFZhbHVlIHx8IGluZGV4RGVmaW5pdGlvbi5pc0RlZmluZWRPbihuZXh0Lm5vZGUpO1xuICAgICAgICAgICAgY2hpbGRMaXN0LnB1c2gobmV4dCk7XG4gICAgICAgICAgICBuZXh0ID0gaXRlci5nZXROZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld0luZGV4O1xuICAgICAgICBpZiAoc2F3SW5kZXhlZFZhbHVlKSB7XG4gICAgICAgICAgICBuZXdJbmRleCA9IGJ1aWxkQ2hpbGRTZXQoY2hpbGRMaXN0LCBpbmRleERlZmluaXRpb24uZ2V0Q29tcGFyZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld0luZGV4ID0gZmFsbGJhY2tPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4TmFtZSA9IGluZGV4RGVmaW5pdGlvbi50b1N0cmluZygpO1xuICAgICAgICB2YXIgbmV3SW5kZXhTZXQgPSBjbG9uZSh0aGlzLmluZGV4U2V0Xyk7XG4gICAgICAgIG5ld0luZGV4U2V0W2luZGV4TmFtZV0gPSBpbmRleERlZmluaXRpb247XG4gICAgICAgIHZhciBuZXdJbmRleGVzID0gY2xvbmUodGhpcy5pbmRleGVzXyk7XG4gICAgICAgIG5ld0luZGV4ZXNbaW5kZXhOYW1lXSA9IG5ld0luZGV4O1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4TWFwKG5ld0luZGV4ZXMsIG5ld0luZGV4U2V0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IHRoaXMgbm9kZSBpcyBwcm9wZXJseSB0cmFja2VkIGluIGFueSBpbmRleGVzIHRoYXQgd2UncmUgbWFpbnRhaW5pbmdcbiAgICAgKiBAcGFyYW0geyFOYW1lZE5vZGV9IG5hbWVkTm9kZVxuICAgICAqIEBwYXJhbSB7IVNvcnRlZE1hcC48c3RyaW5nLCAhTm9kZT59IGV4aXN0aW5nQ2hpbGRyZW5cbiAgICAgKiBAcmV0dXJuIHshSW5kZXhNYXB9XG4gICAgICovXG4gICAgSW5kZXhNYXAucHJvdG90eXBlLmFkZFRvSW5kZXhlcyA9IGZ1bmN0aW9uIChuYW1lZE5vZGUsIGV4aXN0aW5nQ2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5ld0luZGV4ZXMgPSBtYXAodGhpcy5pbmRleGVzXywgZnVuY3Rpb24gKGluZGV4ZWRDaGlsZHJlbiwgaW5kZXhOYW1lKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBzYWZlR2V0KF90aGlzLmluZGV4U2V0XywgaW5kZXhOYW1lKTtcbiAgICAgICAgICAgIGFzc2VydChpbmRleCwgJ01pc3NpbmcgaW5kZXggaW1wbGVtZW50YXRpb24gZm9yICcgKyBpbmRleE5hbWUpO1xuICAgICAgICAgICAgaWYgKGluZGV4ZWRDaGlsZHJlbiA9PT0gZmFsbGJhY2tPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgbmVlZCB0byBpbmRleCBldmVyeXRoaW5nXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4LmlzRGVmaW5lZE9uKG5hbWVkTm9kZS5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGJ1aWxkIHRoaXMgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkTGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0SXRlcmF0b3IoTmFtZWROb2RlLldyYXApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQubmFtZSAhPSBuYW1lZE5vZGUubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdC5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdC5wdXNoKG5hbWVkTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWlsZENoaWxkU2V0KGNoaWxkTGlzdCwgaW5kZXguZ2V0Q29tcGFyZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGNoYW5nZSwgdGhpcyByZW1haW5zIGEgZmFsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrT2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ1NuYXAgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuYW1lZE5vZGUubmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkcmVuID0gaW5kZXhlZENoaWxkcmVuO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1NuYXApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSBuZXdDaGlsZHJlbi5yZW1vdmUobmV3IE5hbWVkTm9kZShuYW1lZE5vZGUubmFtZSwgZXhpc3RpbmdTbmFwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZHJlbi5pbnNlcnQobmFtZWROb2RlLCBuYW1lZE5vZGUubm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4TWFwKG5ld0luZGV4ZXMsIHRoaXMuaW5kZXhTZXRfKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBJbmRleE1hcCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiB2YWx1ZSByZW1vdmVkXG4gICAgICogQHBhcmFtIHshTmFtZWROb2RlfSBuYW1lZE5vZGVcbiAgICAgKiBAcGFyYW0geyFTb3J0ZWRNYXAuPHN0cmluZywgIU5vZGU+fSBleGlzdGluZ0NoaWxkcmVuXG4gICAgICogQHJldHVybiB7IUluZGV4TWFwfVxuICAgICAqL1xuICAgIEluZGV4TWFwLnByb3RvdHlwZS5yZW1vdmVGcm9tSW5kZXhlcyA9IGZ1bmN0aW9uIChuYW1lZE5vZGUsIGV4aXN0aW5nQ2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIG5ld0luZGV4ZXMgPSBtYXAodGhpcy5pbmRleGVzXywgZnVuY3Rpb24gKGluZGV4ZWRDaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGluZGV4ZWRDaGlsZHJlbiA9PT0gZmFsbGJhY2tPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmYWxsYmFjay4gSnVzdCByZXR1cm4gaXQsIG5vdGhpbmcgdG8gZG8gaW4gdGhpcyBjYXNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ZWRDaGlsZHJlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ1NuYXAgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuYW1lZE5vZGUubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nU25hcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhlZENoaWxkcmVuLnJlbW92ZShuZXcgTmFtZWROb2RlKG5hbWVkTm9kZS5uYW1lLCBleGlzdGluZ1NuYXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHJlY29yZCBvZiB0aGlzIGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleGVkQ2hpbGRyZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE1hcChuZXdJbmRleGVzLCB0aGlzLmluZGV4U2V0Xyk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5kZXhNYXA7XG59KCkpO1xuZXhwb3J0IHsgSW5kZXhNYXAgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9zbmFwL0luZGV4TWFwLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgTExSQk5vZGUgfSBmcm9tICcuLi91dGlsL1NvcnRlZE1hcCc7XG5pbXBvcnQgeyBTb3J0ZWRNYXAgfSBmcm9tICcuLi91dGlsL1NvcnRlZE1hcCc7XG52YXIgTE9HXzIgPSBNYXRoLmxvZygyKTtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBCYXNlMTJOdW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJhc2UxMk51bShsZW5ndGgpIHtcbiAgICAgICAgdmFyIGxvZ0Jhc2UyID0gZnVuY3Rpb24gKG51bSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KChNYXRoLmxvZyhudW0pIC8gTE9HXzIpLCAxMCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBiaXRNYXNrID0gZnVuY3Rpb24gKGJpdHMpIHsgcmV0dXJuIHBhcnNlSW50KEFycmF5KGJpdHMgKyAxKS5qb2luKCcxJyksIDIpOyB9O1xuICAgICAgICB0aGlzLmNvdW50ID0gbG9nQmFzZTIobGVuZ3RoICsgMSk7XG4gICAgICAgIHRoaXMuY3VycmVudF8gPSB0aGlzLmNvdW50IC0gMTtcbiAgICAgICAgdmFyIG1hc2sgPSBiaXRNYXNrKHRoaXMuY291bnQpO1xuICAgICAgICB0aGlzLmJpdHNfID0gKGxlbmd0aCArIDEpICYgbWFzaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBCYXNlMTJOdW0ucHJvdG90eXBlLm5leHRCaXRJc09uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNCaXR3aXNlT3BlcmF0b3JVc2FnZVxuICAgICAgICB2YXIgcmVzdWx0ID0gISh0aGlzLmJpdHNfICYgKDB4MSA8PCB0aGlzLmN1cnJlbnRfKSk7XG4gICAgICAgIHRoaXMuY3VycmVudF8tLTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlMTJOdW07XG59KCkpO1xuLyoqXG4gKiBUYWtlcyBhIGxpc3Qgb2YgY2hpbGQgbm9kZXMgYW5kIGNvbnN0cnVjdHMgYSBTb3J0ZWRTZXQgdXNpbmcgdGhlIGdpdmVuIGNvbXBhcmlzb25cbiAqIGZ1bmN0aW9uXG4gKlxuICogVXNlcyB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBpbiB0aGUgcGFwZXIgbGlua2VkIGhlcmU6XG4gKiBodHRwOi8vY2l0ZXNlZXJ4LmlzdC5wc3UuZWR1L3ZpZXdkb2Mvc3VtbWFyeT9kb2k9MTAuMS4xLjQ2LjE0NThcbiAqXG4gKiBAdGVtcGxhdGUgSywgVlxuICogQHBhcmFtIHtBcnJheS48IU5hbWVkTm9kZT59IGNoaWxkTGlzdCBVbnNvcnRlZCBsaXN0IG9mIGNoaWxkcmVuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCFOYW1lZE5vZGUsICFOYW1lZE5vZGUpOm51bWJlcn0gY21wIFRoZSBjb21wYXJpc29uIG1ldGhvZCB0byBiZSB1c2VkXG4gKiBAcGFyYW0geyhmdW5jdGlvbihOYW1lZE5vZGUpOkspPX0ga2V5Rm4gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZXh0cmFjdCBLIGZyb20gYSBub2RlIHdyYXBwZXIsIGlmIEsnc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgaXMgbm90IE5hbWVkTm9kZVxuICogQHBhcmFtIHsoZnVuY3Rpb24oSywgSyk6bnVtYmVyKT19IG1hcFNvcnRGbiBBbiBvcHRpb25hbCBvdmVycmlkZSBmb3IgY29tcGFyYXRvciB1c2VkIGJ5IHRoZSBnZW5lcmF0ZWQgc29ydGVkIG1hcFxuICogQHJldHVybiB7U29ydGVkTWFwLjxLLCBWPn1cbiAqL1xuZXhwb3J0IHZhciBidWlsZENoaWxkU2V0ID0gZnVuY3Rpb24gKGNoaWxkTGlzdCwgY21wLCBrZXlGbiwgbWFwU29ydEZuKSB7XG4gICAgY2hpbGRMaXN0LnNvcnQoY21wKTtcbiAgICB2YXIgYnVpbGRCYWxhbmNlZFRyZWUgPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBoaWdoIC0gbG93O1xuICAgICAgICB2YXIgbmFtZWROb2RlO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBpZiAobGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBuYW1lZE5vZGUgPSBjaGlsZExpc3RbbG93XTtcbiAgICAgICAgICAgIGtleSA9IGtleUZuID8ga2V5Rm4obmFtZWROb2RlKSA6IG5hbWVkTm9kZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5LCBuYW1lZE5vZGUubm9kZSwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1pZGRsZSA9IHBhcnNlSW50KChsZW5ndGggLyAyKSwgMTApICsgbG93O1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBidWlsZEJhbGFuY2VkVHJlZShsb3csIG1pZGRsZSk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBidWlsZEJhbGFuY2VkVHJlZShtaWRkbGUgKyAxLCBoaWdoKTtcbiAgICAgICAgICAgIG5hbWVkTm9kZSA9IGNoaWxkTGlzdFttaWRkbGVdO1xuICAgICAgICAgICAga2V5ID0ga2V5Rm4gPyBrZXlGbihuYW1lZE5vZGUpIDogbmFtZWROb2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXksIG5hbWVkTm9kZS5ub2RlLCBMTFJCTm9kZS5CTEFDSywgbGVmdCwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgYnVpbGRGcm9tMTJBcnJheSA9IGZ1bmN0aW9uIChiYXNlMTIpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBudWxsO1xuICAgICAgICB2YXIgcm9vdCA9IG51bGw7XG4gICAgICAgIHZhciBpbmRleCA9IGNoaWxkTGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBidWlsZFBlbm5hbnQgPSBmdW5jdGlvbiAoY2h1bmtTaXplLCBjb2xvcikge1xuICAgICAgICAgICAgdmFyIGxvdyA9IGluZGV4IC0gY2h1bmtTaXplO1xuICAgICAgICAgICAgdmFyIGhpZ2ggPSBpbmRleDtcbiAgICAgICAgICAgIGluZGV4IC09IGNodW5rU2l6ZTtcbiAgICAgICAgICAgIHZhciBjaGlsZFRyZWUgPSBidWlsZEJhbGFuY2VkVHJlZShsb3cgKyAxLCBoaWdoKTtcbiAgICAgICAgICAgIHZhciBuYW1lZE5vZGUgPSBjaGlsZExpc3RbbG93XTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlGbiA/IGtleUZuKG5hbWVkTm9kZSkgOiBuYW1lZE5vZGU7XG4gICAgICAgICAgICBhdHRhY2hQZW5uYW50KG5ldyBMTFJCTm9kZShrZXksIG5hbWVkTm9kZS5ub2RlLCBjb2xvciwgbnVsbCwgY2hpbGRUcmVlKSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhdHRhY2hQZW5uYW50ID0gZnVuY3Rpb24gKHBlbm5hbnQpIHtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5sZWZ0ID0gcGVubmFudDtcbiAgICAgICAgICAgICAgICBub2RlID0gcGVubmFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvb3QgPSBwZW5uYW50O1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwZW5uYW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2UxMi5jb3VudDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaXNPbmUgPSBiYXNlMTIubmV4dEJpdElzT25lKCk7XG4gICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIG5vZGVzIHRha2VuIGluIGVhY2ggc2xpY2UgaXMgMl4oYXJyLmxlbmd0aCAtIChpICsgMSkpXG4gICAgICAgICAgICB2YXIgY2h1bmtTaXplID0gTWF0aC5wb3coMiwgYmFzZTEyLmNvdW50IC0gKGkgKyAxKSk7XG4gICAgICAgICAgICBpZiAoaXNPbmUpIHtcbiAgICAgICAgICAgICAgICBidWlsZFBlbm5hbnQoY2h1bmtTaXplLCBMTFJCTm9kZS5CTEFDSyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50ID09IDJcbiAgICAgICAgICAgICAgICBidWlsZFBlbm5hbnQoY2h1bmtTaXplLCBMTFJCTm9kZS5CTEFDSyk7XG4gICAgICAgICAgICAgICAgYnVpbGRQZW5uYW50KGNodW5rU2l6ZSwgTExSQk5vZGUuUkVEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9O1xuICAgIHZhciBiYXNlMTIgPSBuZXcgQmFzZTEyTnVtKGNoaWxkTGlzdC5sZW5ndGgpO1xuICAgIHZhciByb290ID0gYnVpbGRGcm9tMTJBcnJheShiYXNlMTIpO1xuICAgIHJldHVybiBuZXcgU29ydGVkTWFwKG1hcFNvcnRGbiB8fCBjbXAsIHJvb3QpO1xufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9zbmFwL2NoaWxkU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgbmFtZUNvbXBhcmUgfSBmcm9tICcuLi91dGlsL3V0aWwnO1xuZXhwb3J0IGZ1bmN0aW9uIE5BTUVfT05MWV9DT01QQVJBVE9SKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIG5hbWVDb21wYXJlKGxlZnQubmFtZSwgcmlnaHQubmFtZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gTkFNRV9DT01QQVJBVE9SKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIG5hbWVDb21wYXJlKGxlZnQsIHJpZ2h0KTtcbn1cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9zbmFwL2NvbXBhcmF0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBuYW1lQ29tcGFyZSwgTUFYX05BTUUgfSBmcm9tICcuLi8uLi91dGlsL3V0aWwnO1xuaW1wb3J0IHsgSW5kZXggfSBmcm9tICcuL0luZGV4JztcbmltcG9ydCB7IENoaWxkcmVuTm9kZSwgTUFYX05PREUgfSBmcm9tICcuLi9DaGlsZHJlbk5vZGUnO1xuaW1wb3J0IHsgTmFtZWROb2RlIH0gZnJvbSAnLi4vTm9kZSc7XG5pbXBvcnQgeyBub2RlRnJvbUpTT04gfSBmcm9tICcuLi9ub2RlRnJvbUpTT04nO1xuLyoqXG4gKiBAcGFyYW0geyFQYXRofSBpbmRleFBhdGhcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0luZGV4fVxuICovXG52YXIgUGF0aEluZGV4ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYXRoSW5kZXgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGF0aEluZGV4KGluZGV4UGF0aF8pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW5kZXhQYXRoXyA9IGluZGV4UGF0aF87XG4gICAgICAgIGFzc2VydCghaW5kZXhQYXRoXy5pc0VtcHR5KCkgJiYgaW5kZXhQYXRoXy5nZXRGcm9udCgpICE9PSAnLnByaW9yaXR5JywgXCJDYW4ndCBjcmVhdGUgUGF0aEluZGV4IHdpdGggZW1wdHkgcGF0aCBvciAucHJpb3JpdHkga2V5XCIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IHNuYXBcbiAgICAgKiBAcmV0dXJuIHshTm9kZX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgUGF0aEluZGV4LnByb3RvdHlwZS5leHRyYWN0Q2hpbGQgPSBmdW5jdGlvbiAoc25hcCkge1xuICAgICAgICByZXR1cm4gc25hcC5nZXRDaGlsZCh0aGlzLmluZGV4UGF0aF8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQYXRoSW5kZXgucHJvdG90eXBlLmlzRGVmaW5lZE9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICFub2RlLmdldENoaWxkKHRoaXMuaW5kZXhQYXRoXykuaXNFbXB0eSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQYXRoSW5kZXgucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgYUNoaWxkID0gdGhpcy5leHRyYWN0Q2hpbGQoYS5ub2RlKTtcbiAgICAgICAgdmFyIGJDaGlsZCA9IHRoaXMuZXh0cmFjdENoaWxkKGIubm9kZSk7XG4gICAgICAgIHZhciBpbmRleENtcCA9IGFDaGlsZC5jb21wYXJlVG8oYkNoaWxkKTtcbiAgICAgICAgaWYgKGluZGV4Q21wID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZUNvbXBhcmUoYS5uYW1lLCBiLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4Q21wO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFBhdGhJbmRleC5wcm90b3R5cGUubWFrZVBvc3QgPSBmdW5jdGlvbiAoaW5kZXhWYWx1ZSwgbmFtZSkge1xuICAgICAgICB2YXIgdmFsdWVOb2RlID0gbm9kZUZyb21KU09OKGluZGV4VmFsdWUpO1xuICAgICAgICB2YXIgbm9kZSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLnVwZGF0ZUNoaWxkKHRoaXMuaW5kZXhQYXRoXywgdmFsdWVOb2RlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobmFtZSwgbm9kZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFBhdGhJbmRleC5wcm90b3R5cGUubWF4UG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERS51cGRhdGVDaGlsZCh0aGlzLmluZGV4UGF0aF8sIE1BWF9OT0RFKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUoTUFYX05BTUUsIG5vZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQYXRoSW5kZXgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFBhdGhfLnNsaWNlKCkuam9pbignLycpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhdGhJbmRleDtcbn0oSW5kZXgpKTtcbmV4cG9ydCB7IFBhdGhJbmRleCB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3NuYXAvaW5kZXhlcy9QYXRoSW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCB7IEluZGV4IH0gZnJvbSAnLi9JbmRleCc7XG5pbXBvcnQgeyBOYW1lZE5vZGUgfSBmcm9tICcuLi9Ob2RlJztcbmltcG9ydCB7IG5hbWVDb21wYXJlIH0gZnJvbSAnLi4vLi4vdXRpbC91dGlsJztcbmltcG9ydCB7IG5vZGVGcm9tSlNPTiB9IGZyb20gJy4uL25vZGVGcm9tSlNPTic7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0luZGV4fVxuICogQHByaXZhdGVcbiAqL1xudmFyIFZhbHVlSW5kZXggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZhbHVlSW5kZXgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmFsdWVJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFZhbHVlSW5kZXgucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgaW5kZXhDbXAgPSBhLm5vZGUuY29tcGFyZVRvKGIubm9kZSk7XG4gICAgICAgIGlmIChpbmRleENtcCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVDb21wYXJlKGEubmFtZSwgYi5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleENtcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBWYWx1ZUluZGV4LnByb3RvdHlwZS5pc0RlZmluZWRPbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBWYWx1ZUluZGV4LnByb3RvdHlwZS5pbmRleGVkVmFsdWVDaGFuZ2VkID0gZnVuY3Rpb24gKG9sZE5vZGUsIG5ld05vZGUpIHtcbiAgICAgICAgcmV0dXJuICFvbGROb2RlLmVxdWFscyhuZXdOb2RlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgVmFsdWVJbmRleC5wcm90b3R5cGUubWluUG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NSU47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFZhbHVlSW5kZXgucHJvdG90eXBlLm1heFBvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBOYW1lZE5vZGUuTUFYO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBpbmRleFZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHshTmFtZWROb2RlfVxuICAgICAqL1xuICAgIFZhbHVlSW5kZXgucHJvdG90eXBlLm1ha2VQb3N0ID0gZnVuY3Rpb24gKGluZGV4VmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdmFyIHZhbHVlTm9kZSA9IG5vZGVGcm9tSlNPTihpbmRleFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobmFtZSwgdmFsdWVOb2RlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgaW5jbHVzaW9uIGluIGEgcXVlcnkgc3BlY1xuICAgICAqL1xuICAgIFZhbHVlSW5kZXgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJy52YWx1ZSc7XG4gICAgfTtcbiAgICByZXR1cm4gVmFsdWVJbmRleDtcbn0oSW5kZXgpKTtcbmV4cG9ydCB7IFZhbHVlSW5kZXggfTtcbmV4cG9ydCB2YXIgVkFMVUVfSU5ERVggPSBuZXcgVmFsdWVJbmRleCgpO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3NuYXAvaW5kZXhlcy9WYWx1ZUluZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgZG91YmxlVG9JRUVFNzU0U3RyaW5nIH0gZnJvbSAnLi4vdXRpbC91dGlsJztcbmltcG9ydCB7IGNvbnRhaW5zIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xudmFyIE1BWF9OT0RFO1xuZXhwb3J0IGZ1bmN0aW9uIHNldE1heE5vZGUodmFsKSB7XG4gICAgTUFYX05PREUgPSB2YWw7XG59XG4vKipcbiAqIEBwYXJhbSB7KCFzdHJpbmd8IW51bWJlcil9IHByaW9yaXR5XG4gKiBAcmV0dXJuIHshc3RyaW5nfVxuICovXG5leHBvcnQgdmFyIHByaW9yaXR5SGFzaFRleHQgPSBmdW5jdGlvbiAocHJpb3JpdHkpIHtcbiAgICBpZiAodHlwZW9mIHByaW9yaXR5ID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuICdudW1iZXI6JyArIGRvdWJsZVRvSUVFRTc1NFN0cmluZyhwcmlvcml0eSk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gJ3N0cmluZzonICsgcHJpb3JpdHk7XG59O1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCBhIHByaW9yaXR5IHNuYXBzaG90IE5vZGUgaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHshTm9kZX0gcHJpb3JpdHlOb2RlXG4gKi9cbmV4cG9ydCB2YXIgdmFsaWRhdGVQcmlvcml0eU5vZGUgPSBmdW5jdGlvbiAocHJpb3JpdHlOb2RlKSB7XG4gICAgaWYgKHByaW9yaXR5Tm9kZS5pc0xlYWZOb2RlKCkpIHtcbiAgICAgICAgdmFyIHZhbCA9IHByaW9yaXR5Tm9kZS52YWwoKTtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIGNvbnRhaW5zKHZhbCwgJy5zdicpKSwgJ1ByaW9yaXR5IG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtYmVyLicpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KHByaW9yaXR5Tm9kZSA9PT0gTUFYX05PREUgfHwgcHJpb3JpdHlOb2RlLmlzRW1wdHkoKSwgJ3ByaW9yaXR5IG9mIHVuZXhwZWN0ZWQgdHlwZS4nKTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgY2FsbCBnZXRQcmlvcml0eSgpIG9uIE1BWF9OT0RFIHRvIGF2b2lkIGhpdHRpbmcgYXNzZXJ0aW9uLlxuICAgIGFzc2VydChwcmlvcml0eU5vZGUgPT09IE1BWF9OT0RFIHx8IHByaW9yaXR5Tm9kZS5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKSwgXCJQcmlvcml0eSBub2RlcyBjYW4ndCBoYXZlIGEgcHJpb3JpdHkgb2YgdGhlaXIgb3duLlwiKTtcbn07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvc25hcC9zbmFwLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgY2xvbmUsIGZvckVhY2ggfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG4vKipcbiAqIFJldHVybnMgdGhlIGRlbHRhIGZyb20gdGhlIHByZXZpb3VzIGNhbGwgdG8gZ2V0IHN0YXRzLlxuICpcbiAqIEBwYXJhbSBjb2xsZWN0aW9uXyBUaGUgY29sbGVjdGlvbiB0byBcImxpc3RlblwiIHRvLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTdGF0c0xpc3RlbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRzTGlzdGVuZXIoY29sbGVjdGlvbl8pIHtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uXyA9IGNvbGxlY3Rpb25fO1xuICAgICAgICB0aGlzLmxhc3RfID0gbnVsbDtcbiAgICB9XG4gICAgU3RhdHNMaXN0ZW5lci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV3U3RhdHMgPSB0aGlzLmNvbGxlY3Rpb25fLmdldCgpO1xuICAgICAgICB2YXIgZGVsdGEgPSBjbG9uZShuZXdTdGF0cyk7XG4gICAgICAgIGlmICh0aGlzLmxhc3RfKSB7XG4gICAgICAgICAgICBmb3JFYWNoKHRoaXMubGFzdF8sIGZ1bmN0aW9uIChzdGF0LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGRlbHRhW3N0YXRdID0gZGVsdGFbc3RhdF0gLSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdF8gPSBuZXdTdGF0cztcbiAgICAgICAgcmV0dXJuIGRlbHRhO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRzTGlzdGVuZXI7XG59KCkpO1xuZXhwb3J0IHsgU3RhdHNMaXN0ZW5lciB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3N0YXRzL1N0YXRzTGlzdGVuZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBpc0VtcHR5LCBnZXRDb3VudCwgZm9yRWFjaCwgY29udGFpbnMgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG4vKipcbiAqIEltcGxlbWVudHMgYSBzZXQgd2l0aCBhIGNvdW50IG9mIGVsZW1lbnRzLlxuICpcbiAqIEB0ZW1wbGF0ZSBLLCBWXG4gKi9cbnZhciBDb3VudGVkU2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvdW50ZWRTZXQoKSB7XG4gICAgICAgIHRoaXMuc2V0ID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUt9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge1Z9IHZhbFxuICAgICAqL1xuICAgIENvdW50ZWRTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpdGVtLCB2YWwpIHtcbiAgICAgICAgdGhpcy5zZXRbaXRlbV0gPSB2YWwgIT09IG51bGwgPyB2YWwgOiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshS30ga2V5XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBDb3VudGVkU2V0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zKHRoaXMuc2V0LCBrZXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshS30gaXRlbVxuICAgICAqIEByZXR1cm4ge1Z9XG4gICAgICovXG4gICAgQ291bnRlZFNldC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbnMoaXRlbSkgPyB0aGlzLnNldFtpdGVtXSA6IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUt9IGl0ZW1cbiAgICAgKi9cbiAgICBDb3VudGVkU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBkZWxldGUgdGhpcy5zZXRbaXRlbV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGV2ZXJ5dGhpbmcgaW4gdGhlIHNldFxuICAgICAqL1xuICAgIENvdW50ZWRTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldCA9IHt9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHNldFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgQ291bnRlZFNldC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlzRW1wdHkodGhpcy5zZXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBzZXRcbiAgICAgKi9cbiAgICBDb3VudGVkU2V0LnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldENvdW50KHRoaXMuc2V0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJ1biBhIGZ1bmN0aW9uIG9uIGVhY2ggayx2IHBhaXIgaW4gdGhlIHNldFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oSywgVil9IGZuXG4gICAgICovXG4gICAgQ291bnRlZFNldC5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBmb3JFYWNoKHRoaXMuc2V0LCBmdW5jdGlvbiAoaywgdikgeyByZXR1cm4gZm4oaywgdik7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTW9zdGx5IGZvciBkZWJ1Z2dpbmdcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48Sz59IFRoZSBrZXlzIHByZXNlbnQgaW4gdGhpcyBDb3VudGVkU2V0XG4gICAgICovXG4gICAgQ291bnRlZFNldC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yRWFjaCh0aGlzLnNldCwgZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGtleXMucHVzaChrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG4gICAgcmV0dXJuIENvdW50ZWRTZXQ7XG59KCkpO1xuZXhwb3J0IHsgQ291bnRlZFNldCB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3V0aWwvQ291bnRlZFNldC5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbi8qKlxuICogQmFzZSBjbGFzcyB0byBiZSB1c2VkIGlmIHlvdSB3YW50IHRvIGVtaXQgZXZlbnRzLiBDYWxsIHRoZSBjb25zdHJ1Y3RvciB3aXRoXG4gKiB0aGUgc2V0IG9mIGFsbG93ZWQgZXZlbnQgbmFtZXMuXG4gKi9cbnZhciBFdmVudEVtaXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz59IGFsbG93ZWRFdmVudHNfXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKGFsbG93ZWRFdmVudHNfKSB7XG4gICAgICAgIHRoaXMuYWxsb3dlZEV2ZW50c18gPSBhbGxvd2VkRXZlbnRzXztcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNfID0ge307XG4gICAgICAgIGFzc2VydChBcnJheS5pc0FycmF5KGFsbG93ZWRFdmVudHNfKSAmJiBhbGxvd2VkRXZlbnRzXy5sZW5ndGggPiAwLCAnUmVxdWlyZXMgYSBub24tZW1wdHkgYXJyYXknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gYmUgY2FsbGVkIGJ5IGRlcml2ZWQgY2xhc3NlcyB0byB0cmlnZ2VyIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGV2ZW50VHlwZVxuICAgICAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3NcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG4gICAgICAgIHZhciB2YXJfYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyX2FyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0pKSB7XG4gICAgICAgICAgICAvLyBDbG9uZSB0aGUgbGlzdCwgc2luY2UgY2FsbGJhY2tzIGNvdWxkIGFkZC9yZW1vdmUgbGlzdGVuZXJzLlxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5jYWxsYmFjay5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgdmFyX2FyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUV2ZW50VHlwZV8oZXZlbnRUeXBlKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0gPSB0aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXSB8fCBbXTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0ucHVzaCh7IGNhbGxiYWNrOiBjYWxsYmFjaywgY29udGV4dDogY29udGV4dCB9KTtcbiAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHRoaXMuZ2V0SW5pdGlhbEV2ZW50KGV2ZW50VHlwZSk7XG4gICAgICAgIGlmIChldmVudERhdGEpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KGNvbnRleHQsIGV2ZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUV2ZW50VHlwZV8oZXZlbnRUeXBlKTtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdIHx8IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgICAoIWNvbnRleHQgfHwgY29udGV4dCA9PT0gbGlzdGVuZXJzW2ldLmNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUudmFsaWRhdGVFdmVudFR5cGVfID0gZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgICBhc3NlcnQodGhpcy5hbGxvd2VkRXZlbnRzXy5maW5kKGZ1bmN0aW9uIChldCkge1xuICAgICAgICAgICAgcmV0dXJuIGV0ID09PSBldmVudFR5cGU7XG4gICAgICAgIH0pLCAnVW5rbm93biBldmVudDogJyArIGV2ZW50VHlwZSk7XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xufSgpKTtcbmV4cG9ydCB7IEV2ZW50RW1pdHRlciB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3V0aWwvRXZlbnRFbWl0dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgeyBTcGFyc2VTbmFwc2hvdFRyZWUgfSBmcm9tICcuLi9TcGFyc2VTbmFwc2hvdFRyZWUnO1xuaW1wb3J0IHsgTGVhZk5vZGUgfSBmcm9tICcuLi9zbmFwL0xlYWZOb2RlJztcbmltcG9ydCB7IG5vZGVGcm9tSlNPTiB9IGZyb20gJy4uL3NuYXAvbm9kZUZyb21KU09OJztcbmltcG9ydCB7IFBSSU9SSVRZX0lOREVYIH0gZnJvbSAnLi4vc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXgnO1xuLyoqXG4gKiBHZW5lcmF0ZSBwbGFjZWhvbGRlcnMgZm9yIGRlZmVycmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7P09iamVjdH0gdmFsdWVzXG4gKiBAcmV0dXJuIHshT2JqZWN0fVxuICovXG5leHBvcnQgdmFyIGdlbmVyYXRlV2l0aFZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwge307XG4gICAgdmFsdWVzWyd0aW1lc3RhbXAnXSA9IHZhbHVlc1sndGltZXN0YW1wJ10gfHwgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgcmV0dXJuIHZhbHVlcztcbn07XG4vKipcbiAqIFZhbHVlIHRvIHVzZSB3aGVuIGZpcmluZyBsb2NhbCBldmVudHMuIFdoZW4gd3JpdGluZyBzZXJ2ZXIgdmFsdWVzLCBmaXJlXG4gKiBsb2NhbCBldmVudHMgd2l0aCBhbiBhcHByb3hpbWF0ZSB2YWx1ZSwgb3RoZXJ3aXNlIHJldHVybiB2YWx1ZSBhcy1pcy5cbiAqIEBwYXJhbSB7KE9iamVjdHxzdHJpbmd8bnVtYmVyfGJvb2xlYW4pfSB2YWx1ZVxuICogQHBhcmFtIHshT2JqZWN0fSBzZXJ2ZXJWYWx1ZXNcbiAqIEByZXR1cm4geyEoc3RyaW5nfG51bWJlcnxib29sZWFuKX1cbiAqL1xuZXhwb3J0IHZhciByZXNvbHZlRGVmZXJyZWRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2VydmVyVmFsdWVzKSB7XG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydCgnLnN2JyBpbiB2YWx1ZSwgJ1VuZXhwZWN0ZWQgbGVhZiBub2RlIG9yIHByaW9yaXR5IGNvbnRlbnRzJyk7XG4gICAgICAgIHJldHVybiBzZXJ2ZXJWYWx1ZXNbdmFsdWVbJy5zdiddXTtcbiAgICB9XG59O1xuLyoqXG4gKiBSZWN1cnNpdmVseSByZXBsYWNlIGFsbCBkZWZlcnJlZCB2YWx1ZXMgYW5kIHByaW9yaXRpZXMgaW4gdGhlIHRyZWUgd2l0aCB0aGVcbiAqIHNwZWNpZmllZCBnZW5lcmF0ZWQgcmVwbGFjZW1lbnQgdmFsdWVzLlxuICogQHBhcmFtIHshU3BhcnNlU25hcHNob3RUcmVlfSB0cmVlXG4gKiBAcGFyYW0geyFPYmplY3R9IHNlcnZlclZhbHVlc1xuICogQHJldHVybiB7IVNwYXJzZVNuYXBzaG90VHJlZX1cbiAqL1xuZXhwb3J0IHZhciByZXNvbHZlRGVmZXJyZWRWYWx1ZVRyZWUgPSBmdW5jdGlvbiAodHJlZSwgc2VydmVyVmFsdWVzKSB7XG4gICAgdmFyIHJlc29sdmVkVHJlZSA9IG5ldyBTcGFyc2VTbmFwc2hvdFRyZWUoKTtcbiAgICB0cmVlLmZvckVhY2hUcmVlKG5ldyBQYXRoKCcnKSwgZnVuY3Rpb24gKHBhdGgsIG5vZGUpIHtcbiAgICAgICAgcmVzb2x2ZWRUcmVlLnJlbWVtYmVyKHBhdGgsIHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3Qobm9kZSwgc2VydmVyVmFsdWVzKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc29sdmVkVHJlZTtcbn07XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHJlcGxhY2UgYWxsIGRlZmVycmVkIHZhbHVlcyBhbmQgcHJpb3JpdGllcyBpbiB0aGUgbm9kZSB3aXRoIHRoZVxuICogc3BlY2lmaWVkIGdlbmVyYXRlZCByZXBsYWNlbWVudCB2YWx1ZXMuICBJZiB0aGVyZSBhcmUgbm8gc2VydmVyIHZhbHVlcyBpbiB0aGUgbm9kZSxcbiAqIGl0J2xsIGJlIHJldHVybmVkIGFzLWlzLlxuICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICogQHBhcmFtIHshT2JqZWN0fSBzZXJ2ZXJWYWx1ZXNcbiAqIEByZXR1cm4geyFOb2RlfVxuICovXG5leHBvcnQgdmFyIHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QgPSBmdW5jdGlvbiAobm9kZSwgc2VydmVyVmFsdWVzKSB7XG4gICAgdmFyIHJhd1ByaSA9IG5vZGUuZ2V0UHJpb3JpdHkoKS52YWwoKTtcbiAgICB2YXIgcHJpb3JpdHkgPSByZXNvbHZlRGVmZXJyZWRWYWx1ZShyYXdQcmksIHNlcnZlclZhbHVlcyk7XG4gICAgdmFyIG5ld05vZGU7XG4gICAgaWYgKG5vZGUuaXNMZWFmTm9kZSgpKSB7XG4gICAgICAgIHZhciBsZWFmTm9kZSA9IG5vZGU7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc29sdmVEZWZlcnJlZFZhbHVlKGxlYWZOb2RlLmdldFZhbHVlKCksIHNlcnZlclZhbHVlcyk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbGVhZk5vZGUuZ2V0VmFsdWUoKSB8fFxuICAgICAgICAgICAgcHJpb3JpdHkgIT09IGxlYWZOb2RlLmdldFByaW9yaXR5KCkudmFsKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGVhZk5vZGUodmFsdWUsIG5vZGVGcm9tSlNPTihwcmlvcml0eSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjaGlsZHJlbk5vZGUgPSBub2RlO1xuICAgICAgICBuZXdOb2RlID0gY2hpbGRyZW5Ob2RlO1xuICAgICAgICBpZiAocHJpb3JpdHkgIT09IGNoaWxkcmVuTm9kZS5nZXRQcmlvcml0eSgpLnZhbCgpKSB7XG4gICAgICAgICAgICBuZXdOb2RlID0gbmV3Tm9kZS51cGRhdGVQcmlvcml0eShuZXcgTGVhZk5vZGUocHJpb3JpdHkpKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbk5vZGUuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCBmdW5jdGlvbiAoY2hpbGROYW1lLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIHZhciBuZXdDaGlsZE5vZGUgPSByZXNvbHZlRGVmZXJyZWRWYWx1ZVNuYXBzaG90KGNoaWxkTm9kZSwgc2VydmVyVmFsdWVzKTtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZE5vZGUgIT09IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgIG5ld05vZGUgPSBuZXdOb2RlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIH1cbn07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvdXRpbC9TZXJ2ZXJWYWx1ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi4vUGF0aCc7XG5pbXBvcnQgeyBSZXBvSW5mbyB9IGZyb20gJy4uLy4uL1JlcG9JbmZvJztcbmltcG9ydCB7IHdhcm5JZlBhZ2VJc1NlY3VyZSwgZmF0YWwgfSBmcm9tICcuLi91dGlsJztcbi8qKlxuICogQHBhcmFtIHshc3RyaW5nfSBwYXRoU3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aFN0cmluZykge1xuICAgIHZhciBwYXRoU3RyaW5nRGVjb2RlZCA9ICcnO1xuICAgIHZhciBwaWVjZXMgPSBwYXRoU3RyaW5nLnNwbGl0KCcvJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBpZWNlc1tpXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgcGllY2UgPSBwaWVjZXNbaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBpZWNlID0gZGVjb2RlVVJJQ29tcG9uZW50KHBpZWNlLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIHBhdGhTdHJpbmdEZWNvZGVkICs9ICcvJyArIHBpZWNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRoU3RyaW5nRGVjb2RlZDtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gZGF0YVVSTFxuICogQHJldHVybiB7e3JlcG9JbmZvOiAhUmVwb0luZm8sIHBhdGg6ICFQYXRofX1cbiAqL1xuZXhwb3J0IHZhciBwYXJzZVJlcG9JbmZvID0gZnVuY3Rpb24gKGRhdGFVUkwpIHtcbiAgICB2YXIgcGFyc2VkVXJsID0gcGFyc2VVUkwoZGF0YVVSTCksIG5hbWVzcGFjZSA9IHBhcnNlZFVybC5zdWJkb21haW47XG4gICAgaWYgKHBhcnNlZFVybC5kb21haW4gPT09ICdmaXJlYmFzZScpIHtcbiAgICAgICAgZmF0YWwocGFyc2VkVXJsLmhvc3QgK1xuICAgICAgICAgICAgJyBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiAnICtcbiAgICAgICAgICAgICdQbGVhc2UgdXNlIDxZT1VSIEZJUkVCQVNFPi5maXJlYmFzZWlvLmNvbSBpbnN0ZWFkJyk7XG4gICAgfVxuICAgIC8vIENhdGNoIGNvbW1vbiBlcnJvciBvZiB1bmluaXRpYWxpemVkIG5hbWVzcGFjZSB2YWx1ZS5cbiAgICBpZiAoIW5hbWVzcGFjZSB8fCBuYW1lc3BhY2UgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZmF0YWwoJ0Nhbm5vdCBwYXJzZSBGaXJlYmFzZSB1cmwuIFBsZWFzZSB1c2UgaHR0cHM6Ly88WU9VUiBGSVJFQkFTRT4uZmlyZWJhc2Vpby5jb20nKTtcbiAgICB9XG4gICAgaWYgKCFwYXJzZWRVcmwuc2VjdXJlKSB7XG4gICAgICAgIHdhcm5JZlBhZ2VJc1NlY3VyZSgpO1xuICAgIH1cbiAgICB2YXIgd2ViU29ja2V0T25seSA9IHBhcnNlZFVybC5zY2hlbWUgPT09ICd3cycgfHwgcGFyc2VkVXJsLnNjaGVtZSA9PT0gJ3dzcyc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVwb0luZm86IG5ldyBSZXBvSW5mbyhwYXJzZWRVcmwuaG9zdCwgcGFyc2VkVXJsLnNlY3VyZSwgbmFtZXNwYWNlLCB3ZWJTb2NrZXRPbmx5KSxcbiAgICAgICAgcGF0aDogbmV3IFBhdGgocGFyc2VkVXJsLnBhdGhTdHJpbmcpXG4gICAgfTtcbn07XG4vKipcbiAqXG4gKiBAcGFyYW0geyFzdHJpbmd9IGRhdGFVUkxcbiAqIEByZXR1cm4ge3tob3N0OiBzdHJpbmcsIHBvcnQ6IG51bWJlciwgZG9tYWluOiBzdHJpbmcsIHN1YmRvbWFpbjogc3RyaW5nLCBzZWN1cmU6IGJvb2xlYW4sIHNjaGVtZTogc3RyaW5nLCBwYXRoU3RyaW5nOiBzdHJpbmd9fVxuICovXG5leHBvcnQgdmFyIHBhcnNlVVJMID0gZnVuY3Rpb24gKGRhdGFVUkwpIHtcbiAgICAvLyBEZWZhdWx0IHRvIGVtcHR5IHN0cmluZ3MgaW4gdGhlIGV2ZW50IG9mIGEgbWFsZm9ybWVkIHN0cmluZy5cbiAgICB2YXIgaG9zdCA9ICcnLCBkb21haW4gPSAnJywgc3ViZG9tYWluID0gJycsIHBhdGhTdHJpbmcgPSAnJztcbiAgICAvLyBBbHdheXMgZGVmYXVsdCB0byBTU0wsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICAgIHZhciBzZWN1cmUgPSB0cnVlLCBzY2hlbWUgPSAnaHR0cHMnLCBwb3J0ID0gNDQzO1xuICAgIC8vIERvbid0IGRvIGFueSB2YWxpZGF0aW9uIGhlcmUuIFRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIHZhbGlkYXRpbmcgdGhlIHJlc3VsdCBvZiBwYXJzaW5nLlxuICAgIGlmICh0eXBlb2YgZGF0YVVSTCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gUGFyc2Ugc2NoZW1lLlxuICAgICAgICB2YXIgY29sb25JbmQgPSBkYXRhVVJMLmluZGV4T2YoJy8vJyk7XG4gICAgICAgIGlmIChjb2xvbkluZCA+PSAwKSB7XG4gICAgICAgICAgICBzY2hlbWUgPSBkYXRhVVJMLnN1YnN0cmluZygwLCBjb2xvbkluZCAtIDEpO1xuICAgICAgICAgICAgZGF0YVVSTCA9IGRhdGFVUkwuc3Vic3RyaW5nKGNvbG9uSW5kICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2UgaG9zdCBhbmQgcGF0aC5cbiAgICAgICAgdmFyIHNsYXNoSW5kID0gZGF0YVVSTC5pbmRleE9mKCcvJyk7XG4gICAgICAgIGlmIChzbGFzaEluZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHNsYXNoSW5kID0gZGF0YVVSTC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaG9zdCA9IGRhdGFVUkwuc3Vic3RyaW5nKDAsIHNsYXNoSW5kKTtcbiAgICAgICAgcGF0aFN0cmluZyA9IGRlY29kZVBhdGgoZGF0YVVSTC5zdWJzdHJpbmcoc2xhc2hJbmQpKTtcbiAgICAgICAgdmFyIHBhcnRzID0gaG9zdC5zcGxpdCgnLicpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgbmFtZXNwYWNlcyB0byBsb3dlcmNhc2UgdG8gc2hhcmUgc3RvcmFnZSAvIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICBkb21haW4gPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgIHN1YmRvbWFpbiA9IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBkb21haW4gPSBwYXJ0c1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydCwgdXNlIHNjaGVtZSBmb3IgZGV0ZXJtaW5pbmcgaWYgaXQncyBzZWN1cmUuXG4gICAgICAgIGNvbG9uSW5kID0gaG9zdC5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGlmIChjb2xvbkluZCA+PSAwKSB7XG4gICAgICAgICAgICBzZWN1cmUgPSBzY2hlbWUgPT09ICdodHRwcycgfHwgc2NoZW1lID09PSAnd3NzJztcbiAgICAgICAgICAgIHBvcnQgPSBwYXJzZUludChob3N0LnN1YnN0cmluZyhjb2xvbkluZCArIDEpLCAxMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaG9zdDogaG9zdCxcbiAgICAgICAgcG9ydDogcG9ydCxcbiAgICAgICAgZG9tYWluOiBkb21haW4sXG4gICAgICAgIHN1YmRvbWFpbjogc3ViZG9tYWluLFxuICAgICAgICBzZWN1cmU6IHNlY3VyZSxcbiAgICAgICAgc2NoZW1lOiBzY2hlbWUsXG4gICAgICAgIHBhdGhTdHJpbmc6IHBhdGhTdHJpbmdcbiAgICB9O1xufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS91dGlsL2xpYnMvcGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgQ2hpbGRyZW5Ob2RlIH0gZnJvbSAnLi4vc25hcC9DaGlsZHJlbk5vZGUnO1xuaW1wb3J0IHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi9DYWNoZU5vZGUnO1xuLyoqXG4gKiBTdG9yZXMgdGhlIGRhdGEgd2UgaGF2ZSBjYWNoZWQgZm9yIGEgdmlldy5cbiAqXG4gKiBzZXJ2ZXJTbmFwIGlzIHRoZSBjYWNoZWQgc2VydmVyIGRhdGEsIGV2ZW50U25hcCBpcyB0aGUgY2FjaGVkIGV2ZW50IGRhdGEgKHNlcnZlciBkYXRhIHBsdXMgYW55IGxvY2FsIHdyaXRlcykuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBWaWV3Q2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFDYWNoZU5vZGV9IGV2ZW50Q2FjaGVfXG4gICAgICogQHBhcmFtIHshQ2FjaGVOb2RlfSBzZXJ2ZXJDYWNoZV9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWaWV3Q2FjaGUoZXZlbnRDYWNoZV8sIHNlcnZlckNhY2hlXykge1xuICAgICAgICB0aGlzLmV2ZW50Q2FjaGVfID0gZXZlbnRDYWNoZV87XG4gICAgICAgIHRoaXMuc2VydmVyQ2FjaGVfID0gc2VydmVyQ2FjaGVfO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBldmVudFNuYXBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXBsZXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmaWx0ZXJlZFxuICAgICAqIEByZXR1cm4geyFWaWV3Q2FjaGV9XG4gICAgICovXG4gICAgVmlld0NhY2hlLnByb3RvdHlwZS51cGRhdGVFdmVudFNuYXAgPSBmdW5jdGlvbiAoZXZlbnRTbmFwLCBjb21wbGV0ZSwgZmlsdGVyZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3Q2FjaGUobmV3IENhY2hlTm9kZShldmVudFNuYXAsIGNvbXBsZXRlLCBmaWx0ZXJlZCksIHRoaXMuc2VydmVyQ2FjaGVfKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IHNlcnZlclNuYXBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXBsZXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmaWx0ZXJlZFxuICAgICAqIEByZXR1cm4geyFWaWV3Q2FjaGV9XG4gICAgICovXG4gICAgVmlld0NhY2hlLnByb3RvdHlwZS51cGRhdGVTZXJ2ZXJTbmFwID0gZnVuY3Rpb24gKHNlcnZlclNuYXAsIGNvbXBsZXRlLCBmaWx0ZXJlZCkge1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdDYWNoZSh0aGlzLmV2ZW50Q2FjaGVfLCBuZXcgQ2FjaGVOb2RlKHNlcnZlclNuYXAsIGNvbXBsZXRlLCBmaWx0ZXJlZCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IUNhY2hlTm9kZX1cbiAgICAgKi9cbiAgICBWaWV3Q2FjaGUucHJvdG90eXBlLmdldEV2ZW50Q2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50Q2FjaGVfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P05vZGV9XG4gICAgICovXG4gICAgVmlld0NhY2hlLnByb3RvdHlwZS5nZXRDb21wbGV0ZUV2ZW50U25hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRDYWNoZV8uaXNGdWxseUluaXRpYWxpemVkKClcbiAgICAgICAgICAgID8gdGhpcy5ldmVudENhY2hlXy5nZXROb2RlKClcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFDYWNoZU5vZGV9XG4gICAgICovXG4gICAgVmlld0NhY2hlLnByb3RvdHlwZS5nZXRTZXJ2ZXJDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyQ2FjaGVfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P05vZGV9XG4gICAgICovXG4gICAgVmlld0NhY2hlLnByb3RvdHlwZS5nZXRDb21wbGV0ZVNlcnZlclNuYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZlckNhY2hlXy5pc0Z1bGx5SW5pdGlhbGl6ZWQoKVxuICAgICAgICAgICAgPyB0aGlzLnNlcnZlckNhY2hlXy5nZXROb2RlKClcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtWaWV3Q2FjaGV9XG4gICAgICovXG4gICAgVmlld0NhY2hlLkVtcHR5ID0gbmV3IFZpZXdDYWNoZShuZXcgQ2FjaGVOb2RlKENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLCBcbiAgICAvKmZ1bGx5SW5pdGlhbGl6ZWQ9Ki8gZmFsc2UsIFxuICAgIC8qZmlsdGVyZWQ9Ki8gZmFsc2UpLCBuZXcgQ2FjaGVOb2RlKENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLCBcbiAgICAvKmZ1bGx5SW5pdGlhbGl6ZWQ9Ki8gZmFsc2UsIFxuICAgIC8qZmlsdGVyZWQ9Ki8gZmFsc2UpKTtcbiAgICByZXR1cm4gVmlld0NhY2hlO1xufSgpKTtcbmV4cG9ydCB7IFZpZXdDYWNoZSB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3ZpZXcvVmlld0NhY2hlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgSW5kZXhlZEZpbHRlciB9IGZyb20gJy4vSW5kZXhlZEZpbHRlcic7XG5pbXBvcnQgeyBQUklPUklUWV9JTkRFWCB9IGZyb20gJy4uLy4uL3NuYXAvaW5kZXhlcy9Qcmlvcml0eUluZGV4JztcbmltcG9ydCB7IE5hbWVkTm9kZSB9IGZyb20gJy4uLy4uLy4uL2NvcmUvc25hcC9Ob2RlJztcbmltcG9ydCB7IENoaWxkcmVuTm9kZSB9IGZyb20gJy4uLy4uL3NuYXAvQ2hpbGRyZW5Ob2RlJztcbi8qKlxuICogRmlsdGVycyBub2RlcyBieSByYW5nZSBhbmQgdXNlcyBhbiBJbmRleEZpbHRlciB0byB0cmFjayBhbnkgY2hhbmdlcyBhZnRlciBmaWx0ZXJpbmcgdGhlIG5vZGVcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtOb2RlRmlsdGVyfVxuICovXG52YXIgUmFuZ2VkRmlsdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5UGFyYW1zfSBwYXJhbXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSYW5nZWRGaWx0ZXIocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuaW5kZXhlZEZpbHRlcl8gPSBuZXcgSW5kZXhlZEZpbHRlcihwYXJhbXMuZ2V0SW5kZXgoKSk7XG4gICAgICAgIHRoaXMuaW5kZXhfID0gcGFyYW1zLmdldEluZGV4KCk7XG4gICAgICAgIHRoaXMuc3RhcnRQb3N0XyA9IFJhbmdlZEZpbHRlci5nZXRTdGFydFBvc3RfKHBhcmFtcyk7XG4gICAgICAgIHRoaXMuZW5kUG9zdF8gPSBSYW5nZWRGaWx0ZXIuZ2V0RW5kUG9zdF8ocGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IU5hbWVkTm9kZX1cbiAgICAgKi9cbiAgICBSYW5nZWRGaWx0ZXIucHJvdG90eXBlLmdldFN0YXJ0UG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRQb3N0XztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFOYW1lZE5vZGV9XG4gICAgICovXG4gICAgUmFuZ2VkRmlsdGVyLnByb3RvdHlwZS5nZXRFbmRQb3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmRQb3N0XztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IU5hbWVkTm9kZX0gbm9kZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgUmFuZ2VkRmlsdGVyLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmluZGV4Xy5jb21wYXJlKHRoaXMuZ2V0U3RhcnRQb3N0KCksIG5vZGUpIDw9IDAgJiZcbiAgICAgICAgICAgIHRoaXMuaW5kZXhfLmNvbXBhcmUobm9kZSwgdGhpcy5nZXRFbmRQb3N0KCkpIDw9IDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBSYW5nZWRGaWx0ZXIucHJvdG90eXBlLnVwZGF0ZUNoaWxkID0gZnVuY3Rpb24gKHNuYXAsIGtleSwgbmV3Q2hpbGQsIGFmZmVjdGVkUGF0aCwgc291cmNlLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xuICAgICAgICBpZiAoIXRoaXMubWF0Y2hlcyhuZXcgTmFtZWROb2RlKGtleSwgbmV3Q2hpbGQpKSkge1xuICAgICAgICAgICAgbmV3Q2hpbGQgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleGVkRmlsdGVyXy51cGRhdGVDaGlsZChzbmFwLCBrZXksIG5ld0NoaWxkLCBhZmZlY3RlZFBhdGgsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBSYW5nZWRGaWx0ZXIucHJvdG90eXBlLnVwZGF0ZUZ1bGxOb2RlID0gZnVuY3Rpb24gKG9sZFNuYXAsIG5ld1NuYXAsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XG4gICAgICAgIGlmIChuZXdTbmFwLmlzTGVhZk5vZGUoKSkge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBjaGlsZHJlbiBub2RlIHdpdGggdGhlIGNvcnJlY3QgaW5kZXgsIG5vdCBhIGxlYWYgbm9kZTtcbiAgICAgICAgICAgIG5ld1NuYXAgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlsdGVyZWQgPSBuZXdTbmFwLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XG4gICAgICAgIC8vIERvbid0IHN1cHBvcnQgcHJpb3JpdGllcyBvbiBxdWVyaWVzXG4gICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQudXBkYXRlUHJpb3JpdHkoQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIG5ld1NuYXAuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCBmdW5jdGlvbiAoa2V5LCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5tYXRjaGVzKG5ldyBOYW1lZE5vZGUoa2V5LCBjaGlsZE5vZGUpKSkge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQudXBkYXRlSW1tZWRpYXRlQ2hpbGQoa2V5LCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleGVkRmlsdGVyXy51cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBmaWx0ZXJlZCwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBSYW5nZWRGaWx0ZXIucHJvdG90eXBlLnVwZGF0ZVByaW9yaXR5ID0gZnVuY3Rpb24gKG9sZFNuYXAsIG5ld1ByaW9yaXR5KSB7XG4gICAgICAgIC8vIERvbid0IHN1cHBvcnQgcHJpb3JpdGllcyBvbiBxdWVyaWVzXG4gICAgICAgIHJldHVybiBvbGRTbmFwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBSYW5nZWRGaWx0ZXIucHJvdG90eXBlLmZpbHRlcnNOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFJhbmdlZEZpbHRlci5wcm90b3R5cGUuZ2V0SW5kZXhlZEZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhlZEZpbHRlcl87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFJhbmdlZEZpbHRlci5wcm90b3R5cGUuZ2V0SW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5UGFyYW1zfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuIHshTmFtZWROb2RlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmFuZ2VkRmlsdGVyLmdldFN0YXJ0UG9zdF8gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuaGFzU3RhcnQoKSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0TmFtZSA9IHBhcmFtcy5nZXRJbmRleFN0YXJ0TmFtZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5nZXRJbmRleCgpLm1ha2VQb3N0KHBhcmFtcy5nZXRJbmRleFN0YXJ0VmFsdWUoKSwgc3RhcnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuZ2V0SW5kZXgoKS5taW5Qb3N0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5UGFyYW1zfSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuIHshTmFtZWROb2RlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmFuZ2VkRmlsdGVyLmdldEVuZFBvc3RfID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmhhc0VuZCgpKSB7XG4gICAgICAgICAgICB2YXIgZW5kTmFtZSA9IHBhcmFtcy5nZXRJbmRleEVuZE5hbWUoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuZ2V0SW5kZXgoKS5tYWtlUG9zdChwYXJhbXMuZ2V0SW5kZXhFbmRWYWx1ZSgpLCBlbmROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuZ2V0SW5kZXgoKS5tYXhQb3N0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSYW5nZWRGaWx0ZXI7XG59KCkpO1xuZXhwb3J0IHsgUmFuZ2VkRmlsdGVyIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvdmlldy9maWx0ZXIvUmFuZ2VkRmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgZXhlY3V0ZVdoZW5ET01SZWFkeSwgaXNDaHJvbWVFeHRlbnNpb25Db250ZW50U2NyaXB0LCBpc1dpbmRvd3NTdG9yZUFwcCwgbG9nLCBsb2dXcmFwcGVyLCBMVUlER2VuZXJhdG9yLCBzcGxpdFN0cmluZ0J5U2l6ZSB9IGZyb20gJy4uL2NvcmUvdXRpbC91dGlsJztcbmltcG9ydCB7IENvdW50ZWRTZXQgfSBmcm9tICcuLi9jb3JlL3V0aWwvQ291bnRlZFNldCc7XG5pbXBvcnQgeyBTdGF0c01hbmFnZXIgfSBmcm9tICcuLi9jb3JlL3N0YXRzL1N0YXRzTWFuYWdlcic7XG5pbXBvcnQgeyBQYWNrZXRSZWNlaXZlciB9IGZyb20gJy4vcG9sbGluZy9QYWNrZXRSZWNlaXZlcic7XG5pbXBvcnQgeyBGT1JHRV9ET01BSU4sIEZPUkdFX1JFRiwgTEFTVF9TRVNTSU9OX1BBUkFNLCBMT05HX1BPTExJTkcsIFBST1RPQ09MX1ZFUlNJT04sIFJFRkVSRVJfUEFSQU0sIFRSQU5TUE9SVF9TRVNTSU9OX1BBUkFNLCBWRVJTSU9OX1BBUkFNIH0gZnJvbSAnLi9Db25zdGFudHMnO1xuaW1wb3J0IHsgYmFzZTY0RW5jb2RlLCBzdHJpbmdpZnkgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBpc05vZGVTZGsgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG4vLyBVUkwgcXVlcnkgcGFyYW1ldGVycyBhc3NvY2lhdGVkIHdpdGggbG9uZ3BvbGxpbmdcbmV4cG9ydCB2YXIgRklSRUJBU0VfTE9OR1BPTExfU1RBUlRfUEFSQU0gPSAnc3RhcnQnO1xuZXhwb3J0IHZhciBGSVJFQkFTRV9MT05HUE9MTF9DTE9TRV9DT01NQU5EID0gJ2Nsb3NlJztcbmV4cG9ydCB2YXIgRklSRUJBU0VfTE9OR1BPTExfQ09NTUFORF9DQl9OQU1FID0gJ3BMUENvbW1hbmQnO1xuZXhwb3J0IHZhciBGSVJFQkFTRV9MT05HUE9MTF9EQVRBX0NCX05BTUUgPSAncFJUTFBDQic7XG5leHBvcnQgdmFyIEZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNID0gJ2lkJztcbmV4cG9ydCB2YXIgRklSRUJBU0VfTE9OR1BPTExfUFdfUEFSQU0gPSAncHcnO1xuZXhwb3J0IHZhciBGSVJFQkFTRV9MT05HUE9MTF9TRVJJQUxfUEFSQU0gPSAnc2VyJztcbmV4cG9ydCB2YXIgRklSRUJBU0VfTE9OR1BPTExfQ0FMTEJBQ0tfSURfUEFSQU0gPSAnY2InO1xuZXhwb3J0IHZhciBGSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UX05VTV9QQVJBTSA9ICdzZWcnO1xuZXhwb3J0IHZhciBGSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UU19JTl9QQUNLRVQgPSAndHMnO1xuZXhwb3J0IHZhciBGSVJFQkFTRV9MT05HUE9MTF9EQVRBX1BBUkFNID0gJ2QnO1xuZXhwb3J0IHZhciBGSVJFQkFTRV9MT05HUE9MTF9ESVNDT05OX0ZSQU1FX1BBUkFNID0gJ2Rpc2Nvbm4nO1xuZXhwb3J0IHZhciBGSVJFQkFTRV9MT05HUE9MTF9ESVNDT05OX0ZSQU1FX1JFUVVFU1RfUEFSQU0gPSAnZGZyYW1lJztcbi8vRGF0YSBzaXplIGNvbnN0YW50cy5cbi8vVE9ETzogUGVyZjogdGhlIG1heGltdW0gbGVuZ3RoIGFjdHVhbGx5IGRpZmZlcnMgZnJvbSBicm93c2VyIHRvIGJyb3dzZXIuXG4vLyBXZSBzaG91bGQgY2hlY2sgd2hhdCBicm93c2VyIHdlJ3JlIG9uIGFuZCBzZXQgYWNjb3JkaW5nbHkuXG52YXIgTUFYX1VSTF9EQVRBX1NJWkUgPSAxODcwO1xudmFyIFNFR19IRUFERVJfU0laRSA9IDMwOyAvL2llOiAmc2VnPTgyOTkyMzQmdHM9OTgyMzg5MTIzJmQ9XG52YXIgTUFYX1BBWUxPQURfU0laRSA9IE1BWF9VUkxfREFUQV9TSVpFIC0gU0VHX0hFQURFUl9TSVpFO1xuLyoqXG4gKiBLZWVwYWxpdmUgcGVyaW9kXG4gKiBzZW5kIGEgZnJlc2ggcmVxdWVzdCBhdCBtaW5pbXVtIGV2ZXJ5IDI1IHNlY29uZHMuIE9wZXJhIGhhcyBhIG1heGltdW0gcmVxdWVzdFxuICogbGVuZ3RoIG9mIDMwIHNlY29uZHMgdGhhdCB3ZSBjYW4ndCBleGNlZWQuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnZhciBLRUVQQUxJVkVfUkVRVUVTVF9JTlRFUlZBTCA9IDI1MDAwO1xuLyoqXG4gKiBIb3cgbG9uZyB0byB3YWl0IGJlZm9yZSBhYm9ydGluZyBhIGxvbmctcG9sbGluZyBjb25uZWN0aW9uIGF0dGVtcHQuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnZhciBMUF9DT05ORUNUX1RJTUVPVVQgPSAzMDAwMDtcbi8qKlxuICogVGhpcyBjbGFzcyBtYW5hZ2VzIGEgc2luZ2xlIGxvbmctcG9sbGluZyBjb25uZWN0aW9uLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge1RyYW5zcG9ydH1cbiAqL1xudmFyIEJyb3dzZXJQb2xsQ29ubmVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29ubklkIEFuIGlkZW50aWZpZXIgZm9yIHRoaXMgY29ubmVjdGlvbiwgdXNlZCBmb3IgbG9nZ2luZ1xuICAgICAqIEBwYXJhbSB7UmVwb0luZm99IHJlcG9JbmZvIFRoZSBpbmZvIGZvciB0aGUgZW5kcG9pbnQgdG8gc2VuZCBkYXRhIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gdHJhbnNwb3J0U2Vzc2lvbklkIE9wdGlvbmFsIHRyYW5zcG9ydFNlc3Npb25pZCBpZiB3ZSBhcmUgcmVjb25uZWN0aW5nIGZvciBhbiBleGlzdGluZ1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQgc2Vzc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gIGxhc3RTZXNzaW9uSWQgT3B0aW9uYWwgbGFzdFNlc3Npb25JZCBpZiB0aGUgUGVyc2lzdGVudENvbm5lY3Rpb24gaGFzIGFscmVhZHkgY3JlYXRlZCBhXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbiBwcmV2aW91c2x5XG4gICAgICovXG4gICAgZnVuY3Rpb24gQnJvd3NlclBvbGxDb25uZWN0aW9uKGNvbm5JZCwgcmVwb0luZm8sIHRyYW5zcG9ydFNlc3Npb25JZCwgbGFzdFNlc3Npb25JZCkge1xuICAgICAgICB0aGlzLmNvbm5JZCA9IGNvbm5JZDtcbiAgICAgICAgdGhpcy5yZXBvSW5mbyA9IHJlcG9JbmZvO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydFNlc3Npb25JZCA9IHRyYW5zcG9ydFNlc3Npb25JZDtcbiAgICAgICAgdGhpcy5sYXN0U2Vzc2lvbklkID0gbGFzdFNlc3Npb25JZDtcbiAgICAgICAgdGhpcy5ieXRlc1NlbnQgPSAwO1xuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgPSAwO1xuICAgICAgICB0aGlzLmV2ZXJDb25uZWN0ZWRfID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9nXyA9IGxvZ1dyYXBwZXIoY29ubklkKTtcbiAgICAgICAgdGhpcy5zdGF0c18gPSBTdGF0c01hbmFnZXIuZ2V0Q29sbGVjdGlvbihyZXBvSW5mbyk7XG4gICAgICAgIHRoaXMudXJsRm4gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwb0luZm8uY29ubmVjdGlvblVSTChMT05HX1BPTExJTkcsIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QpfSBvbk1lc3NhZ2UgQ2FsbGJhY2sgd2hlbiBtZXNzYWdlcyBhcnJpdmVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IG9uRGlzY29ubmVjdCBDYWxsYmFjayB3aXRoIGNvbm5lY3Rpb24gbG9zdC5cbiAgICAgKi9cbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24ucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAob25NZXNzYWdlLCBvbkRpc2Nvbm5lY3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jdXJTZWdtZW50TnVtID0gMDtcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gb25EaXNjb25uZWN0O1xuICAgICAgICB0aGlzLm15UGFja2V0T3JkZXJlciA9IG5ldyBQYWNrZXRSZWNlaXZlcihvbk1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmlzQ2xvc2VkXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5sb2dfKCdUaW1lZCBvdXQgdHJ5aW5nIHRvIGNvbm5lY3QuJyk7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY2xlYXIgdGhlIGhvc3QgY2FjaGVcbiAgICAgICAgICAgIF90aGlzLm9uQ2xvc2VkXygpO1xuICAgICAgICAgICAgX3RoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8gPSBudWxsO1xuICAgICAgICB9LCBNYXRoLmZsb29yKExQX0NPTk5FQ1RfVElNRU9VVCkpO1xuICAgICAgICAvLyBFbnN1cmUgd2UgZGVsYXkgdGhlIGNyZWF0aW9uIG9mIHRoZSBpZnJhbWUgdW50aWwgdGhlIERPTSBpcyBsb2FkZWQuXG4gICAgICAgIGV4ZWN1dGVXaGVuRE9NUmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzQ2xvc2VkXylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvL1NldCB1cCBhIGNhbGxiYWNrIHRoYXQgZ2V0cyB0cmlnZ2VyZWQgb25jZSBhIGNvbm5lY3Rpb24gaXMgc2V0IHVwLlxuICAgICAgICAgICAgX3RoaXMuc2NyaXB0VGFnSG9sZGVyID0gbmV3IEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSBhcmdzWzBdLCBhcmcxID0gYXJnc1sxXSwgYXJnMiA9IGFyZ3NbMl0sIGFyZzMgPSBhcmdzWzNdLCBhcmc0ID0gYXJnc1s0XTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyhhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnNjcmlwdFRhZ0hvbGRlcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyB3ZSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlckNvbm5lY3RlZF8gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kID09IEZJUkVCQVNFX0xPTkdQT0xMX1NUQVJUX1BBUkFNKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmlkID0gYXJnMTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFzc3dvcmQgPSBhcmcyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb21tYW5kID09PSBGSVJFQkFTRV9MT05HUE9MTF9DTE9TRV9DT01NQU5EKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNsZWFyIHRoZSBob3N0IGNhY2hlLiBXZSBnb3QgYSByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIsIHNvIHdlIGtub3cgaXQncyByZWFjaGFibGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZW4ndCBleHBlY3RpbmcgYW55IG1vcmUgZGF0YSAob3RoZXIgdGhhbiB3aGF0IHRoZSBzZXJ2ZXIncyBhbHJlYWR5IGluIHRoZSBwcm9jZXNzIG9mIHNlbmRpbmcgdXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRocm91Z2ggb3VyIGFscmVhZHkgb3BlbiBwb2xscyksIHNvIGRvbid0IHNlbmQgYW55IG1vcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zY3JpcHRUYWdIb2xkZXIuc2VuZE5ld1BvbGxzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmcxIGluIHRoaXMgY2FzZSBpcyB0aGUgbGFzdCByZXNwb25zZSBudW1iZXIgc2VudCBieSB0aGUgc2VydmVyLiBXZSBzaG91bGQgdHJ5IHRvIHJlY2VpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBvZiB0aGUgcmVzcG9uc2VzIHVwIHRvIHRoaXMgb25lIGJlZm9yZSBjbG9zaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5teVBhY2tldE9yZGVyZXIuY2xvc2VBZnRlcihhcmcxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25DbG9zZWRfKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uQ2xvc2VkXygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBjb21tYW5kIHJlY2VpdmVkOiAnICsgY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcE4gPSBhcmdzWzBdLCBkYXRhID0gYXJnc1sxXTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyhhcmdzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5teVBhY2tldE9yZGVyZXIuaGFuZGxlUmVzcG9uc2UocE4sIGRhdGEpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uQ2xvc2VkXygpO1xuICAgICAgICAgICAgfSwgX3RoaXMudXJsRm4pO1xuICAgICAgICAgICAgLy9TZW5kIHRoZSBpbml0aWFsIHJlcXVlc3QgdG8gY29ubmVjdC4gVGhlIHNlcmlhbCBudW1iZXIgaXMgc2ltcGx5IHRvIGtlZXAgdGhlIGJyb3dzZXIgZnJvbSBwdWxsaW5nIHByZXZpb3VzIHJlc3VsdHNcbiAgICAgICAgICAgIC8vZnJvbSBjYWNoZS5cbiAgICAgICAgICAgIHZhciB1cmxQYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9TVEFSVF9QQVJBTV0gPSAndCc7XG4gICAgICAgICAgICB1cmxQYXJhbXNbRklSRUJBU0VfTE9OR1BPTExfU0VSSUFMX1BBUkFNXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc2NyaXB0VGFnSG9sZGVyLnVuaXF1ZUNhbGxiYWNrSWRlbnRpZmllcilcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXNbRklSRUJBU0VfTE9OR1BPTExfQ0FMTEJBQ0tfSURfUEFSQU1dID0gX3RoaXMuc2NyaXB0VGFnSG9sZGVyLnVuaXF1ZUNhbGxiYWNrSWRlbnRpZmllcjtcbiAgICAgICAgICAgIHVybFBhcmFtc1tWRVJTSU9OX1BBUkFNXSA9IFBST1RPQ09MX1ZFUlNJT047XG4gICAgICAgICAgICBpZiAoX3RoaXMudHJhbnNwb3J0U2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW1RSQU5TUE9SVF9TRVNTSU9OX1BBUkFNXSA9IF90aGlzLnRyYW5zcG9ydFNlc3Npb25JZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5sYXN0U2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW0xBU1RfU0VTU0lPTl9QQVJBTV0gPSBfdGhpcy5sYXN0U2Vzc2lvbklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc05vZGVTZGsoKSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICBsb2NhdGlvbi5ocmVmICYmXG4gICAgICAgICAgICAgICAgbG9jYXRpb24uaHJlZi5pbmRleE9mKEZPUkdFX0RPTUFJTikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW1JFRkVSRVJfUEFSQU1dID0gRk9SR0VfUkVGO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbm5lY3RVUkwgPSBfdGhpcy51cmxGbih1cmxQYXJhbXMpO1xuICAgICAgICAgICAgX3RoaXMubG9nXygnQ29ubmVjdGluZyB2aWEgbG9uZy1wb2xsIHRvICcgKyBjb25uZWN0VVJMKTtcbiAgICAgICAgICAgIF90aGlzLnNjcmlwdFRhZ0hvbGRlci5hZGRUYWcoY29ubmVjdFVSTCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8qIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuIGEgaGFuZHNoYWtlIGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5IGFuZCB3ZSB3YW50IHRvIGNvbnNpZGVyIHRoZSBjb25uZWN0aW9uIGVzdGFibGlzaGVkXG4gICAgICovXG4gICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIuc3RhcnRMb25nUG9sbCh0aGlzLmlkLCB0aGlzLnBhc3N3b3JkKTtcbiAgICAgICAgdGhpcy5hZGREaXNjb25uZWN0UGluZ0ZyYW1lKHRoaXMuaWQsIHRoaXMucGFzc3dvcmQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9yY2VzIGxvbmcgcG9sbGluZyB0byBiZSBjb25zaWRlcmVkIGFzIGEgcG90ZW50aWFsIHRyYW5zcG9ydFxuICAgICAqL1xuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZUFsbG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VBbGxvd18gPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9yY2VzIGxvbmdwb2xsaW5nIHRvIG5vdCBiZSBjb25zaWRlcmVkIGFzIGEgcG90ZW50aWFsIHRyYW5zcG9ydFxuICAgICAqL1xuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZURpc2FsbG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvd18gPSB0cnVlO1xuICAgIH07XG4gICAgLy8gU3RhdGljIG1ldGhvZCwgdXNlIHN0cmluZyBsaXRlcmFsIHNvIGl0IGNhbiBiZSBhY2Nlc3NlZCBpbiBhIGdlbmVyaWMgd2F5XG4gICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLmlzQXZhaWxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBOT1RFOiBJbiBSZWFjdC1OYXRpdmUgdGhlcmUncyBub3JtYWxseSBubyAnZG9jdW1lbnQnLCBidXQgaWYgeW91IGRlYnVnIGEgUmVhY3QtTmF0aXZlIGFwcCBpblxuICAgICAgICAvLyB0aGUgQ2hyb21lIGRlYnVnZ2VyLCAnZG9jdW1lbnQnIGlzIGRlZmluZWQsIGJ1dCBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzIG51bGwgKDIwMTUvMDYvMDgpLlxuICAgICAgICByZXR1cm4gKEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZUFsbG93XyB8fFxuICAgICAgICAgICAgKCFCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvd18gJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgIWlzQ2hyb21lRXh0ZW5zaW9uQ29udGVudFNjcmlwdCgpICYmXG4gICAgICAgICAgICAgICAgIWlzV2luZG93c1N0b3JlQXBwKCkgJiZcbiAgICAgICAgICAgICAgICAhaXNOb2RlU2RrKCkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE5vLW9wIGZvciBwb2xsaW5nXG4gICAgICovXG4gICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLnByb3RvdHlwZS5tYXJrQ29ubmVjdGlvbkhlYWx0aHkgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLyoqXG4gICAgICogU3RvcHMgcG9sbGluZyBhbmQgY2xlYW5zIHVwIHRoZSBpZnJhbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5wcm90b3R5cGUuc2h1dGRvd25fID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzQ2xvc2VkXyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnNjcmlwdFRhZ0hvbGRlcikge1xuICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvL3JlbW92ZSB0aGUgZGlzY29ubmVjdCBmcmFtZSwgd2hpY2ggd2lsbCB0cmlnZ2VyIGFuIFhIUiBjYWxsIHRvIHRoZSBzZXJ2ZXIgdG8gdGVsbCBpdCB3ZSdyZSBsZWF2aW5nLlxuICAgICAgICBpZiAodGhpcy5teURpc2Nvbm5GcmFtZSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLm15RGlzY29ubkZyYW1lKTtcbiAgICAgICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhpcyB0cmFuc3BvcnQgaXMgY2xvc2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24ucHJvdG90eXBlLm9uQ2xvc2VkXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2xvc2VkXykge1xuICAgICAgICAgICAgdGhpcy5sb2dfKCdMb25ncG9sbCBpcyBjbG9zaW5nIGl0c2VsZicpO1xuICAgICAgICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uRGlzY29ubmVjdF8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8odGhpcy5ldmVyQ29ubmVjdGVkXyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRXh0ZXJuYWwtZmFjaW5nIGNsb3NlIGhhbmRsZXIuIFJlYWxUaW1lIGhhcyByZXF1ZXN0ZWQgd2Ugc2h1dCBkb3duLiBLaWxsIG91ciBjb25uZWN0aW9uIGFuZCB0ZWxsIHRoZSBzZXJ2ZXJcbiAgICAgKiB0aGF0IHdlJ3ZlIGxlZnQuXG4gICAgICovXG4gICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2xvc2VkXykge1xuICAgICAgICAgICAgdGhpcy5sb2dfKCdMb25ncG9sbCBpcyBiZWluZyBjbG9zZWQuJyk7XG4gICAgICAgICAgICB0aGlzLnNodXRkb3duXygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSBKU09OIG9iamVjdCBkb3duIHRvIHRoZSBzZXJ2ZXIuIEl0IHdpbGwgbmVlZCB0byBiZSBzdHJpbmdpZmllZCwgYmFzZTY0IGVuY29kZWQsIGFuZCB0aGVuXG4gICAgICogYnJva2VuIGludG8gY2h1bmtzIChzaW5jZSBVUkxzIGhhdmUgYSBzbWFsbCBtYXhpbXVtIGxlbmd0aCkuXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBkYXRhIFRoZSBKU09OIGRhdGEgdG8gdHJhbnNtaXQuXG4gICAgICovXG4gICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGRhdGFTdHIgPSBzdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ICs9IGRhdGFTdHIubGVuZ3RoO1xuICAgICAgICB0aGlzLnN0YXRzXy5pbmNyZW1lbnRDb3VudGVyKCdieXRlc19zZW50JywgZGF0YVN0ci5sZW5ndGgpO1xuICAgICAgICAvL2ZpcnN0LCBsZXRzIGdldCB0aGUgYmFzZTY0LWVuY29kZWQgZGF0YVxuICAgICAgICB2YXIgYmFzZTY0ZGF0YSA9IGJhc2U2NEVuY29kZShkYXRhU3RyKTtcbiAgICAgICAgLy9XZSBjYW4gb25seSBmaXQgYSBjZXJ0YWluIGFtb3VudCBpbiBlYWNoIFVSTCwgc28gd2UgbmVlZCB0byBzcGxpdCB0aGlzIHJlcXVlc3RcbiAgICAgICAgLy91cCBpbnRvIG11bHRpcGxlIHBpZWNlcyBpZiBpdCBkb2Vzbid0IGZpdCBpbiBvbmUgcmVxdWVzdC5cbiAgICAgICAgdmFyIGRhdGFTZWdzID0gc3BsaXRTdHJpbmdCeVNpemUoYmFzZTY0ZGF0YSwgTUFYX1BBWUxPQURfU0laRSk7XG4gICAgICAgIC8vRW5xdWV1ZSBlYWNoIHNlZ21lbnQgZm9yIHRyYW5zbWlzc2lvbi4gV2UgYXNzaWduIGVhY2ggY2h1bmsgYSBzZXF1ZW50aWFsIElEIGFuZCBhIHRvdGFsIG51bWJlclxuICAgICAgICAvL29mIHNlZ21lbnRzIHNvIHRoYXQgd2UgY2FuIHJlYXNzZW1ibGUgdGhlIHBhY2tldCBvbiB0aGUgc2VydmVyLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFTZWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5lbnF1ZXVlU2VnbWVudCh0aGlzLmN1clNlZ21lbnROdW0sIGRhdGFTZWdzLmxlbmd0aCwgZGF0YVNlZ3NbaV0pO1xuICAgICAgICAgICAgdGhpcy5jdXJTZWdtZW50TnVtKys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgaG93IHdlIG5vdGlmeSB0aGUgc2VydmVyIHRoYXQgd2UncmUgbGVhdmluZy5cbiAgICAgKiBXZSBhcmVuJ3QgYWJsZSB0byBzZW5kIHJlcXVlc3RzIHdpdGggREhUTUwgb24gYSB3aW5kb3cgY2xvc2UgZXZlbnQsIGJ1dCB3ZSBjYW5cbiAgICAgKiB0cmlnZ2VyIFhIUiByZXF1ZXN0cyBpbiBzb21lIGJyb3dzZXJzIChldmVyeXRoaW5nIGJ1dCBPcGVyYSBiYXNpY2FsbHkpLlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IHB3XG4gICAgICovXG4gICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLnByb3RvdHlwZS5hZGREaXNjb25uZWN0UGluZ0ZyYW1lID0gZnVuY3Rpb24gKGlkLCBwdykge1xuICAgICAgICBpZiAoaXNOb2RlU2RrKCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgdmFyIHVybFBhcmFtcyA9IHt9O1xuICAgICAgICB1cmxQYXJhbXNbRklSRUJBU0VfTE9OR1BPTExfRElTQ09OTl9GUkFNRV9SRVFVRVNUX1BBUkFNXSA9ICd0JztcbiAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNXSA9IGlkO1xuICAgICAgICB1cmxQYXJhbXNbRklSRUJBU0VfTE9OR1BPTExfUFdfUEFSQU1dID0gcHc7XG4gICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUuc3JjID0gdGhpcy51cmxGbih1cmxQYXJhbXMpO1xuICAgICAgICB0aGlzLm15RGlzY29ubkZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5teURpc2Nvbm5GcmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHRyYWNrIHRoZSBieXRlcyByZWNlaXZlZCBieSB0aGlzIGNsaWVudFxuICAgICAqIEBwYXJhbSB7Kn0gYXJnc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLnByb3RvdHlwZS5pbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgaXMgYW4gYW5ub3lpbmcgcGVyZiBoaXQganVzdCB0byB0cmFjayB0aGUgbnVtYmVyIG9mIGluY29taW5nIGJ5dGVzLiAgTWF5YmUgaXQgc2hvdWxkIGJlIG9wdC1pbi5cbiAgICAgICAgdmFyIGJ5dGVzUmVjZWl2ZWQgPSBzdHJpbmdpZnkoYXJncykubGVuZ3RoO1xuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgKz0gYnl0ZXNSZWNlaXZlZDtcbiAgICAgICAgdGhpcy5zdGF0c18uaW5jcmVtZW50Q291bnRlcignYnl0ZXNfcmVjZWl2ZWQnLCBieXRlc1JlY2VpdmVkKTtcbiAgICB9O1xuICAgIHJldHVybiBCcm93c2VyUG9sbENvbm5lY3Rpb247XG59KCkpO1xuZXhwb3J0IHsgQnJvd3NlclBvbGxDb25uZWN0aW9uIH07XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIGFuIGlmcmFtZSB0aGF0IGlzIHVzZWQgYXMgYSBsb25nLXBvbGxpbmcgc2NyaXB0IGhvbGRlci5cbiAqIEBjb25zdHJ1Y3RvclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29tbWFuZENCIC0gVGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aGVuIGNvbnRyb2wgY29tbWFuZHMgYXJlIHJlY2V2aWVkIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlQ0IgLSBUaGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gcmVzcG9uc2VzIGFycml2ZSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIG9uRGlzY29ubmVjdCAtIFRoZSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGlzIHRhZyBob2xkZXIgaXMgY2xvc2VkXG4gICAgICogQHBhcmFtIHVybEZuIC0gQSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIHRoZSBVUkwgb2YgdGhlIGVuZHBvaW50IHRvIHNlbmQgZGF0YSB0by5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlcihjb21tYW5kQ0IsIG9uTWVzc2FnZUNCLCBvbkRpc2Nvbm5lY3QsIHVybEZuKSB7XG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gb25EaXNjb25uZWN0O1xuICAgICAgICB0aGlzLnVybEZuID0gdXJsRm47XG4gICAgICAgIC8vV2UgbWFpbnRhaW4gYSBjb3VudCBvZiBhbGwgb2YgdGhlIG91dHN0YW5kaW5nIHJlcXVlc3RzLCBiZWNhdXNlIGlmIHdlIGhhdmUgdG9vIG1hbnkgYWN0aXZlIGF0IG9uY2UgaXQgY2FuIGNhdXNlXG4gICAgICAgIC8vcHJvYmxlbXMgaW4gc29tZSBicm93c2Vycy5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtDb3VudGVkU2V0LjxudW1iZXIsIG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMgPSBuZXcgQ291bnRlZFNldCgpO1xuICAgICAgICAvL0EgcXVldWUgb2YgdGhlIHBlbmRpbmcgc2VnbWVudHMgd2FpdGluZyBmb3IgdHJhbnNtaXNzaW9uIHRvIHRoZSBzZXJ2ZXIuXG4gICAgICAgIHRoaXMucGVuZGluZ1NlZ3MgPSBbXTtcbiAgICAgICAgLy9BIHNlcmlhbCBudW1iZXIuIFdlIHVzZSB0aGlzIGZvciB0d28gdGhpbmdzOlxuICAgICAgICAvLyAxKSBBIHdheSB0byBlbnN1cmUgdGhlIGJyb3dzZXIgZG9lc24ndCBjYWNoZSByZXNwb25zZXMgdG8gcG9sbHNcbiAgICAgICAgLy8gMikgQSB3YXkgdG8gbWFrZSB0aGUgc2VydmVyIGF3YXJlIHdoZW4gbG9uZy1wb2xscyBhcnJpdmUgaW4gYSBkaWZmZXJlbnQgb3JkZXIgdGhhbiB3ZSBzdGFydGVkIHRoZW0uIFRoZVxuICAgICAgICAvLyAgICBzZXJ2ZXIgbmVlZHMgdG8gcmVsZWFzZSBib3RoIHBvbGxzIGluIHRoaXMgY2FzZSBvciBpdCB3aWxsIGNhdXNlIHByb2JsZW1zIGluIE9wZXJhIHNpbmNlIE9wZXJhIGNhbiBvbmx5IGV4ZWN1dGVcbiAgICAgICAgLy8gICAgSlNPTlAgY29kZSBpbiB0aGUgb3JkZXIgaXQgd2FzIGFkZGVkIHRvIHRoZSBpZnJhbWUuXG4gICAgICAgIHRoaXMuY3VycmVudFNlcmlhbCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMCk7XG4gICAgICAgIC8vIFRoaXMgZ2V0cyBzZXQgdG8gZmFsc2Ugd2hlbiB3ZSdyZSBcImNsb3NpbmcgZG93blwiIHRoZSBjb25uZWN0aW9uIChlLmcuIHdlJ3JlIHN3aXRjaGluZyB0cmFuc3BvcnRzIGJ1dCB0aGVyZSdzIHN0aWxsXG4gICAgICAgIC8vIGluY29taW5nIGRhdGEgZnJvbSB0aGUgc2VydmVyIHRoYXQgd2UncmUgd2FpdGluZyBmb3IpLlxuICAgICAgICB0aGlzLnNlbmROZXdQb2xscyA9IHRydWU7XG4gICAgICAgIGlmICghaXNOb2RlU2RrKCkpIHtcbiAgICAgICAgICAgIC8vRWFjaCBzY3JpcHQgaG9sZGVyIHJlZ2lzdGVycyBhIGNvdXBsZSBvZiB1bmlxdWVseSBuYW1lZCBjYWxsYmFja3Mgd2l0aCB0aGUgd2luZG93LiBUaGVzZSBhcmUgY2FsbGVkIGZyb20gdGhlXG4gICAgICAgICAgICAvL2lmcmFtZXMgd2hlcmUgd2UgcHV0IHRoZSBsb25nLXBvbGxpbmcgc2NyaXB0IHRhZ3MuIFdlIGhhdmUgdHdvIGNhbGxiYWNrczpcbiAgICAgICAgICAgIC8vICAgMSkgQ29tbWFuZCBDYWxsYmFjayAtIFRyaWdnZXJlZCBmb3IgY29udHJvbCBpc3N1ZXMsIGxpa2Ugc3RhcnRpbmcgYSBjb25uZWN0aW9uLlxuICAgICAgICAgICAgLy8gICAyKSBNZXNzYWdlIENhbGxiYWNrIC0gVHJpZ2dlcmVkIHdoZW4gbmV3IGRhdGEgYXJyaXZlcy5cbiAgICAgICAgICAgIHRoaXMudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyID0gTFVJREdlbmVyYXRvcigpO1xuICAgICAgICAgICAgd2luZG93W0ZJUkVCQVNFX0xPTkdQT0xMX0NPTU1BTkRfQ0JfTkFNRSArIHRoaXMudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyXSA9IGNvbW1hbmRDQjtcbiAgICAgICAgICAgIHdpbmRvd1tGSVJFQkFTRV9MT05HUE9MTF9EQVRBX0NCX05BTUUgKyB0aGlzLnVuaXF1ZUNhbGxiYWNrSWRlbnRpZmllcl0gPSBvbk1lc3NhZ2VDQjtcbiAgICAgICAgICAgIC8vQ3JlYXRlIGFuIGlmcmFtZSBmb3IgdXMgdG8gYWRkIHNjcmlwdCB0YWdzIHRvLlxuICAgICAgICAgICAgdGhpcy5teUlGcmFtZSA9IEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyLmNyZWF0ZUlGcmFtZV8oKTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgaWZyYW1lJ3MgY29udGVudHMuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gJyc7XG4gICAgICAgICAgICAvLyBpZiB3ZSBzZXQgYSBqYXZhc2NyaXB0IHVybCwgaXQncyBJRSBhbmQgd2UgbmVlZCB0byBzZXQgdGhlIGRvY3VtZW50IGRvbWFpbi4gVGhlIGphdmFzY3JpcHQgdXJsIGlzIHN1ZmZpY2llbnRcbiAgICAgICAgICAgIC8vIGZvciBpZTksIGJ1dCBpZTggbmVlZHMgdG8gZG8gaXQgYWdhaW4gaW4gdGhlIGRvY3VtZW50IGl0c2VsZi5cbiAgICAgICAgICAgIGlmICh0aGlzLm15SUZyYW1lLnNyYyAmJlxuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuc3JjLnN1YnN0cigwLCAnamF2YXNjcmlwdDonLmxlbmd0aCkgPT09ICdqYXZhc2NyaXB0OicpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudERvbWFpbiA9IGRvY3VtZW50LmRvbWFpbjtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSAnPHNjcmlwdD5kb2N1bWVudC5kb21haW49XCInICsgY3VycmVudERvbWFpbiArICdcIjs8L3NjcmlwdD4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlmcmFtZUNvbnRlbnRzID0gJzxodG1sPjxib2R5PicgKyBzY3JpcHQgKyAnPC9ib2R5PjwvaHRtbD4nO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLm15SUZyYW1lLmRvYy5vcGVuKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2Mud3JpdGUoaWZyYW1lQ29udGVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZygnZnJhbWUgd3JpdGluZyBleGNlcHRpb24nKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5zdGFjaykge1xuICAgICAgICAgICAgICAgICAgICBsb2coZS5zdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZENCID0gY29tbWFuZENCO1xuICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2VDQiA9IG9uTWVzc2FnZUNCO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVhY2ggYnJvd3NlciBoYXMgaXRzIG93biBmdW5ueSB3YXkgdG8gaGFuZGxlIGlmcmFtZXMuIEhlcmUgd2UgbXVzaCB0aGVtIGFsbCB0b2dldGhlciBpbnRvIG9uZSBvYmplY3QgdGhhdCBJIGNhblxuICAgICAqIGFjdHVhbGx5IHVzZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAgICovXG4gICAgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIuY3JlYXRlSUZyYW1lXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gaW5pdGlhbGl6ZSB0aGUgZG9jdW1lbnQgaW5zaWRlIHRoZSBpZnJhbWVcbiAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgZG9jdW1lbnQuZG9tYWluIGhhcyBiZWVuIG1vZGlmaWVkIGluIElFLCB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IsIGFuZCB3ZSBuZWVkIHRvIHNldCB0aGVcbiAgICAgICAgICAgICAgICAvLyBkb21haW4gb2YgdGhlIGlmcmFtZSdzIGRvY3VtZW50IG1hbnVhbGx5LiBXZSBjYW4gZG8gdGhpcyB2aWEgYSBqYXZhc2NyaXB0OiB1cmwgYXMgdGhlIHNyYyBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAvLyBBbHNvIG5vdGUgdGhhdCB3ZSBtdXN0IGRvIHRoaXMgKmFmdGVyKiB0aGUgaWZyYW1lIGhhcyBiZWVuIGFwcGVuZGVkIHRvIHRoZSBwYWdlLiBPdGhlcndpc2UgaXQgZG9lc24ndCB3b3JrLlxuICAgICAgICAgICAgICAgIHZhciBhID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwb2xvZ2llcyBmb3IgdGhlIGxvZy1zcGFtLCBJIG5lZWQgdG8gZG8gc29tZXRoaW5nIHRvIGtlZXAgY2xvc3VyZSBmcm9tIG9wdGltaXppbmcgb3V0IHRoZSBhc3NpZ25tZW50IGFib3ZlLlxuICAgICAgICAgICAgICAgICAgICBsb2coJ05vIElFIGRvbWFpbiBzZXR0aW5nIHJlcXVpcmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gZG9jdW1lbnQuZG9tYWluO1xuICAgICAgICAgICAgICAgIGlmcmFtZS5zcmMgPVxuICAgICAgICAgICAgICAgICAgICBcImphdmFzY3JpcHQ6dm9pZCgoZnVuY3Rpb24oKXtkb2N1bWVudC5vcGVuKCk7ZG9jdW1lbnQuZG9tYWluPSdcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4gK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCInO2RvY3VtZW50LmNsb3NlKCk7fSkoKSlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIExvbmdQb2xsQ29ubmVjdGlvbiBhdHRlbXB0cyB0byBkZWxheSBpbml0aWFsaXphdGlvbiB1bnRpbCB0aGUgZG9jdW1lbnQgaXMgcmVhZHksIHNvIGhvcGVmdWxseSB0aGlzXG4gICAgICAgICAgICAvLyBuZXZlciBnZXRzIGhpdC5cbiAgICAgICAgICAgIHRocm93ICdEb2N1bWVudCBib2R5IGhhcyBub3QgaW5pdGlhbGl6ZWQuIFdhaXQgdG8gaW5pdGlhbGl6ZSBGaXJlYmFzZSB1bnRpbCBhZnRlciB0aGUgZG9jdW1lbnQgaXMgcmVhZHkuJztcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIGRvY3VtZW50IG9mIHRoZSBpZnJhbWUgaW4gYSBicm93c2VyLXNwZWNpZmljIHdheS5cbiAgICAgICAgaWYgKGlmcmFtZS5jb250ZW50RG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGlmcmFtZS5kb2MgPSBpZnJhbWUuY29udGVudERvY3VtZW50OyAvLyBGaXJlZm94LCBPcGVyYSwgU2FmYXJpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIGlmcmFtZS5kb2MgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDsgLy8gSW50ZXJuZXQgRXhwbG9yZXJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpZnJhbWUuZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGlmcmFtZS5kb2MgPSBpZnJhbWUuZG9jdW1lbnQ7IC8vb3RoZXJzP1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZnJhbWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYW5jZWwgYWxsIG91dHN0YW5kaW5nIHF1ZXJpZXMgYW5kIHJlbW92ZSB0aGUgZnJhbWUuXG4gICAgICovXG4gICAgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvL01hcmsgdGhpcyBpZnJhbWUgYXMgZGVhZCwgc28gbm8gbmV3IHJlcXVlc3RzIGFyZSBzZW50LlxuICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm15SUZyYW1lKSB7XG4gICAgICAgICAgICAvL1dlIGhhdmUgdG8gYWN0dWFsbHkgcmVtb3ZlIGFsbCBvZiB0aGUgaHRtbCBpbnNpZGUgdGhpcyBpZnJhbWUgYmVmb3JlIHJlbW92aW5nIGl0IGZyb20gdGhlXG4gICAgICAgICAgICAvL3dpbmRvdywgb3IgSUUgd2lsbCBjb250aW51ZSBsb2FkaW5nIGFuZCBleGVjdXRpbmcgdGhlIHNjcmlwdCB0YWdzIHdlJ3ZlIGFscmVhZHkgYWRkZWQsIHdoaWNoXG4gICAgICAgICAgICAvL2NhbiBsZWFkIHRvIHNvbWUgZXJyb3JzIGJlaW5nIHRocm93bi4gU2V0dGluZyBpbm5lckhUTUwgc2VlbXMgdG8gYmUgdGhlIGVhc2llc3Qgd2F5IHRvIGRvIHRoaXMuXG4gICAgICAgICAgICB0aGlzLm15SUZyYW1lLmRvYy5ib2R5LmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm15SUZyYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoX3RoaXMubXlJRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5teUlGcmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgTWF0aC5mbG9vcigwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTm9kZVNkaygpICYmIHRoaXMubXlJRCkge1xuICAgICAgICAgICAgdmFyIHVybFBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0RJU0NPTk5fRlJBTUVfUEFSQU1dID0gJ3QnO1xuICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNXSA9IHRoaXMubXlJRDtcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTV0gPSB0aGlzLm15UFc7XG4gICAgICAgICAgICB2YXIgdGhlVVJMID0gdGhpcy51cmxGbih1cmxQYXJhbXMpO1xuICAgICAgICAgICAgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIubm9kZVJlc3RSZXF1ZXN0KHRoZVVSTCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJvdGVjdCBmcm9tIGJlaW5nIGNhbGxlZCByZWN1cnNpdmVseS5cbiAgICAgICAgdmFyIG9uRGlzY29ubmVjdCA9IHRoaXMub25EaXNjb25uZWN0O1xuICAgICAgICBpZiAob25EaXNjb25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCA9IG51bGw7XG4gICAgICAgICAgICBvbkRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWN0dWFsbHkgc3RhcnQgdGhlIGxvbmctcG9sbGluZyBzZXNzaW9uIGJ5IGFkZGluZyB0aGUgZmlyc3Qgc2NyaXB0IHRhZyhzKSB0byB0aGUgaWZyYW1lLlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gaWQgLSBUaGUgSUQgb2YgdGhpcyBjb25uZWN0aW9uXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBwdyAtIFRoZSBwYXNzd29yZCBmb3IgdGhpcyBjb25uZWN0aW9uXG4gICAgICovXG4gICAgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIucHJvdG90eXBlLnN0YXJ0TG9uZ1BvbGwgPSBmdW5jdGlvbiAoaWQsIHB3KSB7XG4gICAgICAgIHRoaXMubXlJRCA9IGlkO1xuICAgICAgICB0aGlzLm15UFcgPSBwdztcbiAgICAgICAgdGhpcy5hbGl2ZSA9IHRydWU7XG4gICAgICAgIC8vc2VuZCB0aGUgaW5pdGlhbCByZXF1ZXN0LiBJZiB0aGVyZSBhcmUgcmVxdWVzdHMgcXVldWVkLCBtYWtlIHN1cmUgdGhhdCB3ZSB0cmFuc21pdCBhcyBtYW55IGFzIHdlIGFyZSBjdXJyZW50bHkgYWJsZSB0by5cbiAgICAgICAgd2hpbGUgKHRoaXMubmV3UmVxdWVzdF8oKSkgeyB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBhbnkgdGltZSBzb21lb25lIG1pZ2h0IHdhbnQgYSBzY3JpcHQgdGFnIHRvIGJlIGFkZGVkLiBJdCBhZGRzIGEgc2NyaXB0IHRhZyB3aGVuIHRoZXJlIGFyZW4ndFxuICAgICAqIHRvbyBtYW55IG91dHN0YW5kaW5nIHJlcXVlc3RzIGFuZCB3ZSBhcmUgc3RpbGwgYWxpdmUuXG4gICAgICpcbiAgICAgKiBJZiB0aGVyZSBhcmUgb3V0c3RhbmRpbmcgcGFja2V0IHNlZ21lbnRzIHRvIHNlbmQsIGl0IHNlbmRzIG9uZS4gSWYgdGhlcmUgYXJlbid0LCBpdCBzZW5kcyBhIGxvbmctcG9sbCBhbnl3YXlzIGlmXG4gICAgICogbmVlZGVkLlxuICAgICAqL1xuICAgIEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyLnByb3RvdHlwZS5uZXdSZXF1ZXN0XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gV2Uga2VlcCBvbmUgb3V0c3RhbmRpbmcgcmVxdWVzdCBvcGVuIGFsbCB0aGUgdGltZSB0byByZWNlaXZlIGRhdGEsIGJ1dCBpZiB3ZSBuZWVkIHRvIHNlbmQgZGF0YVxuICAgICAgICAvLyAocGVuZGluZ1NlZ3MubGVuZ3RoID4gMCkgdGhlbiB3ZSBjcmVhdGUgYSBuZXcgcmVxdWVzdCB0byBzZW5kIHRoZSBkYXRhLiAgVGhlIHNlcnZlciB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgLy8gY2xvc2UgdGhlIG9sZCByZXF1ZXN0LlxuICAgICAgICBpZiAodGhpcy5hbGl2ZSAmJlxuICAgICAgICAgICAgdGhpcy5zZW5kTmV3UG9sbHMgJiZcbiAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdSZXF1ZXN0cy5jb3VudCgpIDwgKHRoaXMucGVuZGluZ1NlZ3MubGVuZ3RoID4gMCA/IDIgOiAxKSkge1xuICAgICAgICAgICAgLy9jb25zdHJ1Y3Qgb3VyIHVybFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VyaWFsKys7XG4gICAgICAgICAgICB2YXIgdXJsUGFyYW1zID0ge307XG4gICAgICAgICAgICB1cmxQYXJhbXNbRklSRUJBU0VfTE9OR1BPTExfSURfUEFSQU1dID0gdGhpcy5teUlEO1xuICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX1BXX1BBUkFNXSA9IHRoaXMubXlQVztcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9TRVJJQUxfUEFSQU1dID0gdGhpcy5jdXJyZW50U2VyaWFsO1xuICAgICAgICAgICAgdmFyIHRoZVVSTCA9IHRoaXMudXJsRm4odXJsUGFyYW1zKTtcbiAgICAgICAgICAgIC8vTm93IGFkZCBhcyBtdWNoIGRhdGEgYXMgd2UgY2FuLlxuICAgICAgICAgICAgdmFyIGN1ckRhdGFTdHJpbmcgPSAnJztcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnBlbmRpbmdTZWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvL2ZpcnN0LCBsZXRzIHNlZSBpZiB0aGUgbmV4dCBzZWdtZW50IHdpbGwgZml0LlxuICAgICAgICAgICAgICAgIHZhciBuZXh0U2VnID0gdGhpcy5wZW5kaW5nU2Vnc1swXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNlZy5kLmxlbmd0aCArIFNFR19IRUFERVJfU0laRSArIGN1ckRhdGFTdHJpbmcubGVuZ3RoIDw9XG4gICAgICAgICAgICAgICAgICAgIE1BWF9VUkxfREFUQV9TSVpFKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vZ3JlYXQsIHRoZSBzZWdtZW50IHdpbGwgZml0LiBMZXRzIGFwcGVuZCBpdC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZVNlZyA9IHRoaXMucGVuZGluZ1NlZ3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY3VyRGF0YVN0cmluZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJEYXRhU3RyaW5nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZJUkVCQVNFX0xPTkdQT0xMX1NFR01FTlRfTlVNX1BBUkFNICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZVNlZy5zZWcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRklSRUJBU0VfTE9OR1BPTExfU0VHTUVOVFNfSU5fUEFDS0VUICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZVNlZy50cyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGSVJFQkFTRV9MT05HUE9MTF9EQVRBX1BBUkFNICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZVNlZy5kO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGVVUkwgPSB0aGVVUkwgKyBjdXJEYXRhU3RyaW5nO1xuICAgICAgICAgICAgdGhpcy5hZGRMb25nUG9sbFRhZ18odGhlVVJMLCB0aGlzLmN1cnJlbnRTZXJpYWwpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFF1ZXVlIGEgcGFja2V0IGZvciB0cmFuc21pc3Npb24gdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gc2VnbnVtIC0gQSBzZXF1ZW50aWFsIGlkIGZvciB0aGlzIHBhY2tldCBzZWdtZW50IHVzZWQgZm9yIHJlYXNzZW1ibHlcbiAgICAgKiBAcGFyYW0gdG90YWxzZWdzIC0gVGhlIHRvdGFsIG51bWJlciBvZiBzZWdtZW50cyBpbiB0aGlzIHBhY2tldFxuICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgZm9yIHRoaXMgc2VnbWVudC5cbiAgICAgKi9cbiAgICBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlci5wcm90b3R5cGUuZW5xdWV1ZVNlZ21lbnQgPSBmdW5jdGlvbiAoc2VnbnVtLCB0b3RhbHNlZ3MsIGRhdGEpIHtcbiAgICAgICAgLy9hZGQgdGhpcyB0byB0aGUgcXVldWUgb2Ygc2VnbWVudHMgdG8gc2VuZC5cbiAgICAgICAgdGhpcy5wZW5kaW5nU2Vncy5wdXNoKHsgc2VnOiBzZWdudW0sIHRzOiB0b3RhbHNlZ3MsIGQ6IGRhdGEgfSk7XG4gICAgICAgIC8vc2VuZCB0aGUgZGF0YSBpbW1lZGlhdGVseSBpZiB0aGVyZSBpc24ndCBhbHJlYWR5IGRhdGEgYmVpbmcgdHJhbnNtaXR0ZWQsIHVubGVzc1xuICAgICAgICAvL3N0YXJ0TG9uZ1BvbGwgaGFzbid0IGJlZW4gY2FsbGVkIHlldC5cbiAgICAgICAgaWYgKHRoaXMuYWxpdmUpIHtcbiAgICAgICAgICAgIHRoaXMubmV3UmVxdWVzdF8oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEgc2NyaXB0IHRhZyBmb3IgYSByZWd1bGFyIGxvbmctcG9sbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gdXJsIC0gVGhlIFVSTCBvZiB0aGUgc2NyaXB0IHRhZy5cbiAgICAgKiBAcGFyYW0geyFudW1iZXJ9IHNlcmlhbCAtIFRoZSBzZXJpYWwgbnVtYmVyIG9mIHRoZSByZXF1ZXN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIucHJvdG90eXBlLmFkZExvbmdQb2xsVGFnXyA9IGZ1bmN0aW9uICh1cmwsIHNlcmlhbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvL3JlbWVtYmVyIHRoYXQgd2Ugc2VudCB0aGlzIHJlcXVlc3QuXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdSZXF1ZXN0cy5hZGQoc2VyaWFsLCAxKTtcbiAgICAgICAgdmFyIGRvTmV3UmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMucmVtb3ZlKHNlcmlhbCk7XG4gICAgICAgICAgICBfdGhpcy5uZXdSZXF1ZXN0XygpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJZiB0aGlzIHJlcXVlc3QgZG9lc24ndCByZXR1cm4gb24gaXRzIG93biBhY2NvcmQgKGJ5IHRoZSBzZXJ2ZXIgc2VuZGluZyB1cyBzb21lIGRhdGEpLCB3ZSdsbFxuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgb25lIGFmdGVyIHRoZSBLRUVQQUxJVkUgaW50ZXJ2YWwgdG8gbWFrZSBzdXJlIHdlIGFsd2F5cyBrZWVwIGEgZnJlc2ggcmVxdWVzdCBvcGVuLlxuICAgICAgICB2YXIga2VlcGFsaXZlVGltZW91dCA9IHNldFRpbWVvdXQoZG9OZXdSZXF1ZXN0LCBNYXRoLmZsb29yKEtFRVBBTElWRV9SRVFVRVNUX0lOVEVSVkFMKSk7XG4gICAgICAgIHZhciByZWFkeVN0YXRlQ0IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBSZXF1ZXN0IGNvbXBsZXRlZC4gIENhbmNlbCB0aGUga2VlcGFsaXZlLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGtlZXBhbGl2ZVRpbWVvdXQpO1xuICAgICAgICAgICAgLy8gVHJpZ2dlciBhIG5ldyByZXF1ZXN0IHNvIHdlIGNhbiBjb250aW51ZSByZWNlaXZpbmcgZGF0YS5cbiAgICAgICAgICAgIGRvTmV3UmVxdWVzdCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZFRhZyh1cmwsIHJlYWR5U3RhdGVDQik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYW4gYXJiaXRyYXJ5IHNjcmlwdCB0YWcgdG8gdGhlIGlmcmFtZS5cbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IHVybCAtIFRoZSBVUkwgZm9yIHRoZSBzY3JpcHQgdGFnIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBsb2FkQ0IgLSBBIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCBvbmNlIHRoZSBzY3JpcHQgaGFzIGxvYWRlZC5cbiAgICAgKi9cbiAgICBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlci5wcm90b3R5cGUuYWRkVGFnID0gZnVuY3Rpb24gKHVybCwgbG9hZENCKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChpc05vZGVTZGsoKSkge1xuICAgICAgICAgICAgdGhpcy5kb05vZGVMb25nUG9sbCh1cmwsIGxvYWRDQik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBhbHJlYWR5IGNsb3NlZCwgZG9uJ3QgYWRkIHRoaXMgcG9sbFxuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnNlbmROZXdQb2xscylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1NjcmlwdF8xID0gX3RoaXMubXlJRnJhbWUuZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHRfMS50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdF8xLmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0XzEuc3JjID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHRfMS5vbmxvYWQgPSBuZXdTY3JpcHRfMS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnN0YXRlID0gbmV3U2NyaXB0XzEucmVhZHlTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnN0YXRlIHx8IHJzdGF0ZSA9PT0gJ2xvYWRlZCcgfHwgcnN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0XzEub25sb2FkID0gbmV3U2NyaXB0XzEub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3U2NyaXB0XzEucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHRfMS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5ld1NjcmlwdF8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZENCKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdF8xLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2coJ0xvbmctcG9sbCBzY3JpcHQgZmFpbGVkIHRvIGxvYWQ6ICcgKyB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VuZE5ld1BvbGxzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5teUlGcmFtZS5kb2MuYm9keS5hcHBlbmRDaGlsZChuZXdTY3JpcHRfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHdlIHNob3VsZCBtYWtlIHRoaXMgZXJyb3IgdmlzaWJsZSBzb21laG93XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgTWF0aC5mbG9vcigxKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlcjtcbn0oKSk7XG5leHBvcnQgeyBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlciB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9yZWFsdGltZS9Ccm93c2VyUG9sbENvbm5lY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBlcnJvciwgbG9nV3JhcHBlciwgcmVxdWlyZUtleSwgc2V0VGltZW91dE5vbkJsb2NraW5nLCB3YXJuIH0gZnJvbSAnLi4vY29yZS91dGlsL3V0aWwnO1xuaW1wb3J0IHsgUGVyc2lzdGVudFN0b3JhZ2UgfSBmcm9tICcuLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZSc7XG5pbXBvcnQgeyBQUk9UT0NPTF9WRVJTSU9OIH0gZnJvbSAnLi9Db25zdGFudHMnO1xuaW1wb3J0IHsgVHJhbnNwb3J0TWFuYWdlciB9IGZyb20gJy4vVHJhbnNwb3J0TWFuYWdlcic7XG4vLyBBYm9ydCB1cGdyYWRlIGF0dGVtcHQgaWYgaXQgdGFrZXMgbG9uZ2VyIHRoYW4gNjBzLlxudmFyIFVQR1JBREVfVElNRU9VVCA9IDYwMDAwO1xuLy8gRm9yIHNvbWUgdHJhbnNwb3J0cyAoV2ViU29ja2V0cyksIHdlIG5lZWQgdG8gXCJ2YWxpZGF0ZVwiIHRoZSB0cmFuc3BvcnQgYnkgZXhjaGFuZ2luZyBhIGZldyByZXF1ZXN0cyBhbmQgcmVzcG9uc2VzLlxuLy8gSWYgd2UgaGF2ZW4ndCBzZW50IGVub3VnaCByZXF1ZXN0cyB3aXRoaW4gNXMsIHdlJ2xsIHN0YXJ0IHNlbmRpbmcgbm9vcCBwaW5nIHJlcXVlc3RzLlxudmFyIERFTEFZX0JFRk9SRV9TRU5ESU5HX0VYVFJBX1JFUVVFU1RTID0gNTAwMDtcbi8vIElmIHRoZSBpbml0aWFsIGRhdGEgc2VudCB0cmlnZ2VycyBhIGxvdCBvZiBiYW5kd2lkdGggKGkuZS4gaXQncyBhIGxhcmdlIHB1dCBvciBhIGxpc3RlbiBmb3IgYSBsYXJnZSBhbW91bnQgb2YgZGF0YSlcbi8vIHRoZW4gd2UgbWF5IG5vdCBiZSBhYmxlIHRvIGV4Y2hhbmdlIG91ciBwaW5nL3BvbmcgcmVxdWVzdHMgd2l0aGluIHRoZSBoZWFsdGh5IHRpbWVvdXQuICBTbyBpZiB3ZSByZWFjaCB0aGUgdGltZW91dFxuLy8gYnV0IHdlJ3ZlIHNlbnQvcmVjZWl2ZWQgZW5vdWdoIGJ5dGVzLCB3ZSBkb24ndCBjYW5jZWwgdGhlIGNvbm5lY3Rpb24uXG52YXIgQllURVNfU0VOVF9IRUFMVEhZX09WRVJSSURFID0gMTAgKiAxMDI0O1xudmFyIEJZVEVTX1JFQ0VJVkVEX0hFQUxUSFlfT1ZFUlJJREUgPSAxMDAgKiAxMDI0O1xudmFyIE1FU1NBR0VfVFlQRSA9ICd0JztcbnZhciBNRVNTQUdFX0RBVEEgPSAnZCc7XG52YXIgQ09OVFJPTF9TSFVURE9XTiA9ICdzJztcbnZhciBDT05UUk9MX1JFU0VUID0gJ3InO1xudmFyIENPTlRST0xfRVJST1IgPSAnZSc7XG52YXIgQ09OVFJPTF9QT05HID0gJ28nO1xudmFyIFNXSVRDSF9BQ0sgPSAnYSc7XG52YXIgRU5EX1RSQU5TTUlTU0lPTiA9ICduJztcbnZhciBQSU5HID0gJ3AnO1xudmFyIFNFUlZFUl9IRUxMTyA9ICdoJztcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyByZWFsLXRpbWUgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyIHVzaW5nIHdoaWNoZXZlciBtZXRob2Qgd29ya3NcbiAqIGJlc3QgaW4gdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENvbm5lY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBpZCAtIGFuIGlkIGZvciB0aGlzIGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0geyFSZXBvSW5mb30gcmVwb0luZm9fIC0gdGhlIGluZm8gZm9yIHRoZSBlbmRwb2ludCB0byBjb25uZWN0IHRvXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QpfSBvbk1lc3NhZ2VfIC0gdGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIGEgc2VydmVyLXB1c2ggbWVzc2FnZSBhcnJpdmVzXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIsIHN0cmluZyl9IG9uUmVhZHlfIC0gdGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoaXMgY29ubmVjdGlvbiBpcyByZWFkeSB0byBzZW5kIG1lc3NhZ2VzLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gb25EaXNjb25uZWN0XyAtIHRoZSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiBhIGNvbm5lY3Rpb24gd2FzIGxvc3RcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyl9IG9uS2lsbF8gLSB0aGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhpcyBjb25uZWN0aW9uIGhhcyBwZXJtYW5lbnRseSBzaHV0IGRvd24uXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBsYXN0U2Vzc2lvbklkIC0gbGFzdCBzZXNzaW9uIGlkIGluIHBlcnNpc3RlbnQgY29ubmVjdGlvbi4gaXMgdXNlZCB0byBjbGVhbiB1cCBvbGQgc2Vzc2lvbiBpbiByZWFsLXRpbWUgc2VydmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvbihpZCwgcmVwb0luZm9fLCBvbk1lc3NhZ2VfLCBvblJlYWR5Xywgb25EaXNjb25uZWN0Xywgb25LaWxsXywgbGFzdFNlc3Npb25JZCkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xuICAgICAgICB0aGlzLm9uTWVzc2FnZV8gPSBvbk1lc3NhZ2VfO1xuICAgICAgICB0aGlzLm9uUmVhZHlfID0gb25SZWFkeV87XG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0XyA9IG9uRGlzY29ubmVjdF87XG4gICAgICAgIHRoaXMub25LaWxsXyA9IG9uS2lsbF87XG4gICAgICAgIHRoaXMubGFzdFNlc3Npb25JZCA9IGxhc3RTZXNzaW9uSWQ7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzID0gW107XG4gICAgICAgIHRoaXMuc3RhdGVfID0gMCAvKiBDT05ORUNUSU5HICovO1xuICAgICAgICB0aGlzLmxvZ18gPSBsb2dXcmFwcGVyKCdjOicgKyB0aGlzLmlkICsgJzonKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnRNYW5hZ2VyXyA9IG5ldyBUcmFuc3BvcnRNYW5hZ2VyKHJlcG9JbmZvXyk7XG4gICAgICAgIHRoaXMubG9nXygnQ29ubmVjdGlvbiBjcmVhdGVkJyk7XG4gICAgICAgIHRoaXMuc3RhcnRfKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhIGNvbm5lY3Rpb24gYXR0ZW1wdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RhcnRfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29ubiA9IHRoaXMudHJhbnNwb3J0TWFuYWdlcl8uaW5pdGlhbFRyYW5zcG9ydCgpO1xuICAgICAgICB0aGlzLmNvbm5fID0gbmV3IGNvbm4odGhpcy5uZXh0VHJhbnNwb3J0SWRfKCksIHRoaXMucmVwb0luZm9fLCB1bmRlZmluZWQsIHRoaXMubGFzdFNlc3Npb25JZCk7XG4gICAgICAgIC8vIEZvciBjZXJ0YWluIHRyYW5zcG9ydHMgKFdlYlNvY2tldHMpLCB3ZSBuZWVkIHRvIHNlbmQgYW5kIHJlY2VpdmUgc2V2ZXJhbCBtZXNzYWdlcyBiYWNrIGFuZCBmb3J0aCBiZWZvcmUgd2VcbiAgICAgICAgLy8gY2FuIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgaGVhbHRoeS5cbiAgICAgICAgdGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfID0gY29ublsncmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeSddIHx8IDA7XG4gICAgICAgIHZhciBvbk1lc3NhZ2VSZWNlaXZlZCA9IHRoaXMuY29ublJlY2VpdmVyXyh0aGlzLmNvbm5fKTtcbiAgICAgICAgdmFyIG9uQ29ubmVjdGlvbkxvc3QgPSB0aGlzLmRpc2Nvbm5SZWNlaXZlcl8odGhpcy5jb25uXyk7XG4gICAgICAgIHRoaXMudHhfID0gdGhpcy5jb25uXztcbiAgICAgICAgdGhpcy5yeF8gPSB0aGlzLmNvbm5fO1xuICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0hlYWx0aHlfID0gZmFsc2U7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEZpcmVmb3ggZG9lc24ndCBsaWtlIHdoZW4gY29kZSBmcm9tIG9uZSBpZnJhbWUgdHJpZXMgdG8gY3JlYXRlIGFub3RoZXIgaWZyYW1lIGJ5IHdheSBvZiB0aGUgcGFyZW50IGZyYW1lLlxuICAgICAgICAgKiBUaGlzIGNhbiBvY2N1ciBpbiB0aGUgY2FzZSBvZiBhIHJlZGlyZWN0LCBpLmUuIHdlIGd1ZXNzZWQgd3Jvbmcgb24gd2hhdCBzZXJ2ZXIgdG8gY29ubmVjdCB0byBhbmQgcmVjZWl2ZWQgYSByZXNldC5cbiAgICAgICAgICogU29tZWhvdywgc2V0VGltZW91dCBzZWVtcyB0byBtYWtlIHRoaXMgb2suIFRoYXQgZG9lc24ndCBtYWtlIHNlbnNlIGZyb20gYSBzZWN1cml0eSBwZXJzcGVjdGl2ZSwgc2luY2UgeW91IHNob3VsZFxuICAgICAgICAgKiBzdGlsbCBoYXZlIHRoZSBjb250ZXh0IG9mIHlvdXIgb3JpZ2luYXRpbmcgZnJhbWUuXG4gICAgICAgICAqL1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHRoaXMuY29ubl8gZ2V0cyBzZXQgdG8gbnVsbCBpbiBzb21lIG9mIHRoZSB0ZXN0cy4gQ2hlY2sgdG8gbWFrZSBzdXJlIGl0IHN0aWxsIGV4aXN0cyBiZWZvcmUgdXNpbmcgaXRcbiAgICAgICAgICAgIF90aGlzLmNvbm5fICYmIF90aGlzLmNvbm5fLm9wZW4ob25NZXNzYWdlUmVjZWl2ZWQsIG9uQ29ubmVjdGlvbkxvc3QpO1xuICAgICAgICB9LCBNYXRoLmZsb29yKDApKTtcbiAgICAgICAgdmFyIGhlYWx0aHlUaW1lb3V0X21zID0gY29ublsnaGVhbHRoeVRpbWVvdXQnXSB8fCAwO1xuICAgICAgICBpZiAoaGVhbHRoeVRpbWVvdXRfbXMgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWx0aHlUaW1lb3V0XyA9IHNldFRpbWVvdXROb25CbG9ja2luZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGVhbHRoeVRpbWVvdXRfID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmlzSGVhbHRoeV8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbm5fICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25uXy5ieXRlc1JlY2VpdmVkID4gQllURVNfUkVDRUlWRURfSEVBTFRIWV9PVkVSUklERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nXygnQ29ubmVjdGlvbiBleGNlZWRlZCBoZWFsdGh5IHRpbWVvdXQgYnV0IGhhcyByZWNlaXZlZCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25uXy5ieXRlc1JlY2VpdmVkICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzLiAgTWFya2luZyBjb25uZWN0aW9uIGhlYWx0aHkuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc0hlYWx0aHlfID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbm5fLm1hcmtDb25uZWN0aW9uSGVhbHRoeSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLmNvbm5fICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25uXy5ieXRlc1NlbnQgPiBCWVRFU19TRU5UX0hFQUxUSFlfT1ZFUlJJREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ18oJ0Nvbm5lY3Rpb24gZXhjZWVkZWQgaGVhbHRoeSB0aW1lb3V0IGJ1dCBoYXMgc2VudCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25uXy5ieXRlc1NlbnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgYnl0ZXMuICBMZWF2aW5nIGNvbm5lY3Rpb24gYWxpdmUuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBXZSBkb24ndCB3YW50IHRvIG1hcmsgaXQgaGVhbHRoeSwgc2luY2Ugd2UgaGF2ZSBubyBndWFyYW50ZWUgdGhhdCB0aGUgYnl0ZXMgaGF2ZSBtYWRlIGl0IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2VydmVyLlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nXygnQ2xvc2luZyB1bmhlYWx0aHkgY29ubmVjdGlvbiBhZnRlciB0aW1lb3V0LicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIE1hdGguZmxvb3IoaGVhbHRoeVRpbWVvdXRfbXMpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IXN0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLm5leHRUcmFuc3BvcnRJZF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnYzonICsgdGhpcy5pZCArICc6JyArIHRoaXMuY29ubmVjdGlvbkNvdW50Kys7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5kaXNjb25uUmVjZWl2ZXJfID0gZnVuY3Rpb24gKGNvbm4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVyQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICBpZiAoY29ubiA9PT0gX3RoaXMuY29ubl8pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkNvbm5lY3Rpb25Mb3N0XyhldmVyQ29ubmVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbm4gPT09IF90aGlzLnNlY29uZGFyeUNvbm5fKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nXygnU2Vjb25kYXJ5IGNvbm5lY3Rpb24gbG9zdC4nKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vblNlY29uZGFyeUNvbm5lY3Rpb25Mb3N0XygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nXygnY2xvc2luZyBhbiBvbGQgY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuY29ublJlY2VpdmVyXyA9IGZ1bmN0aW9uIChjb25uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlXyAhPSAyIC8qIERJU0NPTk5FQ1RFRCAqLykge1xuICAgICAgICAgICAgICAgIGlmIChjb25uID09PSBfdGhpcy5yeF8pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25QcmltYXJ5TWVzc2FnZVJlY2VpdmVkXyhtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29ubiA9PT0gX3RoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25TZWNvbmRhcnlNZXNzYWdlUmVjZWl2ZWRfKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nXygnbWVzc2FnZSBvbiBvbGQgY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFNc2cgQW4gYXJiaXRyYXJ5IGRhdGEgbWVzc2FnZSB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIChkYXRhTXNnKSB7XG4gICAgICAgIC8vIHdyYXAgaW4gYSBkYXRhIG1lc3NhZ2UgZW52ZWxvcGUgYW5kIHNlbmQgaXQgb25cbiAgICAgICAgdmFyIG1zZyA9IHsgdDogJ2QnLCBkOiBkYXRhTXNnIH07XG4gICAgICAgIHRoaXMuc2VuZERhdGFfKG1zZyk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS50cnlDbGVhbnVwQ29ubmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudHhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fICYmIHRoaXMucnhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ2NsZWFuaW5nIHVwIGFuZCBwcm9tb3RpbmcgYSBjb25uZWN0aW9uOiAnICsgdGhpcy5zZWNvbmRhcnlDb25uXy5jb25uSWQpO1xuICAgICAgICAgICAgdGhpcy5jb25uXyA9IHRoaXMuc2Vjb25kYXJ5Q29ubl87XG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbnVsbDtcbiAgICAgICAgICAgIC8vIHRoZSBzZXJ2ZXIgd2lsbCBzaHV0ZG93biB0aGUgb2xkIGNvbm5lY3Rpb25cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUub25TZWNvbmRhcnlDb250cm9sXyA9IGZ1bmN0aW9uIChjb250cm9sRGF0YSkge1xuICAgICAgICBpZiAoTUVTU0FHRV9UWVBFIGluIGNvbnRyb2xEYXRhKSB7XG4gICAgICAgICAgICB2YXIgY21kID0gY29udHJvbERhdGFbTUVTU0FHRV9UWVBFXTtcbiAgICAgICAgICAgIGlmIChjbWQgPT09IFNXSVRDSF9BQ0spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZ3JhZGVJZlNlY29uZGFyeUhlYWx0aHlfKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfUkVTRVQpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3N0IGxpa2VseSB0aGUgc2Vzc2lvbiB3YXNuJ3QgdmFsaWQuIEFiYW5kb24gdGhlIHN3aXRjaCBhdHRlbXB0XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdHb3QgYSByZXNldCBvbiBzZWNvbmRhcnksIGNsb3NpbmcgaXQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZSBhbHJlYWR5IHVzaW5nIHRoaXMgY29ubmVjdGlvbiBmb3Igc29tZXRoaW5nLCB0aGFuIHdlIG5lZWQgdG8gZnVsbHkgY2xvc2VcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eF8gPT09IHRoaXMuc2Vjb25kYXJ5Q29ubl8gfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yeF8gPT09IHRoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gQ09OVFJPTF9QT05HKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdnb3QgcG9uZyBvbiBzZWNvbmRhcnkuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlSZXNwb25zZXNSZXF1aXJlZF8tLTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZ3JhZGVJZlNlY29uZGFyeUhlYWx0aHlfKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLm9uU2Vjb25kYXJ5TWVzc2FnZVJlY2VpdmVkXyA9IGZ1bmN0aW9uIChwYXJzZWREYXRhKSB7XG4gICAgICAgIHZhciBsYXllciA9IHJlcXVpcmVLZXkoJ3QnLCBwYXJzZWREYXRhKTtcbiAgICAgICAgdmFyIGRhdGEgPSByZXF1aXJlS2V5KCdkJywgcGFyc2VkRGF0YSk7XG4gICAgICAgIGlmIChsYXllciA9PSAnYycpIHtcbiAgICAgICAgICAgIHRoaXMub25TZWNvbmRhcnlDb250cm9sXyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYXllciA9PSAnZCcpIHtcbiAgICAgICAgICAgIC8vIGdvdCBhIGRhdGEgbWVzc2FnZSwgYnV0IHdlJ3JlIHN0aWxsIHNlY29uZCBjb25uZWN0aW9uLiBOZWVkIHRvIGJ1ZmZlciBpdCB1cFxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJvdG9jb2wgbGF5ZXI6ICcgKyBsYXllcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLnVwZ3JhZGVJZlNlY29uZGFyeUhlYWx0aHlfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zZWNvbmRhcnlSZXNwb25zZXNSZXF1aXJlZF8gPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5sb2dfKCdTZWNvbmRhcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LicpO1xuICAgICAgICAgICAgdGhpcy5pc0hlYWx0aHlfID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8ubWFya0Nvbm5lY3Rpb25IZWFsdGh5KCk7XG4gICAgICAgICAgICB0aGlzLnByb2NlZWRXaXRoVXBncmFkZV8oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNlbmQgYSBwaW5nIHRvIG1ha2Ugc3VyZSB0aGUgY29ubmVjdGlvbiBpcyBoZWFsdGh5LlxuICAgICAgICAgICAgdGhpcy5sb2dfKCdzZW5kaW5nIHBpbmcgb24gc2Vjb25kYXJ5LicpO1xuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5zZW5kKHsgdDogJ2MnLCBkOiB7IHQ6IFBJTkcsIGQ6IHt9IH0gfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLnByb2NlZWRXaXRoVXBncmFkZV8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRlbGwgdGhpcyBjb25uZWN0aW9uIHRvIGNvbnNpZGVyIGl0c2VsZiBvcGVuXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8uc3RhcnQoKTtcbiAgICAgICAgLy8gc2VuZCBhY2tcbiAgICAgICAgdGhpcy5sb2dfKCdzZW5kaW5nIGNsaWVudCBhY2sgb24gc2Vjb25kYXJ5Jyk7XG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8uc2VuZCh7IHQ6ICdjJywgZDogeyB0OiBTV0lUQ0hfQUNLLCBkOiB7fSB9IH0pO1xuICAgICAgICAvLyBzZW5kIGVuZCBwYWNrZXQgb24gcHJpbWFyeSB0cmFuc3BvcnQsIHN3aXRjaCB0byBzZW5kaW5nIG9uIHRoaXMgb25lXG4gICAgICAgIC8vIGNhbiByZWNlaXZlIG9uIHRoaXMgb25lLCBidWZmZXIgcmVzcG9uc2VzIHVudGlsIGVuZCByZWNlaXZlZCBvbiBwcmltYXJ5IHRyYW5zcG9ydFxuICAgICAgICB0aGlzLmxvZ18oJ0VuZGluZyB0cmFuc21pc3Npb24gb24gcHJpbWFyeScpO1xuICAgICAgICB0aGlzLmNvbm5fLnNlbmQoeyB0OiAnYycsIGQ6IHsgdDogRU5EX1RSQU5TTUlTU0lPTiwgZDoge30gfSB9KTtcbiAgICAgICAgdGhpcy50eF8gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xuICAgICAgICB0aGlzLnRyeUNsZWFudXBDb25uZWN0aW9uKCk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5vblByaW1hcnlNZXNzYWdlUmVjZWl2ZWRfID0gZnVuY3Rpb24gKHBhcnNlZERhdGEpIHtcbiAgICAgICAgLy8gTXVzdCByZWZlciB0byBwYXJzZWREYXRhIHByb3BlcnRpZXMgaW4gcXVvdGVzLCBzbyBjbG9zdXJlIGRvZXNuJ3QgdG91Y2ggdGhlbS5cbiAgICAgICAgdmFyIGxheWVyID0gcmVxdWlyZUtleSgndCcsIHBhcnNlZERhdGEpO1xuICAgICAgICB2YXIgZGF0YSA9IHJlcXVpcmVLZXkoJ2QnLCBwYXJzZWREYXRhKTtcbiAgICAgICAgaWYgKGxheWVyID09ICdjJykge1xuICAgICAgICAgICAgdGhpcy5vbkNvbnRyb2xfKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxheWVyID09ICdkJykge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGFNZXNzYWdlXyhkYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUub25EYXRhTWVzc2FnZV8gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLm9uUHJpbWFyeVJlc3BvbnNlXygpO1xuICAgICAgICAvLyBXZSBkb24ndCBkbyBhbnl0aGluZyB3aXRoIGRhdGEgbWVzc2FnZXMsIGp1c3Qga2ljayB0aGVtIHVwIGEgbGV2ZWxcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2VfKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUub25QcmltYXJ5UmVzcG9uc2VfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNIZWFsdGh5Xykge1xuICAgICAgICAgICAgdGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfLS07XG4gICAgICAgICAgICBpZiAodGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfIDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ1ByaW1hcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LicpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uXy5tYXJrQ29ubmVjdGlvbkhlYWx0aHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUub25Db250cm9sXyA9IGZ1bmN0aW9uIChjb250cm9sRGF0YSkge1xuICAgICAgICB2YXIgY21kID0gcmVxdWlyZUtleShNRVNTQUdFX1RZUEUsIGNvbnRyb2xEYXRhKTtcbiAgICAgICAgaWYgKE1FU1NBR0VfREFUQSBpbiBjb250cm9sRGF0YSkge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBjb250cm9sRGF0YVtNRVNTQUdFX0RBVEFdO1xuICAgICAgICAgICAgaWYgKGNtZCA9PT0gU0VSVkVSX0hFTExPKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkhhbmRzaGFrZV8ocGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IEVORF9UUkFOU01JU1NJT04pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ3JlY3ZkIGVuZCB0cmFuc21pc3Npb24gb24gcHJpbWFyeScpO1xuICAgICAgICAgICAgICAgIHRoaXMucnhfID0gdGhpcy5zZWNvbmRhcnlDb25uXztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGVuZGluZ0RhdGFNZXNzYWdlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YU1lc3NhZ2VfKHRoaXMucGVuZGluZ0RhdGFNZXNzYWdlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0RhdGFNZXNzYWdlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5Q2xlYW51cENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gQ09OVFJPTF9TSFVURE9XTikge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2FzIHByZXZpb3VzbHkgdGhlICdvbktpbGwnIGNhbGxiYWNrIHBhc3NlZCB0byB0aGUgbG93ZXItbGV2ZWwgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgIC8vIHBheWxvYWQgaW4gdGhpcyBjYXNlIGlzIHRoZSByZWFzb24gZm9yIHRoZSBzaHV0ZG93bi4gR2VuZXJhbGx5IGEgaHVtYW4tcmVhZGFibGUgZXJyb3JcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29ubmVjdGlvblNodXRkb3duXyhwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gQ09OVFJPTF9SRVNFVCkge1xuICAgICAgICAgICAgICAgIC8vIHBheWxvYWQgaW4gdGhpcyBjYXNlIGlzIHRoZSBob3N0IHdlIHNob3VsZCBjb250YWN0XG4gICAgICAgICAgICAgICAgdGhpcy5vblJlc2V0XyhwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gQ09OVFJPTF9FUlJPUikge1xuICAgICAgICAgICAgICAgIGVycm9yKCdTZXJ2ZXIgRXJyb3I6ICcgKyBwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gQ09OVFJPTF9QT05HKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdnb3QgcG9uZyBvbiBwcmltYXJ5LicpO1xuICAgICAgICAgICAgICAgIHRoaXMub25QcmltYXJ5UmVzcG9uc2VfKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kUGluZ09uUHJpbWFyeUlmTmVjZXNzYXJ5XygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ1Vua25vd24gY29udHJvbCBwYWNrZXQgY29tbWFuZDogJyArIGNtZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRzaGFrZSBUaGUgaGFuZHNoYWtlIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5vbkhhbmRzaGFrZV8gPSBmdW5jdGlvbiAoaGFuZHNoYWtlKSB7XG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBoYW5kc2hha2UudHM7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gaGFuZHNoYWtlLnY7XG4gICAgICAgIHZhciBob3N0ID0gaGFuZHNoYWtlLmg7XG4gICAgICAgIHRoaXMuc2Vzc2lvbklkID0gaGFuZHNoYWtlLnM7XG4gICAgICAgIHRoaXMucmVwb0luZm9fLnVwZGF0ZUhvc3QoaG9zdCk7XG4gICAgICAgIC8vIGlmIHdlJ3ZlIGFscmVhZHkgY2xvc2VkIHRoZSBjb25uZWN0aW9uLCB0aGVuIGRvbid0IGJvdGhlciB0cnlpbmcgdG8gcHJvZ3Jlc3MgZnVydGhlclxuICAgICAgICBpZiAodGhpcy5zdGF0ZV8gPT0gMCAvKiBDT05ORUNUSU5HICovKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5fLnN0YXJ0KCk7XG4gICAgICAgICAgICB0aGlzLm9uQ29ubmVjdGlvbkVzdGFibGlzaGVkXyh0aGlzLmNvbm5fLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgaWYgKFBST1RPQ09MX1ZFUlNJT04gIT09IHZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdQcm90b2NvbCB2ZXJzaW9uIG1pc21hdGNoIGRldGVjdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBkbyB3ZSB3YW50IHRvIHVwZ3JhZGU/IHdoZW4/IG1heWJlIGEgZGVsYXk/XG4gICAgICAgICAgICB0aGlzLnRyeVN0YXJ0VXBncmFkZV8oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUudHJ5U3RhcnRVcGdyYWRlXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbm4gPSB0aGlzLnRyYW5zcG9ydE1hbmFnZXJfLnVwZ3JhZGVUcmFuc3BvcnQoKTtcbiAgICAgICAgaWYgKGNvbm4pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRVcGdyYWRlXyhjb25uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RhcnRVcGdyYWRlXyA9IGZ1bmN0aW9uIChjb25uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8gPSBuZXcgY29ubih0aGlzLm5leHRUcmFuc3BvcnRJZF8oKSwgdGhpcy5yZXBvSW5mb18sIHRoaXMuc2Vzc2lvbklkKTtcbiAgICAgICAgLy8gRm9yIGNlcnRhaW4gdHJhbnNwb3J0cyAoV2ViU29ja2V0cyksIHdlIG5lZWQgdG8gc2VuZCBhbmQgcmVjZWl2ZSBzZXZlcmFsIG1lc3NhZ2VzIGJhY2sgYW5kIGZvcnRoIGJlZm9yZSB3ZVxuICAgICAgICAvLyBjYW4gY29uc2lkZXIgdGhlIHRyYW5zcG9ydCBoZWFsdGh5LlxuICAgICAgICB0aGlzLnNlY29uZGFyeVJlc3BvbnNlc1JlcXVpcmVkXyA9XG4gICAgICAgICAgICBjb25uWydyZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5J10gfHwgMDtcbiAgICAgICAgdmFyIG9uTWVzc2FnZSA9IHRoaXMuY29ublJlY2VpdmVyXyh0aGlzLnNlY29uZGFyeUNvbm5fKTtcbiAgICAgICAgdmFyIG9uRGlzY29ubmVjdCA9IHRoaXMuZGlzY29ublJlY2VpdmVyXyh0aGlzLnNlY29uZGFyeUNvbm5fKTtcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5vcGVuKG9uTWVzc2FnZSwgb25EaXNjb25uZWN0KTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBzdWNjZXNzZnVsbHkgdXBncmFkZWQgYWZ0ZXIgVVBHUkFERV9USU1FT1VULCBnaXZlIHVwIGFuZCBraWxsIHRoZSBzZWNvbmRhcnkuXG4gICAgICAgIHNldFRpbWVvdXROb25CbG9ja2luZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dfKCdUaW1lZCBvdXQgdHJ5aW5nIHRvIHVwZ3JhZGUuJyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2Vjb25kYXJ5Q29ubl8uY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgTWF0aC5mbG9vcihVUEdSQURFX1RJTUVPVVQpKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLm9uUmVzZXRfID0gZnVuY3Rpb24gKGhvc3QpIHtcbiAgICAgICAgdGhpcy5sb2dfKCdSZXNldCBwYWNrZXQgcmVjZWl2ZWQuICBOZXcgaG9zdDogJyArIGhvc3QpO1xuICAgICAgICB0aGlzLnJlcG9JbmZvXy51cGRhdGVIb3N0KGhvc3QpO1xuICAgICAgICAvLyBUT0RPOiBpZiB3ZSdyZSBhbHJlYWR5IFwiY29ubmVjdGVkXCIsIHdlIG5lZWQgdG8gdHJpZ2dlciBhIGRpc2Nvbm5lY3QgYXQgdGhlIG5leHQgbGF5ZXIgdXAuXG4gICAgICAgIC8vIFdlIGRvbid0IGN1cnJlbnRseSBzdXBwb3J0IHJlc2V0cyBhZnRlciB0aGUgY29ubmVjdGlvbiBoYXMgYWxyZWFkeSBiZWVuIGVzdGFibGlzaGVkXG4gICAgICAgIGlmICh0aGlzLnN0YXRlXyA9PT0gMSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENsb3NlIHdoYXRldmVyIGNvbm5lY3Rpb25zIHdlIGhhdmUgb3BlbiBhbmQgc3RhcnQgYWdhaW4uXG4gICAgICAgICAgICB0aGlzLmNsb3NlQ29ubmVjdGlvbnNfKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0XygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5vbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZF8gPSBmdW5jdGlvbiAoY29ubiwgdGltZXN0YW1wKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubG9nXygnUmVhbHRpbWUgY29ubmVjdGlvbiBlc3RhYmxpc2hlZC4nKTtcbiAgICAgICAgdGhpcy5jb25uXyA9IGNvbm47XG4gICAgICAgIHRoaXMuc3RhdGVfID0gMSAvKiBDT05ORUNURUQgKi87XG4gICAgICAgIGlmICh0aGlzLm9uUmVhZHlfKSB7XG4gICAgICAgICAgICB0aGlzLm9uUmVhZHlfKHRpbWVzdGFtcCwgdGhpcy5zZXNzaW9uSWQpO1xuICAgICAgICAgICAgdGhpcy5vblJlYWR5XyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYWZ0ZXIgNSBzZWNvbmRzIHdlIGhhdmVuJ3Qgc2VudCBlbm91Z2ggcmVxdWVzdHMgdG8gdGhlIHNlcnZlciB0byBnZXQgdGhlIGNvbm5lY3Rpb24gaGVhbHRoeSxcbiAgICAgICAgLy8gc2VuZCBzb21lIHBpbmdzLlxuICAgICAgICBpZiAodGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1ByaW1hcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LicpO1xuICAgICAgICAgICAgdGhpcy5pc0hlYWx0aHlfID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXROb25CbG9ja2luZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VuZFBpbmdPblByaW1hcnlJZk5lY2Vzc2FyeV8oKTtcbiAgICAgICAgICAgIH0sIE1hdGguZmxvb3IoREVMQVlfQkVGT1JFX1NFTkRJTkdfRVhUUkFfUkVRVUVTVFMpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZFBpbmdPblByaW1hcnlJZk5lY2Vzc2FyeV8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElmIHRoZSBjb25uZWN0aW9uIGlzbid0IGNvbnNpZGVyZWQgaGVhbHRoeSB5ZXQsIHdlJ2xsIHNlbmQgYSBub29wIHBpbmcgcGFja2V0IHJlcXVlc3QuXG4gICAgICAgIGlmICghdGhpcy5pc0hlYWx0aHlfICYmIHRoaXMuc3RhdGVfID09PSAxIC8qIENPTk5FQ1RFRCAqLykge1xuICAgICAgICAgICAgdGhpcy5sb2dfKCdzZW5kaW5nIHBpbmcgb24gcHJpbWFyeS4nKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZERhdGFfKHsgdDogJ2MnLCBkOiB7IHQ6IFBJTkcsIGQ6IHt9IH0gfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLm9uU2Vjb25kYXJ5Q29ubmVjdGlvbkxvc3RfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29ubiA9IHRoaXMuc2Vjb25kYXJ5Q29ubl87XG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy50eF8gPT09IGNvbm4gfHwgdGhpcy5yeF8gPT09IGNvbm4pIHtcbiAgICAgICAgICAgIC8vIHdlIGFyZSByZWx5aW5nIG9uIHRoaXMgY29ubmVjdGlvbiBhbHJlYWR5IGluIHNvbWUgY2FwYWNpdHkuIFRoZXJlZm9yZSwgYSBmYWlsdXJlIGlzIHJlYWxcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV2ZXJDb25uZWN0ZWQgV2hldGhlciBvciBub3QgdGhlIGNvbm5lY3Rpb24gZXZlciByZWFjaGVkIGEgc2VydmVyLiBVc2VkIHRvIGRldGVybWluZSBpZlxuICAgICAqIHdlIHNob3VsZCBmbHVzaCB0aGUgaG9zdCBjYWNoZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUub25Db25uZWN0aW9uTG9zdF8gPSBmdW5jdGlvbiAoZXZlckNvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLmNvbm5fID0gbnVsbDtcbiAgICAgICAgLy8gTk9URTogSUYgeW91J3JlIHNlZWluZyBhIEZpcmVmb3ggZXJyb3IgZm9yIHRoaXMgbGluZSwgSSB0aGluayBpdCBtaWdodCBiZSBiZWNhdXNlIGl0J3MgZ2V0dGluZ1xuICAgICAgICAvLyBjYWxsZWQgb24gd2luZG93IGNsb3NlIGFuZCBSZWFsdGltZVN0YXRlLkNPTk5FQ1RJTkcgaXMgbm8gbG9uZ2VyIGRlZmluZWQuICBKdXN0IGEgZ3Vlc3MuXG4gICAgICAgIGlmICghZXZlckNvbm5lY3RlZCAmJiB0aGlzLnN0YXRlXyA9PT0gMCAvKiBDT05ORUNUSU5HICovKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1JlYWx0aW1lIGNvbm5lY3Rpb24gZmFpbGVkLicpO1xuICAgICAgICAgICAgLy8gU2luY2Ugd2UgZmFpbGVkIHRvIGNvbm5lY3QgYXQgYWxsLCBjbGVhciBhbnkgY2FjaGVkIGVudHJ5IGZvciB0aGlzIG5hbWVzcGFjZSBpbiBjYXNlIHRoZSBtYWNoaW5lIHdlbnQgYXdheVxuICAgICAgICAgICAgaWYgKHRoaXMucmVwb0luZm9fLmlzQ2FjaGVhYmxlSG9zdCgpKSB7XG4gICAgICAgICAgICAgICAgUGVyc2lzdGVudFN0b3JhZ2UucmVtb3ZlKCdob3N0OicgKyB0aGlzLnJlcG9JbmZvXy5ob3N0KTtcbiAgICAgICAgICAgICAgICAvLyByZXNldCB0aGUgaW50ZXJuYWwgaG9zdCB0byB3aGF0IHdlIHdvdWxkIHNob3cgdGhlIHVzZXIsIGkuZS4gPG5zPi5maXJlYmFzZWlvLmNvbVxuICAgICAgICAgICAgICAgIHRoaXMucmVwb0luZm9fLmludGVybmFsSG9zdCA9IHRoaXMucmVwb0luZm9fLmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZV8gPT09IDEgLyogQ09OTkVDVEVEICovKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1JlYWx0aW1lIGNvbm5lY3Rpb24gbG9zdC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLm9uQ29ubmVjdGlvblNodXRkb3duXyA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhpcy5sb2dfKCdDb25uZWN0aW9uIHNodXRkb3duIGNvbW1hbmQgcmVjZWl2ZWQuIFNodXR0aW5nIGRvd24uLi4nKTtcbiAgICAgICAgaWYgKHRoaXMub25LaWxsXykge1xuICAgICAgICAgICAgdGhpcy5vbktpbGxfKHJlYXNvbik7XG4gICAgICAgICAgICB0aGlzLm9uS2lsbF8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3Qgd2FudCB0byBmaXJlIG9uRGlzY29ubmVjdCAoa2lsbCBpcyBhIGRpZmZlcmVudCBjYXNlKSxcbiAgICAgICAgLy8gc28gY2xlYXIgdGhlIGNhbGxiYWNrLlxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBudWxsO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kRGF0YV8gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZV8gIT09IDEgLyogQ09OTkVDVEVEICovKSB7XG4gICAgICAgICAgICB0aHJvdyAnQ29ubmVjdGlvbiBpcyBub3QgY29ubmVjdGVkJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHhfLnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCB0aGlzIGNvbm5lY3Rpb24sIGNhbGxpbmcgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZV8gIT09IDIgLyogRElTQ09OTkVDVEVEICovKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0Nsb3NpbmcgcmVhbHRpbWUgY29ubmVjdGlvbi4nKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVfID0gMiAvKiBESVNDT05ORUNURUQgKi87XG4gICAgICAgICAgICB0aGlzLmNsb3NlQ29ubmVjdGlvbnNfKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5vbkRpc2Nvbm5lY3RfKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlQ29ubmVjdGlvbnNfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZ18oJ1NodXR0aW5nIGRvd24gYWxsIGNvbm5lY3Rpb25zJyk7XG4gICAgICAgIGlmICh0aGlzLmNvbm5fKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5fLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5fID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZWNvbmRhcnlDb25uXykge1xuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGVhbHRoeVRpbWVvdXRfKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oZWFsdGh5VGltZW91dF8pO1xuICAgICAgICAgICAgdGhpcy5oZWFsdGh5VGltZW91dF8gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGlvbjtcbn0oKSk7XG5leHBvcnQgeyBDb25uZWN0aW9uIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL3JlYWx0aW1lL0Nvbm5lY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgZmlyZWJhc2UgZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBsb2dXcmFwcGVyLCBzcGxpdFN0cmluZ0J5U2l6ZSB9IGZyb20gJy4uL2NvcmUvdXRpbC91dGlsJztcbmltcG9ydCB7IFN0YXRzTWFuYWdlciB9IGZyb20gJy4uL2NvcmUvc3RhdHMvU3RhdHNNYW5hZ2VyJztcbmltcG9ydCB7IEZPUkdFX0RPTUFJTiwgRk9SR0VfUkVGLCBMQVNUX1NFU1NJT05fUEFSQU0sIFBST1RPQ09MX1ZFUlNJT04sIFJFRkVSRVJfUEFSQU0sIFRSQU5TUE9SVF9TRVNTSU9OX1BBUkFNLCBWRVJTSU9OX1BBUkFNLCBXRUJTT0NLRVQgfSBmcm9tICcuL0NvbnN0YW50cyc7XG5pbXBvcnQgeyBDT05TVEFOVFMgYXMgRU5WX0NPTlNUQU5UUyB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IFBlcnNpc3RlbnRTdG9yYWdlIH0gZnJvbSAnLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2UnO1xuaW1wb3J0IHsganNvbkV2YWwsIHN0cmluZ2lmeSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IGlzTm9kZVNkayB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbnZhciBXRUJTT0NLRVRfTUFYX0ZSQU1FX1NJWkUgPSAxNjM4NDtcbnZhciBXRUJTT0NLRVRfS0VFUEFMSVZFX0lOVEVSVkFMID0gNDUwMDA7XG52YXIgV2ViU29ja2V0SW1wbCA9IG51bGw7XG5pZiAodHlwZW9mIE1veldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBXZWJTb2NrZXRJbXBsID0gTW96V2ViU29ja2V0O1xufVxuZWxzZSBpZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBXZWJTb2NrZXRJbXBsID0gV2ViU29ja2V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldFdlYlNvY2tldEltcGwoaW1wbCkge1xuICAgIFdlYlNvY2tldEltcGwgPSBpbXBsO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgd2Vic29ja2V0IGNvbm5lY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gY2FsbGJhY2tzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7VHJhbnNwb3J0fVxuICovXG52YXIgV2ViU29ja2V0Q29ubmVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29ubklkIGlkZW50aWZpZXIgZm9yIHRoaXMgdHJhbnNwb3J0XG4gICAgICogQHBhcmFtIHtSZXBvSW5mb30gcmVwb0luZm8gVGhlIGluZm8gZm9yIHRoZSB3ZWJzb2NrZXQgZW5kcG9pbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSB0cmFuc3BvcnRTZXNzaW9uSWQgT3B0aW9uYWwgdHJhbnNwb3J0U2Vzc2lvbklkIGlmIHRoaXMgaXMgY29ubmVjdGluZyB0byBhbiBleGlzdGluZyB0cmFuc3BvcnRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gbGFzdFNlc3Npb25JZCBPcHRpb25hbCBsYXN0U2Vzc2lvbklkIGlmIHRoZXJlIHdhcyBhIHByZXZpb3VzIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBXZWJTb2NrZXRDb25uZWN0aW9uKGNvbm5JZCwgcmVwb0luZm8sIHRyYW5zcG9ydFNlc3Npb25JZCwgbGFzdFNlc3Npb25JZCkge1xuICAgICAgICB0aGlzLmNvbm5JZCA9IGNvbm5JZDtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuZnJhbWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy50b3RhbEZyYW1lcyA9IDA7XG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ID0gMDtcbiAgICAgICAgdGhpcy5ieXRlc1JlY2VpdmVkID0gMDtcbiAgICAgICAgdGhpcy5sb2dfID0gbG9nV3JhcHBlcih0aGlzLmNvbm5JZCk7XG4gICAgICAgIHRoaXMuc3RhdHNfID0gU3RhdHNNYW5hZ2VyLmdldENvbGxlY3Rpb24ocmVwb0luZm8pO1xuICAgICAgICB0aGlzLmNvbm5VUkwgPSBXZWJTb2NrZXRDb25uZWN0aW9uLmNvbm5lY3Rpb25VUkxfKHJlcG9JbmZvLCB0cmFuc3BvcnRTZXNzaW9uSWQsIGxhc3RTZXNzaW9uSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlcG9JbmZvfSByZXBvSW5mbyBUaGUgaW5mbyBmb3IgdGhlIHdlYnNvY2tldCBlbmRwb2ludC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHRyYW5zcG9ydFNlc3Npb25JZCBPcHRpb25hbCB0cmFuc3BvcnRTZXNzaW9uSWQgaWYgdGhpcyBpcyBjb25uZWN0aW5nIHRvIGFuIGV4aXN0aW5nIHRyYW5zcG9ydFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBsYXN0U2Vzc2lvbklkIE9wdGlvbmFsIGxhc3RTZXNzaW9uSWQgaWYgdGhlcmUgd2FzIGEgcHJldmlvdXMgY29ubmVjdGlvblxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gY29ubmVjdGlvbiB1cmxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24uY29ubmVjdGlvblVSTF8gPSBmdW5jdGlvbiAocmVwb0luZm8sIHRyYW5zcG9ydFNlc3Npb25JZCwgbGFzdFNlc3Npb25JZCkge1xuICAgICAgICB2YXIgdXJsUGFyYW1zID0ge307XG4gICAgICAgIHVybFBhcmFtc1tWRVJTSU9OX1BBUkFNXSA9IFBST1RPQ09MX1ZFUlNJT047XG4gICAgICAgIGlmICghaXNOb2RlU2RrKCkgJiZcbiAgICAgICAgICAgIHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGxvY2F0aW9uLmhyZWYgJiZcbiAgICAgICAgICAgIGxvY2F0aW9uLmhyZWYuaW5kZXhPZihGT1JHRV9ET01BSU4pICE9PSAtMSkge1xuICAgICAgICAgICAgdXJsUGFyYW1zW1JFRkVSRVJfUEFSQU1dID0gRk9SR0VfUkVGO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc3BvcnRTZXNzaW9uSWQpIHtcbiAgICAgICAgICAgIHVybFBhcmFtc1tUUkFOU1BPUlRfU0VTU0lPTl9QQVJBTV0gPSB0cmFuc3BvcnRTZXNzaW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RTZXNzaW9uSWQpIHtcbiAgICAgICAgICAgIHVybFBhcmFtc1tMQVNUX1NFU1NJT05fUEFSQU1dID0gbGFzdFNlc3Npb25JZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVwb0luZm8uY29ubmVjdGlvblVSTChXRUJTT0NLRVQsIHVybFBhcmFtcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvbk1lc3NhZ2UgQ2FsbGJhY2sgd2hlbiBtZXNzYWdlcyBhcnJpdmVcbiAgICAgKiBAcGFyYW0gb25EaXNjb25uZWN0IENhbGxiYWNrIHdpdGggY29ubmVjdGlvbiBsb3N0LlxuICAgICAqL1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAob25NZXNzYWdlLCBvbkRpc2Nvbm5lY3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QgPSBvbkRpc2Nvbm5lY3Q7XG4gICAgICAgIHRoaXMub25NZXNzYWdlID0gb25NZXNzYWdlO1xuICAgICAgICB0aGlzLmxvZ18oJ1dlYnNvY2tldCBjb25uZWN0aW5nIHRvICcgKyB0aGlzLmNvbm5VUkwpO1xuICAgICAgICB0aGlzLmV2ZXJDb25uZWN0ZWRfID0gZmFsc2U7XG4gICAgICAgIC8vIEFzc3VtZSBmYWlsdXJlIHVudGlsIHByb3ZlbiBvdGhlcndpc2UuXG4gICAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLnNldCgncHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmUnLCB0cnVlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpc05vZGVTZGsoKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXZpY2UgPSBFTlZfQ09OU1RBTlRTLk5PREVfQURNSU4gPyAnQWRtaW5Ob2RlJyA6ICdOb2RlJztcbiAgICAgICAgICAgICAgICAvLyBVQSBGb3JtYXQ6IEZpcmViYXNlLzx3aXJlX3Byb3RvY29sPi88c2RrX3ZlcnNpb24+LzxwbGF0Zm9ybT4vPGRldmljZT5cbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBcIkZpcmViYXNlL1wiICsgUFJPVE9DT0xfVkVSU0lPTiArIFwiL1wiICsgZmlyZWJhc2UuU0RLX1ZFUlNJT04gKyBcIi9cIiArIHByb2Nlc3MucGxhdGZvcm0gKyBcIi9cIiArIGRldmljZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBQbHVtYiBhcHByb3ByaWF0ZSBodHRwX3Byb3h5IGVudmlyb25tZW50IHZhcmlhYmxlIGludG8gZmF5ZS13ZWJzb2NrZXQgaWYgaXQgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHZhciBlbnYgPSBwcm9jZXNzWydlbnYnXTtcbiAgICAgICAgICAgICAgICB2YXIgcHJveHkgPSB0aGlzLmNvbm5VUkwuaW5kZXhPZignd3NzOi8vJykgPT0gMFxuICAgICAgICAgICAgICAgICAgICA/IGVudlsnSFRUUFNfUFJPWFknXSB8fCBlbnZbJ2h0dHBzX3Byb3h5J11cbiAgICAgICAgICAgICAgICAgICAgOiBlbnZbJ0hUVFBfUFJPWFknXSB8fCBlbnZbJ2h0dHBfcHJveHknXTtcbiAgICAgICAgICAgICAgICBpZiAocHJveHkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1sncHJveHknXSA9IHsgb3JpZ2luOiBwcm94eSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm15U29jayA9IG5ldyBXZWJTb2NrZXRJbXBsKHRoaXMuY29ublVSTCwgW10sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5teVNvY2sgPSBuZXcgV2ViU29ja2V0SW1wbCh0aGlzLmNvbm5VUkwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0Vycm9yIGluc3RhbnRpYXRpbmcgV2ViU29ja2V0LicpO1xuICAgICAgICAgICAgdmFyIGVycm9yID0gZS5tZXNzYWdlIHx8IGUuZGF0YTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nXyhlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubXlTb2NrLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ18oJ1dlYnNvY2tldCBjb25uZWN0ZWQuJyk7XG4gICAgICAgICAgICBfdGhpcy5ldmVyQ29ubmVjdGVkXyA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubXlTb2NrLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5sb2dfKCdXZWJzb2NrZXQgY29ubmVjdGlvbiB3YXMgZGlzY29ubmVjdGVkLicpO1xuICAgICAgICAgICAgX3RoaXMubXlTb2NrID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLm9uQ2xvc2VkXygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm15U29jay5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlSW5jb21pbmdGcmFtZShtKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5teVNvY2sub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5sb2dfKCdXZWJTb2NrZXQgZXJyb3IuICBDbG9zaW5nIGNvbm5lY3Rpb24uJyk7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBlLm1lc3NhZ2UgfHwgZS5kYXRhO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nXyhlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5vbkNsb3NlZF8oKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE5vLW9wIGZvciB3ZWJzb2NrZXRzLCB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIG9uY2UgdGhlIGNvbm5lY3Rpb24gaXMgY29uZmlybWVkIGFzIG9wZW5cbiAgICAgKi9cbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFdlYlNvY2tldENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvd18gPSB0cnVlO1xuICAgIH07XG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlzT2xkQW5kcm9pZCA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCkge1xuICAgICAgICAgICAgdmFyIG9sZEFuZHJvaWRSZWdleCA9IC9BbmRyb2lkIChbMC05XXswLH1cXC5bMC05XXswLH0pLztcbiAgICAgICAgICAgIHZhciBvbGRBbmRyb2lkTWF0Y2ggPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKG9sZEFuZHJvaWRSZWdleCk7XG4gICAgICAgICAgICBpZiAob2xkQW5kcm9pZE1hdGNoICYmIG9sZEFuZHJvaWRNYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQob2xkQW5kcm9pZE1hdGNoWzFdKSA8IDQuNCkge1xuICAgICAgICAgICAgICAgICAgICBpc09sZEFuZHJvaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCFpc09sZEFuZHJvaWQgJiZcbiAgICAgICAgICAgIFdlYlNvY2tldEltcGwgIT09IG51bGwgJiZcbiAgICAgICAgICAgICFXZWJTb2NrZXRDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3dfKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB3ZSBwcmV2aW91c2x5IGZhaWxlZCB0byBjb25uZWN0IHdpdGggdGhpcyB0cmFuc3BvcnQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLnByZXZpb3VzbHlGYWlsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElmIG91ciBwZXJzaXN0ZW50IHN0b3JhZ2UgaXMgYWN0dWFsbHkgb25seSBpbi1tZW1vcnkgc3RvcmFnZSxcbiAgICAgICAgLy8gd2UgZGVmYXVsdCB0byBhc3N1bWluZyB0aGF0IGl0IHByZXZpb3VzbHkgZmFpbGVkIHRvIGJlIHNhZmUuXG4gICAgICAgIHJldHVybiAoUGVyc2lzdGVudFN0b3JhZ2UuaXNJbk1lbW9yeVN0b3JhZ2UgfHxcbiAgICAgICAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLmdldCgncHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmUnKSA9PT0gdHJ1ZSk7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5tYXJrQ29ubmVjdGlvbkhlYWx0aHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLnJlbW92ZSgncHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmUnKTtcbiAgICB9O1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmFwcGVuZEZyYW1lXyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuZnJhbWVzLnB1c2goZGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmZyYW1lcy5sZW5ndGggPT0gdGhpcy50b3RhbEZyYW1lcykge1xuICAgICAgICAgICAgdmFyIGZ1bGxNZXNzID0gdGhpcy5mcmFtZXMuam9pbignJyk7XG4gICAgICAgICAgICB0aGlzLmZyYW1lcyA9IG51bGw7XG4gICAgICAgICAgICB2YXIganNvbk1lc3MgPSBqc29uRXZhbChmdWxsTWVzcyk7XG4gICAgICAgICAgICAvL2hhbmRsZSB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2UoanNvbk1lc3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZnJhbWVDb3VudCBUaGUgbnVtYmVyIG9mIGZyYW1lcyB3ZSBhcmUgZXhwZWN0aW5nIGZyb20gdGhlIHNlcnZlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlTmV3RnJhbWVDb3VudF8gPSBmdW5jdGlvbiAoZnJhbWVDb3VudCkge1xuICAgICAgICB0aGlzLnRvdGFsRnJhbWVzID0gZnJhbWVDb3VudDtcbiAgICAgICAgdGhpcy5mcmFtZXMgPSBbXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIHBhcnNlIGEgZnJhbWUgY291bnQgb3V0IG9mIHNvbWUgdGV4dC4gSWYgaXQgY2FuJ3QsIGFzc3VtZXMgYSB2YWx1ZSBvZiAxXG4gICAgICogQHBhcmFtIHshU3RyaW5nfSBkYXRhXG4gICAgICogQHJldHVybiB7P1N0cmluZ30gQW55IHJlbWFpbmluZyBkYXRhIHRvIGJlIHByb2Nlc3MsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9uZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuZXh0cmFjdEZyYW1lQ291bnRfID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuZnJhbWVzID09PSBudWxsLCAnV2UgYWxyZWFkeSBoYXZlIGEgZnJhbWUgYnVmZmVyJyk7XG4gICAgICAgIC8vIFRPRE86IFRoZSBzZXJ2ZXIgaXMgb25seSBzdXBwb3NlZCB0byBzZW5kIHVwIHRvIDk5OTkgZnJhbWVzIChpLmUuIGxlbmd0aCA8PSA0KSwgYnV0IHRoYXQgaXNuJ3QgYmVpbmcgZW5mb3JjZWRcbiAgICAgICAgLy8gY3VycmVudGx5LiAgU28gYWxsb3dpbmcgbGFyZ2VyIGZyYW1lIGNvdW50cyAobGVuZ3RoIDw9IDYpLiAgU2VlIGh0dHBzOi8vYXBwLmFzYW5hLmNvbS8wL3NlYXJjaC84Njg4NTk4OTk4MzgwLzgyMzc2MDgwNDI1MDhcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDw9IDYpIHtcbiAgICAgICAgICAgIHZhciBmcmFtZUNvdW50ID0gTnVtYmVyKGRhdGEpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihmcmFtZUNvdW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTmV3RnJhbWVDb3VudF8oZnJhbWVDb3VudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVOZXdGcmFtZUNvdW50XygxKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgd2Vic29ja2V0IGZyYW1lIHRoYXQgaGFzIGFycml2ZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSBtZXNzIFRoZSBmcmFtZSBkYXRhXG4gICAgICovXG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlSW5jb21pbmdGcmFtZSA9IGZ1bmN0aW9uIChtZXNzKSB7XG4gICAgICAgIGlmICh0aGlzLm15U29jayA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjsgLy8gQ2hyb21lIGFwcGFyZW50bHkgZGVsaXZlcnMgaW5jb21pbmcgcGFja2V0cyBldmVuIGFmdGVyIHdlIC5jbG9zZSgpIHRoZSBjb25uZWN0aW9uIHNvbWV0aW1lcy5cbiAgICAgICAgdmFyIGRhdGEgPSBtZXNzWydkYXRhJ107XG4gICAgICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5zdGF0c18uaW5jcmVtZW50Q291bnRlcignYnl0ZXNfcmVjZWl2ZWQnLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgIHRoaXMucmVzZXRLZWVwQWxpdmUoKTtcbiAgICAgICAgaWYgKHRoaXMuZnJhbWVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB3ZSdyZSBidWZmZXJpbmdcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kRnJhbWVfKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdHJ5IHRvIHBhcnNlIG91dCBhIGZyYW1lIGNvdW50LCBvdGhlcndpc2UsIGFzc3VtZSAxIGFuZCBwcm9jZXNzIGl0XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nRGF0YSA9IHRoaXMuZXh0cmFjdEZyYW1lQ291bnRfKGRhdGEpO1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0RhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZEZyYW1lXyhyZW1haW5pbmdEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIHNlcnZlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBKU09OIG9iamVjdCB0byB0cmFuc21pdFxuICAgICAqL1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLnJlc2V0S2VlcEFsaXZlKCk7XG4gICAgICAgIHZhciBkYXRhU3RyID0gc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICB0aGlzLmJ5dGVzU2VudCArPSBkYXRhU3RyLmxlbmd0aDtcbiAgICAgICAgdGhpcy5zdGF0c18uaW5jcmVtZW50Q291bnRlcignYnl0ZXNfc2VudCcsIGRhdGFTdHIubGVuZ3RoKTtcbiAgICAgICAgLy9XZSBjYW4gb25seSBmaXQgYSBjZXJ0YWluIGFtb3VudCBpbiBlYWNoIHdlYnNvY2tldCBmcmFtZSwgc28gd2UgbmVlZCB0byBzcGxpdCB0aGlzIHJlcXVlc3RcbiAgICAgICAgLy91cCBpbnRvIG11bHRpcGxlIHBpZWNlcyBpZiBpdCBkb2Vzbid0IGZpdCBpbiBvbmUgcmVxdWVzdC5cbiAgICAgICAgdmFyIGRhdGFTZWdzID0gc3BsaXRTdHJpbmdCeVNpemUoZGF0YVN0ciwgV0VCU09DS0VUX01BWF9GUkFNRV9TSVpFKTtcbiAgICAgICAgLy9TZW5kIHRoZSBsZW5ndGggaGVhZGVyXG4gICAgICAgIGlmIChkYXRhU2Vncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRTdHJpbmdfKFN0cmluZyhkYXRhU2Vncy5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICAvL1NlbmQgdGhlIGFjdHVhbCBkYXRhIGluIHNlZ21lbnRzLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFTZWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRTdHJpbmdfKGRhdGFTZWdzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2h1dGRvd25fID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzQ2xvc2VkXyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmtlZXBhbGl2ZVRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMua2VlcGFsaXZlVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubXlTb2NrKSB7XG4gICAgICAgICAgICB0aGlzLm15U29jay5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5teVNvY2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5vbkNsb3NlZF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0Nsb3NlZF8pIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2ViU29ja2V0IGlzIGNsb3NpbmcgaXRzZWxmJyk7XG4gICAgICAgICAgICB0aGlzLnNodXRkb3duXygpO1xuICAgICAgICAgICAgLy8gc2luY2UgdGhpcyBpcyBhbiBpbnRlcm5hbCBjbG9zZSwgdHJpZ2dlciB0aGUgY2xvc2UgbGlzdGVuZXJcbiAgICAgICAgICAgIGlmICh0aGlzLm9uRGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0KHRoaXMuZXZlckNvbm5lY3RlZF8pO1xuICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRXh0ZXJuYWwtZmFjaW5nIGNsb3NlIGhhbmRsZXIuXG4gICAgICogQ2xvc2UgdGhlIHdlYnNvY2tldCBhbmQga2lsbCB0aGUgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2xvc2VkXykge1xuICAgICAgICAgICAgdGhpcy5sb2dfKCdXZWJTb2NrZXQgaXMgYmVpbmcgY2xvc2VkJyk7XG4gICAgICAgICAgICB0aGlzLnNodXRkb3duXygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBLaWxsIHRoZSBjdXJyZW50IGtlZXBhbGl2ZSB0aW1lciBhbmQgc3RhcnQgYSBuZXcgb25lLCB0byBlbnN1cmUgdGhhdCBpdCBhbHdheXMgZmlyZXMgTiBzZWNvbmRzIGFmdGVyXG4gICAgICogdGhlIGxhc3QgYWN0aXZpdHkuXG4gICAgICovXG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUucmVzZXRLZWVwQWxpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5rZWVwYWxpdmVUaW1lcik7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvL0lmIHRoZXJlIGhhcyBiZWVuIG5vIHdlYnNvY2tldCBhY3Rpdml0eSBmb3IgYSB3aGlsZSwgc2VuZCBhIG5vLW9wXG4gICAgICAgICAgICBpZiAoX3RoaXMubXlTb2NrKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VuZFN0cmluZ18oJzAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnJlc2V0S2VlcEFsaXZlKCk7XG4gICAgICAgIH0sIE1hdGguZmxvb3IoV0VCU09DS0VUX0tFRVBBTElWRV9JTlRFUlZBTCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBhIHN0cmluZyBvdmVyIHRoZSB3ZWJzb2NrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBzZW5kLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZFN0cmluZ18gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIC8vIEZpcmVmb3ggc2VlbXMgdG8gc29tZXRpbWVzIHRocm93IGV4Y2VwdGlvbnMgKE5TX0VSUk9SX1VORVhQRUNURUQpIGZyb20gd2Vic29ja2V0IC5zZW5kKClcbiAgICAgICAgLy8gY2FsbHMgZm9yIHNvbWUgdW5rbm93biByZWFzb24uICBXZSB0cmVhdCB0aGVzZSBhcyBhbiBlcnJvciBhbmQgZGlzY29ubmVjdC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vYXBwLmFzYW5hLmNvbS8wLzU4OTI2MTExNDAyMjkyLzY4MDIxMzQwMjUwNDEwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLm15U29jay5zZW5kKHN0cik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnRXhjZXB0aW9uIHRocm93biBmcm9tIFdlYlNvY2tldC5zZW5kKCk6JywgZS5tZXNzYWdlIHx8IGUuZGF0YSwgJ0Nsb3NpbmcgY29ubmVjdGlvbi4nKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5vbkNsb3NlZF8uYmluZCh0aGlzKSwgMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiByZXNwb25zZSBiZWZvcmUgd2UgY29uc2lkZXIgdGhlIGNvbm5lY3Rpb24gXCJoZWFsdGh5LlwiXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLnJlc3BvbnNlc1JlcXVpcmVkVG9CZUhlYWx0aHkgPSAyO1xuICAgIC8qKlxuICAgICAqIFRpbWUgdG8gd2FpdCBmb3IgdGhlIGNvbm5lY3Rpb24gdGUgYmVjb21lIGhlYWx0aHkgYmVmb3JlIGdpdmluZyB1cC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24uaGVhbHRoeVRpbWVvdXQgPSAzMDAwMDtcbiAgICByZXR1cm4gV2ViU29ja2V0Q29ubmVjdGlvbjtcbn0oKSk7XG5leHBvcnQgeyBXZWJTb2NrZXRDb25uZWN0aW9uIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL3JlYWx0aW1lL1dlYlNvY2tldENvbm5lY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG4vKipcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcHJvdmlkZWQgYXNzZXJ0aW9uIGlzIGZhbHN5XG4gKiBAcGFyYW0geyp9IGFzc2VydGlvbiBUaGUgYXNzZXJ0aW9uIHRvIGJlIHRlc3RlZCBmb3IgZmFsc2luZXNzXG4gKiBAcGFyYW0geyFzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZGlzcGxheSBpZiB0aGUgY2hlY2sgZmFpbHNcbiAqL1xuZXhwb3J0IHZhciBhc3NlcnQgPSBmdW5jdGlvbiAoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IobWVzc2FnZSk7XG4gICAgfVxufTtcbi8qKlxuICogUmV0dXJucyBhbiBFcnJvciBvYmplY3Qgc3VpdGFibGUgZm9yIHRocm93aW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm4geyFFcnJvcn1cbiAqL1xuZXhwb3J0IHZhciBhc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignRmlyZWJhc2UgRGF0YWJhc2UgKCcgK1xuICAgICAgICBDT05TVEFOVFMuU0RLX1ZFUlNJT04gK1xuICAgICAgICAnKSBJTlRFUk5BTCBBU1NFUlQgRkFJTEVEOiAnICtcbiAgICAgICAgbWVzc2FnZSk7XG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL3V0aWwvZGlzdC9lc20vc3JjL2Fzc2VydC5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBzdHJpbmdUb0J5dGVBcnJheSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIHAgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHdoaWxlIChjID4gMjU1KSB7XG4gICAgICAgICAgICBvdXRwdXRbcCsrXSA9IGMgJiAyNTU7XG4gICAgICAgICAgICBjID4+PSA4O1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFtwKytdID0gYztcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIG51bWJlcnMgaW50byB0aGUgc3RyaW5nIGdpdmVuIGJ5IHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZVxuICogY2hhcmFjdGVycyB0byB3aGljaCB0aGUgbnVtYmVycyBjb3JyZXNwb25kLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBieXRlcyBBcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyBjaGFyYWN0ZXJzLlxuICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmdpZmljYXRpb24gb2YgdGhlIGFycmF5LlxuICovXG52YXIgYnl0ZUFycmF5VG9TdHJpbmcgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICB2YXIgQ0hVTktfU0laRSA9IDgxOTI7XG4gICAgLy8gU3BlY2lhbC1jYXNlIHRoZSBzaW1wbGUgY2FzZSBmb3Igc3BlZWQncyBzYWtlLlxuICAgIGlmIChieXRlcy5sZW5ndGggPCBDSFVOS19TSVpFKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKTtcbiAgICB9XG4gICAgLy8gVGhlIHJlbWFpbmluZyBsb2dpYyBzcGxpdHMgY29udmVyc2lvbiBieSBjaHVua3Mgc2luY2VcbiAgICAvLyBGdW5jdGlvbiNhcHBseSgpIGhhcyBhIG1heGltdW0gcGFyYW1ldGVyIGNvdW50LlxuICAgIC8vIFNlZSBkaXNjdXNzaW9uOiBodHRwOi8vZ29vLmdsL0xyV21aOVxuICAgIHZhciBzdHIgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSBDSFVOS19TSVpFKSB7XG4gICAgICAgIHZhciBjaHVuayA9IGJ5dGVzLnNsaWNlKGksIGkgKyBDSFVOS19TSVpFKTtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY2h1bmspO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufTtcbi8vIFN0YXRpYyBsb29rdXAgbWFwcywgbGF6aWx5IHBvcHVsYXRlZCBieSBpbml0XygpXG5leHBvcnQgdmFyIGJhc2U2NCA9IHtcbiAgICAvKipcbiAgICAgKiBNYXBzIGJ5dGVzIHRvIGNoYXJhY3RlcnMuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJ5dGVUb0NoYXJNYXBfOiBudWxsLFxuICAgIC8qKlxuICAgICAqIE1hcHMgY2hhcmFjdGVycyB0byBieXRlcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2hhclRvQnl0ZU1hcF86IG51bGwsXG4gICAgLyoqXG4gICAgICogTWFwcyBieXRlcyB0byB3ZWJzYWZlIGNoYXJhY3RlcnMuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJ5dGVUb0NoYXJNYXBXZWJTYWZlXzogbnVsbCxcbiAgICAvKipcbiAgICAgKiBNYXBzIHdlYnNhZmUgY2hhcmFjdGVycyB0byBieXRlcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2hhclRvQnl0ZU1hcFdlYlNhZmVfOiBudWxsLFxuICAgIC8qKlxuICAgICAqIE91ciBkZWZhdWx0IGFscGhhYmV0LCBzaGFyZWQgYmV0d2VlblxuICAgICAqIEVOQ09ERURfVkFMUyBhbmQgRU5DT0RFRF9WQUxTX1dFQlNBRkVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIEVOQ09ERURfVkFMU19CQVNFOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonICsgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyArICcwMTIzNDU2Nzg5JyxcbiAgICAvKipcbiAgICAgKiBPdXIgZGVmYXVsdCBhbHBoYWJldC4gVmFsdWUgNjQgKD0pIGlzIHNwZWNpYWw7IGl0IG1lYW5zIFwibm90aGluZy5cIlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IEVOQ09ERURfVkFMUygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnKy89JztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE91ciB3ZWJzYWZlIGFscGhhYmV0LlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IEVOQ09ERURfVkFMU19XRUJTQUZFKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRSArICctXy4nO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgdGhlIGF0b2IgYW5kIGJ0b2EgZnVuY3Rpb25zLiBUaGlzIGV4dGVuc2lvblxuICAgICAqIHN0YXJ0ZWQgYXQgTW96aWxsYSBidXQgaXMgbm93IGltcGxlbWVudGVkIGJ5IG1hbnkgYnJvd3NlcnMuIFdlIHVzZSB0aGVcbiAgICAgKiBBU1NVTUVfKiB2YXJpYWJsZXMgdG8gYXZvaWQgcHVsbGluZyBpbiB0aGUgZnVsbCB1c2VyYWdlbnQgZGV0ZWN0aW9uIGxpYnJhcnlcbiAgICAgKiBidXQgc3RpbGwgYWxsb3dpbmcgdGhlIHN0YW5kYXJkIHBlci1icm93c2VyIGNvbXBpbGF0aW9ucy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIEhBU19OQVRJVkVfU1VQUE9SVDogdHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbicsXG4gICAgLyoqXG4gICAgICogQmFzZTY0LWVuY29kZSBhbiBhcnJheSBvZiBieXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPnxVaW50OEFycmF5fSBpbnB1dCBBbiBhcnJheSBvZiBieXRlcyAobnVtYmVycyB3aXRoXG4gICAgICogICAgIHZhbHVlIGluIFswLCAyNTVdKSB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3dlYlNhZmUgQm9vbGVhbiBpbmRpY2F0aW5nIHdlIHNob3VsZCB1c2UgdGhlXG4gICAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBlbmNvZGVCeXRlQXJyYXk6IGZ1bmN0aW9uIChpbnB1dCwgb3B0X3dlYlNhZmUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ2VuY29kZUJ5dGVBcnJheSB0YWtlcyBhbiBhcnJheSBhcyBhIHBhcmFtZXRlcicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdF8oKTtcbiAgICAgICAgdmFyIGJ5dGVUb0NoYXJNYXAgPSBvcHRfd2ViU2FmZVxuICAgICAgICAgICAgPyB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1xuICAgICAgICAgICAgOiB0aGlzLmJ5dGVUb0NoYXJNYXBfO1xuICAgICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIHZhciBieXRlMSA9IGlucHV0W2ldO1xuICAgICAgICAgICAgdmFyIGhhdmVCeXRlMiA9IGkgKyAxIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGJ5dGUyID0gaGF2ZUJ5dGUyID8gaW5wdXRbaSArIDFdIDogMDtcbiAgICAgICAgICAgIHZhciBoYXZlQnl0ZTMgPSBpICsgMiA8IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBieXRlMyA9IGhhdmVCeXRlMyA/IGlucHV0W2kgKyAyXSA6IDA7XG4gICAgICAgICAgICB2YXIgb3V0Qnl0ZTEgPSBieXRlMSA+PiAyO1xuICAgICAgICAgICAgdmFyIG91dEJ5dGUyID0gKChieXRlMSAmIDB4MDMpIDw8IDQpIHwgKGJ5dGUyID4+IDQpO1xuICAgICAgICAgICAgdmFyIG91dEJ5dGUzID0gKChieXRlMiAmIDB4MGYpIDw8IDIpIHwgKGJ5dGUzID4+IDYpO1xuICAgICAgICAgICAgdmFyIG91dEJ5dGU0ID0gYnl0ZTMgJiAweDNmO1xuICAgICAgICAgICAgaWYgKCFoYXZlQnl0ZTMpIHtcbiAgICAgICAgICAgICAgICBvdXRCeXRlNCA9IDY0O1xuICAgICAgICAgICAgICAgIGlmICghaGF2ZUJ5dGUyKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dEJ5dGUzID0gNjQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0LnB1c2goYnl0ZVRvQ2hhck1hcFtvdXRCeXRlMV0sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTJdLCBieXRlVG9DaGFyTWFwW291dEJ5dGUzXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlNF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBCYXNlNjQtZW5jb2RlIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IEEgc3RyaW5nIHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfd2ViU2FmZSBJZiB0cnVlLCB3ZSBzaG91bGQgdXNlIHRoZVxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZW5jb2RlU3RyaW5nOiBmdW5jdGlvbiAoaW5wdXQsIG9wdF93ZWJTYWZlKSB7XG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XG4gICAgICAgIC8vIGEgbmF0aXZlIGJhc2U2NCBlbmNvZGVyIGluIHRoZSBmb3JtIG9mIFwiYnRvYS9hdG9iXCJcbiAgICAgICAgaWYgKHRoaXMuSEFTX05BVElWRV9TVVBQT1JUICYmICFvcHRfd2ViU2FmZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ0b2EoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZUJ5dGVBcnJheShzdHJpbmdUb0J5dGVBcnJheShpbnB1dCksIG9wdF93ZWJTYWZlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgdG8gZGVjb2RlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF93ZWJTYWZlIFRydWUgaWYgd2Ugc2hvdWxkIHVzZSB0aGVcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBkZWNvZGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGRlY29kZVN0cmluZzogZnVuY3Rpb24gKGlucHV0LCBvcHRfd2ViU2FmZSkge1xuICAgICAgICAvLyBTaG9ydGN1dCBmb3IgTW96aWxsYSBicm93c2VycyB0aGF0IGltcGxlbWVudFxuICAgICAgICAvLyBhIG5hdGl2ZSBiYXNlNjQgZW5jb2RlciBpbiB0aGUgZm9ybSBvZiBcImJ0b2EvYXRvYlwiXG4gICAgICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhb3B0X3dlYlNhZmUpIHtcbiAgICAgICAgICAgIHJldHVybiBhdG9iKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZUFycmF5VG9TdHJpbmcodGhpcy5kZWNvZGVTdHJpbmdUb0J5dGVBcnJheShpbnB1dCwgb3B0X3dlYlNhZmUpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBJbiBiYXNlLTY0IGRlY29kaW5nLCBncm91cHMgb2YgZm91ciBjaGFyYWN0ZXJzIGFyZSBjb252ZXJ0ZWQgaW50byB0aHJlZVxuICAgICAqIGJ5dGVzLiAgSWYgdGhlIGVuY29kZXIgZGlkIG5vdCBhcHBseSBwYWRkaW5nLCB0aGUgaW5wdXQgbGVuZ3RoIG1heSBub3RcbiAgICAgKiBiZSBhIG11bHRpcGxlIG9mIDQuXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIGNhc2UsIHRoZSBsYXN0IGdyb3VwIHdpbGwgaGF2ZSBmZXdlciB0aGFuIDQgY2hhcmFjdGVycywgYW5kXG4gICAgICogcGFkZGluZyB3aWxsIGJlIGluZmVycmVkLiAgSWYgdGhlIGdyb3VwIGhhcyBvbmUgb3IgdHdvIGNoYXJhY3RlcnMsIGl0IGRlY29kZXNcbiAgICAgKiB0byBvbmUgYnl0ZS4gIElmIHRoZSBncm91cCBoYXMgdGhyZWUgY2hhcmFjdGVycywgaXQgZGVjb2RlcyB0byB0d28gYnl0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgSW5wdXQgdG8gZGVjb2RlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF93ZWJTYWZlIFRydWUgaWYgd2Ugc2hvdWxkIHVzZSB0aGUgd2ViLXNhZmUgYWxwaGFiZXQuXG4gICAgICogQHJldHVybiB7IUFycmF5PG51bWJlcj59IGJ5dGVzIHJlcHJlc2VudGluZyB0aGUgZGVjb2RlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBkZWNvZGVTdHJpbmdUb0J5dGVBcnJheTogZnVuY3Rpb24gKGlucHV0LCBvcHRfd2ViU2FmZSkge1xuICAgICAgICB0aGlzLmluaXRfKCk7XG4gICAgICAgIHZhciBjaGFyVG9CeXRlTWFwID0gb3B0X3dlYlNhZmVcbiAgICAgICAgICAgID8gdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9cbiAgICAgICAgICAgIDogdGhpcy5jaGFyVG9CeXRlTWFwXztcbiAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDspIHtcbiAgICAgICAgICAgIHZhciBieXRlMSA9IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgdmFyIGhhdmVCeXRlMiA9IGkgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYnl0ZTIgPSBoYXZlQnl0ZTIgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiAwO1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgdmFyIGhhdmVCeXRlMyA9IGkgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiA2NDtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIHZhciBoYXZlQnl0ZTQgPSBpIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGJ5dGU0ID0gaGF2ZUJ5dGU0ID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogNjQ7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICBpZiAoYnl0ZTEgPT0gbnVsbCB8fCBieXRlMiA9PSBudWxsIHx8IGJ5dGUzID09IG51bGwgfHwgYnl0ZTQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3V0Qnl0ZTEgPSAoYnl0ZTEgPDwgMikgfCAoYnl0ZTIgPj4gNCk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMSk7XG4gICAgICAgICAgICBpZiAoYnl0ZTMgIT0gNjQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0Qnl0ZTIgPSAoKGJ5dGUyIDw8IDQpICYgMHhmMCkgfCAoYnl0ZTMgPj4gMik7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTIpO1xuICAgICAgICAgICAgICAgIGlmIChieXRlNCAhPSA2NCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0Qnl0ZTMgPSAoKGJ5dGUzIDw8IDYpICYgMHhjMCkgfCBieXRlNDtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogTGF6eSBzdGF0aWMgaW5pdGlhbGl6YXRpb24gZnVuY3Rpb24uIENhbGxlZCBiZWZvcmVcbiAgICAgKiBhY2Nlc3NpbmcgYW55IG9mIHRoZSBzdGF0aWMgbWFwIHZhcmlhYmxlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXRfOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5ieXRlVG9DaGFyTWFwXykge1xuICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwXyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwXyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV8gPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfID0ge307XG4gICAgICAgICAgICAvLyBXZSB3YW50IHF1aWNrIG1hcHBpbmdzIGJhY2sgYW5kIGZvcnRoLCBzbyB3ZSBwcmVjb21wdXRlIHR3byBtYXBzLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLkVOQ09ERURfVkFMUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcF9baV0gPSB0aGlzLkVOQ09ERURfVkFMUy5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwX1t0aGlzLmJ5dGVUb0NoYXJNYXBfW2ldXSA9IGk7XG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9baV0gPSB0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1t0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1tpXV0gPSBpO1xuICAgICAgICAgICAgICAgIC8vIEJlIGZvcmdpdmluZyB3aGVuIGRlY29kaW5nIGFuZCBjb3JyZWN0bHkgZGVjb2RlIGJvdGggZW5jb2RpbmdzLlxuICAgICAgICAgICAgICAgIGlmIChpID49IHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF9bdGhpcy5FTkNPREVEX1ZBTFNfV0VCU0FGRS5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9bdGhpcy5FTkNPREVEX1ZBTFMuY2hhckF0KGkpXSA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nXG4gKiBAcGFyYW0geyFzdHJpbmd9IHN0clxuICogQHJldHVybiB7IXN0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBiYXNlNjRFbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIHV0ZjhCeXRlcyA9IHN0cmluZ1RvQnl0ZUFycmF5KHN0cik7XG4gICAgcmV0dXJuIGJhc2U2NC5lbmNvZGVCeXRlQXJyYXkodXRmOEJ5dGVzLCB0cnVlKTtcbn07XG4vKipcbiAqIFVSTC1zYWZlIGJhc2U2NCBkZWNvZGluZ1xuICpcbiAqIE5PVEU6IERPIE5PVCB1c2UgdGhlIGdsb2JhbCBhdG9iKCkgZnVuY3Rpb24gLSBpdCBkb2VzIE5PVCBzdXBwb3J0IHRoZVxuICogYmFzZTY0VXJsIHZhcmlhbnQgZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUbyBiZSBkZWNvZGVkXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBEZWNvZGVkIHJlc3VsdCwgaWYgcG9zc2libGVcbiAqL1xuZXhwb3J0IHZhciBiYXNlNjREZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGJhc2U2NC5kZWNvZGVTdHJpbmcoc3RyLCB0cnVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignYmFzZTY0RGVjb2RlIGZhaWxlZDogJywgZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS91dGlsL2Rpc3QvZXNtL3NyYy9jcnlwdC5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRXZhbHVhdGVzIGEgSlNPTiBzdHJpbmcgaW50byBhIGphdmFzY3JpcHQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgQSBzdHJpbmcgY29udGFpbmluZyBKU09OLlxuICogQHJldHVybiB7Kn0gVGhlIGphdmFzY3JpcHQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIEpTT04uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqc29uRXZhbChzdHIpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xufVxuLyoqXG4gKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50aW5nIGEgamF2YXNjcmlwdCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IGRhdGEgSmF2YXNjcmlwdCBvYmplY3QgdG8gYmUgc3RyaW5naWZpZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBKU09OIGNvbnRlbnRzIG9mIHRoZSBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkoZGF0YSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbn1cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS91dGlsL2Rpc3QvZXNtL3NyYy9qc29uLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gU2VlIGh0dHA6Ly93d3cuZGV2dGhvdWdodC5jb20vMjAxMi8wMS8xOC9hbi1vYmplY3QtaXMtbm90LWEtaGFzaC9cbmV4cG9ydCB2YXIgY29udGFpbnMgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn07XG5leHBvcnQgdmFyIHNhZmVHZXQgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSlcbiAgICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIC8vIGVsc2UgcmV0dXJuIHVuZGVmaW5lZC5cbn07XG4vKipcbiAqIEVudW1lcmF0ZXMgdGhlIGtleXMvdmFsdWVzIGluIGFuIG9iamVjdCwgZXhjbHVkaW5nIGtleXMgZGVmaW5lZCBvbiB0aGUgcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB7P09iamVjdC48SyxWPn0gb2JqIE9iamVjdCB0byBlbnVtZXJhdGUuXG4gKiBAcGFyYW0geyFmdW5jdGlvbihLLCBWKX0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBrZXkgYW5kIHZhbHVlLlxuICogQHRlbXBsYXRlIEssVlxuICovXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqLCBmbikge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIGZuKGtleSwgb2JqW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogQ29waWVzIGFsbCB0aGUgKG93bikgcHJvcGVydGllcyBmcm9tIG9uZSBvYmplY3QgdG8gYW5vdGhlci5cbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqVG9cbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqRnJvbVxuICogQHJldHVybiB7IU9iamVjdH0gb2JqVG9cbiAqL1xuZXhwb3J0IHZhciBleHRlbmQgPSBmdW5jdGlvbiAob2JqVG8sIG9iakZyb20pIHtcbiAgICBmb3JFYWNoKG9iakZyb20sIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIG9ialRvW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqVG87XG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIHNwZWNpZmllZCBvYmplY3QuXG4gKiBAcGFyYW0geyFPYmplY3R9IG9ialxuICogQHJldHVybiB7IU9iamVjdH0gY2xvbmVkIG9iai5cbiAqL1xuZXhwb3J0IHZhciBjbG9uZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gZXh0ZW5kKHt9LCBvYmopO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBoYXMgdHlwZW9mIFwib2JqZWN0XCIgYW5kIGlzIG5vdCBudWxsLiAgVW5saWtlIGdvb2cuaXNPYmplY3QoKSwgZG9lcyBub3QgcmV0dXJuIHRydWVcbiAqIGZvciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIG9iaiB7Kn0gQSBwb3RlbnRpYWwgb2JqZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgaXQncyBhbiBvYmplY3QuXG4gKi9cbmV4cG9ydCB2YXIgaXNOb25OdWxsT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGw7XG59O1xuZXhwb3J0IHZhciBpc0VtcHR5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5leHBvcnQgdmFyIGdldENvdW50ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBydiA9IDA7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBydisrO1xuICAgIH1cbiAgICByZXR1cm4gcnY7XG59O1xuZXhwb3J0IHZhciBtYXAgPSBmdW5jdGlvbiAob2JqLCBmLCBvcHRfb2JqKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgcmVzW2tleV0gPSBmLmNhbGwob3B0X29iaiwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5leHBvcnQgdmFyIGZpbmRLZXkgPSBmdW5jdGlvbiAob2JqLCBmbiwgb3B0X3RoaXMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChmbi5jYWxsKG9wdF90aGlzLCBvYmpba2V5XSwga2V5LCBvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuZXhwb3J0IHZhciBmaW5kVmFsdWUgPSBmdW5jdGlvbiAob2JqLCBmbiwgb3B0X3RoaXMpIHtcbiAgICB2YXIga2V5ID0gZmluZEtleShvYmosIGZuLCBvcHRfdGhpcyk7XG4gICAgcmV0dXJuIGtleSAmJiBvYmpba2V5XTtcbn07XG5leHBvcnQgdmFyIGdldEFueUtleSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxufTtcbmV4cG9ydCB2YXIgZ2V0VmFsdWVzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICByZXNbaSsrXSA9IG9ialtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcbi8qKlxuICogVGVzdHMgd2hldGhlciBldmVyeSBrZXkvdmFsdWUgcGFpciBpbiBhbiBvYmplY3QgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZFxuICogYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHs/T2JqZWN0LjxLLFY+fSBvYmogT2JqZWN0IHRvIHRlc3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbihLLCBWKX0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBrZXkgYW5kIHZhbHVlLlxuICogQHRlbXBsYXRlIEssVlxuICovXG5leHBvcnQgdmFyIGV2ZXJ5ID0gZnVuY3Rpb24gKG9iaiwgZm4pIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIWZuKGtleSwgb2JqW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS91dGlsL2Rpc3QvZXNtL3NyYy9vYmouanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuaW1wb3J0ICogYXMgbWF0aHMgZnJvbSBcIi4vbWF0aHNcIjtcbmltcG9ydCAqIGFzIHJhbmRvbSBmcm9tIFwiLi9yYW5kb21cIjtcbmltcG9ydCAqIGFzIFJhbmdlIGZyb20gXCIuL1JhbmdlXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaHVmZmxlZChhKSB7XG4gIHJldHVybiByYW5kb20uc2h1ZmZsZShhKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21JdGVtKGEpIHtcbiAgcmV0dXJuIHJhbmRvbS5pdGVtKGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlcyhhKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoYSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkT25jZShhLCBpdGVtKSB7XG4gIGlmIChhLmluZGV4T2YoaXRlbSkgPT0gLTEpIHtcbiAgICBhLnB1c2goaXRlbSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5leHQoaSwgYSwgY2xhbXAgPSBmYWxzZSkge1xuICByZXR1cm4gbWF0aHMubmV4dFdpdGhpbihpLCAwLCBhLmxlbmd0aCAtIDEsIGNsYW1wKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwcmV2KGksIGEsIGNsYW1wID0gZmFsc2UpIHtcbiAgcmV0dXJuIG1hdGhzLnByZXZXaXRoaW4oaSwgMCwgYS5sZW5ndGggLSAxLCBjbGFtcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXh0SXRlbShpdGVtLCBhLCBjbGFtcCA9IGZhbHNlKSB7XG5cbiAgbGV0IGkgICAgPSBhLmluZGV4T2YoaXRlbSksXG4gICAgaU5leHQgID0gbmV4dChpLCBhLCBjbGFtcCk7XG5cbiAgcmV0dXJuIGFbaU5leHRdO1xuXG59XG5leHBvcnQgZnVuY3Rpb24gcHJldkl0ZW0oaXRlbSwgYSwgY2xhbXAgPSBmYWxzZSkge1xuXG4gIGxldCBpICAgID0gYS5pbmRleE9mKGl0ZW0pLFxuICAgIGlQcmV2ICA9IHByZXYoaSwgYSwgY2xhbXApO1xuXG4gIHJldHVybiBhW2lQcmV2XTtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRmlyc3QoYSwgaXRlbSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXSA9PSBpdGVtKSB7XG4gICAgICBhLnNwbGljZShpLCAxKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVBbGwoYSwgaXRlbSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXSA9PSBpdGVtKSB7XG4gICAgICBhLnNwbGljZShpLCAxKTtcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zKGEsIGl0ZW0pIHtcbiAgcmV0dXJuIChhLmluZGV4T2YoaXRlbSkgIT0gLTEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcEluZGV4KGksIGEpIHtcbiAgcmV0dXJuIG1hdGhzLndyYXAoaSwgMCwgYS5sZW5ndGggLSAxKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0SXRlbShhKSB7XG4gIHJldHVybiBhWzBdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxhc3RJdGVtKGEpIHtcbiAgcmV0dXJuIGFbbGFzdEluZGV4KGEpXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxhc3RJbmRleChhKSB7XG4gIHJldHVybiBhLmxlbmd0aCAtIDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmRleFJhbmdlKGEpIHtcbiAgcmV0dXJuIG5ldyBSYW5nZSgwLCBhLmxlbmd0aCAtIDEpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ZhcnlkLXV0aWxzL2FycmF5cy5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5pbXBvcnQgKiBhcyBtYXRocyBmcm9tIFwiLi9tYXRoc1wiO1xuXG4vLyBQdHNcblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVB0KHB0LCBzY2FsZVgsIHNjYWxlWSwgcmFkcykge1xuICByZXR1cm4gcm90YXRlUHQoc2NhbGVQdChwdCwgc2NhbGVYLCBzY2FsZVkpLCByYWRzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZVB0KHB0LCBzY2FsZVgsIHNjYWxlWSkge1xuXG4gIHJldHVybiB7XG4gICAgeDogcHQueCAqIHNjYWxlWCxcbiAgICB5OiBwdC55ICogc2NhbGVZXG4gIH07XG5cbn1cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVQdChwdCwgcmFkcywgb3JpZ2luKSB7XG5cbiAgbGV0IG94ID0gKG9yaWdpbiA9PT0gdW5kZWZpbmVkKSA/IDAgOiBvcmlnaW4ueCxcbiAgICAgIG95ID0gKG9yaWdpbiA9PT0gdW5kZWZpbmVkKSA/IDAgOiBvcmlnaW4ueTtcblxuICBsZXQgZHggPSBwdC54IC0gb3gsXG4gICAgICBkeSA9IHB0LnkgLSBveTtcblxuICBsZXQgYVNpbiA9IE1hdGguc2luKHJhZHMpLFxuICAgICAgYUNvcyA9IE1hdGguY29zKHJhZHMpO1xuXG4gIGxldCB4ICA9IChhQ29zICogZHgpIC0gKGFTaW4gKiBkeSkgKyBveCxcbiAgICAgIHkgID0gKGFTaW4gKiBkeCkgKyAoYUNvcyAqIGR5KSArIG95XG5cbiAgcmV0dXJuIHsgeCwgeSB9O1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwdEFyb3VuZENpcmNsZShyYWQsIHBlcmMsIG9yaWdpbiA9IG51bGwpIHtcblxuICBsZXQgYW5nbGUgPSAocGVyYyAqIG1hdGhzLlRBTykgLSAoTWF0aC5QSSAvIDIpLFxuICAgICAgeCAgICAgPSAob3JpZ2luID8gb3JpZ2luLnggOiAwKSArIChyYWQgKiBNYXRoLmNvcyhhbmdsZSkpLFxuICAgICAgeSAgICAgPSAob3JpZ2luID8gb3JpZ2luLnkgOiAwKSArIChyYWQgKiBNYXRoLnNpbihhbmdsZSkpO1xuXG4gIHJldHVybiB7IHgsIHkgfTtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzdChwdDEsIHB0Mikge1xuICByZXR1cm4gTWF0aC5zcXJ0KGRpc3RTcShwdDEsIHB0MikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RYWSh4MSwgeTEsIHgyLCB5Mikge1xuICByZXR1cm4gTWF0aC5zcXJ0KGRpc3RTcVhZKHgxLCB5MSwgeDIsIHkyKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0U3EocHQxLCBwdDIpIHtcbiAgcmV0dXJuIGRpc3RTcVhZKHB0MS54LCBwdDEueSwgcHQyLngsIHB0Mi55KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkaXN0U3FYWSh4MSwgeTEsIHgyLCB5Mikge1xuICByZXR1cm4gKCh4MiAtIHgxKSAqICh4MiAtIHgxKSkgKyAoKHkyIC0geTEpICogKHkyIC0geTEpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxlcnBQdChwMSwgcDIsIHZhbCA9IDAuNSkge1xuICByZXR1cm4ge1xuICAgIHg6IG1hdGhzLmxlcnAocDEueCwgcDIueCwgdmFsKSxcbiAgICB5OiBtYXRocy5sZXJwKHAxLnksIHAyLnksIHZhbClcbiAgfTtcbn1cblxuXG4vLyBUcmlnXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWdUb1JhZChkZWdzKSB7XG4gIHJldHVybiBkZWdzICogKG1hdGhzLlRBTyAvIDM2MCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmFkVG9EZWcocmFkcykge1xuICByZXR1cm4gcmFkcyAqICgzNjAgLyBtYXRocy5UQU8pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFkRnJvbVB0cyhmcm9tUHQsIHRvUHQpIHtcblxuICBpZiAodG9QdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG9QdCAgICA9IHsgeDogZnJvbVB0LngsIHk6IGZyb21QdC55IH07XG4gICAgZnJvbVB0ICA9IHsgeDogMCwgeTogMCB9O1xuICB9XG5cbiAgcmV0dXJuIE1hdGguYXRhbjIodG9QdC55IC0gZnJvbVB0LnksIHRvUHQueCAtIGZyb21QdC54KTtcblxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhZEZyb21YWShmcm9tWCwgZnJvbVksIHRvWCwgdG9ZKSB7XG5cbiAgaWYgKHRvWCA9PT0gdW5kZWZpbmVkIHx8IHRvWSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG9YICAgPSBmcm9tWDtcbiAgICB0b1kgICA9IGZyb21ZO1xuICAgIGZyb21YID0gMDtcbiAgICBmcm9tWSA9IDA7XG4gIH1cblxuICByZXR1cm4gTWF0aC5hdGFuMih0b1kgLSBmcm9tWSwgdG9YIC0gZnJvbVgpO1xuXG59XG5cblxuLy8gQXJlYXNcblxuZXhwb3J0IGZ1bmN0aW9uIGxlcnBSZWN0KHJlY3RBLCByZWN0QiwgdmFsID0gMC41KSB7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiAgICAgIG1hdGhzLmxlcnAocmVjdEEueCwgICAgICByZWN0Qi54LCAgICAgIHZhbCksXG4gICAgeTogICAgICBtYXRocy5sZXJwKHJlY3RBLnksICAgICAgcmVjdEIueSwgICAgICB2YWwpLFxuICAgIHdpZHRoOiAgbWF0aHMubGVycChyZWN0QS53aWR0aCwgIHJlY3RCLndpZHRoLCAgdmFsKSxcbiAgICBoZWlnaHQ6IG1hdGhzLmxlcnAocmVjdEEuaGVpZ2h0LCByZWN0Qi5oZWlnaHQsIHZhbClcbiAgfTtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmlsbFJlY3QodywgaCwgYXJlYSkge1xuXG4gIGNvbnN0IGF3ID0gYXJlYS53aWR0aCxcbiAgICAgICAgYWggPSBhcmVhLmhlaWdodCxcbiAgICAgICAgYXggPSBhcmVhLngsXG4gICAgICAgIGF5ID0gYXJlYS55LFxuICAgICAgICBzdyA9IGFoICogdyAvIGgsXG4gICAgICAgIHNoID0gYXcgKiBoIC8gdyxcbiAgICAgICAgcncgPSAoc3cgPiBhdykgPyBzdyA6IGF3LFxuICAgICAgICByaCA9IChzdyA+IGF3KSA/IGFoIDogc2gsXG4gICAgICAgIHJ4ID0gTWF0aC5taW4oYXgsIE1hdGgubWF4KGF4ICsgYXcgLSBydywgYXggKyBNYXRoLnJvdW5kKChhdyAtIHJ3KSAvIDIpKSksXG4gICAgICAgIHJ5ID0gTWF0aC5taW4oYXksIE1hdGgubWF4KGF5ICsgYWggLSByaCwgYXkgKyBNYXRoLnJvdW5kKChhaCAtIHJoKSAvIDIpKSk7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByeCxcbiAgICB5OiByeSxcbiAgICB3aWR0aDogcncsXG4gICAgaGVpZ2h0OiByaFxuICB9O1xuXG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Rml0UmVjdCh3LCBoLCBhcmVhKSB7XG5cbiAgY29uc3QgYXcgPSBhcmVhLndpZHRoLFxuICAgICAgICBhaCA9IGFyZWEuaGVpZ2h0LFxuICAgICAgICBheCA9IGFyZWEueCxcbiAgICAgICAgYXkgPSBhcmVhLnksXG4gICAgICAgIHN3ID0gYWggKiB3IC8gaCxcbiAgICAgICAgc2ggPSBhdyAqIGggLyB3LFxuICAgICAgICBydyA9IChzdyA8PSBhdykgPyBzdyA6IGF3LFxuICAgICAgICByaCA9IChzdyA8PSBhdykgPyBhaCA6IHNoLFxuICAgICAgICByeCA9IGF4ICsgTWF0aC5yb3VuZCgoYXcgLSBydykgLyAyKSxcbiAgICAgICAgcnkgPSBheSArIE1hdGgucm91bmQoKGFoIC0gcmgpIC8gMik7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByeCxcbiAgICB5OiByeSxcbiAgICB3aWR0aDogcncsXG4gICAgaGVpZ2h0OiByaFxuICB9O1xuXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdmFyeWQtdXRpbHMvZ2VvbS5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5pbXBvcnQgKiBhcyByYW5kb20gZnJvbSBcIi4vcmFuZG9tXCI7XG5pbXBvcnQgKiBhcyBhcnJheXMgZnJvbSBcIi4vYXJyYXlzXCI7XG5cbmV4cG9ydCBjb25zdCBRVU9URV9MICAgID0gXCJcXHUyMDFDXCI7XG5leHBvcnQgY29uc3QgUVVPVEVfUiAgICA9IFwiXFx1MjAxRFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGF0aW4od29yZENvdW50ID0gMSwgcHVuY3R1YXRlID0gZmFsc2UpIHtcblxuICBjb25zdCBDSEFOQ0VfUEVSSU9EID0gMC4xLFxuICAgICAgICBDSEFOQ0VfQ09NTUEgID0gMC4xNTtcblxuICBsZXQgc291cmNlV29yZHMgPSBbXG4gICAgXCJhXCIsIFwiYWNcIiwgXCJhY2N1bXNhblwiLCBcImFkXCIsIFwiYWRpcGlzY2luZ1wiLCBcImFlbmVhblwiLCBcImFsaXF1YW1cIiwgXCJhbWV0XCIsIFwiYW50ZVwiLFxuICAgIFwiYXB0ZW50XCIsIFwiYXJjdVwiLCBcImF0XCIsIFwiYXVjdG9yXCIsIFwiYXVndWVcIiwgXCJiaWJlbmR1bVwiLCBcImJsYW5kaXRcIiwgXCJjbGFzc1wiLFxuICAgIFwiY29tbW9kb1wiLCBcImNvbmd1ZVwiLCBcImNvbnNlY3RldHVyXCIsIFwiY29uc2VxdWF0XCIsIFwiY29udWJpYVwiLCBcImNvbnZhbGxpc1wiLCBcImNyYXNcIixcbiAgICBcImN1cmFiaXR1clwiLCBcImN1cnN1c1wiLCBcImRhcGlidXNcIiwgXCJkaWFtXCIsIFwiZGljdHVtXCIsIFwiZGlnbmlzc2ltXCIsIFwiZG9sb3JcIixcbiAgICBcImRvbmVjXCIsIFwiZHVpXCIsIFwiZHVpc1wiLCBcImVnZXN0YXNcIiwgXCJlZ2V0XCIsIFwiZWxlaWZlbmRcIiwgXCJlbGVtZW50dW1cIiwgXCJlbGl0XCIsXG4gICAgXCJlbmltXCIsIFwiZXJhdFwiLCBcImVyb3NcIiwgXCJlc3RcIiwgXCJldFwiLCBcImV0aWFtXCIsIFwiZXVcIiwgXCJldWlzbW9kXCIsIFwiZmFtZXNcIixcbiAgICBcImZhdWNpYnVzXCIsIFwiZmVsaXNcIiwgXCJmZXJtZW50dW1cIiwgXCJmZXVnaWF0XCIsIFwiZnJpbmdpbGxhXCIsIFwiZnVzY2VcIiwgXCJncmF2aWRhXCIsXG4gICAgXCJoYWJpdGFudFwiLCBcImhlbmRyZXJpdFwiLCBcImhpbWVuYWVvc1wiLCBcImlhY3VsaXNcIiwgXCJpZFwiLCBcImltcGVyZGlldFwiLCBcImluXCIsXG4gICAgXCJpbmNlcHRvc1wiLCBcImludGVnZXJcIiwgXCJpbnRlcmR1bVwiLCBcImlwc3VtXCIsIFwianVzdG9cIiwgXCJsYWNpbmlhXCIsIFwibGFjdXNcIixcbiAgICBcImxhb3JlZXRcIiwgXCJsZWN0dXNcIiwgXCJsZW9cIiwgXCJsaWJlcm9cIiwgXCJsaWd1bGFcIiwgXCJsaXRvcmFcIiwgXCJsb2JvcnRpc1wiLCBcImxvcmVtXCIsXG4gICAgXCJsdWN0dXNcIiwgXCJtYWVjZW5hc1wiLCBcIm1hZ25hXCIsIFwibWFsZXN1YWRhXCIsIFwibWFzc2FcIiwgXCJtYXR0aXNcIiwgXCJtYXVyaXNcIixcbiAgICBcIm1ldHVzXCIsIFwibWlcIiwgXCJtb2xsaXNcIiwgXCJtb3JiaVwiLCBcIm5hbVwiLCBcIm5lY1wiLCBcIm5lcXVlXCIsIFwibmV0dXNcIiwgXCJuaWJoXCIsXG4gICAgXCJuaXNpXCIsIFwibmlzbFwiLCBcIm5vblwiLCBcIm5vc3RyYVwiLCBcIm51bGxhXCIsIFwibnVsbGFtXCIsIFwibnVuY1wiLCBcIm9kaW9cIiwgXCJvcmNpXCIsXG4gICAgXCJvcm5hcmVcIiwgXCJwZWxsZW50ZXNxdWVcIiwgXCJwZXJcIiwgXCJwaGFyZXRyYVwiLCBcInBoYXNlbGx1c1wiLCBcInBsYWNlcmF0XCIsXG4gICAgXCJwb3J0dGl0b3JcIiwgXCJwb3N1ZXJlXCIsIFwicHJhZXNlbnRcIiwgXCJwcmV0aXVtXCIsIFwicHJvaW5cIiwgXCJwdWx2aW5hclwiLCBcInB1cnVzXCIsXG4gICAgXCJxdWFtXCIsIFwicXVpc1wiLCBcInF1aXNxdWVcIiwgXCJyaG9uY3VzXCIsIFwicmlzdXNcIiwgXCJydXRydW1cIiwgXCJzYWdpdHRpc1wiLCBcInNhcGllblwiLFxuICAgIFwic2NlbGVyaXNxdWVcIiwgXCJzZWRcIiwgXCJzZW1cIiwgXCJzZW1wZXJcIiwgXCJzZW5lY3R1c1wiLCBcInNpdFwiLCBcInNvY2lvc3F1XCIsXG4gICAgXCJzdXNjaXBpdFwiLCBcInN1c3BlbmRpc3NlXCIsIFwidGFjaXRpXCIsIFwidGVsbHVzXCIsIFwidGVtcG9yXCIsIFwidGVtcHVzXCIsIFwidGluY2lkdW50XCIsXG4gICAgXCJ0b3JxdWVudFwiLCBcInRvcnRvclwiLCBcInRyaXN0aXF1ZVwiLCBcInR1cnBpc1wiLCBcInVsbGFtY29ycGVyXCIsIFwidWx0cmljZXNcIixcbiAgICBcInVsdHJpY2llc1wiLCBcInVybmFcIiwgXCJ1dFwiLCBcInZhcml1c1wiLCBcInZlaGljdWxhXCIsIFwidmVsXCIsIFwidmVsaXRcIiwgXCJ2ZW5lbmF0aXNcIixcbiAgICBcInZpdGFlXCIsIFwidml2YW11c1wiLCBcInZpdmVycmFcIiwgXCJ2b2x1dHBhdFwiLCBcInZ1bHB1dGF0ZVwiXG4gIF07XG5cbiAgd2hpbGUoc291cmNlV29yZHMubGVuZ3RoIDwgd29yZENvdW50KSB7XG4gICAgc291cmNlV29yZHMgPSBzb3VyY2VXb3Jkcy5jb25jYXQoc291cmNlV29yZHMpO1xuICB9XG5cbiAgbGV0IGlzTmV3U2VudGVuY2UgPSB0cnVlLFxuICAgICAgd29yZHMgICAgICAgICA9IHJhbmRvbS5pdGVtcyhzb3VyY2VXb3Jkcywgd29yZENvdW50KSxcbiAgICAgIHJlc3VsdCAgICAgICAgPSBcIlwiO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcblxuICAgIGxldCBpc0xhc3RXb3JkICA9IChpID09PSBhcnJheXMubGFzdEluZGV4KHdvcmRzKSksXG4gICAgICAgIG5leHRXb3JkICAgID0gd29yZHNbaV07XG5cbiAgICBpZiAoaXNOZXdTZW50ZW5jZSkge1xuICAgICAgcmVzdWx0ICs9IG5leHRXb3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmV4dFdvcmQuc3Vic3RyKDEpO1xuICAgICAgaXNOZXdTZW50ZW5jZSA9IGZhbHNlO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSB3b3Jkc1tpXTtcblxuICAgIH1cblxuICAgIGlmIChwdW5jdHVhdGUpIHtcblxuICAgICAgaWYgKGlzTGFzdFdvcmQpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiLlwiO1xuXG4gICAgICB9IGVsc2UgaWYgKHJhbmRvbS5ib29sZWFuKENIQU5DRV9QRVJJT0QpKSB7XG4gICAgICAgIHJlc3VsdCArPSBcIi4gXCI7XG4gICAgICAgIGlzTmV3U2VudGVuY2UgPSB0cnVlO1xuXG4gICAgICB9IGVsc2UgaWYgKHJhbmRvbS5ib29sZWFuKENIQU5DRV9DT01NQSkpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiLCBcIjtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiIFwiO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICghaXNMYXN0V29yZCkge1xuICAgICAgcmVzdWx0ICs9IFwiIFwiO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJ1bmMocywgY2hhckNvdW50LCBhZGRFbGlwc2lzID0gZmFsc2UpIHtcbiAgaWYgKCFzKSByZXR1cm4gXCJcIjtcbiAgaWYgKHMubGVuZ3RoIDw9IGNoYXJDb3VudCkge1xuICAgIHJldHVybiBzO1xuICB9IGVsc2Uge1xuICAgIGlmIChhZGRFbGlwc2lzKSB7XG4gICAgICByZXR1cm4gcy5zdWJzdHIoMCwgY2hhckNvdW50IC0gMykgKyBcIi4uLlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcy5zdWJzdHIoMCwgY2hhckNvdW50KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJlZ2luc1dpdGgocywgdGVzdCkge1xuICByZXR1cm4gKHMuc3Vic3RyKDAsIHRlc3QubGVuZ3RoKSA9PT0gdGVzdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmRzV2l0aChzLCB0ZXN0KSB7XG4gIHJldHVybiAocy5zdWJzdHIoLXRlc3QubGVuZ3RoKSA9PT0gdGVzdCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdmFyeWQtdXRpbHMvdGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxucmVxdWlyZSgnQGZpcmViYXNlL2F1dGgnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9maXJlYmFzZS9hdXRoL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ0BmaXJlYmFzZS9kYXRhYmFzZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZpcmViYXNlL2RhdGFiYXNlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9zdHlsZS5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL3N0eWxlLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vc3R5bGUuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvc3JjL3N0eWxlcy9zdHlsZS5zY3NzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8vIEltcG9ydHNcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcblxuaW1wb3J0IGZpcmViYXNlIGZyb20gJ2ZpcmViYXNlL2FwcCc7XG5cbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAnO1xuXG4vLyBDb25zdGFudHNcblxuXG4vLyBDb21wb25lbnRcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3VzdG9taXplQ2F0ZWdvcnlGb3JtIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAvLyBDb25zdHJ1Y3RvclxuXG4gIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuaGFuZGxlSW5wdXRDaGFuZ2UgPSBlID0+IHtcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIFtlLmN1cnJlbnRUYXJnZXQubmFtZV06IGUuY3VycmVudFRhcmdldC52YWx1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuaGFuZGxlU3VibWl0ID0gZSA9PiB7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKHRoaXMudmFsaWRhdGUoKSkge1xuXG4gICAgICAgIGNvbnN0IGNhdGVnb3J5ID0ge1xuICAgICAgICAgIGxhYmVsOiB0aGlzLnN0YXRlLnZhbExhYmVsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jYXRlZ29yaWVzUmVmLnB1c2goY2F0ZWdvcnksIGVycm9yID0+IHtcblxuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJJbnB1dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaW5pdFN0YXRlKCk7XG4gIH1cblxuICBpbml0U3RhdGUoKSB7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgdmFsTGFiZWw6ICcnXG4gICAgfTtcbiAgfVxuXG4gIC8vIEV2ZW50IGhhbmRsZXJzXG5cbiAgLy8gTWV0aG9kc1xuXG4gIGNsZWFySW5wdXQoKSB7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHZhbExhYmVsOiAnJ1xuICAgIH0pO1xuICB9XG5cbiAgdmFsaWRhdGUoKSB7XG5cbiAgICBjb25zdCBoYXNMYWJlbCA9IHRoaXMuc3RhdGUudmFsTGFiZWwgJiYgdGhpcy5zdGF0ZS52YWxMYWJlbC5sZW5ndGg7XG5cbiAgICByZXR1cm4gaGFzTGFiZWw7XG4gIH1cblxuICAvLyBSZWFjdFxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuXG4gICAgY29uc3QgdXNlcklkID0gZmlyZWJhc2UuYXV0aCgpLmN1cnJlbnRVc2VyLnVpZDtcblxuICAgIHRoaXMuY2F0ZWdvcmllc1JlZiA9IGZpcmViYXNlLmRhdGFiYXNlKCkucmVmKGBjYXRlZ29yaWVzLyR7dXNlcklkfWApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZm9ybScsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2NhdGVnb3J5LWlucHV0JyxcbiAgICAgICAgb25TdWJtaXQ6IHRoaXMuaGFuZGxlU3VibWl0IH0sXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnaDMnLFxuICAgICAgICBudWxsLFxuICAgICAgICAnQWRkIENhdGVnb3J5J1xuICAgICAgKSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdwJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnbGFiZWwnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGh0bWxGb3I6ICdjYXRlZ29yeS1pbnB1dC1sYWJlbCcgfSxcbiAgICAgICAgICAnTGFiZWwnXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAncCcsXG4gICAgICAgIG51bGwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jywge1xuICAgICAgICAgIGlkOiAnY2F0ZWdvcnktaW5wdXQtbGFiZWwnLFxuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICBuYW1lOiAndmFsTGFiZWwnLFxuICAgICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLnZhbExhYmVsLFxuICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLmhhbmRsZUlucHV0Q2hhbmdlIH0pXG4gICAgICApLFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3AnLFxuICAgICAgICBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHtcbiAgICAgICAgICBpZDogJ2NhdGVnb3J5LWlucHV0LXN1Ym1pdCcsXG4gICAgICAgICAgdHlwZTogJ3N1Ym1pdCcsXG4gICAgICAgICAgZGlzYWJsZWQ6ICF0aGlzLnZhbGlkYXRlKCkgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG5cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FwcC9zcmMvY29tcG9uZW50cy9DdXN0b21pemVDYXRlZ29yeUZvcm0uanN4XG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8vIEltcG9ydHNcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcblxuaW1wb3J0IEFwcCBmcm9tICcuL0FwcCc7XG5cbi8vIENvbnN0YW50c1xuXG5cbi8vIENvbXBvbmVudFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXN0b21pemVUYWJsZUNlbGwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8vIENvbnN0cnVjdG9yXG5cbiAgY29uc3RydWN0b3IoKSB7XG5cbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5oYW5kbGVJbnB1dEZvY3VzID0gZSA9PiB7XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBlZGl0aW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVJbnB1dEJsdXIgPSBlID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBlZGl0aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuaGFuZGxlV2VpZ2h0Q2hhbmdlID0gZSA9PiB7XG5cbiAgICAgIGNvbnN0IGFjdEtleSA9IHRoaXMucHJvcHMuYWN0S2V5LFxuICAgICAgICAgICAgdmFsTGlua0tleSA9IHRoaXMucHJvcHMudmFsTGlua0tleSxcbiAgICAgICAgICAgIHdlaWdodCA9IGUuY3VycmVudFRhcmdldC52YWx1ZTtcblxuICAgICAgaWYgKHRoaXMucHJvcHMub25XZWlnaHRDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbldlaWdodENoYW5nZShhY3RLZXksIHZhbExpbmtLZXksIHdlaWdodCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaW5pdFN0YXRlKCk7XG4gIH1cblxuICBpbml0U3RhdGUoKSB7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZWRpdGluZzogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgLy8gRXZlbnQgaGFuZGxlcnNcblxuICAvLyBSZWFjdFxuXG4gIHJlbmRlcigpIHtcblxuICAgIGNvbnN0IGFjdEtleSA9IHRoaXMucHJvcHMuYWN0S2V5LFxuICAgICAgICAgIGFjdGl2aXR5ID0gdGhpcy5wcm9wcy5hY3Rpdml0eSxcbiAgICAgICAgICB2YWxMaW5rS2V5ID0gdGhpcy5wcm9wcy52YWxMaW5rS2V5LFxuICAgICAgICAgIHZhbExpbmsgPSBhY3Rpdml0eSAmJiBhY3Rpdml0eS52YWx1ZXMgPyBhY3Rpdml0eS52YWx1ZXNbdmFsTGlua0tleV0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgd2VpZ2h0ID0gdmFsTGluayA/IHZhbExpbmsud2VpZ2h0IDogMDtcblxuICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc05hbWVzKHtcbiAgICAgIFsnd2VpZ2h0LScgKyB3ZWlnaHRdOiB0cnVlLFxuICAgICAgZWRpdGluZzogdGhpcy5zdGF0ZS5lZGl0aW5nXG4gICAgfSk7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICd0ZCcsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NlcyB9LFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaW5wdXQnLCB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBvbkZvY3VzOiB0aGlzLmhhbmRsZUlucHV0Rm9jdXMsXG4gICAgICAgIG9uQmx1cjogdGhpcy5oYW5kbGVJbnB1dEJsdXIsXG4gICAgICAgIG9uQ2hhbmdlOiB0aGlzLmhhbmRsZVdlaWdodENoYW5nZSxcbiAgICAgICAgdmFsdWU6IHdlaWdodCB9KVxuICAgICk7XG4gIH1cblxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL3NyYy9jb21wb25lbnRzL0N1c3RvbWl6ZVRhYmxlQ2VsbC5qc3hcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLy8gSW1wb3J0c1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuXG5pbXBvcnQgQXBwIGZyb20gJy4vQXBwJztcbmltcG9ydCBDdXN0b21pemVUYWJsZSBmcm9tICcuL0N1c3RvbWl6ZVRhYmxlJztcbmltcG9ydCBDdXN0b21pemVDYXRlZ29yeUZvcm0gZnJvbSAnLi9DdXN0b21pemVDYXRlZ29yeUZvcm0nO1xuaW1wb3J0IEN1c3RvbWl6ZVZhbHVlRm9ybSBmcm9tICcuL0N1c3RvbWl6ZVZhbHVlRm9ybSc7XG5pbXBvcnQgQ3VzdG9taXplQWN0aXZpdHlGb3JtIGZyb20gJy4vQ3VzdG9taXplQWN0aXZpdHlGb3JtJztcblxuLy8gQ29uc3RhbnRzXG5cblxuLy8gQ29tcG9uZW50XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1c3RvbWl6ZVZpZXcgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8vIENvbnN0cnVjdG9yXG5cbiAgY29uc3RydWN0b3IoKSB7XG5cbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5pbml0U3RhdGUoKTtcbiAgfVxuXG4gIGluaXRTdGF0ZSgpIHt9XG5cbiAgLy8gRXZlbnQgaGFuZGxlcnNcblxuXG4gIC8vIE1ldGhvZHNcblxuXG4gIC8vIFJlYWN0XG5cbiAgcmVuZGVyKCkge1xuXG4gICAgY29uc3QgY2xhc3NTZWN0aW9uID0gY2xhc3NOYW1lcyh7XG4gICAgICAnY3VzdG9taXplJzogdHJ1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnc2VjdGlvbicsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NTZWN0aW9uIH0sXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnaGVhZGVyJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnaDInLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgJ0N1c3RvbWl6ZSdcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdhcnRpY2xlJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnaDInLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgJ0VkaXQgQWN0aXZpdGllcydcbiAgICAgICAgKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDdXN0b21pemVUYWJsZSwgbnVsbCksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2gyJyxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgICdBZGQgbmV3J1xuICAgICAgICApLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEN1c3RvbWl6ZUNhdGVnb3J5Rm9ybSwgbnVsbCksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ3VzdG9taXplVmFsdWVGb3JtLCBudWxsKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDdXN0b21pemVBY3Rpdml0eUZvcm0sIG51bGwpXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvc3JjL2NvbXBvbmVudHMvQ3VzdG9taXplVmlldy5qc3hcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLy8gSW1wb3J0c1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuXG5pbXBvcnQgQXBwIGZyb20gJy4vQXBwJztcblxuLy8gQ29uc3RhbnRzXG5cblxuLy8gQ29tcG9uZW50XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2YWx1YXRlVmlldyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgLy8gQ29uc3RydWN0b3JcblxuICBjb25zdHJ1Y3RvcigpIHtcblxuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmluaXRTdGF0ZSgpO1xuICB9XG5cbiAgaW5pdFN0YXRlKCkge31cblxuICAvLyBFdmVudCBoYW5kbGVyc1xuXG5cbiAgLy8gTWV0aG9kc1xuXG5cbiAgLy8gUmVhY3RcblxuICByZW5kZXIoKSB7XG5cbiAgICBjb25zdCBjbGFzc1NlY3Rpb24gPSBjbGFzc05hbWVzKHtcbiAgICAgICdldmFsdWF0ZSc6IHRydWVcbiAgICB9KTtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgJ3NlY3Rpb24nLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IGNsYXNzU2VjdGlvbiB9LFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2hlYWRlcicsXG4gICAgICAgIG51bGwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2gyJyxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgICdFdmFsdWF0ZSdcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdhcnRpY2xlJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnaDInLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgJ1RvIGRvLidcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH1cblxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL3NyYy9jb21wb25lbnRzL0V2YWx1YXRlVmlldy5qc3hcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLy8gSW1wb3J0c1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuXG5pbXBvcnQgQXBwIGZyb20gJy4vQXBwJztcbmltcG9ydCBDdXN0b21pemVUYWJsZSBmcm9tICcuL0N1c3RvbWl6ZVRhYmxlJztcbmltcG9ydCBDdXN0b21pemVWYWx1ZUZvcm0gZnJvbSAnLi9DdXN0b21pemVWYWx1ZUZvcm0nO1xuaW1wb3J0IEN1c3RvbWl6ZUFjdGl2aXR5Rm9ybSBmcm9tICcuL0N1c3RvbWl6ZUFjdGl2aXR5Rm9ybSc7XG5cbi8vIENvbnN0YW50c1xuXG5cbi8vIENvbXBvbmVudFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2dpblZpZXcgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8vIENvbnN0cnVjdG9yXG5cbiAgY29uc3RydWN0b3IoKSB7XG5cbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5oYW5kbGVBbm9ueW1vdXNMb2dpbkNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5wcm9wcy5vbkFub255bW91c0xvZ2luQ2xpY2soKTtcbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVHb29nbGVMb2dpbkNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5wcm9wcy5vbkdvb2dsZUxvZ2luQ2xpY2soKTtcbiAgICB9O1xuXG4gICAgdGhpcy5pbml0U3RhdGUoKTtcbiAgfVxuXG4gIGluaXRTdGF0ZSgpIHt9XG5cbiAgLy8gRXZlbnQgaGFuZGxlcnNcblxuICAvLyBNZXRob2RzXG5cblxuICAvLyBSZWFjdFxuXG4gIHJlbmRlcigpIHtcblxuICAgIGNvbnN0IGNsYXNzU2VjdGlvbiA9IGNsYXNzTmFtZXMoe1xuICAgICAgJ2xvZ2luJzogdHJ1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnc2VjdGlvbicsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NTZWN0aW9uIH0sXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6ICdsb2dpbi1wYW5lbCcgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnaDEnLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgJ0VuZGVhdm9ycydcbiAgICAgICAgKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAncCcsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2J1dHRvbicsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuaGFuZGxlR29vZ2xlTG9naW5DbGljayB9LFxuICAgICAgICAgICAgJ0xvZyBpbiB3aXRoIEdvb2dsZSdcbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3AnLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdidXR0b24nLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZUFub255bW91c0xvZ2luQ2xpY2sgfSxcbiAgICAgICAgICAgICdMb2cgaW4gQW5vbnltb3VzbHknXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvc3JjL2NvbXBvbmVudHMvTG9naW5WaWV3LmpzeFxuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vLyBJbXBvcnRzXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAnO1xuXG4vLyBDb25zdGFudHNcblxuXG4vLyBDb21wb25lbnRcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2V0dGluZ3NWaWV3IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAvLyBDb25zdHJ1Y3RvclxuXG4gIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuaW5pdFN0YXRlKCk7XG4gIH1cblxuICBpbml0U3RhdGUoKSB7fVxuXG4gIC8vIEV2ZW50IGhhbmRsZXJzXG5cblxuICAvLyBNZXRob2RzXG5cblxuICAvLyBSZWFjdFxuXG4gIHJlbmRlcigpIHtcblxuICAgIGNvbnN0IGNsYXNzU2VjdGlvbiA9IGNsYXNzTmFtZXMoe1xuICAgICAgJ3NldHRpbmdzJzogdHJ1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnc2VjdGlvbicsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NTZWN0aW9uIH0sXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnaGVhZGVyJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnaDInLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgJ1NldHRpbmdzJ1xuICAgICAgICApXG4gICAgICApLFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2FydGljbGUnLFxuICAgICAgICBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdoMicsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICAnVG8gZG8uJ1xuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvc3JjL2NvbXBvbmVudHMvU2V0dGluZ3NWaWV3LmpzeFxuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vLyBJbXBvcnRzXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAnO1xuaW1wb3J0IFNpZGViYXJJdGVtIGZyb20gJy4vU2lkZWJhckl0ZW0nO1xuXG4vLyBDb25zdGFudHNcblxuXG4vLyBDb21wb25lbnRcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2lkZWJhciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgLy8gQ29uc3RydWN0b3JcblxuICBjb25zdHJ1Y3RvcigpIHtcblxuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmhhbmRsZUl0ZW1TZWxlY3QgPSBpdGVtQ2xhc3MgPT4ge1xuXG4gICAgICB0aGlzLnByb3BzLm9uTW9kZUNoYW5nZShpdGVtQ2xhc3MpO1xuICAgIH07XG5cbiAgICB0aGlzLmluaXRTdGF0ZSgpO1xuICB9XG5cbiAgaW5pdFN0YXRlKCkge31cblxuICAvLyBFdmVudCBoYW5kbGVyc1xuXG4gIC8vIE1ldGhvZHNcblxuXG4gIC8vIFJlYWN0XG5cbiAgcmVuZGVyKCkge1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnYXNpZGUnLFxuICAgICAgbnVsbCxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICd1bCcsXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzc05hbWU6ICdtYWluLW5hdicgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTaWRlYmFySXRlbSwge1xuICAgICAgICAgIGxhYmVsOiAnVHJhY2snLFxuICAgICAgICAgIGNsYXNzTmFtZTogJ3RyYWNrJyxcbiAgICAgICAgICBpY29uOiAnY2hlY2tfYm94JyxcbiAgICAgICAgICBzZWxlY3RlZDogdGhpcy5wcm9wcy5tb2RlID09PSAndHJhY2snLFxuICAgICAgICAgIG9uU2VsZWN0OiB0aGlzLmhhbmRsZUl0ZW1TZWxlY3QgfSksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2lkZWJhckl0ZW0sIHtcbiAgICAgICAgICBsYWJlbDogJ0V2YWx1YXRlJyxcbiAgICAgICAgICBjbGFzc05hbWU6ICdldmFsdWF0ZScsXG4gICAgICAgICAgaWNvbjogJ3RpbWVsaW5lJyxcbiAgICAgICAgICBzZWxlY3RlZDogdGhpcy5wcm9wcy5tb2RlID09PSAnZXZhbHVhdGUnLFxuICAgICAgICAgIG9uU2VsZWN0OiB0aGlzLmhhbmRsZUl0ZW1TZWxlY3QgfSlcbiAgICAgICksXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAndWwnLFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3NOYW1lOiAnc3ViLW5hdicgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTaWRlYmFySXRlbSwge1xuICAgICAgICAgIGxhYmVsOiAnQ3VzdG9taXplJyxcbiAgICAgICAgICBjbGFzc05hbWU6ICdjdXN0b21pemUnLFxuICAgICAgICAgIGljb246ICdmaW5nZXJwcmludCcsXG4gICAgICAgICAgc2VsZWN0ZWQ6IHRoaXMucHJvcHMubW9kZSA9PT0gJ2N1c3RvbWl6ZScsXG4gICAgICAgICAgb25TZWxlY3Q6IHRoaXMuaGFuZGxlSXRlbVNlbGVjdCB9KSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTaWRlYmFySXRlbSwge1xuICAgICAgICAgIGxhYmVsOiAnU2V0dGluZ3MnLFxuICAgICAgICAgIGNsYXNzTmFtZTogJ3NldHRpbmdzJyxcbiAgICAgICAgICBpY29uOiAnc2V0dGluZ3NfYXBwbGljYXRpb25zJyxcbiAgICAgICAgICBzZWxlY3RlZDogdGhpcy5wcm9wcy5tb2RlID09PSAnc2V0dGluZ3MnLFxuICAgICAgICAgIG9uU2VsZWN0OiB0aGlzLmhhbmRsZUl0ZW1TZWxlY3QgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG5cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FwcC9zcmMvY29tcG9uZW50cy9TaWRlYmFyLmpzeFxuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vLyBJbXBvcnRzXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAnO1xuXG4vLyBDb25zdGFudHNcblxuXG4vLyBDb21wb25lbnRcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2lkZWJhckl0ZW0gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8vIENvbnN0cnVjdG9yXG5cbiAgY29uc3RydWN0b3IoKSB7XG5cbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5oYW5kbGVDbGljayA9IGUgPT4ge1xuICAgICAgdGhpcy5wcm9wcy5vblNlbGVjdCh0aGlzLnByb3BzLmNsYXNzTmFtZSk7XG4gICAgfTtcblxuICAgIHRoaXMuaW5pdFN0YXRlKCk7XG4gIH1cblxuICBpbml0U3RhdGUoKSB7fVxuXG4gIC8vIEV2ZW50IGhhbmRsZXJzXG5cbiAgLy8gTWV0aG9kc1xuXG5cbiAgLy8gUmVhY3RcblxuICByZW5kZXIoKSB7XG5cbiAgICBjb25zdCBjbGFzc0xpID0gY2xhc3NOYW1lcyh7XG4gICAgICBbdGhpcy5wcm9wcy5jbGFzc05hbWVdOiB0cnVlLFxuICAgICAgc2VsZWN0ZWQ6IHRoaXMucHJvcHMuc2VsZWN0ZWRcbiAgICB9KTtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2xpJyxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc0xpLFxuICAgICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrIH0sXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAncCcsXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzc05hbWU6ICdpY29uJyB9LFxuICAgICAgICB0aGlzLnByb3BzLmljb25cbiAgICAgICksXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAncCcsXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzc05hbWU6ICdsYWJlbCcgfSxcbiAgICAgICAgdGhpcy5wcm9wcy5sYWJlbFxuICAgICAgKVxuICAgICk7XG4gIH1cblxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL3NyYy9jb21wb25lbnRzL1NpZGViYXJJdGVtLmpzeFxuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vLyBJbXBvcnRzXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAnO1xuXG4vLyBDb25zdGFudHNcblxuXG4vLyBDb21wb25lbnRcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhY2tWaWV3IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAvLyBDb25zdHJ1Y3RvclxuXG4gIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuaW5pdFN0YXRlKCk7XG4gIH1cblxuICBpbml0U3RhdGUoKSB7fVxuXG4gIC8vIEV2ZW50IGhhbmRsZXJzXG5cblxuICAvLyBNZXRob2RzXG5cblxuICAvLyBSZWFjdFxuXG4gIHJlbmRlcigpIHtcblxuICAgIGNvbnN0IGNsYXNzU2VjdGlvbiA9IGNsYXNzTmFtZXMoe1xuICAgICAgJ3RyYWNrJzogdHJ1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnc2VjdGlvbicsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NTZWN0aW9uIH0sXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnaGVhZGVyJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnaDInLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgJ1RyYWNrJ1xuICAgICAgICApXG4gICAgICApLFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2FydGljbGUnLFxuICAgICAgICBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdoMicsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICAnVG8gZG8uJ1xuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvc3JjL2NvbXBvbmVudHMvVHJhY2tWaWV3LmpzeFxuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG5pbXBvcnQgZmlyZWJhc2UgZnJvbSAnZmlyZWJhc2UvYXBwJztcbmltcG9ydCAnZmlyZWJhc2UvYXV0aCc7XG5pbXBvcnQgJ2ZpcmViYXNlL2RhdGFiYXNlJztcblxuaW1wb3J0ICcuL3N0eWxlcy9zdHlsZS5zY3NzJztcblxuaW1wb3J0IEFwcCBmcm9tICcuL2NvbXBvbmVudHMvQXBwJztcblxuY29uc3QgREVCVUdfU0lHTl9PVVQgPSBmYWxzZTtcblxuaW5pdEZpcmViYXNlKCk7XG5pbml0QXBwKCk7XG5cbmZ1bmN0aW9uIGluaXRGaXJlYmFzZSgpIHtcblxuICBmaXJlYmFzZS5pbml0aWFsaXplQXBwKHtcbiAgICBhcGlLZXk6IFwiQUl6YVN5Q2ZjZVV2TFVRclBKVFd4LU9CTjgyRnRFWmUzREtFZk5zXCIsXG4gICAgYXV0aERvbWFpbjogXCJlbmRlYXZvcnNzc3NzLmZpcmViYXNlYXBwLmNvbVwiLFxuICAgIGRhdGFiYXNlVVJMOiBcImh0dHBzOi8vZW5kZWF2b3Jzc3Nzcy5maXJlYmFzZWlvLmNvbVwiLFxuICAgIHByb2plY3RJZDogXCJlbmRlYXZvcnNzc3NzXCIsXG4gICAgc3RvcmFnZUJ1Y2tldDogXCJlbmRlYXZvcnNzc3NzLmFwcHNwb3QuY29tXCIsXG4gICAgbWVzc2FnaW5nU2VuZGVySWQ6IFwiNTg5NTkxMzE2NzM2XCJcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluaXRBcHAoKSB7XG5cbiAgaWYgKERFQlVHX1NJR05fT1VUKSB7XG4gICAgZmlyZWJhc2UuYXV0aCgpLnNldFBlcnNpc3RlbmNlKGZpcmViYXNlLmF1dGguQXV0aC5QZXJzaXN0ZW5jZS5OT05FKTtcbiAgICBmaXJlYmFzZS5hdXRoKCkuc2lnbk91dCgpO1xuICAgIHdpbmRvdy5sb2NhdGlvbiA9IFwiaHR0cHM6Ly9tYWlsLmdvb2dsZS5jb20vbWFpbC91LzAvP2xvZ291dCZobD1lblwiO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwJyksXG4gICAgICAgIGNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXBwKTtcblxuICBSZWFjdERPTS5yZW5kZXIoY29tcG9uZW50LCBlbGVtZW50KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FwcC9zcmMvZW50cnkuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIioge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveCAhaW1wb3J0YW50OyB9XFxuXFxuaHRtbCxcXG5ib2R5LFxcbmRpdiNhcHAsXFxuZGl2LndyYXAtYWxsIHtcXG4gIHdpZHRoOiAxMDB2dztcXG4gIGhlaWdodDogMTAwdmg7XFxuICBtaW4taGVpZ2h0OiAxMDB2aDsgfVxcblxcbkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6ICdNYXRlcmlhbCBJY29ucyc7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxuICBmb250LXdlaWdodDogNDAwO1xcbiAgc3JjOiB1cmwoXCIgKyByZXF1aXJlKFwiLi4vZm9udHMvbWF0ZXJpYWwtaWNvbnMvTWF0ZXJpYWxJY29ucy1SZWd1bGFyLmVvdFwiKSArIFwiKTtcXG4gIC8qIEZvciBJRTYtOCAqL1xcbiAgc3JjOiBsb2NhbChcXFwiTWF0ZXJpYWwgSWNvbnNcXFwiKSwgbG9jYWwoXFxcIk1hdGVyaWFsSWNvbnMtUmVndWxhclxcXCIpLCB1cmwoXCIgKyByZXF1aXJlKFwiLi4vZm9udHMvbWF0ZXJpYWwtaWNvbnMvTWF0ZXJpYWxJY29ucy1SZWd1bGFyLndvZmYyXCIpICsgXCIpIGZvcm1hdChcXFwid29mZjJcXFwiKSwgdXJsKFwiICsgcmVxdWlyZShcIi4uL2ZvbnRzL21hdGVyaWFsLWljb25zL01hdGVyaWFsSWNvbnMtUmVndWxhci53b2ZmXCIpICsgXCIpIGZvcm1hdChcXFwid29mZlxcXCIpLCB1cmwoXCIgKyByZXF1aXJlKFwiLi4vZm9udHMvbWF0ZXJpYWwtaWNvbnMvTWF0ZXJpYWxJY29ucy1SZWd1bGFyLnR0ZlwiKSArIFwiKSBmb3JtYXQoXFxcInRydWV0eXBlXFxcIik7IH1cXG5cXG4uaWNvbiB7XFxuICBmb250LWZhbWlseTogJ01hdGVyaWFsIEljb25zJztcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxuICBmb250LXNpemU6IDI0cHg7XFxuICAvKiBQcmVmZXJyZWQgaWNvbiBzaXplICovXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBsaW5lLWhlaWdodDogMTtcXG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xcbiAgbGV0dGVyLXNwYWNpbmc6IG5vcm1hbDtcXG4gIHdvcmQtd3JhcDogbm9ybWFsO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIGRpcmVjdGlvbjogbHRyO1xcbiAgLyogU3VwcG9ydCBmb3IgYWxsIFdlYktpdCBicm93c2Vycy4gKi9cXG4gIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbiAgLyogU3VwcG9ydCBmb3IgU2FmYXJpIGFuZCBDaHJvbWUuICovXFxuICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xcbiAgLyogU3VwcG9ydCBmb3IgRmlyZWZveC4gKi9cXG4gIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7XFxuICAvKiBTdXBwb3J0IGZvciBJRS4gKi9cXG4gIGZvbnQtZmVhdHVyZS1zZXR0aW5nczogJ2xpZ2EnOyB9XFxuXFxuc2VjdGlvbi5sb2dpbiwgYXNpZGUsIG1haW4gPiBzZWN0aW9uIGhlYWRlciB7XFxuICAtd2Via2l0LWFwcC1yZWdpb246IGRyYWc7IH1cXG5cXG5zZWN0aW9uLmxvZ2luIGRpdi5sb2dpbi1wYW5lbCBwIGJ1dHRvbiB7XFxuICAtd2Via2l0LWFwcC1yZWdpb246IG5vLWRyYWc7IH1cXG5cXG5zZWN0aW9uLmxvZ2luIDpub3QoaW5wdXQpOm5vdCh0ZXh0YXJlYSksIGFzaWRlIDpub3QoaW5wdXQpOm5vdCh0ZXh0YXJlYSksIG1haW4gPiBzZWN0aW9uIGhlYWRlciA6bm90KGlucHV0KTpub3QodGV4dGFyZWEpLCBzZWN0aW9uLmxvZ2luIDpub3QoaW5wdXQpOm5vdCh0ZXh0YXJlYSk6OmFmdGVyLCBhc2lkZSA6bm90KGlucHV0KTpub3QodGV4dGFyZWEpOjphZnRlciwgbWFpbiA+IHNlY3Rpb24gaGVhZGVyIDpub3QoaW5wdXQpOm5vdCh0ZXh0YXJlYSk6OmFmdGVyLCBzZWN0aW9uLmxvZ2luIDpub3QoaW5wdXQpOm5vdCh0ZXh0YXJlYSk6OmJlZm9yZSwgYXNpZGUgOm5vdChpbnB1dCk6bm90KHRleHRhcmVhKTo6YmVmb3JlLCBtYWluID4gc2VjdGlvbiBoZWFkZXIgOm5vdChpbnB1dCk6bm90KHRleHRhcmVhKTo6YmVmb3JlIHtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIGN1cnNvcjogZGVmYXVsdDsgfVxcblxcbnNlY3Rpb24ubG9naW4gaW5wdXQsIGFzaWRlIGlucHV0LCBtYWluID4gc2VjdGlvbiBoZWFkZXIgaW5wdXQsIHNlY3Rpb24ubG9naW4gYnV0dG9uLCBhc2lkZSBidXR0b24sIG1haW4gPiBzZWN0aW9uIGhlYWRlciBidXR0b24sIHNlY3Rpb24ubG9naW4gdGV4dGFyZWEsIGFzaWRlIHRleHRhcmVhLCBtYWluID4gc2VjdGlvbiBoZWFkZXIgdGV4dGFyZWEsIHNlY3Rpb24ubG9naW4gOmZvY3VzLCBhc2lkZSA6Zm9jdXMsIG1haW4gPiBzZWN0aW9uIGhlYWRlciA6Zm9jdXMge1xcbiAgb3V0bGluZTogbm9uZTsgfVxcblxcbmJvZHkge1xcbiAgZm9udDogMTNweC8xN3B4IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXFxcIlNlZ29lIFVJXFxcIiwgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZiwgXFxcIkFwcGxlIENvbG9yIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIFN5bWJvbFxcXCI7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gIG1hcmdpbjogMHB4O1xcbiAgcGFkZGluZzogMHB4O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjsgfVxcblxcbnNlY3Rpb24ubG9naW4ge1xcbiAgYmFja2dyb3VuZDogIzIyMjtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlOyB9XFxuICBzZWN0aW9uLmxvZ2luIGRpdi5sb2dpbi1wYW5lbCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgbGVmdDogNTAlO1xcbiAgICB0b3A6IDUwJTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7IH1cXG4gICAgc2VjdGlvbi5sb2dpbiBkaXYubG9naW4tcGFuZWwgaDEge1xcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXG4gICAgICBsZXR0ZXItc3BhY2luZzogMC4wMjVlbTtcXG4gICAgICBjb2xvcjogI2ZmZjtcXG4gICAgICBtYXJnaW4tYm90dG9tOiAzNXB4OyB9XFxuICAgIHNlY3Rpb24ubG9naW4gZGl2LmxvZ2luLXBhbmVsIHAge1xcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICBtYXJnaW46IDBweCAwcHggMTVweCAwcHg7IH1cXG4gICAgICBzZWN0aW9uLmxvZ2luIGRpdi5sb2dpbi1wYW5lbCBwIGJ1dHRvbiB7XFxuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjOTZmO1xcbiAgICAgICAgYmFja2dyb3VuZDogbm9uZTtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcXG4gICAgICAgIHBhZGRpbmc6IDE1cHggMjBweDtcXG4gICAgICAgIG91dGxpbmU6IG5vbmU7XFxuICAgICAgICBjb2xvcjogIzk2ZjtcXG4gICAgICAgIGZvbnQ6IDYwMCAxNnB4IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXFxcIlNlZ29lIFVJXFxcIiwgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZiwgXFxcIkFwcGxlIENvbG9yIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIFN5bWJvbFxcXCI7XFxuICAgICAgICB0cmFuc2l0aW9uOiBib3JkZXItY29sb3IgMC4xcywgY29sb3IgMC4xcywgYmFja2dyb3VuZC1jb2xvciAwLjFzOyB9XFxuICAgICAgICBzZWN0aW9uLmxvZ2luIGRpdi5sb2dpbi1wYW5lbCBwIGJ1dHRvbjpob3Zlciwgc2VjdGlvbi5sb2dpbiBkaXYubG9naW4tcGFuZWwgcCBidXR0b246YWN0aXZlIHtcXG4gICAgICAgICAgYm9yZGVyLWNvbG9yOiAjOTZmO1xcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjOTZmO1xcbiAgICAgICAgICBjb2xvcjogIzIyMjsgfVxcbiAgICAgICAgc2VjdGlvbi5sb2dpbiBkaXYubG9naW4tcGFuZWwgcCBidXR0b246YWN0aXZlOmhvdmVyIHtcXG4gICAgICAgICAgb3BhY2l0eTogMC41OyB9XFxuXFxuYXNpZGUge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgdG9wOiAwcHg7XFxuICBsZWZ0OiAwcHg7XFxuICB3aWR0aDogMTAwcHg7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjIyOyB9XFxuICBhc2lkZSB1bCB7XFxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICAgIG1hcmdpbjogMHB4O1xcbiAgICBwYWRkaW5nOiAwcHg7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgbGVmdDogNTAlO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAwcHgpO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIHdpZHRoOiBjYWxjKDEwMCUgLSAyMHB4KTsgfVxcbiAgICBhc2lkZSB1bC5tYWluLW5hdiB7XFxuICAgICAgdG9wOiA4NXB4OyB9XFxuICAgIGFzaWRlIHVsLnN1Yi1uYXYge1xcbiAgICAgIGJvdHRvbTogMTBweDsgfVxcbiAgICBhc2lkZSB1bCBsaSB7XFxuICAgICAgbWFyZ2luLWJvdHRvbTogMTBweDtcXG4gICAgICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICAgICAgcGFkZGluZzogMTBweCAwcHg7XFxuICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjFzOyB9XFxuICAgICAgYXNpZGUgdWwgbGkgcCB7XFxuICAgICAgICBtYXJnaW46IDBweDtcXG4gICAgICAgIGNvbG9yOiAjNTU1O1xcbiAgICAgICAgdHJhbnNpdGlvbjogY29sb3IgMC4xcywgb3BhY2l0eSAwLjFzOyB9XFxuICAgICAgICBhc2lkZSB1bCBsaSBwLmljb24ge1xcbiAgICAgICAgICBmb250LXNpemU6IDQ4cHg7IH1cXG4gICAgICAgIGFzaWRlIHVsIGxpIHAubGFiZWwge1xcbiAgICAgICAgICBmb250LXNpemU6IDEwcHg7XFxuICAgICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxuICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkOyB9XFxuICAgICAgYXNpZGUgdWwgbGk6aG92ZXI6bm90KC5zZWxlY3RlZCkge1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzJmMmYyZjsgfVxcbiAgICAgICAgYXNpZGUgdWwgbGk6aG92ZXI6bm90KC5zZWxlY3RlZCkudHJhY2sgcC5pY29uIHtcXG4gICAgICAgICAgY29sb3I6ICMwY2Q7IH1cXG4gICAgICAgIGFzaWRlIHVsIGxpOmhvdmVyOm5vdCguc2VsZWN0ZWQpLmV2YWx1YXRlIHAuaWNvbiB7XFxuICAgICAgICAgIGNvbG9yOiAjY2YwOyB9XFxuICAgICAgICBhc2lkZSB1bCBsaTpob3Zlcjpub3QoLnNlbGVjdGVkKS5jdXN0b21pemUgcC5pY29uIHtcXG4gICAgICAgICAgY29sb3I6ICM5NmY7IH1cXG4gICAgICAgIGFzaWRlIHVsIGxpOmhvdmVyOm5vdCguc2VsZWN0ZWQpLnNldHRpbmdzIHAuaWNvbiB7XFxuICAgICAgICAgIGNvbG9yOiAjZjY2OyB9XFxuICAgICAgICBhc2lkZSB1bCBsaTpob3Zlcjpub3QoLnNlbGVjdGVkKSBwLmxhYmVsIHtcXG4gICAgICAgICAgY29sb3I6IHdoaXRlOyB9XFxuICAgICAgYXNpZGUgdWwgbGk6YWN0aXZlOm5vdCguc2VsZWN0ZWQpIHAge1xcbiAgICAgICAgb3BhY2l0eTogMC41O1xcbiAgICAgICAgdHJhbnNpdGlvbjogbm9uZTsgfVxcbiAgICAgIGFzaWRlIHVsIGxpLnNlbGVjdGVkLnRyYWNrIHtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMwY2Q7IH1cXG4gICAgICAgIGFzaWRlIHVsIGxpLnNlbGVjdGVkLnRyYWNrIHAubGFiZWwge1xcbiAgICAgICAgICBjb2xvcjogIzFhNGQ1MTsgfVxcbiAgICAgIGFzaWRlIHVsIGxpLnNlbGVjdGVkLmV2YWx1YXRlIHtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNjZjA7IH1cXG4gICAgICAgIGFzaWRlIHVsIGxpLnNlbGVjdGVkLmV2YWx1YXRlIHAubGFiZWwge1xcbiAgICAgICAgICBjb2xvcjogIzRkNTkxYTsgfVxcbiAgICAgIGFzaWRlIHVsIGxpLnNlbGVjdGVkLmN1c3RvbWl6ZSB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjOTZmOyB9XFxuICAgICAgICBhc2lkZSB1bCBsaS5zZWxlY3RlZC5jdXN0b21pemUgcC5sYWJlbCB7XFxuICAgICAgICAgIGNvbG9yOiAjNDAzMzU5OyB9XFxuICAgICAgYXNpZGUgdWwgbGkuc2VsZWN0ZWQuc2V0dGluZ3Mge1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y2NjsgfVxcbiAgICAgICAgYXNpZGUgdWwgbGkuc2VsZWN0ZWQuc2V0dGluZ3MgcC5sYWJlbCB7XFxuICAgICAgICAgIGNvbG9yOiAjNTkzMzMzOyB9XFxuICAgICAgYXNpZGUgdWwgbGkuc2VsZWN0ZWQgcCB7XFxuICAgICAgICBjb2xvcjogYmxhY2s7IH1cXG5cXG5tYWluIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMHB4O1xcbiAgbGVmdDogMTAwcHg7XFxuICB3aWR0aDogY2FsYygxMDAlIC0gMTAwcHgpO1xcbiAgaGVpZ2h0OiAxMDAlOyB9XFxuICBtYWluID4gc2VjdGlvbiB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7IH1cXG4gICAgbWFpbiA+IHNlY3Rpb24gaGVhZGVyIHtcXG4gICAgICBoZWlnaHQ6IDc1cHg7XFxuICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNkZGQ7XFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICAgICAgbWFpbiA+IHNlY3Rpb24gaGVhZGVyIGgyIHtcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIHRvcDogNTAlO1xcbiAgICAgICAgbGVmdDogMjVweDtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDBweCwgLTUwJSk7XFxuICAgICAgICBtYXJnaW46IDBweDtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7IH1cXG4gICAgbWFpbiA+IHNlY3Rpb24gYXJ0aWNsZSB7XFxuICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgaGVpZ2h0OiBjYWxjKDEwMCUgLSA3NXB4KTtcXG4gICAgICBvdmVyZmxvdzogc2Nyb2xsO1xcbiAgICAgIGJhY2tncm91bmQ6ICNmNmY2ZjY7XFxuICAgICAgcGFkZGluZzogMjVweDsgfVxcblxcbnNlY3Rpb24uY3VzdG9taXplIHRhYmxlLmN1c3RvbWl6ZS10YWJsZSB7XFxuICBib3JkZXItc3BhY2luZzogMDtcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuICBtYXJnaW4tYm90dG9tOiAyNXB4OyB9XFxuICBzZWN0aW9uLmN1c3RvbWl6ZSB0YWJsZS5jdXN0b21pemUtdGFibGUgdGgsXFxuICBzZWN0aW9uLmN1c3RvbWl6ZSB0YWJsZS5jdXN0b21pemUtdGFibGUgdGQge1xcbiAgICBwYWRkaW5nOiA1cHg7XFxuICAgIHdpZHRoOiAxMjVweDsgfVxcbiAgICBzZWN0aW9uLmN1c3RvbWl6ZSB0YWJsZS5jdXN0b21pemUtdGFibGUgdGg6Zmlyc3QtY2hpbGQsXFxuICAgIHNlY3Rpb24uY3VzdG9taXplIHRhYmxlLmN1c3RvbWl6ZS10YWJsZSB0ZDpmaXJzdC1jaGlsZCB7XFxuICAgICAgd2lkdGg6IDIwMHB4OyB9XFxuICAgIHNlY3Rpb24uY3VzdG9taXplIHRhYmxlLmN1c3RvbWl6ZS10YWJsZSB0aDpub3QoOmZpcnN0LWNoaWxkKSxcXG4gICAgc2VjdGlvbi5jdXN0b21pemUgdGFibGUuY3VzdG9taXplLXRhYmxlIHRkOm5vdCg6Zmlyc3QtY2hpbGQpIHtcXG4gICAgICBib3JkZXItbGVmdDogMXB4IGRvdHRlZCAjZGRkOyB9XFxuICAgIHNlY3Rpb24uY3VzdG9taXplIHRhYmxlLmN1c3RvbWl6ZS10YWJsZSB0aCBhLnJlbW92ZS1idG4sXFxuICAgIHNlY3Rpb24uY3VzdG9taXplIHRhYmxlLmN1c3RvbWl6ZS10YWJsZSB0ZCBhLnJlbW92ZS1idG4ge1xcbiAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gICAgc2VjdGlvbi5jdXN0b21pemUgdGFibGUuY3VzdG9taXplLXRhYmxlIHRoOmhvdmVyIGEucmVtb3ZlLWJ0bixcXG4gICAgc2VjdGlvbi5jdXN0b21pemUgdGFibGUuY3VzdG9taXplLXRhYmxlIHRkOmhvdmVyIGEucmVtb3ZlLWJ0biB7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9XFxuICBzZWN0aW9uLmN1c3RvbWl6ZSB0YWJsZS5jdXN0b21pemUtdGFibGUgdGhlYWQgdHI6Zmlyc3QtY2hpbGQgdGgge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMjBweDtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG4gICAgY29sb3I6IGJsYWNrOyB9XFxuICBzZWN0aW9uLmN1c3RvbWl6ZSB0YWJsZS5jdXN0b21pemUtdGFibGUgdGhlYWQgdHIgdGgge1xcbiAgICBjb2xvcjogIzc3NztcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBmb250LXdlaWdodDogbm9ybWFsOyB9XFxuICAgIHNlY3Rpb24uY3VzdG9taXplIHRhYmxlLmN1c3RvbWl6ZS10YWJsZSB0aGVhZCB0ciB0aCBhLnJlbW92ZS1idG4ge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgIHJpZ2h0OiA1cHg7XFxuICAgICAgdG9wOiA1cHg7XFxuICAgICAgY29sb3I6ICNhYWE7XFxuICAgICAgYm9yZGVyLWNvbG9yOiAjYWFhOyB9XFxuICBzZWN0aW9uLmN1c3RvbWl6ZSB0YWJsZS5jdXN0b21pemUtdGFibGUgdGJvZHkgdGg6Zmlyc3QtY2hpbGQge1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgICBjb2xvcjogIzc3NztcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBib3JkZXItdG9wOiAxcHggZG90dGVkICNkZGQ7IH1cXG4gICAgc2VjdGlvbi5jdXN0b21pemUgdGFibGUuY3VzdG9taXplLXRhYmxlIHRib2R5IHRoOmZpcnN0LWNoaWxkIGEucmVtb3ZlLWJ0biB7XFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgIHJpZ2h0OiAxMHB4O1xcbiAgICAgIHRvcDogNTAlO1xcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDBweCwgLTUwJSk7IH1cXG4gIHNlY3Rpb24uY3VzdG9taXplIHRhYmxlLmN1c3RvbWl6ZS10YWJsZSB0ZCB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRvdHRlZCAjZGRkOyB9XFxuICAgIHNlY3Rpb24uY3VzdG9taXplIHRhYmxlLmN1c3RvbWl6ZS10YWJsZSB0ZCBpbnB1dCB7XFxuICAgICAgYm9yZGVyOiBub25lO1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgICAgZm9udDogYm9sZCAxM3B4LzE3cHggLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcXFwiU2Vnb2UgVUlcXFwiLCBIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmLCBcXFwiQXBwbGUgQ29sb3IgRW1vamlcXFwiLCBcXFwiU2Vnb2UgVUkgRW1vamlcXFwiLCBcXFwiU2Vnb2UgVUkgU3ltYm9sXFxcIjtcXG4gICAgICB3aWR0aDogMTAwJTtcXG4gICAgICBoZWlnaHQ6IDMwcHg7XFxuICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICBvdXRsaW5lOiBub25lICFpbXBvcnRhbnQ7IH1cXG4gICAgc2VjdGlvbi5jdXN0b21pemUgdGFibGUuY3VzdG9taXplLXRhYmxlIHRkLmVkaXRpbmcgaW5wdXQge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgICAgIGNvbG9yOiAjOTBmO1xcbiAgICAgIGJveC1zaGFkb3c6IGluc2V0IDAgMCAwIDNweCAjOTBmOyB9XFxuICAgIHNlY3Rpb24uY3VzdG9taXplIHRhYmxlLmN1c3RvbWl6ZS10YWJsZSB0ZDpub3QoLmVkaXRpbmcpIGlucHV0W3R5cGU9bnVtYmVyXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcXG4gICAgc2VjdGlvbi5jdXN0b21pemUgdGFibGUuY3VzdG9taXplLXRhYmxlIHRkOm5vdCguZWRpdGluZykgaW5wdXRbdHlwZT1udW1iZXJdOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcXG4gICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgbWFyZ2luOiAwOyB9XFxuICAgIHNlY3Rpb24uY3VzdG9taXplIHRhYmxlLmN1c3RvbWl6ZS10YWJsZSB0ZDpub3QoLmVkaXRpbmcpOmhvdmVyLndlaWdodC0wIGlucHV0IHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTsgfVxcbiAgICBzZWN0aW9uLmN1c3RvbWl6ZSB0YWJsZS5jdXN0b21pemUtdGFibGUgdGQ6bm90KC5lZGl0aW5nKS53ZWlnaHQtMCBpbnB1dCB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuICAgIHNlY3Rpb24uY3VzdG9taXplIHRhYmxlLmN1c3RvbWl6ZS10YWJsZSB0ZDpub3QoLmVkaXRpbmcpLndlaWdodC0xIGlucHV0IHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE1MywgMTAyLCAyNTUsIDAuMTUpO1xcbiAgICAgIGNvbG9yOiByZ2JhKDM3LCAyNSwgNjIsIDAuMzIpOyB9XFxuICAgIHNlY3Rpb24uY3VzdG9taXplIHRhYmxlLmN1c3RvbWl6ZS10YWJsZSB0ZDpub3QoLmVkaXRpbmcpLndlaWdodC0yIGlucHV0IHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE1MywgMTAyLCAyNTUsIDAuNSk7XFxuICAgICAgY29sb3I6IHJnYmEoMzcsIDI1LCA2MiwgMC4zMik7IH1cXG4gICAgc2VjdGlvbi5jdXN0b21pemUgdGFibGUuY3VzdG9taXplLXRhYmxlIHRkOm5vdCguZWRpdGluZykud2VpZ2h0LTMgaW5wdXQge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICM5NmY7XFxuICAgICAgY29sb3I6IHJnYmEoMzcsIDI1LCA2MiwgMC4zMik7IH1cXG4gIHNlY3Rpb24uY3VzdG9taXplIHRhYmxlLmN1c3RvbWl6ZS10YWJsZSBhLnJlbW92ZS1idG4ge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNhYWE7XFxuICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgICBmb250LXNpemU6IDE1cHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDEwMCU7XFxuICAgIGNvbG9yOiAjYWFhO1xcbiAgICB3aWR0aDogMjBweDtcXG4gICAgaGVpZ2h0OiAyMHB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IH1cXG4gICAgc2VjdGlvbi5jdXN0b21pemUgdGFibGUuY3VzdG9taXplLXRhYmxlIGEucmVtb3ZlLWJ0bjpob3ZlciB7XFxuICAgICAgYm9yZGVyLWNvbG9yOiAjZjY2O1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmNjY7XFxuICAgICAgY29sb3I6IHdoaXRlO1xcbiAgICAgIGN1cnNvcjogcG9pbnRlcjsgfVxcblxcbnNlY3Rpb24uY3VzdG9taXplIGZvcm0ge1xcbiAgdmVydGljYWwtYWxpZ246IHRvcDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7XFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBwYWRkaW5nOiAxMHB4O1xcbiAgbWFyZ2luLXJpZ2h0OiAxNXB4OyB9XFxuICBzZWN0aW9uLmN1c3RvbWl6ZSBmb3JtIGgzIHtcXG4gICAgbWFyZ2luLXRvcDogMHB4O1xcbiAgICBmb250LXNpemU6IDEzcHg7XFxuICAgIGNvbG9yOiAjNjY2OyB9XFxuICBzZWN0aW9uLmN1c3RvbWl6ZSBmb3JtIGxhYmVsIHtcXG4gICAgY29sb3I6ICM5OTk7IH1cXG4gIHNlY3Rpb24uY3VzdG9taXplIGZvcm0gcCB7XFxuICAgIG1hcmdpbjogNXB4IDA7IH1cXG4gIHNlY3Rpb24uY3VzdG9taXplIGZvcm0gaW5wdXRbdHlwZT0ndGV4dCddIHtcXG4gICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXFxcIlNlZ29lIFVJXFxcIiwgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZiwgXFxcIkFwcGxlIENvbG9yIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIFN5bWJvbFxcXCI7XFxuICAgIGZvbnQtc2l6ZTogMTNweDsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vYXBwL3NyYy9zdHlsZXMvc3R5bGUuc2Nzc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwicmVzb3VyY2VzL2ZvbnRzL01hdGVyaWFsSWNvbnMtUmVndWxhci5lb3RcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FwcC9zcmMvZm9udHMvbWF0ZXJpYWwtaWNvbnMvTWF0ZXJpYWxJY29ucy1SZWd1bGFyLmVvdFxuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwicmVzb3VyY2VzL2ZvbnRzL01hdGVyaWFsSWNvbnMtUmVndWxhci50dGZcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FwcC9zcmMvZm9udHMvbWF0ZXJpYWwtaWNvbnMvTWF0ZXJpYWxJY29ucy1SZWd1bGFyLnR0ZlxuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwicmVzb3VyY2VzL2ZvbnRzL01hdGVyaWFsSWNvbnMtUmVndWxhci53b2ZmXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvc3JjL2ZvbnRzL21hdGVyaWFsLWljb25zL01hdGVyaWFsSWNvbnMtUmVndWxhci53b2ZmXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJyZXNvdXJjZXMvZm9udHMvTWF0ZXJpYWxJY29ucy1SZWd1bGFyLndvZmYyXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvc3JjL2ZvbnRzL21hdGVyaWFsLWljb25zL01hdGVyaWFsSWNvbnMtUmVndWxhci53b2ZmMlxuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGNyZWF0ZVN1YnNjcmliZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IHBhdGNoUHJvcGVydHksIGRlZXBDb3B5LCBkZWVwRXh0ZW5kLCBFcnJvckZhY3RvcnkgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG52YXIgY29udGFpbnMgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn07XG52YXIgREVGQVVMVF9FTlRSWV9OQU1FID0gJ1tERUZBVUxUXSc7XG4vLyBBbiBhcnJheSB0byBjYXB0dXJlIGxpc3RlbmVycyBiZWZvcmUgdGhlIHRydWUgYXV0aCBmdW5jdGlvbnNcbi8vIGV4aXN0XG52YXIgdG9rZW5MaXN0ZW5lcnMgPSBbXTtcbi8qKlxuICogR2xvYmFsIGNvbnRleHQgb2JqZWN0IGZvciBhIGNvbGxlY3Rpb24gb2Ygc2VydmljZXMgdXNpbmdcbiAqIGEgc2hhcmVkIGF1dGhlbnRpY2F0aW9uIHN0YXRlLlxuICovXG52YXIgRmlyZWJhc2VBcHBJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpcmViYXNlQXBwSW1wbChvcHRpb25zLCBuYW1lLCBmaXJlYmFzZV8pIHtcbiAgICAgICAgdGhpcy5maXJlYmFzZV8gPSBmaXJlYmFzZV87XG4gICAgICAgIHRoaXMuaXNEZWxldGVkXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlcnZpY2VzXyA9IHt9O1xuICAgICAgICB0aGlzLm5hbWVfID0gbmFtZTtcbiAgICAgICAgdGhpcy5vcHRpb25zXyA9IGRlZXBDb3B5KG9wdGlvbnMpO1xuICAgICAgICB0aGlzLklOVEVSTkFMID0ge1xuICAgICAgICAgICAgZ2V0VWlkOiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZ2V0VG9rZW46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTsgfSxcbiAgICAgICAgICAgIGFkZEF1dGhUb2tlbkxpc3RlbmVyOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0b2tlbkxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgY2FsbGJhY2sgaXMgY2FsbGVkLCBhc3luY2hyb25vdXNseSwgaW4gdGhlIGFic2VuY2Ugb2YgdGhlIGF1dGggbW9kdWxlXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhudWxsKTsgfSwgMCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlQXV0aFRva2VuTGlzdGVuZXI6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRva2VuTGlzdGVuZXJzID0gdG9rZW5MaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIgIT09IGNhbGxiYWNrOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZpcmViYXNlQXBwSW1wbC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZF8oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWVfO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmlyZWJhc2VBcHBJbXBsLnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkXygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc187XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEZpcmViYXNlQXBwSW1wbC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIF90aGlzLmNoZWNrRGVzdHJveWVkXygpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZmlyZWJhc2VfLklOVEVSTkFMLnJlbW92ZUFwcChfdGhpcy5uYW1lXyk7XG4gICAgICAgICAgICB2YXIgc2VydmljZXMgPSBbXTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF90aGlzLnNlcnZpY2VzXykuZm9yRWFjaChmdW5jdGlvbiAoc2VydmljZUtleSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKF90aGlzLnNlcnZpY2VzX1tzZXJ2aWNlS2V5XSkuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2VLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VydmljZXMucHVzaChfdGhpcy5zZXJ2aWNlc19bc2VydmljZUtleV1baW5zdGFuY2VLZXldKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHNlcnZpY2VzLm1hcChmdW5jdGlvbiAoc2VydmljZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXJ2aWNlLklOVEVSTkFMLmRlbGV0ZSgpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaXNEZWxldGVkXyA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5zZXJ2aWNlc18gPSB7fTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBzZXJ2aWNlIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGFwcCAoY3JlYXRpbmcgaXRcbiAgICAgKiBvbiBkZW1hbmQpLCBpZGVudGlmaWVkIGJ5IHRoZSBwYXNzZWQgaW5zdGFuY2VJZGVudGlmaWVyLlxuICAgICAqXG4gICAgICogTk9URTogQ3VycmVudGx5IHN0b3JhZ2UgaXMgdGhlIG9ubHkgb25lIHRoYXQgaXMgbGV2ZXJhZ2luZyB0aGlzXG4gICAgICogZnVuY3Rpb25hbGl0eS4gVGhleSBpbnZva2UgaXQgYnkgY2FsbGluZzpcbiAgICAgKlxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBmaXJlYmFzZS5hcHAoKS5zdG9yYWdlKCdTVE9SQUdFIEJVQ0tFVCBJRCcpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgc2VydmljZSBuYW1lIGlzIHBhc3NlZCB0byB0aGlzIGFscmVhZHlcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBGaXJlYmFzZUFwcEltcGwucHJvdG90eXBlLl9nZXRTZXJ2aWNlID0gZnVuY3Rpb24gKG5hbWUsIGluc3RhbmNlSWRlbnRpZmllcikge1xuICAgICAgICBpZiAoaW5zdGFuY2VJZGVudGlmaWVyID09PSB2b2lkIDApIHsgaW5zdGFuY2VJZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FOyB9XG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWRfKCk7XG4gICAgICAgIGlmICghdGhpcy5zZXJ2aWNlc19bbmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZXNfW25hbWVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNlcnZpY2VzX1tuYW1lXVtpbnN0YW5jZUlkZW50aWZpZXJdKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIGEgY3VzdG9tIGluc3RhbmNlIGhhcyBiZWVuIGRlZmluZWQgKGkuZS4gbm90ICdbREVGQVVMVF0nKVxuICAgICAgICAgICAgICogdGhlbiB3ZSB3aWxsIHBhc3MgdGhhdCBpbnN0YW5jZSBvbiwgb3RoZXJ3aXNlIHdlIHBhc3MgYG51bGxgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZVNwZWNpZmllciA9IGluc3RhbmNlSWRlbnRpZmllciAhPT0gREVGQVVMVF9FTlRSWV9OQU1FXG4gICAgICAgICAgICAgICAgPyBpbnN0YW5jZUlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBzZXJ2aWNlID0gdGhpcy5maXJlYmFzZV8uSU5URVJOQUwuZmFjdG9yaWVzW25hbWVdKHRoaXMsIHRoaXMuZXh0ZW5kQXBwLmJpbmQodGhpcyksIGluc3RhbmNlU3BlY2lmaWVyKTtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZXNfW25hbWVdW2luc3RhbmNlSWRlbnRpZmllcl0gPSBzZXJ2aWNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZpY2VzX1tuYW1lXVtpbnN0YW5jZUlkZW50aWZpZXJdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24gdXNlZCB0byBleHRlbmQgYW4gQXBwIGluc3RhbmNlIGF0IHRoZSB0aW1lXG4gICAgICogb2Ygc2VydmljZSBpbnN0YW5jZSBjcmVhdGlvbi5cbiAgICAgKi9cbiAgICBGaXJlYmFzZUFwcEltcGwucHJvdG90eXBlLmV4dGVuZEFwcCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBDb3B5IHRoZSBvYmplY3Qgb250byB0aGUgRmlyZWJhc2VBcHBJbXBsIHByb3RvdHlwZVxuICAgICAgICBkZWVwRXh0ZW5kKHRoaXMsIHByb3BzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBhcHAgaGFzIG92ZXJ3cml0dGVuIHRoZSBhZGRBdXRoVG9rZW5MaXN0ZW5lciBzdHViLCBmb3J3YXJkXG4gICAgICAgICAqIHRoZSBhY3RpdmUgdG9rZW4gbGlzdGVuZXJzIG9uIHRvIHRoZSB0cnVlIGZ4bi5cbiAgICAgICAgICpcbiAgICAgICAgICogVE9ETzogVGhpcyBmdW5jdGlvbiBpcyByZXF1aXJlZCBkdWUgdG8gb3VyIGN1cnJlbnQgbW9kdWxlXG4gICAgICAgICAqIHN0cnVjdHVyZS4gT25jZSB3ZSBhcmUgYWJsZSB0byByZWx5IHN0cmljdGx5IHVwb24gYSBzaW5nbGUgbW9kdWxlXG4gICAgICAgICAqIGltcGxlbWVudGF0aW9uLCB0aGlzIGNvZGUgc2hvdWxkIGJlIHJlZmFjdG9yZWQgYW5kIEF1dGggc2hvdWxkXG4gICAgICAgICAqIHByb3ZpZGUgdGhlc2Ugc3R1YnMgYW5kIHRoZSB1cGdyYWRlIGxvZ2ljXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocHJvcHMuSU5URVJOQUwgJiYgcHJvcHMuSU5URVJOQUwuYWRkQXV0aFRva2VuTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRva2VuTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuSU5URVJOQUwuYWRkQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0b2tlbkxpc3RlbmVycyA9IFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IgaWYgdGhlIEFwcCBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQgLVxuICAgICAqIHVzZSBiZWZvcmUgcGVyZm9ybWluZyBBUEkgYWN0aW9ucyBvbiB0aGUgQXBwLlxuICAgICAqL1xuICAgIEZpcmViYXNlQXBwSW1wbC5wcm90b3R5cGUuY2hlY2tEZXN0cm95ZWRfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0RlbGV0ZWRfKSB7XG4gICAgICAgICAgICBlcnJvcignYXBwLWRlbGV0ZWQnLCB7IG5hbWU6IHRoaXMubmFtZV8gfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGaXJlYmFzZUFwcEltcGw7XG59KCkpO1xuLy8gUHJldmVudCBkZWFkLWNvZGUgZWxpbWluYXRpb24gb2YgdGhlc2UgbWV0aG9kcyB3L28gaW52YWxpZCBwcm9wZXJ0eVxuLy8gY29weWluZy5cbihGaXJlYmFzZUFwcEltcGwucHJvdG90eXBlLm5hbWUgJiYgRmlyZWJhc2VBcHBJbXBsLnByb3RvdHlwZS5vcHRpb25zKSB8fFxuICAgIEZpcmViYXNlQXBwSW1wbC5wcm90b3R5cGUuZGVsZXRlIHx8XG4gICAgY29uc29sZS5sb2coJ2RjJyk7XG4vKipcbiAqIFJldHVybiBhIGZpcmViYXNlIG5hbWVzcGFjZSBvYmplY3QuXG4gKlxuICogSW4gcHJvZHVjdGlvbiwgdGhpcyB3aWxsIGJlIGNhbGxlZCBleGFjdGx5IG9uY2UgYW5kIHRoZSByZXN1bHRcbiAqIGFzc2lnbmVkIHRvIHRoZSAnZmlyZWJhc2UnIGdsb2JhbC4gIEl0IG1heSBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXNcbiAqIGluIHVuaXQgdGVzdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaXJlYmFzZU5hbWVzcGFjZSgpIHtcbiAgICB2YXIgYXBwc18gPSB7fTtcbiAgICB2YXIgZmFjdG9yaWVzID0ge307XG4gICAgdmFyIGFwcEhvb2tzID0ge307XG4gICAgLy8gQSBuYW1lc3BhY2UgaXMgYSBwbGFpbiBKYXZhU2NyaXB0IE9iamVjdC5cbiAgICB2YXIgbmFtZXNwYWNlID0ge1xuICAgICAgICAvLyBIYWNrIHRvIHByZXZlbnQgQmFiZWwgZnJvbSBtb2RpZnlpbmcgdGhlIG9iamVjdCByZXR1cm5lZFxuICAgICAgICAvLyBhcyB0aGUgZmlyZWJhc2UgbmFtZXNwYWNlLlxuICAgICAgICBfX2VzTW9kdWxlOiB0cnVlLFxuICAgICAgICBpbml0aWFsaXplQXBwOiBpbml0aWFsaXplQXBwLFxuICAgICAgICBhcHA6IGFwcCxcbiAgICAgICAgYXBwczogbnVsbCxcbiAgICAgICAgUHJvbWlzZTogUHJvbWlzZSxcbiAgICAgICAgU0RLX1ZFUlNJT046ICc0LjUuMicsXG4gICAgICAgIElOVEVSTkFMOiB7XG4gICAgICAgICAgICByZWdpc3RlclNlcnZpY2U6IHJlZ2lzdGVyU2VydmljZSxcbiAgICAgICAgICAgIGNyZWF0ZUZpcmViYXNlTmFtZXNwYWNlOiBjcmVhdGVGaXJlYmFzZU5hbWVzcGFjZSxcbiAgICAgICAgICAgIGV4dGVuZE5hbWVzcGFjZTogZXh0ZW5kTmFtZXNwYWNlLFxuICAgICAgICAgICAgY3JlYXRlU3Vic2NyaWJlOiBjcmVhdGVTdWJzY3JpYmUsXG4gICAgICAgICAgICBFcnJvckZhY3Rvcnk6IEVycm9yRmFjdG9yeSxcbiAgICAgICAgICAgIHJlbW92ZUFwcDogcmVtb3ZlQXBwLFxuICAgICAgICAgICAgZmFjdG9yaWVzOiBmYWN0b3JpZXMsXG4gICAgICAgICAgICB1c2VBc1NlcnZpY2U6IHVzZUFzU2VydmljZSxcbiAgICAgICAgICAgIFByb21pc2U6IFByb21pc2UsXG4gICAgICAgICAgICBkZWVwRXh0ZW5kOiBkZWVwRXh0ZW5kXG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEluamVjdCBhIGNpcmN1bGFyIGRlZmF1bHQgZXhwb3J0IHRvIGFsbG93IEJhYmVsIHVzZXJzIHdobyB3ZXJlIHByZXZpb3VzbHlcbiAgICAvLyB1c2luZzpcbiAgICAvL1xuICAgIC8vICAgaW1wb3J0IGZpcmViYXNlIGZyb20gJ2ZpcmViYXNlJztcbiAgICAvLyAgIHdoaWNoIGJlY29tZXM6IHZhciBmaXJlYmFzZSA9IHJlcXVpcmUoJ2ZpcmViYXNlJykuZGVmYXVsdDtcbiAgICAvL1xuICAgIC8vIGluc3RlYWQgb2ZcbiAgICAvL1xuICAgIC8vICAgaW1wb3J0ICogYXMgZmlyZWJhc2UgZnJvbSAnZmlyZWJhc2UnO1xuICAgIC8vICAgd2hpY2ggYmVjb21lczogdmFyIGZpcmViYXNlID0gcmVxdWlyZSgnZmlyZWJhc2UnKTtcbiAgICBwYXRjaFByb3BlcnR5KG5hbWVzcGFjZSwgJ2RlZmF1bHQnLCBuYW1lc3BhY2UpO1xuICAgIC8vIGZpcmViYXNlLmFwcHMgaXMgYSByZWFkLW9ubHkgZ2V0dGVyLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYW1lc3BhY2UsICdhcHBzJywge1xuICAgICAgICBnZXQ6IGdldEFwcHNcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYnkgQXBwLmRlbGV0ZSgpIC0gYnV0IGJlZm9yZSBhbnkgc2VydmljZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBBcHBcbiAgICAgKiBhcmUgZGVsZXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmVBcHAobmFtZSkge1xuICAgICAgICB2YXIgYXBwID0gYXBwc19bbmFtZV07XG4gICAgICAgIGNhbGxBcHBIb29rcyhhcHAsICdkZWxldGUnKTtcbiAgICAgICAgZGVsZXRlIGFwcHNfW25hbWVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEFwcCBvYmplY3QgZm9yIGEgZ2l2ZW4gbmFtZSAob3IgREVGQVVMVCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXBwKG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUgfHwgREVGQVVMVF9FTlRSWV9OQU1FO1xuICAgICAgICBpZiAoIWNvbnRhaW5zKGFwcHNfLCBuYW1lKSkge1xuICAgICAgICAgICAgZXJyb3IoJ25vLWFwcCcsIHsgbmFtZTogbmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwc19bbmFtZV07XG4gICAgfVxuICAgIHBhdGNoUHJvcGVydHkoYXBwLCAnQXBwJywgRmlyZWJhc2VBcHBJbXBsKTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgQXBwIGluc3RhbmNlIChuYW1lIG11c3QgYmUgdW5pcXVlKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplQXBwKG9wdGlvbnMsIG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmFtZSA9IERFRkFVTFRfRU5UUllfTkFNRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignYmFkLWFwcC1uYW1lJywgeyBuYW1lOiBuYW1lICsgJycgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRhaW5zKGFwcHNfLCBuYW1lKSkge1xuICAgICAgICAgICAgZXJyb3IoJ2R1cGxpY2F0ZS1hcHAnLCB7IG5hbWU6IG5hbWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFwcCA9IG5ldyBGaXJlYmFzZUFwcEltcGwob3B0aW9ucywgbmFtZSwgbmFtZXNwYWNlKTtcbiAgICAgICAgYXBwc19bbmFtZV0gPSBhcHA7XG4gICAgICAgIGNhbGxBcHBIb29rcyhhcHAsICdjcmVhdGUnKTtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICB9XG4gICAgLypcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgYWxsIHRoZSBub24tZGVsZXRlZCBGaXJlYmFzZUFwcHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QXBwcygpIHtcbiAgICAgICAgLy8gTWFrZSBhIGNvcHkgc28gY2FsbGVyIGNhbm5vdCBtdXRhdGUgdGhlIGFwcHMgbGlzdC5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGFwcHNfKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGFwcHNfW25hbWVdOyB9KTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBSZWdpc3RlciBhIEZpcmViYXNlIFNlcnZpY2UuXG4gICAgICpcbiAgICAgKiBmaXJlYmFzZS5JTlRFUk5BTC5yZWdpc3RlclNlcnZpY2UoKVxuICAgICAqXG4gICAgICogVE9ETzogSW1wbGVtZW50IHNlcnZpY2VQcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyU2VydmljZShuYW1lLCBjcmVhdGVTZXJ2aWNlLCBzZXJ2aWNlUHJvcGVydGllcywgYXBwSG9vaywgYWxsb3dNdWx0aXBsZUluc3RhbmNlcykge1xuICAgICAgICAvLyBDYW5ub3QgcmUtcmVnaXN0ZXIgYSBzZXJ2aWNlIHRoYXQgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgaWYgKGZhY3Rvcmllc1tuYW1lXSkge1xuICAgICAgICAgICAgZXJyb3IoJ2R1cGxpY2F0ZS1zZXJ2aWNlJywgeyBuYW1lOiBuYW1lIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhcHR1cmUgdGhlIHNlcnZpY2UgZmFjdG9yeSBmb3IgbGF0ZXIgc2VydmljZSBpbnN0YW50aWF0aW9uXG4gICAgICAgIGZhY3Rvcmllc1tuYW1lXSA9IGNyZWF0ZVNlcnZpY2U7XG4gICAgICAgIC8vIENhcHR1cmUgdGhlIGFwcEhvb2ssIGlmIHBhc3NlZFxuICAgICAgICBpZiAoYXBwSG9vaykge1xuICAgICAgICAgICAgYXBwSG9va3NbbmFtZV0gPSBhcHBIb29rO1xuICAgICAgICAgICAgLy8gUnVuIHRoZSAqKm5ldyoqIGFwcCBob29rIG9uIGFsbCBleGlzdGluZyBhcHBzXG4gICAgICAgICAgICBnZXRBcHBzKCkuZm9yRWFjaChmdW5jdGlvbiAoYXBwKSB7XG4gICAgICAgICAgICAgICAgYXBwSG9vaygnY3JlYXRlJywgYXBwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBTZXJ2aWNlIG5hbWVzcGFjZSBpcyBhbiBhY2Nlc3NvciBmdW5jdGlvbiAuLi5cbiAgICAgICAgdmFyIHNlcnZpY2VOYW1lc3BhY2UgPSBmdW5jdGlvbiAoYXBwQXJnKSB7XG4gICAgICAgICAgICBpZiAoYXBwQXJnID09PSB2b2lkIDApIHsgYXBwQXJnID0gYXBwKCk7IH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXBwQXJnW25hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gSW52YWxpZCBhcmd1bWVudC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGhhcHBlbnMgaW4gdGhlIGZvbGxvd2luZyBjYXNlOiBmaXJlYmFzZS5zdG9yYWdlKCdnczovJylcbiAgICAgICAgICAgICAgICBlcnJvcignaW52YWxpZC1hcHAtYXJndW1lbnQnLCB7IG5hbWU6IG5hbWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGb3J3YXJkIHNlcnZpY2UgaW5zdGFuY2UgbG9va3VwIHRvIHRoZSBGaXJlYmFzZUFwcC5cbiAgICAgICAgICAgIHJldHVybiBhcHBBcmdbbmFtZV0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gLi4uIGFuZCBhIGNvbnRhaW5lciBmb3Igc2VydmljZS1sZXZlbCBwcm9wZXJ0aWVzLlxuICAgICAgICBpZiAoc2VydmljZVByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVlcEV4dGVuZChzZXJ2aWNlTmFtZXNwYWNlLCBzZXJ2aWNlUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTW9ua2V5LXBhdGNoIHRoZSBzZXJ2aWNlTmFtZXNwYWNlIG9udG8gdGhlIGZpcmViYXNlIG5hbWVzcGFjZVxuICAgICAgICBuYW1lc3BhY2VbbmFtZV0gPSBzZXJ2aWNlTmFtZXNwYWNlO1xuICAgICAgICAvLyBQYXRjaCB0aGUgRmlyZWJhc2VBcHBJbXBsIHByb3RvdHlwZVxuICAgICAgICBGaXJlYmFzZUFwcEltcGwucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNlcnZpY2VGeG4gPSB0aGlzLl9nZXRTZXJ2aWNlLmJpbmQodGhpcywgbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gc2VydmljZUZ4bi5hcHBseSh0aGlzLCBhbGxvd011bHRpcGxlSW5zdGFuY2VzID8gYXJncyA6IFtdKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2VOYW1lc3BhY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhdGNoIHRoZSB0b3AtbGV2ZWwgZmlyZWJhc2UgbmFtZXNwYWNlIHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogZmlyZWJhc2UuSU5URVJOQUwuZXh0ZW5kTmFtZXNwYWNlKClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBleHRlbmROYW1lc3BhY2UocHJvcHMpIHtcbiAgICAgICAgZGVlcEV4dGVuZChuYW1lc3BhY2UsIHByb3BzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbEFwcEhvb2tzKGFwcCwgZXZlbnROYW1lKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGZhY3RvcmllcykuZm9yRWFjaChmdW5jdGlvbiAoc2VydmljZU5hbWUpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSB2aXJ0dWFsIHNlcnZpY2VzXG4gICAgICAgICAgICB2YXIgZmFjdG9yeU5hbWUgPSB1c2VBc1NlcnZpY2UoYXBwLCBzZXJ2aWNlTmFtZSk7XG4gICAgICAgICAgICBpZiAoZmFjdG9yeU5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXBwSG9va3NbZmFjdG9yeU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgYXBwSG9va3NbZmFjdG9yeU5hbWVdKGV2ZW50TmFtZSwgYXBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIE1hcCB0aGUgcmVxdWVzdGVkIHNlcnZpY2UgdG8gYSByZWdpc3RlcmVkIHNlcnZpY2UgbmFtZVxuICAgIC8vICh1c2VkIHRvIG1hcCBhdXRoIHRvIHNlcnZlckF1dGggc2VydmljZSB3aGVuIG5lZWRlZCkuXG4gICAgZnVuY3Rpb24gdXNlQXNTZXJ2aWNlKGFwcCwgbmFtZSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3NlcnZlckF1dGgnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXNlU2VydmljZSA9IG5hbWU7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXBwLm9wdGlvbnM7XG4gICAgICAgIHJldHVybiB1c2VTZXJ2aWNlO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXNwYWNlO1xufVxuZnVuY3Rpb24gZXJyb3IoY29kZSwgYXJncykge1xuICAgIHRocm93IGFwcEVycm9ycy5jcmVhdGUoY29kZSwgYXJncyk7XG59XG4vLyBUeXBlU2NyaXB0IGRvZXMgbm90IHN1cHBvcnQgbm9uLXN0cmluZyBpbmRleGVzIVxuLy8gbGV0IGVycm9yczoge1tjb2RlOiBBcHBFcnJvcjogc3RyaW5nfSA9IHtcbnZhciBlcnJvcnMgPSB7XG4gICAgJ25vLWFwcCc6IFwiTm8gRmlyZWJhc2UgQXBwICd7JG5hbWV9JyBoYXMgYmVlbiBjcmVhdGVkIC0gXCIgK1xuICAgICAgICAnY2FsbCBGaXJlYmFzZSBBcHAuaW5pdGlhbGl6ZUFwcCgpJyxcbiAgICAnYmFkLWFwcC1uYW1lJzogXCJJbGxlZ2FsIEFwcCBuYW1lOiAneyRuYW1lfVwiLFxuICAgICdkdXBsaWNhdGUtYXBwJzogXCJGaXJlYmFzZSBBcHAgbmFtZWQgJ3skbmFtZX0nIGFscmVhZHkgZXhpc3RzXCIsXG4gICAgJ2FwcC1kZWxldGVkJzogXCJGaXJlYmFzZSBBcHAgbmFtZWQgJ3skbmFtZX0nIGFscmVhZHkgZGVsZXRlZFwiLFxuICAgICdkdXBsaWNhdGUtc2VydmljZSc6IFwiRmlyZWJhc2Ugc2VydmljZSBuYW1lZCAneyRuYW1lfScgYWxyZWFkeSByZWdpc3RlcmVkXCIsXG4gICAgJ3NhLW5vdC1zdXBwb3J0ZWQnOiAnSW5pdGlhbGl6aW5nIHRoZSBGaXJlYmFzZSBTREsgd2l0aCBhIHNlcnZpY2UgJyArXG4gICAgICAgICdhY2NvdW50IGlzIG9ubHkgYWxsb3dlZCBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQuIE9uIGNsaWVudCAnICtcbiAgICAgICAgJ2RldmljZXMsIHlvdSBzaG91bGQgaW5zdGVhZCBpbml0aWFsaXplIHRoZSBTREsgd2l0aCBhbiBhcGkga2V5IGFuZCAnICtcbiAgICAgICAgJ2F1dGggZG9tYWluJyxcbiAgICAnaW52YWxpZC1hcHAtYXJndW1lbnQnOiAnZmlyZWJhc2UueyRuYW1lfSgpIHRha2VzIGVpdGhlciBubyBhcmd1bWVudCBvciBhICcgK1xuICAgICAgICAnRmlyZWJhc2UgQXBwIGluc3RhbmNlLidcbn07XG52YXIgYXBwRXJyb3JzID0gbmV3IEVycm9yRmFjdG9yeSgnYXBwJywgJ0ZpcmViYXNlJywgZXJyb3JzKTtcblxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9zcmMvZmlyZWJhc2VBcHAuanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmaXJlYmFzZSA9IHJlcXVpcmUoJ0BmaXJlYmFzZS9hcHAnKS5kZWZhdWx0OyAoZnVuY3Rpb24oKXsvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4oZnVuY3Rpb24oKXt2YXIgaCxhYT1hYXx8e30saz10aGlzLGJhPWZ1bmN0aW9uKGEpe3JldHVybiB2b2lkIDAhPT1hfSxtPWZ1bmN0aW9uKGEpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBhfSxjYT1mdW5jdGlvbihhKXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIGF9LGRhPWZ1bmN0aW9uKCl7fSxlYT1mdW5jdGlvbihhKXt2YXIgYj10eXBlb2YgYTtpZihcIm9iamVjdFwiPT1iKWlmKGEpe2lmKGEgaW5zdGFuY2VvZiBBcnJheSlyZXR1cm5cImFycmF5XCI7aWYoYSBpbnN0YW5jZW9mIE9iamVjdClyZXR1cm4gYjt2YXIgYz1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSk7aWYoXCJbb2JqZWN0IFdpbmRvd11cIj09YylyZXR1cm5cIm9iamVjdFwiO2lmKFwiW29iamVjdCBBcnJheV1cIj09Y3x8XCJudW1iZXJcIj09dHlwZW9mIGEubGVuZ3RoJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5zcGxpY2UmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLnByb3BlcnR5SXNFbnVtZXJhYmxlJiYhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcInNwbGljZVwiKSlyZXR1cm5cImFycmF5XCI7XG5pZihcIltvYmplY3QgRnVuY3Rpb25dXCI9PWN8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLmNhbGwmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLnByb3BlcnR5SXNFbnVtZXJhYmxlJiYhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcImNhbGxcIikpcmV0dXJuXCJmdW5jdGlvblwifWVsc2UgcmV0dXJuXCJudWxsXCI7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PWImJlwidW5kZWZpbmVkXCI9PXR5cGVvZiBhLmNhbGwpcmV0dXJuXCJvYmplY3RcIjtyZXR1cm4gYn0sZmE9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PT1hfSxoYT1mdW5jdGlvbihhKXtyZXR1cm5cImFycmF5XCI9PWVhKGEpfSxpYT1mdW5jdGlvbihhKXt2YXIgYj1lYShhKTtyZXR1cm5cImFycmF5XCI9PWJ8fFwib2JqZWN0XCI9PWImJlwibnVtYmVyXCI9PXR5cGVvZiBhLmxlbmd0aH0scD1mdW5jdGlvbihhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PWVhKGEpfSxxPWZ1bmN0aW9uKGEpe3ZhciBiPXR5cGVvZiBhO3JldHVyblwib2JqZWN0XCI9PWImJm51bGwhPWF8fFwiZnVuY3Rpb25cIj09XG5ifSxqYT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGEuY2FsbC5hcHBseShhLmJpbmQsYXJndW1lbnRzKX0sa2E9ZnVuY3Rpb24oYSxiLGMpe2lmKCFhKXRocm93IEVycm9yKCk7aWYoMjxhcmd1bWVudHMubGVuZ3RoKXt2YXIgZD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMik7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShjLGQpO3JldHVybiBhLmFwcGx5KGIsYyl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KGIsYXJndW1lbnRzKX19LHI9ZnVuY3Rpb24oYSxiLGMpe3I9RnVuY3Rpb24ucHJvdG90eXBlLmJpbmQmJi0xIT1GdW5jdGlvbi5wcm90b3R5cGUuYmluZC50b1N0cmluZygpLmluZGV4T2YoXCJuYXRpdmUgY29kZVwiKT9qYTprYTtyZXR1cm4gci5hcHBseShudWxsLGFyZ3VtZW50cyl9LGxhPWZ1bmN0aW9uKGEsYil7dmFyIGM9XG5BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGI9Yy5zbGljZSgpO2IucHVzaC5hcHBseShiLGFyZ3VtZW50cyk7cmV0dXJuIGEuYXBwbHkodGhpcyxiKX19LG1hPURhdGUubm93fHxmdW5jdGlvbigpe3JldHVybituZXcgRGF0ZX0sdD1mdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt9Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGU7YS5VYz1iLnByb3RvdHlwZTthLnByb3RvdHlwZT1uZXcgYzthLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1hO2EuT2c9ZnVuY3Rpb24oYSxjLGYpe2Zvcih2YXIgZD1BcnJheShhcmd1bWVudHMubGVuZ3RoLTIpLGU9MjtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKWRbZS0yXT1hcmd1bWVudHNbZV07cmV0dXJuIGIucHJvdG90eXBlW2NdLmFwcGx5KGEsZCl9fTt2YXIgdT1mdW5jdGlvbihhKXtpZihFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLHUpO2Vsc2V7dmFyIGI9RXJyb3IoKS5zdGFjaztiJiYodGhpcy5zdGFjaz1iKX1hJiYodGhpcy5tZXNzYWdlPVN0cmluZyhhKSl9O3QodSxFcnJvcik7dS5wcm90b3R5cGUubmFtZT1cIkN1c3RvbUVycm9yXCI7dmFyIG5hPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPWEuc3BsaXQoXCIlc1wiKSxkPVwiXCIsZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7ZS5sZW5ndGgmJjE8Yy5sZW5ndGg7KWQrPWMuc2hpZnQoKStlLnNoaWZ0KCk7cmV0dXJuIGQrYy5qb2luKFwiJXNcIil9LG9hPVN0cmluZy5wcm90b3R5cGUudHJpbT9mdW5jdGlvbihhKXtyZXR1cm4gYS50cmltKCl9OmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlcGxhY2UoL15bXFxzXFx4YTBdK3xbXFxzXFx4YTBdKyQvZyxcIlwiKX0sd2E9ZnVuY3Rpb24oYSl7aWYoIXBhLnRlc3QoYSkpcmV0dXJuIGE7LTEhPWEuaW5kZXhPZihcIiZcIikmJihhPWEucmVwbGFjZShxYSxcIiZhbXA7XCIpKTstMSE9YS5pbmRleE9mKFwiPFwiKSYmKGE9YS5yZXBsYWNlKHJhLFwiJmx0O1wiKSk7LTEhPWEuaW5kZXhPZihcIj5cIikmJihhPWEucmVwbGFjZShzYSxcIiZndDtcIikpOy0xIT1hLmluZGV4T2YoJ1wiJykmJihhPWEucmVwbGFjZSh0YSxcIiZxdW90O1wiKSk7LTEhPWEuaW5kZXhPZihcIidcIikmJlxuKGE9YS5yZXBsYWNlKHVhLFwiJiMzOTtcIikpOy0xIT1hLmluZGV4T2YoXCJcXHgwMFwiKSYmKGE9YS5yZXBsYWNlKHZhLFwiJiMwO1wiKSk7cmV0dXJuIGF9LHFhPS8mL2cscmE9LzwvZyxzYT0vPi9nLHRhPS9cIi9nLHVhPS8nL2csdmE9L1xceDAwL2cscGE9L1tcXHgwMCY8PlwiJ10vLHY9ZnVuY3Rpb24oYSxiKXtyZXR1cm4tMSE9YS5pbmRleE9mKGIpfSx4YT1mdW5jdGlvbihhLGIpe3JldHVybiBhPGI/LTE6YT5iPzE6MH07dmFyIHlhPWZ1bmN0aW9uKGEsYil7Yi51bnNoaWZ0KGEpO3UuY2FsbCh0aGlzLG5hLmFwcGx5KG51bGwsYikpO2Iuc2hpZnQoKX07dCh5YSx1KTt5YS5wcm90b3R5cGUubmFtZT1cIkFzc2VydGlvbkVycm9yXCI7XG52YXIgemE9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9XCJBc3NlcnRpb24gZmFpbGVkXCI7aWYoYyl7ZSs9XCI6IFwiK2M7dmFyIGY9ZH1lbHNlIGEmJihlKz1cIjogXCIrYSxmPWIpO3Rocm93IG5ldyB5YShcIlwiK2UsZnx8W10pO30sdz1mdW5jdGlvbihhLGIsYyl7YXx8emEoXCJcIixudWxsLGIsQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDIpKTtyZXR1cm4gYX0sQWE9ZnVuY3Rpb24oYSxiKXt0aHJvdyBuZXcgeWEoXCJGYWlsdXJlXCIrKGE/XCI6IFwiK2E6XCJcIiksQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKTt9LEJhPWZ1bmN0aW9uKGEsYixjKXtcIm51bWJlclwiPT10eXBlb2YgYXx8emEoXCJFeHBlY3RlZCBudW1iZXIgYnV0IGdvdCAlczogJXMuXCIsW2VhKGEpLGFdLGIsQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDIpKTtyZXR1cm4gYX0sQ2E9ZnVuY3Rpb24oYSxiLGMpe20oYSl8fHphKFwiRXhwZWN0ZWQgc3RyaW5nIGJ1dCBnb3QgJXM6ICVzLlwiLFxuW2VhKGEpLGFdLGIsQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDIpKX0sRGE9ZnVuY3Rpb24oYSxiLGMpe3AoYSl8fHphKFwiRXhwZWN0ZWQgZnVuY3Rpb24gYnV0IGdvdCAlczogJXMuXCIsW2VhKGEpLGFdLGIsQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDIpKX07dmFyIEZhPWZ1bmN0aW9uKCl7dGhpcy5UYz1cIlwiO3RoaXMua2Y9RWF9O0ZhLnByb3RvdHlwZS5xYj0hMDtGYS5wcm90b3R5cGUub2I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5UY307RmEucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJDb25zdHtcIit0aGlzLlRjK1wifVwifTt2YXIgR2E9ZnVuY3Rpb24oYSl7aWYoYSBpbnN0YW5jZW9mIEZhJiZhLmNvbnN0cnVjdG9yPT09RmEmJmEua2Y9PT1FYSlyZXR1cm4gYS5UYztBYShcImV4cGVjdGVkIG9iamVjdCBvZiB0eXBlIENvbnN0LCBnb3QgJ1wiK2ErXCInXCIpO3JldHVyblwidHlwZV9lcnJvcjpDb25zdFwifSxFYT17fSxIYT1mdW5jdGlvbihhKXt2YXIgYj1uZXcgRmE7Yi5UYz1hO3JldHVybiBifTtIYShcIlwiKTt2YXIgSmE9ZnVuY3Rpb24oKXt0aGlzLkxjPVwiXCI7dGhpcy5sZj1JYX07SmEucHJvdG90eXBlLnFiPSEwO0phLnByb3RvdHlwZS5vYj1mdW5jdGlvbigpe3JldHVybiB0aGlzLkxjfTtKYS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIlRydXN0ZWRSZXNvdXJjZVVybHtcIit0aGlzLkxjK1wifVwifTtcbnZhciBLYT1mdW5jdGlvbihhKXtpZihhIGluc3RhbmNlb2YgSmEmJmEuY29uc3RydWN0b3I9PT1KYSYmYS5sZj09PUlhKXJldHVybiBhLkxjO0FhKFwiZXhwZWN0ZWQgb2JqZWN0IG9mIHR5cGUgVHJ1c3RlZFJlc291cmNlVXJsLCBnb3QgJ1wiK2ErXCInIG9mIHR5cGUgXCIrZWEoYSkpO3JldHVyblwidHlwZV9lcnJvcjpUcnVzdGVkUmVzb3VyY2VVcmxcIn0sT2E9ZnVuY3Rpb24oYSxiKXt2YXIgYz1HYShhKTtpZighTGEudGVzdChjKSl0aHJvdyBFcnJvcihcIkludmFsaWQgVHJ1c3RlZFJlc291cmNlVXJsIGZvcm1hdDogXCIrYyk7YT1jLnJlcGxhY2UoTWEsZnVuY3Rpb24oYSxlKXtpZighT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsZSkpdGhyb3cgRXJyb3IoJ0ZvdW5kIG1hcmtlciwgXCInK2UrJ1wiLCBpbiBmb3JtYXQgc3RyaW5nLCBcIicrYysnXCIsIGJ1dCBubyB2YWxpZCBsYWJlbCBtYXBwaW5nIGZvdW5kIGluIGFyZ3M6ICcrSlNPTi5zdHJpbmdpZnkoYikpO2E9YltlXTtcbnJldHVybiBhIGluc3RhbmNlb2YgRmE/R2EoYSk6ZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhKSl9KTtyZXR1cm4gTmEoYSl9LE1hPS8leyhcXHcrKX0vZyxMYT0vXig/Omh0dHBzOik/XFwvXFwvWzAtOWEtei46W1xcXS1dK1xcL3xeXFwvW15cXC9cXFxcXXxeYWJvdXQ6YmxhbmsoI3wkKS9pLElhPXt9LE5hPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBKYTtiLkxjPWE7cmV0dXJuIGJ9O3ZhciBQYT1BcnJheS5wcm90b3R5cGUuaW5kZXhPZj9mdW5jdGlvbihhLGIsYyl7dyhudWxsIT1hLmxlbmd0aCk7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7Yz1udWxsPT1jPzA6MD5jP01hdGgubWF4KDAsYS5sZW5ndGgrYyk6YztpZihtKGEpKXJldHVybiBtKGIpJiYxPT1iLmxlbmd0aD9hLmluZGV4T2YoYixjKTotMTtmb3IoO2M8YS5sZW5ndGg7YysrKWlmKGMgaW4gYSYmYVtjXT09PWIpcmV0dXJuIGM7cmV0dXJuLTF9LHg9QXJyYXkucHJvdG90eXBlLmZvckVhY2g/ZnVuY3Rpb24oYSxiLGMpe3cobnVsbCE9YS5sZW5ndGgpO0FycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGU9bShhKT9hLnNwbGl0KFwiXCIpOmEsZj0wO2Y8ZDtmKyspZiBpbiBlJiZiLmNhbGwoYyxlW2ZdLGYsYSl9LFFhPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPW0oYSk/XG5hLnNwbGl0KFwiXCIpOmEsZD1hLmxlbmd0aC0xOzA8PWQ7LS1kKWQgaW4gYyYmYi5jYWxsKHZvaWQgMCxjW2RdLGQsYSl9LFJhPUFycmF5LnByb3RvdHlwZS5tYXA/ZnVuY3Rpb24oYSxiLGMpe3cobnVsbCE9YS5sZW5ndGgpO3JldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGU9QXJyYXkoZCksZj1tKGEpP2Euc3BsaXQoXCJcIik6YSxnPTA7ZzxkO2crKylnIGluIGYmJihlW2ddPWIuY2FsbChjLGZbZ10sZyxhKSk7cmV0dXJuIGV9LFNhPUFycmF5LnByb3RvdHlwZS5zb21lP2Z1bmN0aW9uKGEsYixjKXt3KG51bGwhPWEubGVuZ3RoKTtyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbChhLGIsYyl9OmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9YS5sZW5ndGgsZT1tKGEpP2Euc3BsaXQoXCJcIik6YSxmPTA7ZjxkO2YrKylpZihmIGluIGUmJmIuY2FsbChjLGVbZl0sZixhKSlyZXR1cm4hMDtyZXR1cm4hMX0sXG5VYT1mdW5jdGlvbihhKXthOnt2YXIgYj1UYTtmb3IodmFyIGM9YS5sZW5ndGgsZD1tKGEpP2Euc3BsaXQoXCJcIik6YSxlPTA7ZTxjO2UrKylpZihlIGluIGQmJmIuY2FsbCh2b2lkIDAsZFtlXSxlLGEpKXtiPWU7YnJlYWsgYX1iPS0xfXJldHVybiAwPmI/bnVsbDptKGEpP2EuY2hhckF0KGIpOmFbYl19LFZhPWZ1bmN0aW9uKGEsYil7cmV0dXJuIDA8PVBhKGEsYil9LFhhPWZ1bmN0aW9uKGEsYil7Yj1QYShhLGIpO3ZhciBjOyhjPTA8PWIpJiZXYShhLGIpO3JldHVybiBjfSxXYT1mdW5jdGlvbihhLGIpe3cobnVsbCE9YS5sZW5ndGgpO3JldHVybiAxPT1BcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYSxiLDEpLmxlbmd0aH0sWWE9ZnVuY3Rpb24oYSxiKXt2YXIgYz0wO1FhKGEsZnVuY3Rpb24oZCxlKXtiLmNhbGwodm9pZCAwLGQsZSxhKSYmV2EoYSxlKSYmYysrfSl9LFphPWZ1bmN0aW9uKGEpe3JldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLGFyZ3VtZW50cyl9LFxuJGE9ZnVuY3Rpb24oYSl7dmFyIGI9YS5sZW5ndGg7aWYoMDxiKXtmb3IodmFyIGM9QXJyYXkoYiksZD0wO2Q8YjtkKyspY1tkXT1hW2RdO3JldHVybiBjfXJldHVybltdfTt2YXIgYWI9ZnVuY3Rpb24oYSl7cmV0dXJuIFJhKGEsZnVuY3Rpb24oYSl7YT1hLnRvU3RyaW5nKDE2KTtyZXR1cm4gMTxhLmxlbmd0aD9hOlwiMFwiK2F9KS5qb2luKFwiXCIpfTt2YXIgYmI7YTp7dmFyIGNiPWsubmF2aWdhdG9yO2lmKGNiKXt2YXIgZGI9Y2IudXNlckFnZW50O2lmKGRiKXtiYj1kYjticmVhayBhfX1iYj1cIlwifXZhciB5PWZ1bmN0aW9uKGEpe3JldHVybiB2KGJiLGEpfTt2YXIgZWI9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGMgaW4gYSliLmNhbGwodm9pZCAwLGFbY10sYyxhKX0sZmI9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGMgaW4gYSlpZihiLmNhbGwodm9pZCAwLGFbY10sYyxhKSlyZXR1cm4hMDtyZXR1cm4hMX0sZ2I9ZnVuY3Rpb24oYSl7dmFyIGI9W10sYz0wLGQ7Zm9yKGQgaW4gYSliW2MrK109YVtkXTtyZXR1cm4gYn0saGI9ZnVuY3Rpb24oYSl7dmFyIGI9W10sYz0wLGQ7Zm9yKGQgaW4gYSliW2MrK109ZDtyZXR1cm4gYn0saWI9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiIGluIGEpcmV0dXJuITE7cmV0dXJuITB9LGpiPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjIGluIGEpaWYoIShjIGluIGIpfHxhW2NdIT09YltjXSlyZXR1cm4hMTtmb3IoYyBpbiBiKWlmKCEoYyBpbiBhKSlyZXR1cm4hMTtyZXR1cm4hMH0sa2I9ZnVuY3Rpb24oYSl7dmFyIGI9e30sYztmb3IoYyBpbiBhKWJbY109YVtjXTtyZXR1cm4gYn0sbGI9XCJjb25zdHJ1Y3RvciBoYXNPd25Qcm9wZXJ0eSBpc1Byb3RvdHlwZU9mIHByb3BlcnR5SXNFbnVtZXJhYmxlIHRvTG9jYWxlU3RyaW5nIHRvU3RyaW5nIHZhbHVlT2ZcIi5zcGxpdChcIiBcIiksXG5tYj1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYyxkLGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXtkPWFyZ3VtZW50c1tlXTtmb3IoYyBpbiBkKWFbY109ZFtjXTtmb3IodmFyIGY9MDtmPGxiLmxlbmd0aDtmKyspYz1sYltmXSxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZCxjKSYmKGFbY109ZFtjXSl9fTt2YXIgbmI9ZnVuY3Rpb24oYSl7bmJbXCIgXCJdKGEpO3JldHVybiBhfTtuYltcIiBcIl09ZGE7dmFyIHBiPWZ1bmN0aW9uKGEsYil7dmFyIGM9b2I7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjLGEpP2NbYV06Y1thXT1iKGEpfTt2YXIgcWI9eShcIk9wZXJhXCIpLHo9eShcIlRyaWRlbnRcIil8fHkoXCJNU0lFXCIpLHJiPXkoXCJFZGdlXCIpLHNiPXJifHx6LHRiPXkoXCJHZWNrb1wiKSYmISh2KGJiLnRvTG93ZXJDYXNlKCksXCJ3ZWJraXRcIikmJiF5KFwiRWRnZVwiKSkmJiEoeShcIlRyaWRlbnRcIil8fHkoXCJNU0lFXCIpKSYmIXkoXCJFZGdlXCIpLHViPXYoYmIudG9Mb3dlckNhc2UoKSxcIndlYmtpdFwiKSYmIXkoXCJFZGdlXCIpLHZiPWZ1bmN0aW9uKCl7dmFyIGE9ay5kb2N1bWVudDtyZXR1cm4gYT9hLmRvY3VtZW50TW9kZTp2b2lkIDB9LHdiO1xuYTp7dmFyIHhiPVwiXCIseWI9ZnVuY3Rpb24oKXt2YXIgYT1iYjtpZih0YilyZXR1cm4vcnY6KFteXFwpO10rKShcXCl8OykvLmV4ZWMoYSk7aWYocmIpcmV0dXJuL0VkZ2VcXC8oW1xcZFxcLl0rKS8uZXhlYyhhKTtpZih6KXJldHVybi9cXGIoPzpNU0lFfHJ2KVs6IF0oW15cXCk7XSspKFxcKXw7KS8uZXhlYyhhKTtpZih1YilyZXR1cm4vV2ViS2l0XFwvKFxcUyspLy5leGVjKGEpO2lmKHFiKXJldHVybi8oPzpWZXJzaW9uKVsgXFwvXT8oXFxTKykvLmV4ZWMoYSl9KCk7eWImJih4Yj15Yj95YlsxXTpcIlwiKTtpZih6KXt2YXIgQWI9dmIoKTtpZihudWxsIT1BYiYmQWI+cGFyc2VGbG9hdCh4Yikpe3diPVN0cmluZyhBYik7YnJlYWsgYX19d2I9eGJ9XG52YXIgQmI9d2Isb2I9e30sQT1mdW5jdGlvbihhKXtyZXR1cm4gcGIoYSxmdW5jdGlvbigpe2Zvcih2YXIgYj0wLGM9b2EoU3RyaW5nKEJiKSkuc3BsaXQoXCIuXCIpLGQ9b2EoU3RyaW5nKGEpKS5zcGxpdChcIi5cIiksZT1NYXRoLm1heChjLmxlbmd0aCxkLmxlbmd0aCksZj0wOzA9PWImJmY8ZTtmKyspe3ZhciBnPWNbZl18fFwiXCIsbD1kW2ZdfHxcIlwiO2Rve2c9LyhcXGQqKShcXEQqKSguKikvLmV4ZWMoZyl8fFtcIlwiLFwiXCIsXCJcIixcIlwiXTtsPS8oXFxkKikoXFxEKikoLiopLy5leGVjKGwpfHxbXCJcIixcIlwiLFwiXCIsXCJcIl07aWYoMD09Z1swXS5sZW5ndGgmJjA9PWxbMF0ubGVuZ3RoKWJyZWFrO2I9eGEoMD09Z1sxXS5sZW5ndGg/MDpwYXJzZUludChnWzFdLDEwKSwwPT1sWzFdLmxlbmd0aD8wOnBhcnNlSW50KGxbMV0sMTApKXx8eGEoMD09Z1syXS5sZW5ndGgsMD09bFsyXS5sZW5ndGgpfHx4YShnWzJdLGxbMl0pO2c9Z1szXTtsPWxbM119d2hpbGUoMD09Yil9cmV0dXJuIDA8PWJ9KX0sQ2I7dmFyIERiPWsuZG9jdW1lbnQ7XG5DYj1EYiYmej92YigpfHwoXCJDU1MxQ29tcGF0XCI9PURiLmNvbXBhdE1vZGU/cGFyc2VJbnQoQmIsMTApOjUpOnZvaWQgMDt2YXIgRWI9bnVsbCxGYj1udWxsLEhiPWZ1bmN0aW9uKGEpe3ZhciBiPVwiXCI7R2IoYSxmdW5jdGlvbihhKXtiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpfSk7cmV0dXJuIGJ9LEdiPWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhiKXtmb3IoO2Q8YS5sZW5ndGg7KXt2YXIgYz1hLmNoYXJBdChkKyspLGU9RmJbY107aWYobnVsbCE9ZSlyZXR1cm4gZTtpZighL15bXFxzXFx4YTBdKiQvLnRlc3QoYykpdGhyb3cgRXJyb3IoXCJVbmtub3duIGJhc2U2NCBlbmNvZGluZyBhdCBjaGFyOiBcIitjKTt9cmV0dXJuIGJ9SWIoKTtmb3IodmFyIGQ9MDs7KXt2YXIgZT1jKC0xKSxmPWMoMCksZz1jKDY0KSxsPWMoNjQpO2lmKDY0PT09bCYmLTE9PT1lKWJyZWFrO2IoZTw8MnxmPj40KTs2NCE9ZyYmKGIoZjw8NCYyNDB8Zz4+MiksNjQhPWwmJmIoZzw8NiYxOTJ8bCkpfX0sSWI9ZnVuY3Rpb24oKXtpZighRWIpe0ViPXt9O0ZiPXt9O2Zvcih2YXIgYT0wOzY1PmE7YSsrKUViW2FdPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIi5jaGFyQXQoYSksXG5GYltFYlthXV09YSw2Mjw9YSYmKEZiW1wiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXy5cIi5jaGFyQXQoYSldPWEpfX07dmFyIEpiPWZ1bmN0aW9uKCl7dGhpcy5EYT0tMX07dmFyIE1iPWZ1bmN0aW9uKGEsYil7dGhpcy5EYT0tMTt0aGlzLkRhPTY0O3RoaXMucWM9ay5VaW50OEFycmF5P25ldyBVaW50OEFycmF5KHRoaXMuRGEpOkFycmF5KHRoaXMuRGEpO3RoaXMuWGM9dGhpcy5yYj0wO3RoaXMubD1bXTt0aGlzLmJnPWE7dGhpcy5GZT1iO3RoaXMuQ2c9ay5JbnQzMkFycmF5P25ldyBJbnQzMkFycmF5KDY0KTpBcnJheSg2NCk7YmEoS2IpfHwoS2I9ay5JbnQzMkFycmF5P25ldyBJbnQzMkFycmF5KExiKTpMYik7dGhpcy5yZXNldCgpfSxLYjt0KE1iLEpiKTtmb3IodmFyIE5iPVtdLE9iPTA7NjM+T2I7T2IrKylOYltPYl09MDt2YXIgUGI9WmEoMTI4LE5iKTtNYi5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLlhjPXRoaXMucmI9MDt0aGlzLmw9ay5JbnQzMkFycmF5P25ldyBJbnQzMkFycmF5KHRoaXMuRmUpOiRhKHRoaXMuRmUpfTtcbnZhciBRYj1mdW5jdGlvbihhKXt2YXIgYj1hLnFjO3coYi5sZW5ndGg9PWEuRGEpO2Zvcih2YXIgYz1hLkNnLGQ9MCxlPTA7ZTxiLmxlbmd0aDspY1tkKytdPWJbZV08PDI0fGJbZSsxXTw8MTZ8YltlKzJdPDw4fGJbZSszXSxlPTQqZDtmb3IoYj0xNjs2ND5iO2IrKyl7ZT1jW2ItMTVdfDA7ZD1jW2ItMl18MDt2YXIgZj0oY1tiLTE2XXwwKSsoKGU+Pj43fGU8PDI1KV4oZT4+PjE4fGU8PDE0KV5lPj4+Myl8MCxnPShjW2ItN118MCkrKChkPj4+MTd8ZDw8MTUpXihkPj4+MTl8ZDw8MTMpXmQ+Pj4xMCl8MDtjW2JdPWYrZ3wwfWQ9YS5sWzBdfDA7ZT1hLmxbMV18MDt2YXIgbD1hLmxbMl18MCxuPWEubFszXXwwLEY9YS5sWzRdfDAsemI9YS5sWzVdfDAsaWM9YS5sWzZdfDA7Zj1hLmxbN118MDtmb3IoYj0wOzY0PmI7YisrKXt2YXIgeWk9KChkPj4+MnxkPDwzMCleKGQ+Pj4xM3xkPDwxOSleKGQ+Pj4yMnxkPDwxMCkpKyhkJmVeZCZsXmUmbCl8MDtnPUYmemJefkYmaWM7Zj1mKygoRj4+PlxuNnxGPDwyNileKEY+Pj4xMXxGPDwyMSleKEY+Pj4yNXxGPDw3KSl8MDtnPWcrKEtiW2JdfDApfDA7Zz1mKyhnKyhjW2JdfDApfDApfDA7Zj1pYztpYz16Yjt6Yj1GO0Y9bitnfDA7bj1sO2w9ZTtlPWQ7ZD1nK3lpfDB9YS5sWzBdPWEubFswXStkfDA7YS5sWzFdPWEubFsxXStlfDA7YS5sWzJdPWEubFsyXStsfDA7YS5sWzNdPWEubFszXStufDA7YS5sWzRdPWEubFs0XStGfDA7YS5sWzVdPWEubFs1XSt6YnwwO2EubFs2XT1hLmxbNl0raWN8MDthLmxbN109YS5sWzddK2Z8MH07XG5NYi5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEsYil7YmEoYil8fChiPWEubGVuZ3RoKTt2YXIgYz0wLGQ9dGhpcy5yYjtpZihtKGEpKWZvcig7YzxiOyl0aGlzLnFjW2QrK109YS5jaGFyQ29kZUF0KGMrKyksZD09dGhpcy5EYSYmKFFiKHRoaXMpLGQ9MCk7ZWxzZSBpZihpYShhKSlmb3IoO2M8Yjspe3ZhciBlPWFbYysrXTtpZighKFwibnVtYmVyXCI9PXR5cGVvZiBlJiYwPD1lJiYyNTU+PWUmJmU9PShlfDApKSl0aHJvdyBFcnJvcihcIm1lc3NhZ2UgbXVzdCBiZSBhIGJ5dGUgYXJyYXlcIik7dGhpcy5xY1tkKytdPWU7ZD09dGhpcy5EYSYmKFFiKHRoaXMpLGQ9MCl9ZWxzZSB0aHJvdyBFcnJvcihcIm1lc3NhZ2UgbXVzdCBiZSBzdHJpbmcgb3IgYXJyYXlcIik7dGhpcy5yYj1kO3RoaXMuWGMrPWJ9O1xuTWIucHJvdG90eXBlLmRpZ2VzdD1mdW5jdGlvbigpe3ZhciBhPVtdLGI9OCp0aGlzLlhjOzU2PnRoaXMucmI/dGhpcy51cGRhdGUoUGIsNTYtdGhpcy5yYik6dGhpcy51cGRhdGUoUGIsdGhpcy5EYS0odGhpcy5yYi01NikpO2Zvcih2YXIgYz02Mzs1Njw9YztjLS0pdGhpcy5xY1tjXT1iJjI1NSxiLz0yNTY7UWIodGhpcyk7Zm9yKGM9Yj0wO2M8dGhpcy5iZztjKyspZm9yKHZhciBkPTI0OzA8PWQ7ZC09OClhW2IrK109dGhpcy5sW2NdPj5kJjI1NTtyZXR1cm4gYX07XG52YXIgTGI9WzExMTYzNTI0MDgsMTg5OTQ0NzQ0MSwzMDQ5MzIzNDcxLDM5MjEwMDk1NzMsOTYxOTg3MTYzLDE1MDg5NzA5OTMsMjQ1MzYzNTc0OCwyODcwNzYzMjIxLDM2MjQzODEwODAsMzEwNTk4NDAxLDYwNzIyNTI3OCwxNDI2ODgxOTg3LDE5MjUwNzgzODgsMjE2MjA3ODIwNiwyNjE0ODg4MTAzLDMyNDgyMjI1ODAsMzgzNTM5MDQwMSw0MDIyMjI0Nzc0LDI2NDM0NzA3OCw2MDQ4MDc2MjgsNzcwMjU1OTgzLDEyNDkxNTAxMjIsMTU1NTA4MTY5MiwxOTk2MDY0OTg2LDI1NTQyMjA4ODIsMjgyMTgzNDM0OSwyOTUyOTk2ODA4LDMyMTAzMTM2NzEsMzMzNjU3MTg5MSwzNTg0NTI4NzExLDExMzkyNjk5MywzMzgyNDE4OTUsNjY2MzA3MjA1LDc3MzUyOTkxMiwxMjk0NzU3MzcyLDEzOTYxODIyOTEsMTY5NTE4MzcwMCwxOTg2NjYxMDUxLDIxNzcwMjYzNTAsMjQ1Njk1NjAzNywyNzMwNDg1OTIxLDI4MjAzMDI0MTEsMzI1OTczMDgwMCwzMzQ1NzY0NzcxLDM1MTYwNjU4MTcsMzYwMDM1MjgwNCxcbjQwOTQ1NzE5MDksMjc1NDIzMzQ0LDQzMDIyNzczNCw1MDY5NDg2MTYsNjU5MDYwNTU2LDg4Mzk5Nzg3Nyw5NTgxMzk1NzEsMTMyMjgyMjIxOCwxNTM3MDAyMDYzLDE3NDc4NzM3NzksMTk1NTU2MjIyMiwyMDI0MTA0ODE1LDIyMjc3MzA0NTIsMjM2MTg1MjQyNCwyNDI4NDM2NDc0LDI3NTY3MzQxODcsMzIwNDAzMTQ3OSwzMzI5MzI1Mjk4XTt2YXIgU2I9ZnVuY3Rpb24oKXtNYi5jYWxsKHRoaXMsOCxSYil9O3QoU2IsTWIpO3ZhciBSYj1bMTc3OTAzMzcwMywzMTQ0MTM0Mjc3LDEwMTM5MDQyNDIsMjc3MzQ4MDc2MiwxMzU5ODkzMTE5LDI2MDA4MjI5MjQsNTI4NzM0NjM1LDE1NDE0NTkyMjVdO3ZhciBUYj1PYmplY3QuZnJlZXplfHxmdW5jdGlvbihhKXtyZXR1cm4gYX07dmFyIFViPWZ1bmN0aW9uKCl7dGhpcy5NYT10aGlzLk1hO3RoaXMuSWM9dGhpcy5JY307VWIucHJvdG90eXBlLk1hPSExO1ViLnByb3RvdHlwZS5pc0Rpc3Bvc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuTWF9O1ViLnByb3RvdHlwZS5sYj1mdW5jdGlvbigpe2lmKHRoaXMuSWMpZm9yKDt0aGlzLkljLmxlbmd0aDspdGhpcy5JYy5zaGlmdCgpKCl9O3ZhciBWYj0henx8OTw9TnVtYmVyKENiKSxXYj16JiYhQShcIjlcIik7IXVifHxBKFwiNTI4XCIpO3RiJiZBKFwiMS45YlwiKXx8eiYmQShcIjhcIil8fHFiJiZBKFwiOS41XCIpfHx1YiYmQShcIjUyOFwiKTt0YiYmIUEoXCI4XCIpfHx6JiZBKFwiOVwiKTt2YXIgWGI9ZnVuY3Rpb24oKXtpZighay5hZGRFdmVudExpc3RlbmVyfHwhT2JqZWN0LmRlZmluZVByb3BlcnR5KXJldHVybiExO3ZhciBhPSExLGI9T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LFwicGFzc2l2ZVwiLHtnZXQ6ZnVuY3Rpb24oKXthPSEwfX0pO2suYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RcIixkYSxiKTtrLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsZGEsYik7cmV0dXJuIGF9KCk7dmFyIEI9ZnVuY3Rpb24oYSxiKXt0aGlzLnR5cGU9YTt0aGlzLmN1cnJlbnRUYXJnZXQ9dGhpcy50YXJnZXQ9Yjt0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ9dGhpcy5XYT0hMTt0aGlzLlVlPSEwfTtCLnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb249ZnVuY3Rpb24oKXt0aGlzLldhPSEwfTtCLnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdD1mdW5jdGlvbigpe3RoaXMuZGVmYXVsdFByZXZlbnRlZD0hMDt0aGlzLlVlPSExfTt2YXIgWWI9ZnVuY3Rpb24oYSxiKXtCLmNhbGwodGhpcyxhP2EudHlwZTpcIlwiKTt0aGlzLnJlbGF0ZWRUYXJnZXQ9dGhpcy5jdXJyZW50VGFyZ2V0PXRoaXMudGFyZ2V0PW51bGw7dGhpcy5idXR0b249dGhpcy5zY3JlZW5ZPXRoaXMuc2NyZWVuWD10aGlzLmNsaWVudFk9dGhpcy5jbGllbnRYPXRoaXMub2Zmc2V0WT10aGlzLm9mZnNldFg9MDt0aGlzLmtleT1cIlwiO3RoaXMuY2hhckNvZGU9dGhpcy5rZXlDb2RlPTA7dGhpcy5tZXRhS2V5PXRoaXMuc2hpZnRLZXk9dGhpcy5hbHRLZXk9dGhpcy5jdHJsS2V5PSExO3RoaXMuc3RhdGU9bnVsbDt0aGlzLnBvaW50ZXJJZD0wO3RoaXMucG9pbnRlclR5cGU9XCJcIjt0aGlzLlI9bnVsbDthJiZ0aGlzLmluaXQoYSxiKX07dChZYixCKTt2YXIgWmI9VGIoezI6XCJ0b3VjaFwiLDM6XCJwZW5cIiw0OlwibW91c2VcIn0pO1xuWWIucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLnR5cGU9YS50eXBlLGQ9YS5jaGFuZ2VkVG91Y2hlcz9hLmNoYW5nZWRUb3VjaGVzWzBdOm51bGw7dGhpcy50YXJnZXQ9YS50YXJnZXR8fGEuc3JjRWxlbWVudDt0aGlzLmN1cnJlbnRUYXJnZXQ9YjtpZihiPWEucmVsYXRlZFRhcmdldCl7aWYodGIpe2E6e3RyeXtuYihiLm5vZGVOYW1lKTt2YXIgZT0hMDticmVhayBhfWNhdGNoKGYpe31lPSExfWV8fChiPW51bGwpfX1lbHNlXCJtb3VzZW92ZXJcIj09Yz9iPWEuZnJvbUVsZW1lbnQ6XCJtb3VzZW91dFwiPT1jJiYoYj1hLnRvRWxlbWVudCk7dGhpcy5yZWxhdGVkVGFyZ2V0PWI7bnVsbD09PWQ/KHRoaXMub2Zmc2V0WD11Ynx8dm9pZCAwIT09YS5vZmZzZXRYP2Eub2Zmc2V0WDphLmxheWVyWCx0aGlzLm9mZnNldFk9dWJ8fHZvaWQgMCE9PWEub2Zmc2V0WT9hLm9mZnNldFk6YS5sYXllclksdGhpcy5jbGllbnRYPXZvaWQgMCE9PWEuY2xpZW50WD9hLmNsaWVudFg6YS5wYWdlWCxcbnRoaXMuY2xpZW50WT12b2lkIDAhPT1hLmNsaWVudFk/YS5jbGllbnRZOmEucGFnZVksdGhpcy5zY3JlZW5YPWEuc2NyZWVuWHx8MCx0aGlzLnNjcmVlblk9YS5zY3JlZW5ZfHwwKToodGhpcy5jbGllbnRYPXZvaWQgMCE9PWQuY2xpZW50WD9kLmNsaWVudFg6ZC5wYWdlWCx0aGlzLmNsaWVudFk9dm9pZCAwIT09ZC5jbGllbnRZP2QuY2xpZW50WTpkLnBhZ2VZLHRoaXMuc2NyZWVuWD1kLnNjcmVlblh8fDAsdGhpcy5zY3JlZW5ZPWQuc2NyZWVuWXx8MCk7dGhpcy5idXR0b249YS5idXR0b247dGhpcy5rZXlDb2RlPWEua2V5Q29kZXx8MDt0aGlzLmtleT1hLmtleXx8XCJcIjt0aGlzLmNoYXJDb2RlPWEuY2hhckNvZGV8fChcImtleXByZXNzXCI9PWM/YS5rZXlDb2RlOjApO3RoaXMuY3RybEtleT1hLmN0cmxLZXk7dGhpcy5hbHRLZXk9YS5hbHRLZXk7dGhpcy5zaGlmdEtleT1hLnNoaWZ0S2V5O3RoaXMubWV0YUtleT1hLm1ldGFLZXk7dGhpcy5wb2ludGVySWQ9YS5wb2ludGVySWR8fDA7dGhpcy5wb2ludGVyVHlwZT1cbm0oYS5wb2ludGVyVHlwZSk/YS5wb2ludGVyVHlwZTpaYlthLnBvaW50ZXJUeXBlXXx8XCJcIjt0aGlzLnN0YXRlPWEuc3RhdGU7dGhpcy5SPWE7YS5kZWZhdWx0UHJldmVudGVkJiZ0aGlzLnByZXZlbnREZWZhdWx0KCl9O1liLnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb249ZnVuY3Rpb24oKXtZYi5VYy5zdG9wUHJvcGFnYXRpb24uY2FsbCh0aGlzKTt0aGlzLlIuc3RvcFByb3BhZ2F0aW9uP3RoaXMuUi5zdG9wUHJvcGFnYXRpb24oKTp0aGlzLlIuY2FuY2VsQnViYmxlPSEwfTtZYi5wcm90b3R5cGUucHJldmVudERlZmF1bHQ9ZnVuY3Rpb24oKXtZYi5VYy5wcmV2ZW50RGVmYXVsdC5jYWxsKHRoaXMpO3ZhciBhPXRoaXMuUjtpZihhLnByZXZlbnREZWZhdWx0KWEucHJldmVudERlZmF1bHQoKTtlbHNlIGlmKGEucmV0dXJuVmFsdWU9ITEsV2IpdHJ5e2lmKGEuY3RybEtleXx8MTEyPD1hLmtleUNvZGUmJjEyMz49YS5rZXlDb2RlKWEua2V5Q29kZT0tMX1jYXRjaChiKXt9fTtcblliLnByb3RvdHlwZS5IZj1mdW5jdGlvbigpe3JldHVybiB0aGlzLlJ9O3ZhciAkYj1cImNsb3N1cmVfbGlzdGVuYWJsZV9cIisoMUU2Kk1hdGgucmFuZG9tKCl8MCksYWM9MDt2YXIgYmM9ZnVuY3Rpb24oYSxiLGMsZCxlKXt0aGlzLmxpc3RlbmVyPWE7dGhpcy5NYz1udWxsO3RoaXMuc3JjPWI7dGhpcy50eXBlPWM7dGhpcy5jYXB0dXJlPSEhZDt0aGlzLnZjPWU7dGhpcy5rZXk9KythYzt0aGlzLkJiPXRoaXMucGM9ITF9LGNjPWZ1bmN0aW9uKGEpe2EuQmI9ITA7YS5saXN0ZW5lcj1udWxsO2EuTWM9bnVsbDthLnNyYz1udWxsO2EudmM9bnVsbH07dmFyIGRjPWZ1bmN0aW9uKGEpe3RoaXMuc3JjPWE7dGhpcy5JPXt9O3RoaXMuamM9MH07ZGMucHJvdG90eXBlLmFkZD1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPWEudG9TdHJpbmcoKTthPXRoaXMuSVtmXTthfHwoYT10aGlzLklbZl09W10sdGhpcy5qYysrKTt2YXIgZz1lYyhhLGIsZCxlKTstMTxnPyhiPWFbZ10sY3x8KGIucGM9ITEpKTooYj1uZXcgYmMoYix0aGlzLnNyYyxmLCEhZCxlKSxiLnBjPWMsYS5wdXNoKGIpKTtyZXR1cm4gYn07ZGMucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbihhLGIsYyxkKXthPWEudG9TdHJpbmcoKTtpZighKGEgaW4gdGhpcy5JKSlyZXR1cm4hMTt2YXIgZT10aGlzLklbYV07Yj1lYyhlLGIsYyxkKTtyZXR1cm4tMTxiPyhjYyhlW2JdKSxXYShlLGIpLDA9PWUubGVuZ3RoJiYoZGVsZXRlIHRoaXMuSVthXSx0aGlzLmpjLS0pLCEwKTohMX07XG52YXIgZmM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1iLnR5cGU7YyBpbiBhLkkmJlhhKGEuSVtjXSxiKSYmKGNjKGIpLDA9PWEuSVtjXS5sZW5ndGgmJihkZWxldGUgYS5JW2NdLGEuamMtLSkpfTtkYy5wcm90b3R5cGUudGQ9ZnVuY3Rpb24oYSxiLGMsZCl7YT10aGlzLklbYS50b1N0cmluZygpXTt2YXIgZT0tMTthJiYoZT1lYyhhLGIsYyxkKSk7cmV0dXJuLTE8ZT9hW2VdOm51bGx9O2RjLnByb3RvdHlwZS5oYXNMaXN0ZW5lcj1mdW5jdGlvbihhLGIpe3ZhciBjPWJhKGEpLGQ9Yz9hLnRvU3RyaW5nKCk6XCJcIixlPWJhKGIpO3JldHVybiBmYih0aGlzLkksZnVuY3Rpb24oYSl7Zm9yKHZhciBmPTA7ZjxhLmxlbmd0aDsrK2YpaWYoIShjJiZhW2ZdLnR5cGUhPWR8fGUmJmFbZl0uY2FwdHVyZSE9YikpcmV0dXJuITA7cmV0dXJuITF9KX07XG52YXIgZWM9ZnVuY3Rpb24oYSxiLGMsZCl7Zm9yKHZhciBlPTA7ZTxhLmxlbmd0aDsrK2Upe3ZhciBmPWFbZV07aWYoIWYuQmImJmYubGlzdGVuZXI9PWImJmYuY2FwdHVyZT09ISFjJiZmLnZjPT1kKXJldHVybiBlfXJldHVybi0xfTt2YXIgZ2M9XCJjbG9zdXJlX2xtX1wiKygxRTYqTWF0aC5yYW5kb20oKXwwKSxoYz17fSxqYz0wLGxjPWZ1bmN0aW9uKGEsYixjLGQsZSl7aWYoZCYmZC5vbmNlKWtjKGEsYixjLGQsZSk7ZWxzZSBpZihoYShiKSlmb3IodmFyIGY9MDtmPGIubGVuZ3RoO2YrKylsYyhhLGJbZl0sYyxkLGUpO2Vsc2UgYz1tYyhjKSxhJiZhWyRiXT9hLmxpc3RlbihiLGMscShkKT8hIWQuY2FwdHVyZTohIWQsZSk6bmMoYSxiLGMsITEsZCxlKX0sbmM9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2lmKCFiKXRocm93IEVycm9yKFwiSW52YWxpZCBldmVudCB0eXBlXCIpO3ZhciBnPXEoZSk/ISFlLmNhcHR1cmU6ISFlLGw9b2MoYSk7bHx8KGFbZ2NdPWw9bmV3IGRjKGEpKTtjPWwuYWRkKGIsYyxkLGcsZik7aWYoIWMuTWMpe2Q9cGMoKTtjLk1jPWQ7ZC5zcmM9YTtkLmxpc3RlbmVyPWM7aWYoYS5hZGRFdmVudExpc3RlbmVyKVhifHwoZT1nKSx2b2lkIDA9PT1lJiYoZT0hMSksYS5hZGRFdmVudExpc3RlbmVyKGIudG9TdHJpbmcoKSxcbmQsZSk7ZWxzZSBpZihhLmF0dGFjaEV2ZW50KWEuYXR0YWNoRXZlbnQocWMoYi50b1N0cmluZygpKSxkKTtlbHNlIHRocm93IEVycm9yKFwiYWRkRXZlbnRMaXN0ZW5lciBhbmQgYXR0YWNoRXZlbnQgYXJlIHVuYXZhaWxhYmxlLlwiKTtqYysrfX0scGM9ZnVuY3Rpb24oKXt2YXIgYT1yYyxiPVZiP2Z1bmN0aW9uKGMpe3JldHVybiBhLmNhbGwoYi5zcmMsYi5saXN0ZW5lcixjKX06ZnVuY3Rpb24oYyl7Yz1hLmNhbGwoYi5zcmMsYi5saXN0ZW5lcixjKTtpZighYylyZXR1cm4gY307cmV0dXJuIGJ9LGtjPWZ1bmN0aW9uKGEsYixjLGQsZSl7aWYoaGEoYikpZm9yKHZhciBmPTA7ZjxiLmxlbmd0aDtmKyspa2MoYSxiW2ZdLGMsZCxlKTtlbHNlIGM9bWMoYyksYSYmYVskYl0/c2MoYSxiLGMscShkKT8hIWQuY2FwdHVyZTohIWQsZSk6bmMoYSxiLGMsITAsZCxlKX0sdGM9ZnVuY3Rpb24oYSxiLGMsZCxlKXtpZihoYShiKSlmb3IodmFyIGY9MDtmPGIubGVuZ3RoO2YrKyl0YyhhLGJbZl0sYyxkLFxuZSk7ZWxzZSBkPXEoZCk/ISFkLmNhcHR1cmU6ISFkLGM9bWMoYyksYSYmYVskYl0/YS5nYS5yZW1vdmUoU3RyaW5nKGIpLGMsZCxlKTphJiYoYT1vYyhhKSkmJihiPWEudGQoYixjLGQsZSkpJiZ1YyhiKX0sdWM9ZnVuY3Rpb24oYSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGEmJmEmJiFhLkJiKXt2YXIgYj1hLnNyYztpZihiJiZiWyRiXSlmYyhiLmdhLGEpO2Vsc2V7dmFyIGM9YS50eXBlLGQ9YS5NYztiLnJlbW92ZUV2ZW50TGlzdGVuZXI/Yi5yZW1vdmVFdmVudExpc3RlbmVyKGMsZCxhLmNhcHR1cmUpOmIuZGV0YWNoRXZlbnQmJmIuZGV0YWNoRXZlbnQocWMoYyksZCk7amMtLTsoYz1vYyhiKSk/KGZjKGMsYSksMD09Yy5qYyYmKGMuc3JjPW51bGwsYltnY109bnVsbCkpOmNjKGEpfX19LHFjPWZ1bmN0aW9uKGEpe3JldHVybiBhIGluIGhjP2hjW2FdOmhjW2FdPVwib25cIithfSx3Yz1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT0hMDtpZihhPW9jKGEpKWlmKGI9YS5JW2IudG9TdHJpbmcoKV0pZm9yKGI9XG5iLmNvbmNhdCgpLGE9MDthPGIubGVuZ3RoO2ErKyl7dmFyIGY9YlthXTtmJiZmLmNhcHR1cmU9PWMmJiFmLkJiJiYoZj12YyhmLGQpLGU9ZSYmITEhPT1mKX1yZXR1cm4gZX0sdmM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmxpc3RlbmVyLGQ9YS52Y3x8YS5zcmM7YS5wYyYmdWMoYSk7cmV0dXJuIGMuY2FsbChkLGIpfSxyYz1mdW5jdGlvbihhLGIpe2lmKGEuQmIpcmV0dXJuITA7aWYoIVZiKXtpZighYilhOntiPVtcIndpbmRvd1wiLFwiZXZlbnRcIl07Zm9yKHZhciBjPWssZD0wO2Q8Yi5sZW5ndGg7ZCsrKWlmKGM9Y1tiW2RdXSxudWxsPT1jKXtiPW51bGw7YnJlYWsgYX1iPWN9ZD1iO2I9bmV3IFliKGQsdGhpcyk7Yz0hMDtpZighKDA+ZC5rZXlDb2RlfHx2b2lkIDAhPWQucmV0dXJuVmFsdWUpKXthOnt2YXIgZT0hMTtpZigwPT1kLmtleUNvZGUpdHJ5e2Qua2V5Q29kZT0tMTticmVhayBhfWNhdGNoKGcpe2U9ITB9aWYoZXx8dm9pZCAwPT1kLnJldHVyblZhbHVlKWQucmV0dXJuVmFsdWU9XG4hMH1kPVtdO2ZvcihlPWIuY3VycmVudFRhcmdldDtlO2U9ZS5wYXJlbnROb2RlKWQucHVzaChlKTthPWEudHlwZTtmb3IoZT1kLmxlbmd0aC0xOyFiLldhJiYwPD1lO2UtLSl7Yi5jdXJyZW50VGFyZ2V0PWRbZV07dmFyIGY9d2MoZFtlXSxhLCEwLGIpO2M9YyYmZn1mb3IoZT0wOyFiLldhJiZlPGQubGVuZ3RoO2UrKyliLmN1cnJlbnRUYXJnZXQ9ZFtlXSxmPXdjKGRbZV0sYSwhMSxiKSxjPWMmJmZ9cmV0dXJuIGN9cmV0dXJuIHZjKGEsbmV3IFliKGIsdGhpcykpfSxvYz1mdW5jdGlvbihhKXthPWFbZ2NdO3JldHVybiBhIGluc3RhbmNlb2YgZGM/YTpudWxsfSx4Yz1cIl9fY2xvc3VyZV9ldmVudHNfZm5fXCIrKDFFOSpNYXRoLnJhbmRvbSgpPj4+MCksbWM9ZnVuY3Rpb24oYSl7dyhhLFwiTGlzdGVuZXIgY2FuIG5vdCBiZSBudWxsLlwiKTtpZihwKGEpKXJldHVybiBhO3coYS5oYW5kbGVFdmVudCxcIkFuIG9iamVjdCBsaXN0ZW5lciBtdXN0IGhhdmUgaGFuZGxlRXZlbnQgbWV0aG9kLlwiKTtcbmFbeGNdfHwoYVt4Y109ZnVuY3Rpb24oYil7cmV0dXJuIGEuaGFuZGxlRXZlbnQoYil9KTtyZXR1cm4gYVt4Y119O3ZhciB5Yz0vXlsrYS16QS1aMC05Xy4hIyQlJicqXFwvPT9eYHt8fX4tXStAKFthLXpBLVowLTktXStcXC4pK1thLXpBLVowLTldezIsNjN9JC87dmFyIEFjPWZ1bmN0aW9uKCl7dGhpcy54YT1cIlwiO3RoaXMuamY9emN9O0FjLnByb3RvdHlwZS5xYj0hMDtBYy5wcm90b3R5cGUub2I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54YX07QWMucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJTYWZlVXJse1wiK3RoaXMueGErXCJ9XCJ9O1xudmFyIEJjPWZ1bmN0aW9uKGEpe2lmKGEgaW5zdGFuY2VvZiBBYyYmYS5jb25zdHJ1Y3Rvcj09PUFjJiZhLmpmPT09emMpcmV0dXJuIGEueGE7QWEoXCJleHBlY3RlZCBvYmplY3Qgb2YgdHlwZSBTYWZlVXJsLCBnb3QgJ1wiK2ErXCInIG9mIHR5cGUgXCIrZWEoYSkpO3JldHVyblwidHlwZV9lcnJvcjpTYWZlVXJsXCJ9LENjPS9eKD86KD86aHR0cHM/fG1haWx0b3xmdHApOnxbXjovPyNdKig/OlsvPyNdfCQpKS9pLEVjPWZ1bmN0aW9uKGEpe2lmKGEgaW5zdGFuY2VvZiBBYylyZXR1cm4gYTthPWEucWI/YS5vYigpOlN0cmluZyhhKTtDYy50ZXN0KGEpfHwoYT1cImFib3V0OmludmFsaWQjekNsb3N1cmV6XCIpO3JldHVybiBEYyhhKX0semM9e30sRGM9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IEFjO2IueGE9YTtyZXR1cm4gYn07RGMoXCJhYm91dDpibGFua1wiKTt2YXIgSGM9ZnVuY3Rpb24oYSl7dmFyIGI9W107RmMobmV3IEdjLGEsYik7cmV0dXJuIGIuam9pbihcIlwiKX0sR2M9ZnVuY3Rpb24oKXt0aGlzLk5jPXZvaWQgMH0sRmM9ZnVuY3Rpb24oYSxiLGMpe2lmKG51bGw9PWIpYy5wdXNoKFwibnVsbFwiKTtlbHNle2lmKFwib2JqZWN0XCI9PXR5cGVvZiBiKXtpZihoYShiKSl7dmFyIGQ9YjtiPWQubGVuZ3RoO2MucHVzaChcIltcIik7Zm9yKHZhciBlPVwiXCIsZj0wO2Y8YjtmKyspYy5wdXNoKGUpLGU9ZFtmXSxGYyhhLGEuTmM/YS5OYy5jYWxsKGQsU3RyaW5nKGYpLGUpOmUsYyksZT1cIixcIjtjLnB1c2goXCJdXCIpO3JldHVybn1pZihiIGluc3RhbmNlb2YgU3RyaW5nfHxiIGluc3RhbmNlb2YgTnVtYmVyfHxiIGluc3RhbmNlb2YgQm9vbGVhbiliPWIudmFsdWVPZigpO2Vsc2V7Yy5wdXNoKFwie1wiKTtmPVwiXCI7Zm9yKGQgaW4gYilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYixkKSYmKGU9YltkXSxcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiYoYy5wdXNoKGYpLFxuSWMoZCxjKSxjLnB1c2goXCI6XCIpLEZjKGEsYS5OYz9hLk5jLmNhbGwoYixkLGUpOmUsYyksZj1cIixcIikpO2MucHVzaChcIn1cIik7cmV0dXJufX1zd2l0Y2godHlwZW9mIGIpe2Nhc2UgXCJzdHJpbmdcIjpJYyhiLGMpO2JyZWFrO2Nhc2UgXCJudW1iZXJcIjpjLnB1c2goaXNGaW5pdGUoYikmJiFpc05hTihiKT9TdHJpbmcoYik6XCJudWxsXCIpO2JyZWFrO2Nhc2UgXCJib29sZWFuXCI6Yy5wdXNoKFN0cmluZyhiKSk7YnJlYWs7Y2FzZSBcImZ1bmN0aW9uXCI6Yy5wdXNoKFwibnVsbFwiKTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiVW5rbm93biB0eXBlOiBcIit0eXBlb2YgYik7fX19LEpjPXsnXCInOidcXFxcXCInLFwiXFxcXFwiOlwiXFxcXFxcXFxcIixcIi9cIjpcIlxcXFwvXCIsXCJcXGJcIjpcIlxcXFxiXCIsXCJcXGZcIjpcIlxcXFxmXCIsXCJcXG5cIjpcIlxcXFxuXCIsXCJcXHJcIjpcIlxcXFxyXCIsXCJcXHRcIjpcIlxcXFx0XCIsXCJcXHgwQlwiOlwiXFxcXHUwMDBiXCJ9LEtjPS9cXHVmZmZmLy50ZXN0KFwiXFx1ZmZmZlwiKT8vW1xcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx1ZmZmZl0vZzovW1xcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4ZmZdL2csXG5JYz1mdW5jdGlvbihhLGIpe2IucHVzaCgnXCInLGEucmVwbGFjZShLYyxmdW5jdGlvbihhKXt2YXIgYj1KY1thXTtifHwoYj1cIlxcXFx1XCIrKGEuY2hhckNvZGVBdCgwKXw2NTUzNikudG9TdHJpbmcoMTYpLnN1YnN0cigxKSxKY1thXT1iKTtyZXR1cm4gYn0pLCdcIicpfTt2YXIgTGM9ZnVuY3Rpb24oKXt9O0xjLnByb3RvdHlwZS5qZT1udWxsO3ZhciBNYz1mdW5jdGlvbihhKXtyZXR1cm4gYS5qZXx8KGEuamU9YS5DZCgpKX07dmFyIE5jLE9jPWZ1bmN0aW9uKCl7fTt0KE9jLExjKTtPYy5wcm90b3R5cGUucmM9ZnVuY3Rpb24oKXt2YXIgYT1QYyh0aGlzKTtyZXR1cm4gYT9uZXcgQWN0aXZlWE9iamVjdChhKTpuZXcgWE1MSHR0cFJlcXVlc3R9O09jLnByb3RvdHlwZS5DZD1mdW5jdGlvbigpe3ZhciBhPXt9O1BjKHRoaXMpJiYoYVswXT0hMCxhWzFdPSEwKTtyZXR1cm4gYX07XG52YXIgUGM9ZnVuY3Rpb24oYSl7aWYoIWEuRWUmJlwidW5kZWZpbmVkXCI9PXR5cGVvZiBYTUxIdHRwUmVxdWVzdCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEFjdGl2ZVhPYmplY3Qpe2Zvcih2YXIgYj1bXCJNU1hNTDIuWE1MSFRUUC42LjBcIixcIk1TWE1MMi5YTUxIVFRQLjMuMFwiLFwiTVNYTUwyLlhNTEhUVFBcIixcIk1pY3Jvc29mdC5YTUxIVFRQXCJdLGM9MDtjPGIubGVuZ3RoO2MrKyl7dmFyIGQ9YltjXTt0cnl7cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KGQpLGEuRWU9ZH1jYXRjaChlKXt9fXRocm93IEVycm9yKFwiQ291bGQgbm90IGNyZWF0ZSBBY3RpdmVYT2JqZWN0LiBBY3RpdmVYIG1pZ2h0IGJlIGRpc2FibGVkLCBvciBNU1hNTCBtaWdodCBub3QgYmUgaW5zdGFsbGVkXCIpO31yZXR1cm4gYS5FZX07TmM9bmV3IE9jO3ZhciBRYz1mdW5jdGlvbigpe307dChRYyxMYyk7UWMucHJvdG90eXBlLnJjPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFhNTEh0dHBSZXF1ZXN0O2lmKFwid2l0aENyZWRlbnRpYWxzXCJpbiBhKXJldHVybiBhO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBYRG9tYWluUmVxdWVzdClyZXR1cm4gbmV3IFJjO3Rocm93IEVycm9yKFwiVW5zdXBwb3J0ZWQgYnJvd3NlclwiKTt9O1FjLnByb3RvdHlwZS5DZD1mdW5jdGlvbigpe3JldHVybnt9fTtcbnZhciBSYz1mdW5jdGlvbigpe3RoaXMub2E9bmV3IFhEb21haW5SZXF1ZXN0O3RoaXMucmVhZHlTdGF0ZT0wO3RoaXMub25yZWFkeXN0YXRlY2hhbmdlPW51bGw7dGhpcy5yZXNwb25zZVRleHQ9XCJcIjt0aGlzLnN0YXR1cz0tMTt0aGlzLnN0YXR1c1RleHQ9dGhpcy5yZXNwb25zZVhNTD1udWxsO3RoaXMub2Eub25sb2FkPXIodGhpcy5MZix0aGlzKTt0aGlzLm9hLm9uZXJyb3I9cih0aGlzLnplLHRoaXMpO3RoaXMub2Eub25wcm9ncmVzcz1yKHRoaXMuTWYsdGhpcyk7dGhpcy5vYS5vbnRpbWVvdXQ9cih0aGlzLk5mLHRoaXMpfTtoPVJjLnByb3RvdHlwZTtoLm9wZW49ZnVuY3Rpb24oYSxiLGMpe2lmKG51bGwhPWMmJiFjKXRocm93IEVycm9yKFwiT25seSBhc3luYyByZXF1ZXN0cyBhcmUgc3VwcG9ydGVkLlwiKTt0aGlzLm9hLm9wZW4oYSxiKX07XG5oLnNlbmQ9ZnVuY3Rpb24oYSl7aWYoYSlpZihcInN0cmluZ1wiPT10eXBlb2YgYSl0aGlzLm9hLnNlbmQoYSk7ZWxzZSB0aHJvdyBFcnJvcihcIk9ubHkgc3RyaW5nIGRhdGEgaXMgc3VwcG9ydGVkXCIpO2Vsc2UgdGhpcy5vYS5zZW5kKCl9O2guYWJvcnQ9ZnVuY3Rpb24oKXt0aGlzLm9hLmFib3J0KCl9O2guc2V0UmVxdWVzdEhlYWRlcj1mdW5jdGlvbigpe307aC5nZXRSZXNwb25zZUhlYWRlcj1mdW5jdGlvbihhKXtyZXR1cm5cImNvbnRlbnQtdHlwZVwiPT1hLnRvTG93ZXJDYXNlKCk/dGhpcy5vYS5jb250ZW50VHlwZTpcIlwifTtoLkxmPWZ1bmN0aW9uKCl7dGhpcy5zdGF0dXM9MjAwO3RoaXMucmVzcG9uc2VUZXh0PXRoaXMub2EucmVzcG9uc2VUZXh0O1NjKHRoaXMsNCl9O2guemU9ZnVuY3Rpb24oKXt0aGlzLnN0YXR1cz01MDA7dGhpcy5yZXNwb25zZVRleHQ9XCJcIjtTYyh0aGlzLDQpfTtoLk5mPWZ1bmN0aW9uKCl7dGhpcy56ZSgpfTtcbmguTWY9ZnVuY3Rpb24oKXt0aGlzLnN0YXR1cz0yMDA7U2ModGhpcywxKX07dmFyIFNjPWZ1bmN0aW9uKGEsYil7YS5yZWFkeVN0YXRlPWI7aWYoYS5vbnJlYWR5c3RhdGVjaGFuZ2UpYS5vbnJlYWR5c3RhdGVjaGFuZ2UoKX07UmMucHJvdG90eXBlLmdldEFsbFJlc3BvbnNlSGVhZGVycz1mdW5jdGlvbigpe3JldHVyblwiY29udGVudC10eXBlOiBcIit0aGlzLm9hLmNvbnRlbnRUeXBlfTt2YXIgVGM9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuWWY9Yzt0aGlzLndmPWE7dGhpcy5sZz1iO3RoaXMuSGM9MDt0aGlzLndjPW51bGx9O1RjLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXtpZigwPHRoaXMuSGMpe3RoaXMuSGMtLTt2YXIgYT10aGlzLndjO3RoaXMud2M9YS5uZXh0O2EubmV4dD1udWxsfWVsc2UgYT10aGlzLndmKCk7cmV0dXJuIGF9O1RjLnByb3RvdHlwZS5wdXQ9ZnVuY3Rpb24oYSl7dGhpcy5sZyhhKTt0aGlzLkhjPHRoaXMuWWYmJih0aGlzLkhjKyssYS5uZXh0PXRoaXMud2MsdGhpcy53Yz1hKX07dmFyIFVjPWZ1bmN0aW9uKGEpe2suc2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGE7fSwwKX0sVmMsV2M9ZnVuY3Rpb24oKXt2YXIgYT1rLk1lc3NhZ2VDaGFubmVsO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYSYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cmJndpbmRvdy5wb3N0TWVzc2FnZSYmd2luZG93LmFkZEV2ZW50TGlzdGVuZXImJiF5KFwiUHJlc3RvXCIpJiYoYT1mdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJJRlJBTUVcIik7YS5zdHlsZS5kaXNwbGF5PVwibm9uZVwiO2Euc3JjPVwiXCI7ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGEpO3ZhciBiPWEuY29udGVudFdpbmRvdzthPWIuZG9jdW1lbnQ7YS5vcGVuKCk7YS53cml0ZShcIlwiKTthLmNsb3NlKCk7dmFyIGM9XCJjYWxsSW1tZWRpYXRlXCIrTWF0aC5yYW5kb20oKSxkPVwiZmlsZTpcIj09Yi5sb2NhdGlvbi5wcm90b2NvbD9cIipcIjpiLmxvY2F0aW9uLnByb3RvY29sK1wiLy9cIitiLmxvY2F0aW9uLmhvc3Q7XG5hPXIoZnVuY3Rpb24oYSl7aWYoKFwiKlwiPT1kfHxhLm9yaWdpbj09ZCkmJmEuZGF0YT09Yyl0aGlzLnBvcnQxLm9ubWVzc2FnZSgpfSx0aGlzKTtiLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsYSwhMSk7dGhpcy5wb3J0MT17fTt0aGlzLnBvcnQyPXtwb3N0TWVzc2FnZTpmdW5jdGlvbigpe2IucG9zdE1lc3NhZ2UoYyxkKX19fSk7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhJiYheShcIlRyaWRlbnRcIikmJiF5KFwiTVNJRVwiKSl7dmFyIGI9bmV3IGEsYz17fSxkPWM7Yi5wb3J0MS5vbm1lc3NhZ2U9ZnVuY3Rpb24oKXtpZihiYShjLm5leHQpKXtjPWMubmV4dDt2YXIgYT1jLm1lO2MubWU9bnVsbDthKCl9fTtyZXR1cm4gZnVuY3Rpb24oYSl7ZC5uZXh0PXttZTphfTtkPWQubmV4dDtiLnBvcnQyLnBvc3RNZXNzYWdlKDApfX1yZXR1cm5cInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50JiZcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIlNDUklQVFwiKT9cbmZ1bmN0aW9uKGEpe3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJTQ1JJUFRcIik7Yi5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtiLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsO2IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKTtiPW51bGw7YSgpO2E9bnVsbH07ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGIpfTpmdW5jdGlvbihhKXtrLnNldFRpbWVvdXQoYSwwKX19O3ZhciBYYz1mdW5jdGlvbigpe3RoaXMuYmQ9dGhpcy5oYj1udWxsfSxaYz1uZXcgVGMoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFljfSxmdW5jdGlvbihhKXthLnJlc2V0KCl9LDEwMCk7WGMucHJvdG90eXBlLmFkZD1mdW5jdGlvbihhLGIpe3ZhciBjPVpjLmdldCgpO2Muc2V0KGEsYik7dGhpcy5iZD90aGlzLmJkLm5leHQ9YzoodyghdGhpcy5oYiksdGhpcy5oYj1jKTt0aGlzLmJkPWN9O1hjLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt2YXIgYT1udWxsO3RoaXMuaGImJihhPXRoaXMuaGIsdGhpcy5oYj10aGlzLmhiLm5leHQsdGhpcy5oYnx8KHRoaXMuYmQ9bnVsbCksYS5uZXh0PW51bGwpO3JldHVybiBhfTt2YXIgWWM9ZnVuY3Rpb24oKXt0aGlzLm5leHQ9dGhpcy5zY29wZT10aGlzLnJkPW51bGx9O1ljLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXt0aGlzLnJkPWE7dGhpcy5zY29wZT1iO3RoaXMubmV4dD1udWxsfTtcblljLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMubmV4dD10aGlzLnNjb3BlPXRoaXMucmQ9bnVsbH07dmFyIGRkPWZ1bmN0aW9uKGEsYil7JGN8fGFkKCk7YmR8fCgkYygpLGJkPSEwKTtjZC5hZGQoYSxiKX0sJGMsYWQ9ZnVuY3Rpb24oKXtpZigtMSE9U3RyaW5nKGsuUHJvbWlzZSkuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikpe3ZhciBhPWsuUHJvbWlzZS5yZXNvbHZlKHZvaWQgMCk7JGM9ZnVuY3Rpb24oKXthLnRoZW4oZWQpfX1lbHNlICRjPWZ1bmN0aW9uKCl7dmFyIGE9ZWQ7IXAoay5zZXRJbW1lZGlhdGUpfHxrLldpbmRvdyYmay5XaW5kb3cucHJvdG90eXBlJiYheShcIkVkZ2VcIikmJmsuV2luZG93LnByb3RvdHlwZS5zZXRJbW1lZGlhdGU9PWsuc2V0SW1tZWRpYXRlPyhWY3x8KFZjPVdjKCkpLFZjKGEpKTprLnNldEltbWVkaWF0ZShhKX19LGJkPSExLGNkPW5ldyBYYyxlZD1mdW5jdGlvbigpe2Zvcih2YXIgYTthPWNkLnJlbW92ZSgpOyl7dHJ5e2EucmQuY2FsbChhLnNjb3BlKX1jYXRjaChiKXtVYyhiKX1aYy5wdXQoYSl9YmQ9ITF9O3ZhciBmZD1mdW5jdGlvbihhLGIpe3ZhciBjPShjPWEmJmEub3duZXJEb2N1bWVudCkmJihjLmRlZmF1bHRWaWV3fHxjLnBhcmVudFdpbmRvdyl8fGs7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGNbYl0mJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBjLkxvY2F0aW9uJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYy5FbGVtZW50JiYoYz1hJiYoYSBpbnN0YW5jZW9mIGNbYl18fCEoYSBpbnN0YW5jZW9mIGMuTG9jYXRpb258fGEgaW5zdGFuY2VvZiBjLkVsZW1lbnQpKSxhPXEoYSk/YS5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZXx8YS5jb25zdHJ1Y3Rvci5uYW1lfHxPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSk6dm9pZCAwPT09YT9cInVuZGVmaW5lZFwiOm51bGw9PT1hP1wibnVsbFwiOnR5cGVvZiBhLHcoYyxcIkFyZ3VtZW50IGlzIG5vdCBhICVzIChvciBhIG5vbi1FbGVtZW50LCBub24tTG9jYXRpb24gbW9jayk7IGdvdDogJXNcIixiLGEpKX07dmFyIGdkPSF6fHw5PD1OdW1iZXIoQ2IpOyF0YiYmIXp8fHomJjk8PU51bWJlcihDYil8fHRiJiZBKFwiMS45LjFcIik7eiYmQShcIjlcIik7dmFyIGlkPWZ1bmN0aW9uKCl7dGhpcy54YT1cIlwiO3RoaXMuaGY9aGR9O2lkLnByb3RvdHlwZS5xYj0hMDtpZC5wcm90b3R5cGUub2I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54YX07aWQucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJTYWZlSHRtbHtcIit0aGlzLnhhK1wifVwifTt2YXIgamQ9ZnVuY3Rpb24oYSl7aWYoYSBpbnN0YW5jZW9mIGlkJiZhLmNvbnN0cnVjdG9yPT09aWQmJmEuaGY9PT1oZClyZXR1cm4gYS54YTtBYShcImV4cGVjdGVkIG9iamVjdCBvZiB0eXBlIFNhZmVIdG1sLCBnb3QgJ1wiK2ErXCInIG9mIHR5cGUgXCIrZWEoYSkpO3JldHVyblwidHlwZV9lcnJvcjpTYWZlSHRtbFwifSxoZD17fTtpZC5wcm90b3R5cGUuVGY9ZnVuY3Rpb24oYSl7dGhpcy54YT1hO3JldHVybiB0aGlzfTt2YXIga2Q9ZnVuY3Rpb24oYSxiKXtmZChhLFwiSFRNTFNjcmlwdEVsZW1lbnRcIik7YS5zcmM9S2EoYil9O3ZhciBsZD1mdW5jdGlvbihhKXt2YXIgYj1kb2N1bWVudDtyZXR1cm4gbShhKT9iLmdldEVsZW1lbnRCeUlkKGEpOmF9LG5kPWZ1bmN0aW9uKGEsYil7ZWIoYixmdW5jdGlvbihiLGQpe2ImJmIucWImJihiPWIub2IoKSk7XCJzdHlsZVwiPT1kP2Euc3R5bGUuY3NzVGV4dD1iOlwiY2xhc3NcIj09ZD9hLmNsYXNzTmFtZT1iOlwiZm9yXCI9PWQ/YS5odG1sRm9yPWI6bWQuaGFzT3duUHJvcGVydHkoZCk/YS5zZXRBdHRyaWJ1dGUobWRbZF0sYik6MD09ZC5sYXN0SW5kZXhPZihcImFyaWEtXCIsMCl8fDA9PWQubGFzdEluZGV4T2YoXCJkYXRhLVwiLDApP2Euc2V0QXR0cmlidXRlKGQsYik6YVtkXT1ifSl9LG1kPXtjZWxscGFkZGluZzpcImNlbGxQYWRkaW5nXCIsY2VsbHNwYWNpbmc6XCJjZWxsU3BhY2luZ1wiLGNvbHNwYW46XCJjb2xTcGFuXCIsZnJhbWVib3JkZXI6XCJmcmFtZUJvcmRlclwiLGhlaWdodDpcImhlaWdodFwiLG1heGxlbmd0aDpcIm1heExlbmd0aFwiLG5vbmNlOlwibm9uY2VcIixyb2xlOlwicm9sZVwiLHJvd3NwYW46XCJyb3dTcGFuXCIsXG50eXBlOlwidHlwZVwiLHVzZW1hcDpcInVzZU1hcFwiLHZhbGlnbjpcInZBbGlnblwiLHdpZHRoOlwid2lkdGhcIn0scGQ9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWFyZ3VtZW50cyxlPWRvY3VtZW50LGY9U3RyaW5nKGRbMF0pLGc9ZFsxXTtpZighZ2QmJmcmJihnLm5hbWV8fGcudHlwZSkpe2Y9W1wiPFwiLGZdO2cubmFtZSYmZi5wdXNoKCcgbmFtZT1cIicsd2EoZy5uYW1lKSwnXCInKTtpZihnLnR5cGUpe2YucHVzaCgnIHR5cGU9XCInLHdhKGcudHlwZSksJ1wiJyk7dmFyIGw9e307bWIobCxnKTtkZWxldGUgbC50eXBlO2c9bH1mLnB1c2goXCI+XCIpO2Y9Zi5qb2luKFwiXCIpfWY9ZS5jcmVhdGVFbGVtZW50KGYpO2cmJihtKGcpP2YuY2xhc3NOYW1lPWc6aGEoZyk/Zi5jbGFzc05hbWU9Zy5qb2luKFwiIFwiKTpuZChmLGcpKTsyPGQubGVuZ3RoJiZvZChlLGYsZCk7cmV0dXJuIGZ9LG9kPWZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGMpe2MmJmIuYXBwZW5kQ2hpbGQobShjKT9hLmNyZWF0ZVRleHROb2RlKGMpOlxuYyl9Zm9yKHZhciBlPTI7ZTxjLmxlbmd0aDtlKyspe3ZhciBmPWNbZV07IWlhKGYpfHxxKGYpJiYwPGYubm9kZVR5cGU/ZChmKTp4KHFkKGYpPyRhKGYpOmYsZCl9fSxxZD1mdW5jdGlvbihhKXtpZihhJiZcIm51bWJlclwiPT10eXBlb2YgYS5sZW5ndGgpe2lmKHEoYSkpcmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgYS5pdGVtfHxcInN0cmluZ1wiPT10eXBlb2YgYS5pdGVtO2lmKHAoYSkpcmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgYS5pdGVtfXJldHVybiExfTt2YXIgcmQ9ZnVuY3Rpb24oYSl7YS5wcm90b3R5cGUudGhlbj1hLnByb3RvdHlwZS50aGVuO2EucHJvdG90eXBlLiRnb29nX1RoZW5hYmxlPSEwfSxzZD1mdW5jdGlvbihhKXtpZighYSlyZXR1cm4hMTt0cnl7cmV0dXJuISFhLiRnb29nX1RoZW5hYmxlfWNhdGNoKGIpe3JldHVybiExfX07dmFyIEM9ZnVuY3Rpb24oYSxiKXt0aGlzLmFhPTA7dGhpcy56YT12b2lkIDA7dGhpcy5rYj10aGlzLnVhPXRoaXMudz1udWxsO3RoaXMudWM9dGhpcy5wZD0hMTtpZihhIT1kYSl0cnl7dmFyIGM9dGhpczthLmNhbGwoYixmdW5jdGlvbihhKXt0ZChjLDIsYSl9LGZ1bmN0aW9uKGEpe2lmKCEoYSBpbnN0YW5jZW9mIHVkKSl0cnl7aWYoYSBpbnN0YW5jZW9mIEVycm9yKXRocm93IGE7dGhyb3cgRXJyb3IoXCJQcm9taXNlIHJlamVjdGVkLlwiKTt9Y2F0Y2goZSl7fXRkKGMsMyxhKX0pfWNhdGNoKGQpe3RkKHRoaXMsMyxkKX19LHZkPWZ1bmN0aW9uKCl7dGhpcy5uZXh0PXRoaXMuY29udGV4dD10aGlzLnRiPXRoaXMuVWE9dGhpcy5jaGlsZD1udWxsO3RoaXMuSGI9ITF9O3ZkLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMuY29udGV4dD10aGlzLnRiPXRoaXMuVWE9dGhpcy5jaGlsZD1udWxsO3RoaXMuSGI9ITF9O1xudmFyIHdkPW5ldyBUYyhmdW5jdGlvbigpe3JldHVybiBuZXcgdmR9LGZ1bmN0aW9uKGEpe2EucmVzZXQoKX0sMTAwKSx4ZD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9d2QuZ2V0KCk7ZC5VYT1hO2QudGI9YjtkLmNvbnRleHQ9YztyZXR1cm4gZH0sRD1mdW5jdGlvbihhKXtpZihhIGluc3RhbmNlb2YgQylyZXR1cm4gYTt2YXIgYj1uZXcgQyhkYSk7dGQoYiwyLGEpO3JldHVybiBifSxFPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgQyhmdW5jdGlvbihiLGMpe2MoYSl9KX0semQ9ZnVuY3Rpb24oYSxiLGMpe3lkKGEsYixjLG51bGwpfHxkZChsYShiLGEpKX0sQWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBDKGZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS5sZW5ndGgsZT1bXTtpZihkKWZvcih2YXIgZj1mdW5jdGlvbihhLGMpe2QtLTtlW2FdPWM7MD09ZCYmYihlKX0sZz1mdW5jdGlvbihhKXtjKGEpfSxsPTAsbjtsPGEubGVuZ3RoO2wrKyluPWFbbF0semQobixsYShmLGwpLGcpO2Vsc2UgYihlKX0pfSxcbkJkPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgQyhmdW5jdGlvbihiKXt2YXIgYz1hLmxlbmd0aCxkPVtdO2lmKGMpZm9yKHZhciBlPWZ1bmN0aW9uKGEsZSxmKXtjLS07ZFthXT1lP3tHZjohMCx2YWx1ZTpmfTp7R2Y6ITEscmVhc29uOmZ9OzA9PWMmJmIoZCl9LGY9MCxnO2Y8YS5sZW5ndGg7ZisrKWc9YVtmXSx6ZChnLGxhKGUsZiwhMCksbGEoZSxmLCExKSk7ZWxzZSBiKGQpfSl9O0MucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24oYSxiLGMpe251bGwhPWEmJkRhKGEsXCJvcHRfb25GdWxmaWxsZWQgc2hvdWxkIGJlIGEgZnVuY3Rpb24uXCIpO251bGwhPWImJkRhKGIsXCJvcHRfb25SZWplY3RlZCBzaG91bGQgYmUgYSBmdW5jdGlvbi4gRGlkIHlvdSBwYXNzIG9wdF9jb250ZXh0IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgaW5zdGVhZCBvZiB0aGUgdGhpcmQ/XCIpO3JldHVybiBDZCh0aGlzLHAoYSk/YTpudWxsLHAoYik/YjpudWxsLGMpfTtyZChDKTtcbnZhciBFZD1mdW5jdGlvbihhLGIpe2I9eGQoYixiLHZvaWQgMCk7Yi5IYj0hMDtEZChhLGIpO3JldHVybiBhfTtDLnByb3RvdHlwZS5nPWZ1bmN0aW9uKGEsYil7cmV0dXJuIENkKHRoaXMsbnVsbCxhLGIpfTtDLnByb3RvdHlwZS5jYW5jZWw9ZnVuY3Rpb24oYSl7MD09dGhpcy5hYSYmZGQoZnVuY3Rpb24oKXt2YXIgYj1uZXcgdWQoYSk7RmQodGhpcyxiKX0sdGhpcyl9O1xudmFyIEZkPWZ1bmN0aW9uKGEsYil7aWYoMD09YS5hYSlpZihhLncpe3ZhciBjPWEudztpZihjLnVhKXtmb3IodmFyIGQ9MCxlPW51bGwsZj1udWxsLGc9Yy51YTtnJiYoZy5IYnx8KGQrKyxnLmNoaWxkPT1hJiYoZT1nKSwhKGUmJjE8ZCkpKTtnPWcubmV4dCllfHwoZj1nKTtlJiYoMD09Yy5hYSYmMT09ZD9GZChjLGIpOihmPyhkPWYsdyhjLnVhKSx3KG51bGwhPWQpLGQubmV4dD09Yy5rYiYmKGMua2I9ZCksZC5uZXh0PWQubmV4dC5uZXh0KTpHZChjKSxIZChjLGUsMyxiKSkpfWEudz1udWxsfWVsc2UgdGQoYSwzLGIpfSxEZD1mdW5jdGlvbihhLGIpe2EudWF8fDIhPWEuYWEmJjMhPWEuYWF8fElkKGEpO3cobnVsbCE9Yi5VYSk7YS5rYj9hLmtiLm5leHQ9YjphLnVhPWI7YS5rYj1ifSxDZD1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT14ZChudWxsLG51bGwsbnVsbCk7ZS5jaGlsZD1uZXcgQyhmdW5jdGlvbihhLGcpe2UuVWE9Yj9mdW5jdGlvbihjKXt0cnl7dmFyIGU9Yi5jYWxsKGQsXG5jKTthKGUpfWNhdGNoKEYpe2coRil9fTphO2UudGI9Yz9mdW5jdGlvbihiKXt0cnl7dmFyIGU9Yy5jYWxsKGQsYik7IWJhKGUpJiZiIGluc3RhbmNlb2YgdWQ/ZyhiKTphKGUpfWNhdGNoKEYpe2coRil9fTpnfSk7ZS5jaGlsZC53PWE7RGQoYSxlKTtyZXR1cm4gZS5jaGlsZH07Qy5wcm90b3R5cGUuemc9ZnVuY3Rpb24oYSl7dygxPT10aGlzLmFhKTt0aGlzLmFhPTA7dGQodGhpcywyLGEpfTtDLnByb3RvdHlwZS5BZz1mdW5jdGlvbihhKXt3KDE9PXRoaXMuYWEpO3RoaXMuYWE9MDt0ZCh0aGlzLDMsYSl9O1xudmFyIHRkPWZ1bmN0aW9uKGEsYixjKXswPT1hLmFhJiYoYT09PWMmJihiPTMsYz1uZXcgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW5ub3QgcmVzb2x2ZSB0byBpdHNlbGZcIikpLGEuYWE9MSx5ZChjLGEuemcsYS5BZyxhKXx8KGEuemE9YyxhLmFhPWIsYS53PW51bGwsSWQoYSksMyE9Ynx8YyBpbnN0YW5jZW9mIHVkfHxKZChhLGMpKSl9LHlkPWZ1bmN0aW9uKGEsYixjLGQpe2lmKGEgaW5zdGFuY2VvZiBDKXJldHVybiBudWxsIT1iJiZEYShiLFwib3B0X29uRnVsZmlsbGVkIHNob3VsZCBiZSBhIGZ1bmN0aW9uLlwiKSxudWxsIT1jJiZEYShjLFwib3B0X29uUmVqZWN0ZWQgc2hvdWxkIGJlIGEgZnVuY3Rpb24uIERpZCB5b3UgcGFzcyBvcHRfY29udGV4dCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IGluc3RlYWQgb2YgdGhlIHRoaXJkP1wiKSxEZChhLHhkKGJ8fGRhLGN8fG51bGwsZCkpLCEwO2lmKHNkKGEpKXJldHVybiBhLnRoZW4oYixjLGQpLCEwO2lmKHEoYSkpdHJ5e3ZhciBlPWEudGhlbjtpZihwKGUpKXJldHVybiBLZChhLFxuZSxiLGMsZCksITB9Y2F0Y2goZil7cmV0dXJuIGMuY2FsbChkLGYpLCEwfXJldHVybiExfSxLZD1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPSExLGc9ZnVuY3Rpb24oYSl7Znx8KGY9ITAsYy5jYWxsKGUsYSkpfSxsPWZ1bmN0aW9uKGEpe2Z8fChmPSEwLGQuY2FsbChlLGEpKX07dHJ5e2IuY2FsbChhLGcsbCl9Y2F0Y2gobil7bChuKX19LElkPWZ1bmN0aW9uKGEpe2EucGR8fChhLnBkPSEwLGRkKGEuQmYsYSkpfSxHZD1mdW5jdGlvbihhKXt2YXIgYj1udWxsO2EudWEmJihiPWEudWEsYS51YT1iLm5leHQsYi5uZXh0PW51bGwpO2EudWF8fChhLmtiPW51bGwpO251bGwhPWImJncobnVsbCE9Yi5VYSk7cmV0dXJuIGJ9O0MucHJvdG90eXBlLkJmPWZ1bmN0aW9uKCl7Zm9yKHZhciBhO2E9R2QodGhpcyk7KUhkKHRoaXMsYSx0aGlzLmFhLHRoaXMuemEpO3RoaXMucGQ9ITF9O1xudmFyIEhkPWZ1bmN0aW9uKGEsYixjLGQpe2lmKDM9PWMmJmIudGImJiFiLkhiKWZvcig7YSYmYS51YzthPWEudylhLnVjPSExO2lmKGIuY2hpbGQpYi5jaGlsZC53PW51bGwsTGQoYixjLGQpO2Vsc2UgdHJ5e2IuSGI/Yi5VYS5jYWxsKGIuY29udGV4dCk6TGQoYixjLGQpfWNhdGNoKGUpe01kLmNhbGwobnVsbCxlKX13ZC5wdXQoYil9LExkPWZ1bmN0aW9uKGEsYixjKXsyPT1iP2EuVWEuY2FsbChhLmNvbnRleHQsYyk6YS50YiYmYS50Yi5jYWxsKGEuY29udGV4dCxjKX0sSmQ9ZnVuY3Rpb24oYSxiKXthLnVjPSEwO2RkKGZ1bmN0aW9uKCl7YS51YyYmTWQuY2FsbChudWxsLGIpfSl9LE1kPVVjLHVkPWZ1bmN0aW9uKGEpe3UuY2FsbCh0aGlzLGEpfTt0KHVkLHUpO3VkLnByb3RvdHlwZS5uYW1lPVwiY2FuY2VsXCI7LypcbiBQb3J0aW9ucyBvZiB0aGlzIGNvZGUgYXJlIGZyb20gTW9jaGlLaXQsIHJlY2VpdmVkIGJ5XG4gVGhlIENsb3N1cmUgQXV0aG9ycyB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIEFsbCBvdGhlciBjb2RlIGlzIENvcHlyaWdodFxuIDIwMDUtMjAwOSBUaGUgQ2xvc3VyZSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuKi9cbnZhciBOZD1mdW5jdGlvbihhLGIpe3RoaXMuUWM9W107dGhpcy5OZT1hO3RoaXMucmU9Ynx8bnVsbDt0aGlzLlBiPXRoaXMubmI9ITE7dGhpcy56YT12b2lkIDA7dGhpcy5iZT10aGlzLmhlPXRoaXMuZmQ9ITE7dGhpcy5ZYz0wO3RoaXMudz1udWxsO3RoaXMuZ2Q9MH07TmQucHJvdG90eXBlLmNhbmNlbD1mdW5jdGlvbihhKXtpZih0aGlzLm5iKXRoaXMuemEgaW5zdGFuY2VvZiBOZCYmdGhpcy56YS5jYW5jZWwoKTtlbHNle2lmKHRoaXMudyl7dmFyIGI9dGhpcy53O2RlbGV0ZSB0aGlzLnc7YT9iLmNhbmNlbChhKTooYi5nZC0tLDA+PWIuZ2QmJmIuY2FuY2VsKCkpfXRoaXMuTmU/dGhpcy5OZS5jYWxsKHRoaXMucmUsdGhpcyk6dGhpcy5iZT0hMDt0aGlzLm5ifHxPZCh0aGlzLG5ldyBQZCl9fTtOZC5wcm90b3R5cGUub2U9ZnVuY3Rpb24oYSxiKXt0aGlzLmZkPSExO1FkKHRoaXMsYSxiKX07XG52YXIgUWQ9ZnVuY3Rpb24oYSxiLGMpe2EubmI9ITA7YS56YT1jO2EuUGI9IWI7UmQoYSl9LFRkPWZ1bmN0aW9uKGEpe2lmKGEubmIpe2lmKCFhLmJlKXRocm93IG5ldyBTZDthLmJlPSExfX07TmQucHJvdG90eXBlLmNhbGxiYWNrPWZ1bmN0aW9uKGEpe1RkKHRoaXMpO1VkKGEpO1FkKHRoaXMsITAsYSl9O3ZhciBPZD1mdW5jdGlvbihhLGIpe1RkKGEpO1VkKGIpO1FkKGEsITEsYil9LFVkPWZ1bmN0aW9uKGEpe3coIShhIGluc3RhbmNlb2YgTmQpLFwiQW4gZXhlY3V0aW9uIHNlcXVlbmNlIG1heSBub3QgYmUgaW5pdGlhdGVkIHdpdGggYSBibG9ja2luZyBEZWZlcnJlZC5cIil9LFdkPWZ1bmN0aW9uKGEsYil7VmQoYSxudWxsLGIsdm9pZCAwKX0sVmQ9ZnVuY3Rpb24oYSxiLGMsZCl7dyghYS5oZSxcIkJsb2NraW5nIERlZmVycmVkcyBjYW4gbm90IGJlIHJlLXVzZWRcIik7YS5RYy5wdXNoKFtiLGMsZF0pO2EubmImJlJkKGEpfTtcbk5kLnByb3RvdHlwZS50aGVuPWZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGY9bmV3IEMoZnVuY3Rpb24oYSxiKXtkPWE7ZT1ifSk7VmQodGhpcyxkLGZ1bmN0aW9uKGEpe2EgaW5zdGFuY2VvZiBQZD9mLmNhbmNlbCgpOmUoYSl9KTtyZXR1cm4gZi50aGVuKGEsYixjKX07cmQoTmQpO1xudmFyIFhkPWZ1bmN0aW9uKGEpe3JldHVybiBTYShhLlFjLGZ1bmN0aW9uKGEpe3JldHVybiBwKGFbMV0pfSl9LFJkPWZ1bmN0aW9uKGEpe2lmKGEuWWMmJmEubmImJlhkKGEpKXt2YXIgYj1hLlljLGM9WWRbYl07YyYmKGsuY2xlYXJUaW1lb3V0KGMuUWIpLGRlbGV0ZSBZZFtiXSk7YS5ZYz0wfWEudyYmKGEudy5nZC0tLGRlbGV0ZSBhLncpO2I9YS56YTtmb3IodmFyIGQ9Yz0hMTthLlFjLmxlbmd0aCYmIWEuZmQ7KXt2YXIgZT1hLlFjLnNoaWZ0KCksZj1lWzBdLGc9ZVsxXTtlPWVbMl07aWYoZj1hLlBiP2c6Zil0cnl7dmFyIGw9Zi5jYWxsKGV8fGEucmUsYik7YmEobCkmJihhLlBiPWEuUGImJihsPT1ifHxsIGluc3RhbmNlb2YgRXJyb3IpLGEuemE9Yj1sKTtpZihzZChiKXx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGsuUHJvbWlzZSYmYiBpbnN0YW5jZW9mIGsuUHJvbWlzZSlkPSEwLGEuZmQ9ITB9Y2F0Y2gobil7Yj1uLGEuUGI9ITAsWGQoYSl8fChjPSEwKX19YS56YT1iO2QmJihsPXIoYS5vZSxcbmEsITApLGQ9cihhLm9lLGEsITEpLGIgaW5zdGFuY2VvZiBOZD8oVmQoYixsLGQpLGIuaGU9ITApOmIudGhlbihsLGQpKTtjJiYoYj1uZXcgWmQoYiksWWRbYi5RYl09YixhLlljPWIuUWIpfSxTZD1mdW5jdGlvbigpe3UuY2FsbCh0aGlzKX07dChTZCx1KTtTZC5wcm90b3R5cGUubWVzc2FnZT1cIkRlZmVycmVkIGhhcyBhbHJlYWR5IGZpcmVkXCI7U2QucHJvdG90eXBlLm5hbWU9XCJBbHJlYWR5Q2FsbGVkRXJyb3JcIjt2YXIgUGQ9ZnVuY3Rpb24oKXt1LmNhbGwodGhpcyl9O3QoUGQsdSk7UGQucHJvdG90eXBlLm1lc3NhZ2U9XCJEZWZlcnJlZCB3YXMgY2FuY2VsZWRcIjtQZC5wcm90b3R5cGUubmFtZT1cIkNhbmNlbGVkRXJyb3JcIjt2YXIgWmQ9ZnVuY3Rpb24oYSl7dGhpcy5RYj1rLnNldFRpbWVvdXQocih0aGlzLnlnLHRoaXMpLDApO3RoaXMuYmE9YX07XG5aZC5wcm90b3R5cGUueWc9ZnVuY3Rpb24oKXt3KFlkW3RoaXMuUWJdLFwiQ2Fubm90IHRocm93IGFuIGVycm9yIHRoYXQgaXMgbm90IHNjaGVkdWxlZC5cIik7ZGVsZXRlIFlkW3RoaXMuUWJdO3Rocm93IHRoaXMuYmE7fTt2YXIgWWQ9e307dmFyIGRlPWZ1bmN0aW9uKGEpe3ZhciBiPXt9LGM9Yi5kb2N1bWVudHx8ZG9jdW1lbnQsZD1LYShhKSxlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJTQ1JJUFRcIiksZj17V2U6ZSxpYzp2b2lkIDB9LGc9bmV3IE5kKCRkLGYpLGw9bnVsbCxuPW51bGwhPWIudGltZW91dD9iLnRpbWVvdXQ6NUUzOzA8biYmKGw9d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXthZShlLCEwKTtPZChnLG5ldyBiZSgxLFwiVGltZW91dCByZWFjaGVkIGZvciBsb2FkaW5nIHNjcmlwdCBcIitkKSl9LG4pLGYuaWM9bCk7ZS5vbmxvYWQ9ZS5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtlLnJlYWR5U3RhdGUmJlwibG9hZGVkXCIhPWUucmVhZHlTdGF0ZSYmXCJjb21wbGV0ZVwiIT1lLnJlYWR5U3RhdGV8fChhZShlLGIuUGd8fCExLGwpLGcuY2FsbGJhY2sobnVsbCkpfTtlLm9uZXJyb3I9ZnVuY3Rpb24oKXthZShlLCEwLGwpO09kKGcsbmV3IGJlKDAsXCJFcnJvciB3aGlsZSBsb2FkaW5nIHNjcmlwdCBcIitkKSl9O1xuZj1iLmF0dHJpYnV0ZXN8fHt9O21iKGYse3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIixjaGFyc2V0OlwiVVRGLThcIn0pO25kKGUsZik7a2QoZSxhKTtjZShjKS5hcHBlbmRDaGlsZChlKTtyZXR1cm4gZ30sY2U9ZnVuY3Rpb24oYSl7dmFyIGI7cmV0dXJuKGI9KGF8fGRvY3VtZW50KS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIkhFQURcIikpJiYwIT1iLmxlbmd0aD9iWzBdOmEuZG9jdW1lbnRFbGVtZW50fSwkZD1mdW5jdGlvbigpe2lmKHRoaXMmJnRoaXMuV2Upe3ZhciBhPXRoaXMuV2U7YSYmXCJTQ1JJUFRcIj09YS50YWdOYW1lJiZhZShhLCEwLHRoaXMuaWMpfX0sYWU9ZnVuY3Rpb24oYSxiLGMpe251bGwhPWMmJmsuY2xlYXJUaW1lb3V0KGMpO2Eub25sb2FkPWRhO2Eub25lcnJvcj1kYTthLm9ucmVhZHlzdGF0ZWNoYW5nZT1kYTtiJiZ3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe2EmJmEucGFyZW50Tm9kZSYmYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpfSwwKX0sYmU9ZnVuY3Rpb24oYSxcbmIpe3ZhciBjPVwiSnNsb2FkZXIgZXJyb3IgKGNvZGUgI1wiK2ErXCIpXCI7YiYmKGMrPVwiOiBcIitiKTt1LmNhbGwodGhpcyxjKTt0aGlzLmNvZGU9YX07dChiZSx1KTt2YXIgZWU9ZnVuY3Rpb24oYSxiLGMsZCxlKXt0aGlzLnJlc2V0KGEsYixjLGQsZSl9O2VlLnByb3RvdHlwZS50ZT1udWxsO3ZhciBmZT0wO2VlLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbihhLGIsYyxkLGUpe1wibnVtYmVyXCI9PXR5cGVvZiBlfHxmZSsrO2R8fG1hKCk7dGhpcy5WYj1hO2RlbGV0ZSB0aGlzLnRlfTtlZS5wcm90b3R5cGUuWGU9ZnVuY3Rpb24oYSl7dGhpcy5WYj1hfTt2YXIgZ2U9ZnVuY3Rpb24oYSl7dGhpcy5MZT1hO3RoaXMuQWU9dGhpcy5rZD10aGlzLlZiPXRoaXMudz1udWxsfSxoZT1mdW5jdGlvbihhLGIpe3RoaXMubmFtZT1hO3RoaXMudmFsdWU9Yn07aGUucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmFtZX07dmFyIGllPW5ldyBoZShcIlNFVkVSRVwiLDFFMyksamU9bmV3IGhlKFwiSU5GT1wiLDgwMCksa2U9bmV3IGhlKFwiQ09ORklHXCIsNzAwKSxsZT1uZXcgaGUoXCJGSU5FXCIsNTAwKTtnZS5wcm90b3R5cGUuZ2V0TmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLkxlfTtnZS5wcm90b3R5cGUuZ2V0UGFyZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMud307Z2UucHJvdG90eXBlLlhlPWZ1bmN0aW9uKGEpe3RoaXMuVmI9YX07dmFyIG1lPWZ1bmN0aW9uKGEpe2lmKGEuVmIpcmV0dXJuIGEuVmI7aWYoYS53KXJldHVybiBtZShhLncpO0FhKFwiUm9vdCBsb2dnZXIgaGFzIG5vIGxldmVsIHNldC5cIik7cmV0dXJuIG51bGx9O1xuZ2UucHJvdG90eXBlLmxvZz1mdW5jdGlvbihhLGIsYyl7aWYoYS52YWx1ZT49bWUodGhpcykudmFsdWUpZm9yKHAoYikmJihiPWIoKSksYT1uZXcgZWUoYSxTdHJpbmcoYiksdGhpcy5MZSksYyYmKGEudGU9YyksYz10aGlzO2M7KXt2YXIgZD1jLGU9YTtpZihkLkFlKWZvcih2YXIgZj0wO2I9ZC5BZVtmXTtmKyspYihlKTtjPWMuZ2V0UGFyZW50KCl9fTtnZS5wcm90b3R5cGUuaW5mbz1mdW5jdGlvbihhLGIpe3RoaXMubG9nKGplLGEsYil9O2dlLnByb3RvdHlwZS5jb25maWc9ZnVuY3Rpb24oYSxiKXt0aGlzLmxvZyhrZSxhLGIpfTtcbnZhciBuZT17fSxvZT1udWxsLHBlPWZ1bmN0aW9uKGEpe29lfHwob2U9bmV3IGdlKFwiXCIpLG5lW1wiXCJdPW9lLG9lLlhlKGtlKSk7dmFyIGI7aWYoIShiPW5lW2FdKSl7Yj1uZXcgZ2UoYSk7dmFyIGM9YS5sYXN0SW5kZXhPZihcIi5cIiksZD1hLnN1YnN0cihjKzEpO2M9cGUoYS5zdWJzdHIoMCxjKSk7Yy5rZHx8KGMua2Q9e30pO2Mua2RbZF09YjtiLnc9YztuZVthXT1ifXJldHVybiBifTt2YXIgRz1mdW5jdGlvbigpe1ViLmNhbGwodGhpcyk7dGhpcy5nYT1uZXcgZGModGhpcyk7dGhpcy5uZj10aGlzO3RoaXMuS2Q9bnVsbH07dChHLFViKTtHLnByb3RvdHlwZVskYl09ITA7aD1HLnByb3RvdHlwZTtoLmFkZEV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oYSxiLGMsZCl7bGModGhpcyxhLGIsYyxkKX07aC5yZW1vdmVFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGEsYixjLGQpe3RjKHRoaXMsYSxiLGMsZCl9O1xuaC5kaXNwYXRjaEV2ZW50PWZ1bmN0aW9uKGEpe3FlKHRoaXMpO3ZhciBiPXRoaXMuS2Q7aWYoYil7dmFyIGM9W107Zm9yKHZhciBkPTE7YjtiPWIuS2QpYy5wdXNoKGIpLHcoMUUzPisrZCxcImluZmluaXRlIGxvb3BcIil9Yj10aGlzLm5mO2Q9YS50eXBlfHxhO2lmKG0oYSkpYT1uZXcgQihhLGIpO2Vsc2UgaWYoYSBpbnN0YW5jZW9mIEIpYS50YXJnZXQ9YS50YXJnZXR8fGI7ZWxzZXt2YXIgZT1hO2E9bmV3IEIoZCxiKTttYihhLGUpfWU9ITA7aWYoYylmb3IodmFyIGY9Yy5sZW5ndGgtMTshYS5XYSYmMDw9ZjtmLS0pe3ZhciBnPWEuY3VycmVudFRhcmdldD1jW2ZdO2U9cmUoZyxkLCEwLGEpJiZlfWEuV2F8fChnPWEuY3VycmVudFRhcmdldD1iLGU9cmUoZyxkLCEwLGEpJiZlLGEuV2F8fChlPXJlKGcsZCwhMSxhKSYmZSkpO2lmKGMpZm9yKGY9MDshYS5XYSYmZjxjLmxlbmd0aDtmKyspZz1hLmN1cnJlbnRUYXJnZXQ9Y1tmXSxlPXJlKGcsZCwhMSxhKSYmZTtyZXR1cm4gZX07XG5oLmxiPWZ1bmN0aW9uKCl7Ry5VYy5sYi5jYWxsKHRoaXMpO2lmKHRoaXMuZ2Epe3ZhciBhPXRoaXMuZ2EsYj0wLGM7Zm9yKGMgaW4gYS5JKXtmb3IodmFyIGQ9YS5JW2NdLGU9MDtlPGQubGVuZ3RoO2UrKykrK2IsY2MoZFtlXSk7ZGVsZXRlIGEuSVtjXTthLmpjLS19fXRoaXMuS2Q9bnVsbH07aC5saXN0ZW49ZnVuY3Rpb24oYSxiLGMsZCl7cWUodGhpcyk7cmV0dXJuIHRoaXMuZ2EuYWRkKFN0cmluZyhhKSxiLCExLGMsZCl9O1xudmFyIHNjPWZ1bmN0aW9uKGEsYixjLGQsZSl7YS5nYS5hZGQoU3RyaW5nKGIpLGMsITAsZCxlKX0scmU9ZnVuY3Rpb24oYSxiLGMsZCl7Yj1hLmdhLklbU3RyaW5nKGIpXTtpZighYilyZXR1cm4hMDtiPWIuY29uY2F0KCk7Zm9yKHZhciBlPSEwLGY9MDtmPGIubGVuZ3RoOysrZil7dmFyIGc9YltmXTtpZihnJiYhZy5CYiYmZy5jYXB0dXJlPT1jKXt2YXIgbD1nLmxpc3RlbmVyLG49Zy52Y3x8Zy5zcmM7Zy5wYyYmZmMoYS5nYSxnKTtlPSExIT09bC5jYWxsKG4sZCkmJmV9fXJldHVybiBlJiYwIT1kLlVlfTtHLnByb3RvdHlwZS50ZD1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5nYS50ZChTdHJpbmcoYSksYixjLGQpfTtHLnByb3RvdHlwZS5oYXNMaXN0ZW5lcj1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmdhLmhhc0xpc3RlbmVyKGJhKGEpP1N0cmluZyhhKTp2b2lkIDAsYil9O3ZhciBxZT1mdW5jdGlvbihhKXt3KGEuZ2EsXCJFdmVudCB0YXJnZXQgaXMgbm90IGluaXRpYWxpemVkLiBEaWQgeW91IGNhbGwgdGhlIHN1cGVyY2xhc3MgKGdvb2cuZXZlbnRzLkV2ZW50VGFyZ2V0KSBjb25zdHJ1Y3Rvcj9cIil9O3ZhciBzZT1cIlN0b3BJdGVyYXRpb25cImluIGs/ay5TdG9wSXRlcmF0aW9uOnttZXNzYWdlOlwiU3RvcEl0ZXJhdGlvblwiLHN0YWNrOlwiXCJ9LHRlPWZ1bmN0aW9uKCl7fTt0ZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3Rocm93IHNlO307dGUucHJvdG90eXBlLm1mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O3ZhciBIPWZ1bmN0aW9uKGEsYil7YSYmYS5sb2cobGUsYix2b2lkIDApfTt2YXIgdWU9ZnVuY3Rpb24oYSxiKXt0aGlzLmphPXt9O3RoaXMuQz1bXTt0aGlzLmdiPXRoaXMudT0wO3ZhciBjPWFyZ3VtZW50cy5sZW5ndGg7aWYoMTxjKXtpZihjJTIpdGhyb3cgRXJyb3IoXCJVbmV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50c1wiKTtmb3IodmFyIGQ9MDtkPGM7ZCs9Mil0aGlzLnNldChhcmd1bWVudHNbZF0sYXJndW1lbnRzW2QrMV0pfWVsc2UgYSYmdGhpcy5hZGRBbGwoYSl9O2g9dWUucHJvdG90eXBlO2guaGE9ZnVuY3Rpb24oKXt2ZSh0aGlzKTtmb3IodmFyIGE9W10sYj0wO2I8dGhpcy5DLmxlbmd0aDtiKyspYS5wdXNoKHRoaXMuamFbdGhpcy5DW2JdXSk7cmV0dXJuIGF9O2gudmE9ZnVuY3Rpb24oKXt2ZSh0aGlzKTtyZXR1cm4gdGhpcy5DLmNvbmNhdCgpfTtoLkpiPWZ1bmN0aW9uKGEpe3JldHVybiB3ZSh0aGlzLmphLGEpfTtoLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5qYT17fTt0aGlzLmdiPXRoaXMudT10aGlzLkMubGVuZ3RoPTB9O1xuaC5yZW1vdmU9ZnVuY3Rpb24oYSl7cmV0dXJuIHdlKHRoaXMuamEsYSk/KGRlbGV0ZSB0aGlzLmphW2FdLHRoaXMudS0tLHRoaXMuZ2IrKyx0aGlzLkMubGVuZ3RoPjIqdGhpcy51JiZ2ZSh0aGlzKSwhMCk6ITF9O3ZhciB2ZT1mdW5jdGlvbihhKXtpZihhLnUhPWEuQy5sZW5ndGgpe2Zvcih2YXIgYj0wLGM9MDtiPGEuQy5sZW5ndGg7KXt2YXIgZD1hLkNbYl07d2UoYS5qYSxkKSYmKGEuQ1tjKytdPWQpO2IrK31hLkMubGVuZ3RoPWN9aWYoYS51IT1hLkMubGVuZ3RoKXt2YXIgZT17fTtmb3IoYz1iPTA7YjxhLkMubGVuZ3RoOylkPWEuQ1tiXSx3ZShlLGQpfHwoYS5DW2MrK109ZCxlW2RdPTEpLGIrKzthLkMubGVuZ3RoPWN9fTtoPXVlLnByb3RvdHlwZTtoLmdldD1mdW5jdGlvbihhLGIpe3JldHVybiB3ZSh0aGlzLmphLGEpP3RoaXMuamFbYV06Yn07XG5oLnNldD1mdW5jdGlvbihhLGIpe3dlKHRoaXMuamEsYSl8fCh0aGlzLnUrKyx0aGlzLkMucHVzaChhKSx0aGlzLmdiKyspO3RoaXMuamFbYV09Yn07aC5hZGRBbGw9ZnVuY3Rpb24oYSl7aWYoYSBpbnN0YW5jZW9mIHVlKXt2YXIgYj1hLnZhKCk7YT1hLmhhKCl9ZWxzZSBiPWhiKGEpLGE9Z2IoYSk7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aDtjKyspdGhpcy5zZXQoYltjXSxhW2NdKX07aC5mb3JFYWNoPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPXRoaXMudmEoKSxkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF0sZj10aGlzLmdldChlKTthLmNhbGwoYixmLGUsdGhpcyl9fTtoLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB1ZSh0aGlzKX07XG5oLm1mPWZ1bmN0aW9uKGEpe3ZlKHRoaXMpO3ZhciBiPTAsYz10aGlzLmdiLGQ9dGhpcyxlPW5ldyB0ZTtlLm5leHQ9ZnVuY3Rpb24oKXtpZihjIT1kLmdiKXRocm93IEVycm9yKFwiVGhlIG1hcCBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgaXRlcmF0b3Igd2FzIGNyZWF0ZWRcIik7aWYoYj49ZC5DLmxlbmd0aCl0aHJvdyBzZTt2YXIgZT1kLkNbYisrXTtyZXR1cm4gYT9lOmQuamFbZV19O3JldHVybiBlfTt2YXIgd2U9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsYil9O3ZhciB4ZT1mdW5jdGlvbihhKXtpZihhLmhhJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLmhhKXJldHVybiBhLmhhKCk7aWYobShhKSlyZXR1cm4gYS5zcGxpdChcIlwiKTtpZihpYShhKSl7Zm9yKHZhciBiPVtdLGM9YS5sZW5ndGgsZD0wO2Q8YztkKyspYi5wdXNoKGFbZF0pO3JldHVybiBifXJldHVybiBnYihhKX0seWU9ZnVuY3Rpb24oYSl7aWYoYS52YSYmXCJmdW5jdGlvblwiPT10eXBlb2YgYS52YSlyZXR1cm4gYS52YSgpO2lmKCFhLmhhfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBhLmhhKXtpZihpYShhKXx8bShhKSl7dmFyIGI9W107YT1hLmxlbmd0aDtmb3IodmFyIGM9MDtjPGE7YysrKWIucHVzaChjKTtyZXR1cm4gYn1yZXR1cm4gaGIoYSl9fSx6ZT1mdW5jdGlvbihhLGIsYyl7aWYoYS5mb3JFYWNoJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLmZvckVhY2gpYS5mb3JFYWNoKGIsYyk7ZWxzZSBpZihpYShhKXx8bShhKSl4KGEsYixjKTtlbHNlIGZvcih2YXIgZD15ZShhKSxlPXhlKGEpLGY9ZS5sZW5ndGgsXG5nPTA7ZzxmO2crKyliLmNhbGwoYyxlW2ddLGQmJmRbZ10sYSl9O3ZhciBBZT1mdW5jdGlvbihhLGIsYyl7aWYocChhKSljJiYoYT1yKGEsYykpO2Vsc2UgaWYoYSYmXCJmdW5jdGlvblwiPT10eXBlb2YgYS5oYW5kbGVFdmVudClhPXIoYS5oYW5kbGVFdmVudCxhKTtlbHNlIHRocm93IEVycm9yKFwiSW52YWxpZCBsaXN0ZW5lciBhcmd1bWVudFwiKTtyZXR1cm4gMjE0NzQ4MzY0NzxOdW1iZXIoYik/LTE6ay5zZXRUaW1lb3V0KGEsYnx8MCl9LEJlPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7cmV0dXJuKG5ldyBDKGZ1bmN0aW9uKGMsZCl7Yj1BZShmdW5jdGlvbigpe2Modm9pZCAwKX0sYSk7LTE9PWImJmQoRXJyb3IoXCJGYWlsZWQgdG8gc2NoZWR1bGUgdGltZXIuXCIpKX0pKS5nKGZ1bmN0aW9uKGEpe2suY2xlYXJUaW1lb3V0KGIpO3Rocm93IGE7fSl9O3ZhciBDZT0vXig/OihbXjovPyMuXSspOik/KD86XFwvXFwvKD86KFteLz8jXSopQCk/KFteLyM/XSo/KSg/OjooWzAtOV0rKSk/KD89Wy8jP118JCkpPyhbXj8jXSspPyg/OlxcPyhbXiNdKikpPyg/OiMoW1xcc1xcU10qKSk/JC8sRGU9ZnVuY3Rpb24oYSxiKXtpZihhKXthPWEuc3BsaXQoXCImXCIpO2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD1hW2NdLmluZGV4T2YoXCI9XCIpLGU9bnVsbDtpZigwPD1kKXt2YXIgZj1hW2NdLnN1YnN0cmluZygwLGQpO2U9YVtjXS5zdWJzdHJpbmcoZCsxKX1lbHNlIGY9YVtjXTtiKGYsZT9kZWNvZGVVUklDb21wb25lbnQoZS5yZXBsYWNlKC9cXCsvZyxcIiBcIikpOlwiXCIpfX19O3ZhciBJPWZ1bmN0aW9uKGEpe0cuY2FsbCh0aGlzKTt0aGlzLmhlYWRlcnM9bmV3IHVlO3RoaXMuZGQ9YXx8bnVsbDt0aGlzLkNhPSExO3RoaXMuY2Q9dGhpcy5iPW51bGw7dGhpcy5VYj10aGlzLktlPXRoaXMuRWM9XCJcIjt0aGlzLlFhPXRoaXMuemQ9dGhpcy56Yz10aGlzLm9kPSExO3RoaXMuRGI9MDt0aGlzLlZjPW51bGw7dGhpcy5PYz1cIlwiO3RoaXMuWmM9dGhpcy5oZz10aGlzLmdmPSExfTt0KEksRyk7dmFyIEVlPUkucHJvdG90eXBlLEZlPXBlKFwiZ29vZy5uZXQuWGhySW9cIik7RWUuVD1GZTt2YXIgR2U9L15odHRwcz8kL2ksSGU9W1wiUE9TVFwiLFwiUFVUXCJdO1xuSS5wcm90b3R5cGUuc2VuZD1mdW5jdGlvbihhLGIsYyxkKXtpZih0aGlzLmIpdGhyb3cgRXJyb3IoXCJbZ29vZy5uZXQuWGhySW9dIE9iamVjdCBpcyBhY3RpdmUgd2l0aCBhbm90aGVyIHJlcXVlc3Q9XCIrdGhpcy5FYytcIjsgbmV3VXJpPVwiK2EpO2I9Yj9iLnRvVXBwZXJDYXNlKCk6XCJHRVRcIjt0aGlzLkVjPWE7dGhpcy5VYj1cIlwiO3RoaXMuS2U9Yjt0aGlzLm9kPSExO3RoaXMuQ2E9ITA7dGhpcy5iPXRoaXMuZGQ/dGhpcy5kZC5yYygpOk5jLnJjKCk7dGhpcy5jZD10aGlzLmRkP01jKHRoaXMuZGQpOk1jKE5jKTt0aGlzLmIub25yZWFkeXN0YXRlY2hhbmdlPXIodGhpcy5SZSx0aGlzKTt0aGlzLmhnJiZcIm9ucHJvZ3Jlc3NcImluIHRoaXMuYiYmKHRoaXMuYi5vbnByb2dyZXNzPXIoZnVuY3Rpb24oYSl7dGhpcy5RZShhLCEwKX0sdGhpcyksdGhpcy5iLnVwbG9hZCYmKHRoaXMuYi51cGxvYWQub25wcm9ncmVzcz1yKHRoaXMuUWUsdGhpcykpKTt0cnl7SCh0aGlzLlQsSWUodGhpcyxcIk9wZW5pbmcgWGhyXCIpKSxcbnRoaXMuemQ9ITAsdGhpcy5iLm9wZW4oYixTdHJpbmcoYSksITApLHRoaXMuemQ9ITF9Y2F0Y2goZil7SCh0aGlzLlQsSWUodGhpcyxcIkVycm9yIG9wZW5pbmcgWGhyOiBcIitmLm1lc3NhZ2UpKTt0aGlzLmJhKDUsZik7cmV0dXJufWE9Y3x8XCJcIjt2YXIgZT10aGlzLmhlYWRlcnMuY2xvbmUoKTtkJiZ6ZShkLGZ1bmN0aW9uKGEsYil7ZS5zZXQoYixhKX0pO2Q9VWEoZS52YSgpKTtjPWsuRm9ybURhdGEmJmEgaW5zdGFuY2VvZiBrLkZvcm1EYXRhOyFWYShIZSxiKXx8ZHx8Y3x8ZS5zZXQoXCJDb250ZW50LVR5cGVcIixcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04XCIpO2UuZm9yRWFjaChmdW5jdGlvbihhLGIpe3RoaXMuYi5zZXRSZXF1ZXN0SGVhZGVyKGIsYSl9LHRoaXMpO3RoaXMuT2MmJih0aGlzLmIucmVzcG9uc2VUeXBlPXRoaXMuT2MpO1wid2l0aENyZWRlbnRpYWxzXCJpbiB0aGlzLmImJnRoaXMuYi53aXRoQ3JlZGVudGlhbHMhPT10aGlzLmdmJiZcbih0aGlzLmIud2l0aENyZWRlbnRpYWxzPXRoaXMuZ2YpO3RyeXtKZSh0aGlzKSwwPHRoaXMuRGImJih0aGlzLlpjPUtlKHRoaXMuYiksSCh0aGlzLlQsSWUodGhpcyxcIldpbGwgYWJvcnQgYWZ0ZXIgXCIrdGhpcy5EYitcIm1zIGlmIGluY29tcGxldGUsIHhocjIgXCIrdGhpcy5aYykpLHRoaXMuWmM/KHRoaXMuYi50aW1lb3V0PXRoaXMuRGIsdGhpcy5iLm9udGltZW91dD1yKHRoaXMuaWMsdGhpcykpOnRoaXMuVmM9QWUodGhpcy5pYyx0aGlzLkRiLHRoaXMpKSxIKHRoaXMuVCxJZSh0aGlzLFwiU2VuZGluZyByZXF1ZXN0XCIpKSx0aGlzLnpjPSEwLHRoaXMuYi5zZW5kKGEpLHRoaXMuemM9ITF9Y2F0Y2goZil7SCh0aGlzLlQsSWUodGhpcyxcIlNlbmQgZXJyb3I6IFwiK2YubWVzc2FnZSkpLHRoaXMuYmEoNSxmKX19O1xudmFyIEtlPWZ1bmN0aW9uKGEpe3JldHVybiB6JiZBKDkpJiZcIm51bWJlclwiPT10eXBlb2YgYS50aW1lb3V0JiZiYShhLm9udGltZW91dCl9LFRhPWZ1bmN0aW9uKGEpe3JldHVyblwiY29udGVudC10eXBlXCI9PWEudG9Mb3dlckNhc2UoKX07SS5wcm90b3R5cGUuaWM9ZnVuY3Rpb24oKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgYWEmJnRoaXMuYiYmKHRoaXMuVWI9XCJUaW1lZCBvdXQgYWZ0ZXIgXCIrdGhpcy5EYitcIm1zLCBhYm9ydGluZ1wiLEgodGhpcy5ULEllKHRoaXMsdGhpcy5VYikpLHRoaXMuZGlzcGF0Y2hFdmVudChcInRpbWVvdXRcIiksdGhpcy5hYm9ydCg4KSl9O0kucHJvdG90eXBlLmJhPWZ1bmN0aW9uKGEsYil7dGhpcy5DYT0hMTt0aGlzLmImJih0aGlzLlFhPSEwLHRoaXMuYi5hYm9ydCgpLHRoaXMuUWE9ITEpO3RoaXMuVWI9YjtMZSh0aGlzKTtNZSh0aGlzKX07dmFyIExlPWZ1bmN0aW9uKGEpe2Eub2R8fChhLm9kPSEwLGEuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpLGEuZGlzcGF0Y2hFdmVudChcImVycm9yXCIpKX07XG5JLnByb3RvdHlwZS5hYm9ydD1mdW5jdGlvbigpe3RoaXMuYiYmdGhpcy5DYSYmKEgodGhpcy5ULEllKHRoaXMsXCJBYm9ydGluZ1wiKSksdGhpcy5DYT0hMSx0aGlzLlFhPSEwLHRoaXMuYi5hYm9ydCgpLHRoaXMuUWE9ITEsdGhpcy5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIiksdGhpcy5kaXNwYXRjaEV2ZW50KFwiYWJvcnRcIiksTWUodGhpcykpfTtJLnByb3RvdHlwZS5sYj1mdW5jdGlvbigpe3RoaXMuYiYmKHRoaXMuQ2EmJih0aGlzLkNhPSExLHRoaXMuUWE9ITAsdGhpcy5iLmFib3J0KCksdGhpcy5RYT0hMSksTWUodGhpcywhMCkpO0kuVWMubGIuY2FsbCh0aGlzKX07SS5wcm90b3R5cGUuUmU9ZnVuY3Rpb24oKXt0aGlzLmlzRGlzcG9zZWQoKXx8KHRoaXMuemR8fHRoaXMuemN8fHRoaXMuUWE/TmUodGhpcyk6dGhpcy5kZygpKX07SS5wcm90b3R5cGUuZGc9ZnVuY3Rpb24oKXtOZSh0aGlzKX07XG52YXIgTmU9ZnVuY3Rpb24oYSl7aWYoYS5DYSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGFhKWlmKGEuY2RbMV0mJjQ9PU9lKGEpJiYyPT1QZShhKSlIKGEuVCxJZShhLFwiTG9jYWwgcmVxdWVzdCBlcnJvciBkZXRlY3RlZCBhbmQgaWdub3JlZFwiKSk7ZWxzZSBpZihhLnpjJiY0PT1PZShhKSlBZShhLlJlLDAsYSk7ZWxzZSBpZihhLmRpc3BhdGNoRXZlbnQoXCJyZWFkeXN0YXRlY2hhbmdlXCIpLDQ9PU9lKGEpKXtIKGEuVCxJZShhLFwiUmVxdWVzdCBjb21wbGV0ZVwiKSk7YS5DYT0hMTt0cnl7dmFyIGI9UGUoYSk7YTpzd2l0Y2goYil7Y2FzZSAyMDA6Y2FzZSAyMDE6Y2FzZSAyMDI6Y2FzZSAyMDQ6Y2FzZSAyMDY6Y2FzZSAzMDQ6Y2FzZSAxMjIzOnZhciBjPSEwO2JyZWFrIGE7ZGVmYXVsdDpjPSExfXZhciBkO2lmKCEoZD1jKSl7dmFyIGU7aWYoZT0wPT09Yil7dmFyIGY9U3RyaW5nKGEuRWMpLm1hdGNoKENlKVsxXXx8bnVsbDtpZighZiYmay5zZWxmJiZrLnNlbGYubG9jYXRpb24pe3ZhciBnPVxuay5zZWxmLmxvY2F0aW9uLnByb3RvY29sO2Y9Zy5zdWJzdHIoMCxnLmxlbmd0aC0xKX1lPSFHZS50ZXN0KGY/Zi50b0xvd2VyQ2FzZSgpOlwiXCIpfWQ9ZX1pZihkKWEuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpLGEuZGlzcGF0Y2hFdmVudChcInN1Y2Nlc3NcIik7ZWxzZXt0cnl7dmFyIGw9MjxPZShhKT9hLmIuc3RhdHVzVGV4dDpcIlwifWNhdGNoKG4pe0goYS5ULFwiQ2FuIG5vdCBnZXQgc3RhdHVzOiBcIituLm1lc3NhZ2UpLGw9XCJcIn1hLlViPWwrXCIgW1wiK1BlKGEpK1wiXVwiO0xlKGEpfX1maW5hbGx5e01lKGEpfX19O0kucHJvdG90eXBlLlFlPWZ1bmN0aW9uKGEsYil7dyhcInByb2dyZXNzXCI9PT1hLnR5cGUsXCJnb29nLm5ldC5FdmVudFR5cGUuUFJPR1JFU1MgaXMgb2YgdGhlIHNhbWUgdHlwZSBhcyByYXcgWEhSIHByb2dyZXNzLlwiKTt0aGlzLmRpc3BhdGNoRXZlbnQoUWUoYSxcInByb2dyZXNzXCIpKTt0aGlzLmRpc3BhdGNoRXZlbnQoUWUoYSxiP1wiZG93bmxvYWRwcm9ncmVzc1wiOlwidXBsb2FkcHJvZ3Jlc3NcIikpfTtcbnZhciBRZT1mdW5jdGlvbihhLGIpe3JldHVybnt0eXBlOmIsbGVuZ3RoQ29tcHV0YWJsZTphLmxlbmd0aENvbXB1dGFibGUsbG9hZGVkOmEubG9hZGVkLHRvdGFsOmEudG90YWx9fSxNZT1mdW5jdGlvbihhLGIpe2lmKGEuYil7SmUoYSk7dmFyIGM9YS5iLGQ9YS5jZFswXT9kYTpudWxsO2EuYj1udWxsO2EuY2Q9bnVsbDtifHxhLmRpc3BhdGNoRXZlbnQoXCJyZWFkeVwiKTt0cnl7Yy5vbnJlYWR5c3RhdGVjaGFuZ2U9ZH1jYXRjaChlKXsoYT1hLlQpJiZhLmxvZyhpZSxcIlByb2JsZW0gZW5jb3VudGVyZWQgcmVzZXR0aW5nIG9ucmVhZHlzdGF0ZWNoYW5nZTogXCIrZS5tZXNzYWdlLHZvaWQgMCl9fX0sSmU9ZnVuY3Rpb24oYSl7YS5iJiZhLlpjJiYoYS5iLm9udGltZW91dD1udWxsKTthLlZjJiYoay5jbGVhclRpbWVvdXQoYS5WYyksYS5WYz1udWxsKX0sT2U9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuYj9hLmIucmVhZHlTdGF0ZTowfSxQZT1mdW5jdGlvbihhKXt0cnl7cmV0dXJuIDI8T2UoYSk/XG5hLmIuc3RhdHVzOi0xfWNhdGNoKGIpe3JldHVybi0xfX0sUmU9ZnVuY3Rpb24oYSl7dHJ5e3JldHVybiBhLmI/YS5iLnJlc3BvbnNlVGV4dDpcIlwifWNhdGNoKGIpe3JldHVybiBIKGEuVCxcIkNhbiBub3QgZ2V0IHJlc3BvbnNlVGV4dDogXCIrYi5tZXNzYWdlKSxcIlwifX07XG5JLnByb3RvdHlwZS5nZXRSZXNwb25zZT1mdW5jdGlvbigpe3RyeXtpZighdGhpcy5iKXJldHVybiBudWxsO2lmKFwicmVzcG9uc2VcImluIHRoaXMuYilyZXR1cm4gdGhpcy5iLnJlc3BvbnNlO3N3aXRjaCh0aGlzLk9jKXtjYXNlIFwiXCI6Y2FzZSBcInRleHRcIjpyZXR1cm4gdGhpcy5iLnJlc3BvbnNlVGV4dDtjYXNlIFwiYXJyYXlidWZmZXJcIjppZihcIm1velJlc3BvbnNlQXJyYXlCdWZmZXJcImluIHRoaXMuYilyZXR1cm4gdGhpcy5iLm1velJlc3BvbnNlQXJyYXlCdWZmZXJ9dmFyIGE9dGhpcy5UO2EmJmEubG9nKGllLFwiUmVzcG9uc2UgdHlwZSBcIit0aGlzLk9jK1wiIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyXCIsdm9pZCAwKTtyZXR1cm4gbnVsbH1jYXRjaChiKXtyZXR1cm4gSCh0aGlzLlQsXCJDYW4gbm90IGdldCByZXNwb25zZTogXCIrYi5tZXNzYWdlKSxudWxsfX07XG5JLnByb3RvdHlwZS5nZXRSZXNwb25zZUhlYWRlcj1mdW5jdGlvbihhKXtpZih0aGlzLmImJjQ9PU9lKHRoaXMpKXJldHVybiBhPXRoaXMuYi5nZXRSZXNwb25zZUhlYWRlcihhKSxudWxsPT09YT92b2lkIDA6YX07SS5wcm90b3R5cGUuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYiYmND09T2UodGhpcyk/dGhpcy5iLmdldEFsbFJlc3BvbnNlSGVhZGVycygpOlwiXCJ9O3ZhciBJZT1mdW5jdGlvbihhLGIpe3JldHVybiBiK1wiIFtcIithLktlK1wiIFwiK2EuRWMrXCIgXCIrUGUoYSkrXCJdXCJ9O3ZhciBTZT1mdW5jdGlvbihhLGIpe3RoaXMucGE9dGhpcy5lYj10aGlzLnFhPVwiXCI7dGhpcy52Yj1udWxsO3RoaXMuUGE9dGhpcy5HYT1cIlwiO3RoaXMuZGE9dGhpcy5YZj0hMTtpZihhIGluc3RhbmNlb2YgU2Upe3RoaXMuZGE9YmEoYik/YjphLmRhO1RlKHRoaXMsYS5xYSk7dmFyIGM9YS5lYjtKKHRoaXMpO3RoaXMuZWI9YztVZSh0aGlzLGEucGEpO1ZlKHRoaXMsYS52Yik7V2UodGhpcyxhLkdhKTtYZSh0aGlzLGEuZWEuY2xvbmUoKSk7YT1hLlBhO0oodGhpcyk7dGhpcy5QYT1hfWVsc2UgYSYmKGM9U3RyaW5nKGEpLm1hdGNoKENlKSk/KHRoaXMuZGE9ISFiLFRlKHRoaXMsY1sxXXx8XCJcIiwhMCksYT1jWzJdfHxcIlwiLEoodGhpcyksdGhpcy5lYj1ZZShhKSxVZSh0aGlzLGNbM118fFwiXCIsITApLFZlKHRoaXMsY1s0XSksV2UodGhpcyxjWzVdfHxcIlwiLCEwKSxYZSh0aGlzLGNbNl18fFwiXCIsITApLGE9Y1s3XXx8XCJcIixKKHRoaXMpLHRoaXMuUGE9WWUoYSkpOih0aGlzLmRhPSEhYix0aGlzLmVhPVxubmV3IFplKG51bGwsMCx0aGlzLmRhKSl9O1NlLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPVtdLGI9dGhpcy5xYTtiJiZhLnB1c2goJGUoYixhZiwhMCksXCI6XCIpO3ZhciBjPXRoaXMucGE7aWYoY3x8XCJmaWxlXCI9PWIpYS5wdXNoKFwiLy9cIiksKGI9dGhpcy5lYikmJmEucHVzaCgkZShiLGFmLCEwKSxcIkBcIiksYS5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYykpLnJlcGxhY2UoLyUyNShbMC05YS1mQS1GXXsyfSkvZyxcIiUkMVwiKSksYz10aGlzLnZiLG51bGwhPWMmJmEucHVzaChcIjpcIixTdHJpbmcoYykpO2lmKGM9dGhpcy5HYSl0aGlzLnBhJiZcIi9cIiE9Yy5jaGFyQXQoMCkmJmEucHVzaChcIi9cIiksYS5wdXNoKCRlKGMsXCIvXCI9PWMuY2hhckF0KDApP2JmOmNmLCEwKSk7KGM9dGhpcy5lYS50b1N0cmluZygpKSYmYS5wdXNoKFwiP1wiLGMpOyhjPXRoaXMuUGEpJiZhLnB1c2goXCIjXCIsJGUoYyxkZikpO3JldHVybiBhLmpvaW4oXCJcIil9O1xuU2UucHJvdG90eXBlLnJlc29sdmU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jbG9uZSgpLGM9ISFhLnFhO2M/VGUoYixhLnFhKTpjPSEhYS5lYjtpZihjKXt2YXIgZD1hLmViO0ooYik7Yi5lYj1kfWVsc2UgYz0hIWEucGE7Yz9VZShiLGEucGEpOmM9bnVsbCE9YS52YjtkPWEuR2E7aWYoYylWZShiLGEudmIpO2Vsc2UgaWYoYz0hIWEuR2Epe2lmKFwiL1wiIT1kLmNoYXJBdCgwKSlpZih0aGlzLnBhJiYhdGhpcy5HYSlkPVwiL1wiK2Q7ZWxzZXt2YXIgZT1iLkdhLmxhc3RJbmRleE9mKFwiL1wiKTstMSE9ZSYmKGQ9Yi5HYS5zdWJzdHIoMCxlKzEpK2QpfWU9ZDtpZihcIi4uXCI9PWV8fFwiLlwiPT1lKWQ9XCJcIjtlbHNlIGlmKHYoZSxcIi4vXCIpfHx2KGUsXCIvLlwiKSl7ZD0wPT1lLmxhc3RJbmRleE9mKFwiL1wiLDApO2U9ZS5zcGxpdChcIi9cIik7Zm9yKHZhciBmPVtdLGc9MDtnPGUubGVuZ3RoOyl7dmFyIGw9ZVtnKytdO1wiLlwiPT1sP2QmJmc9PWUubGVuZ3RoJiZmLnB1c2goXCJcIik6XCIuLlwiPT1sPygoMTxmLmxlbmd0aHx8XG4xPT1mLmxlbmd0aCYmXCJcIiE9ZlswXSkmJmYucG9wKCksZCYmZz09ZS5sZW5ndGgmJmYucHVzaChcIlwiKSk6KGYucHVzaChsKSxkPSEwKX1kPWYuam9pbihcIi9cIil9ZWxzZSBkPWV9Yz9XZShiLGQpOmM9XCJcIiE9PWEuZWEudG9TdHJpbmcoKTtjP1hlKGIsYS5lYS5jbG9uZSgpKTpjPSEhYS5QYTtjJiYoYT1hLlBhLEooYiksYi5QYT1hKTtyZXR1cm4gYn07U2UucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTZSh0aGlzKX07XG52YXIgVGU9ZnVuY3Rpb24oYSxiLGMpe0ooYSk7YS5xYT1jP1llKGIsITApOmI7YS5xYSYmKGEucWE9YS5xYS5yZXBsYWNlKC86JC8sXCJcIikpfSxVZT1mdW5jdGlvbihhLGIsYyl7SihhKTthLnBhPWM/WWUoYiwhMCk6Yn0sVmU9ZnVuY3Rpb24oYSxiKXtKKGEpO2lmKGIpe2I9TnVtYmVyKGIpO2lmKGlzTmFOKGIpfHwwPmIpdGhyb3cgRXJyb3IoXCJCYWQgcG9ydCBudW1iZXIgXCIrYik7YS52Yj1ifWVsc2UgYS52Yj1udWxsfSxXZT1mdW5jdGlvbihhLGIsYyl7SihhKTthLkdhPWM/WWUoYiwhMCk6Yn0sWGU9ZnVuY3Rpb24oYSxiLGMpe0ooYSk7YiBpbnN0YW5jZW9mIFplPyhhLmVhPWIsYS5lYS4kZChhLmRhKSk6KGN8fChiPSRlKGIsZWYpKSxhLmVhPW5ldyBaZShiLDAsYS5kYSkpfSxLPWZ1bmN0aW9uKGEsYixjKXtKKGEpO2EuZWEuc2V0KGIsYyl9LGZmPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuZWEuZ2V0KGIpfTtcblNlLnByb3RvdHlwZS5yZW1vdmVQYXJhbWV0ZXI9ZnVuY3Rpb24oYSl7Sih0aGlzKTt0aGlzLmVhLnJlbW92ZShhKTtyZXR1cm4gdGhpc307dmFyIEo9ZnVuY3Rpb24oYSl7aWYoYS5YZil0aHJvdyBFcnJvcihcIlRyaWVkIHRvIG1vZGlmeSBhIHJlYWQtb25seSBVcmlcIik7fTtTZS5wcm90b3R5cGUuJGQ9ZnVuY3Rpb24oYSl7dGhpcy5kYT1hO3RoaXMuZWEmJnRoaXMuZWEuJGQoYSk7cmV0dXJuIHRoaXN9O1xudmFyIGdmPWZ1bmN0aW9uKGEpe3JldHVybiBhIGluc3RhbmNlb2YgU2U/YS5jbG9uZSgpOm5ldyBTZShhLHZvaWQgMCl9LGhmPWZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IFNlKG51bGwsdm9pZCAwKTtUZShjLFwiaHR0cHNcIik7YSYmVWUoYyxhKTtiJiZXZShjLGIpO3JldHVybiBjfSxZZT1mdW5jdGlvbihhLGIpe3JldHVybiBhP2I/ZGVjb2RlVVJJKGEucmVwbGFjZSgvJTI1L2csXCIlMjUyNVwiKSk6ZGVjb2RlVVJJQ29tcG9uZW50KGEpOlwiXCJ9LCRlPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbShhKT8oYT1lbmNvZGVVUkkoYSkucmVwbGFjZShiLGpmKSxjJiYoYT1hLnJlcGxhY2UoLyUyNShbMC05YS1mQS1GXXsyfSkvZyxcIiUkMVwiKSksYSk6bnVsbH0samY9ZnVuY3Rpb24oYSl7YT1hLmNoYXJDb2RlQXQoMCk7cmV0dXJuXCIlXCIrKGE+PjQmMTUpLnRvU3RyaW5nKDE2KSsoYSYxNSkudG9TdHJpbmcoMTYpfSxhZj0vWyNcXC9cXD9AXS9nLGNmPS9bI1xcPzpdL2csYmY9L1sjXFw/XS9nLGVmPS9bI1xcP0BdL2csXG5kZj0vIy9nLFplPWZ1bmN0aW9uKGEsYixjKXt0aGlzLnU9dGhpcy5zPW51bGw7dGhpcy5YPWF8fG51bGw7dGhpcy5kYT0hIWN9LGtmPWZ1bmN0aW9uKGEpe2Euc3x8KGEucz1uZXcgdWUsYS51PTAsYS5YJiZEZShhLlgsZnVuY3Rpb24oYixjKXthLmFkZChkZWNvZGVVUklDb21wb25lbnQoYi5yZXBsYWNlKC9cXCsvZyxcIiBcIikpLGMpfSkpfSxtZj1mdW5jdGlvbihhKXt2YXIgYj15ZShhKTtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgYil0aHJvdyBFcnJvcihcIktleXMgYXJlIHVuZGVmaW5lZFwiKTt2YXIgYz1uZXcgWmUobnVsbCwwLHZvaWQgMCk7YT14ZShhKTtmb3IodmFyIGQ9MDtkPGIubGVuZ3RoO2QrKyl7dmFyIGU9YltkXSxmPWFbZF07aGEoZik/bGYoYyxlLGYpOmMuYWRkKGUsZil9cmV0dXJuIGN9O2g9WmUucHJvdG90eXBlO1xuaC5hZGQ9ZnVuY3Rpb24oYSxiKXtrZih0aGlzKTt0aGlzLlg9bnVsbDthPXRoaXMuY2EoYSk7dmFyIGM9dGhpcy5zLmdldChhKTtjfHx0aGlzLnMuc2V0KGEsYz1bXSk7Yy5wdXNoKGIpO3RoaXMudT1CYSh0aGlzLnUpKzE7cmV0dXJuIHRoaXN9O2gucmVtb3ZlPWZ1bmN0aW9uKGEpe2tmKHRoaXMpO2E9dGhpcy5jYShhKTtyZXR1cm4gdGhpcy5zLkpiKGEpPyh0aGlzLlg9bnVsbCx0aGlzLnU9QmEodGhpcy51KS10aGlzLnMuZ2V0KGEpLmxlbmd0aCx0aGlzLnMucmVtb3ZlKGEpKTohMX07aC5jbGVhcj1mdW5jdGlvbigpe3RoaXMucz10aGlzLlg9bnVsbDt0aGlzLnU9MH07aC5KYj1mdW5jdGlvbihhKXtrZih0aGlzKTthPXRoaXMuY2EoYSk7cmV0dXJuIHRoaXMucy5KYihhKX07aC5mb3JFYWNoPWZ1bmN0aW9uKGEsYil7a2YodGhpcyk7dGhpcy5zLmZvckVhY2goZnVuY3Rpb24oYyxkKXt4KGMsZnVuY3Rpb24oYyl7YS5jYWxsKGIsYyxkLHRoaXMpfSx0aGlzKX0sdGhpcyl9O1xuaC52YT1mdW5jdGlvbigpe2tmKHRoaXMpO2Zvcih2YXIgYT10aGlzLnMuaGEoKSxiPXRoaXMucy52YSgpLGM9W10sZD0wO2Q8Yi5sZW5ndGg7ZCsrKWZvcih2YXIgZT1hW2RdLGY9MDtmPGUubGVuZ3RoO2YrKyljLnB1c2goYltkXSk7cmV0dXJuIGN9O2guaGE9ZnVuY3Rpb24oYSl7a2YodGhpcyk7dmFyIGI9W107aWYobShhKSl0aGlzLkpiKGEpJiYoYj1aYShiLHRoaXMucy5nZXQodGhpcy5jYShhKSkpKTtlbHNle2E9dGhpcy5zLmhhKCk7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspYj1aYShiLGFbY10pfXJldHVybiBifTtoLnNldD1mdW5jdGlvbihhLGIpe2tmKHRoaXMpO3RoaXMuWD1udWxsO2E9dGhpcy5jYShhKTt0aGlzLkpiKGEpJiYodGhpcy51PUJhKHRoaXMudSktdGhpcy5zLmdldChhKS5sZW5ndGgpO3RoaXMucy5zZXQoYSxbYl0pO3RoaXMudT1CYSh0aGlzLnUpKzE7cmV0dXJuIHRoaXN9O1xuaC5nZXQ9ZnVuY3Rpb24oYSxiKXthPWE/dGhpcy5oYShhKTpbXTtyZXR1cm4gMDxhLmxlbmd0aD9TdHJpbmcoYVswXSk6Yn07dmFyIGxmPWZ1bmN0aW9uKGEsYixjKXthLnJlbW92ZShiKTswPGMubGVuZ3RoJiYoYS5YPW51bGwsYS5zLnNldChhLmNhKGIpLCRhKGMpKSxhLnU9QmEoYS51KStjLmxlbmd0aCl9O2g9WmUucHJvdG90eXBlO2gudG9TdHJpbmc9ZnVuY3Rpb24oKXtpZih0aGlzLlgpcmV0dXJuIHRoaXMuWDtpZighdGhpcy5zKXJldHVyblwiXCI7Zm9yKHZhciBhPVtdLGI9dGhpcy5zLnZhKCksYz0wO2M8Yi5sZW5ndGg7YysrKXt2YXIgZD1iW2NdLGU9ZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhkKSk7ZD10aGlzLmhhKGQpO2Zvcih2YXIgZj0wO2Y8ZC5sZW5ndGg7ZisrKXt2YXIgZz1lO1wiXCIhPT1kW2ZdJiYoZys9XCI9XCIrZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhkW2ZdKSkpO2EucHVzaChnKX19cmV0dXJuIHRoaXMuWD1hLmpvaW4oXCImXCIpfTtcbmguY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgWmU7YS5YPXRoaXMuWDt0aGlzLnMmJihhLnM9dGhpcy5zLmNsb25lKCksYS51PXRoaXMudSk7cmV0dXJuIGF9O2guY2E9ZnVuY3Rpb24oYSl7YT1TdHJpbmcoYSk7dGhpcy5kYSYmKGE9YS50b0xvd2VyQ2FzZSgpKTtyZXR1cm4gYX07aC4kZD1mdW5jdGlvbihhKXthJiYhdGhpcy5kYSYmKGtmKHRoaXMpLHRoaXMuWD1udWxsLHRoaXMucy5mb3JFYWNoKGZ1bmN0aW9uKGEsYyl7dmFyIGI9Yy50b0xvd2VyQ2FzZSgpO2MhPWImJih0aGlzLnJlbW92ZShjKSxsZih0aGlzLGIsYSkpfSx0aGlzKSk7dGhpcy5kYT1hfTtoLmV4dGVuZD1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPGFyZ3VtZW50cy5sZW5ndGg7YisrKXplKGFyZ3VtZW50c1tiXSxmdW5jdGlvbihhLGIpe3RoaXMuYWRkKGIsYSl9LHRoaXMpfTt2YXIgbmY9e0tnOntxZDpcImh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2lkZW50aXR5dG9vbGtpdC92My9yZWx5aW5ncGFydHkvXCIsV2Q6XCJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZWFwaXMuY29tL3YxL3Rva2VuXCIsaWQ6XCJwXCJ9LExnOntxZDpcImh0dHBzOi8vc3RhZ2luZy13d3cuc2FuZGJveC5nb29nbGVhcGlzLmNvbS9pZGVudGl0eXRvb2xraXQvdjMvcmVseWluZ3BhcnR5L1wiLFdkOlwiaHR0cHM6Ly9zdGFnaW5nLXNlY3VyZXRva2VuLnNhbmRib3guZ29vZ2xlYXBpcy5jb20vdjEvdG9rZW5cIixpZDpcInNcIn0sTWc6e3FkOlwiaHR0cHM6Ly93d3ctZ29vZ2xlYXBpcy10ZXN0LnNhbmRib3guZ29vZ2xlLmNvbS9pZGVudGl0eXRvb2xraXQvdjMvcmVseWluZ3BhcnR5L1wiLFdkOlwiaHR0cHM6Ly90ZXN0LXNlY3VyZXRva2VuLnNhbmRib3guZ29vZ2xlYXBpcy5jb20vdjEvdG9rZW5cIixpZDpcInRcIn19LG9mPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYiBpbiBuZilpZihuZltiXS5pZD09PWEpcmV0dXJuIGE9XG5uZltiXSx7ZmlyZWJhc2VFbmRwb2ludDphLnFkLHNlY3VyZVRva2VuRW5kcG9pbnQ6YS5XZH07cmV0dXJuIG51bGx9LHBmO3BmPW9mKFwiX19FSURfX1wiKT9cIl9fRUlEX19cIjp2b2lkIDA7dmFyIHFmPWZ1bmN0aW9uKCl7dmFyIGE9TCgpO3JldHVybiB6JiYhIUNiJiYxMT09Q2J8fC9FZGdlXFwvXFxkKy8udGVzdChhKX0scmY9ZnVuY3Rpb24oKXtyZXR1cm4gay53aW5kb3cmJmsud2luZG93LmxvY2F0aW9uLmhyZWZ8fFwiXCJ9LHNmPWZ1bmN0aW9uKGEsYil7Yj1ifHxrLndpbmRvdzt2YXIgYz1cImFib3V0OmJsYW5rXCI7YSYmKGM9QmMoRWMoYSkpKTtiLmxvY2F0aW9uLmhyZWY9Y30sdGY9ZnVuY3Rpb24oYSxiKXt2YXIgYz1bXSxkO2ZvcihkIGluIGEpZCBpbiBiP3R5cGVvZiBhW2RdIT10eXBlb2YgYltkXT9jLnB1c2goZCk6aGEoYVtkXSk/amIoYVtkXSxiW2RdKXx8Yy5wdXNoKGQpOlwib2JqZWN0XCI9PXR5cGVvZiBhW2RdJiZudWxsIT1hW2RdJiZudWxsIT1iW2RdPzA8dGYoYVtkXSxiW2RdKS5sZW5ndGgmJmMucHVzaChkKTphW2RdIT09YltkXSYmYy5wdXNoKGQpOmMucHVzaChkKTtmb3IoZCBpbiBiKWQgaW4gYXx8Yy5wdXNoKGQpO3JldHVybiBjfSx2Zj1mdW5jdGlvbigpe3ZhciBhPVxuTCgpO2E9XCJDaHJvbWVcIiE9dWYoYSk/bnVsbDooYT1hLm1hdGNoKC9cXHNDaHJvbWVcXC8oXFxkKykvaSkpJiYyPT1hLmxlbmd0aD9wYXJzZUludChhWzFdLDEwKTpudWxsO3JldHVybiBhJiYzMD5hPyExOiF6fHwhQ2J8fDk8Q2J9LHdmPWZ1bmN0aW9uKGEpe2E9KGF8fEwoKSkudG9Mb3dlckNhc2UoKTtyZXR1cm4gYS5tYXRjaCgvYW5kcm9pZC8pfHxhLm1hdGNoKC93ZWJvcy8pfHxhLm1hdGNoKC9pcGhvbmV8aXBhZHxpcG9kLyl8fGEubWF0Y2goL2JsYWNrYmVycnkvKXx8YS5tYXRjaCgvd2luZG93cyBwaG9uZS8pfHxhLm1hdGNoKC9pZW1vYmlsZS8pPyEwOiExfSx4Zj1mdW5jdGlvbihhKXthPWF8fGsud2luZG93O3RyeXthLmNsb3NlKCl9Y2F0Y2goYil7fX0seWY9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPU1hdGguZmxvb3IoMUU5Kk1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKCk7Yj1ifHw1MDA7Yz1jfHw2MDA7dmFyIGU9KHdpbmRvdy5zY3JlZW4uYXZhaWxIZWlnaHQtYykvMixmPSh3aW5kb3cuc2NyZWVuLmF2YWlsV2lkdGgtXG5iKS8yO2I9e3dpZHRoOmIsaGVpZ2h0OmMsdG9wOjA8ZT9lOjAsbGVmdDowPGY/ZjowLGxvY2F0aW9uOiEwLHJlc2l6YWJsZTohMCxzdGF0dXNiYXI6ITAsdG9vbGJhcjohMX07Yz1MKCkudG9Mb3dlckNhc2UoKTtkJiYoYi50YXJnZXQ9ZCx2KGMsXCJjcmlvcy9cIikmJihiLnRhcmdldD1cIl9ibGFua1wiKSk7XCJGaXJlZm94XCI9PXVmKEwoKSkmJihhPWF8fFwiaHR0cDovL2xvY2FsaG9zdFwiLGIuc2Nyb2xsYmFycz0hMCk7Yz1hfHxcIlwiOyhhPWIpfHwoYT17fSk7ZD13aW5kb3c7Yj1jIGluc3RhbmNlb2YgQWM/YzpFYyhcInVuZGVmaW5lZFwiIT10eXBlb2YgYy5ocmVmP2MuaHJlZjpTdHJpbmcoYykpO2M9YS50YXJnZXR8fGMudGFyZ2V0O2U9W107Zm9yKGcgaW4gYSlzd2l0Y2goZyl7Y2FzZSBcIndpZHRoXCI6Y2FzZSBcImhlaWdodFwiOmNhc2UgXCJ0b3BcIjpjYXNlIFwibGVmdFwiOmUucHVzaChnK1wiPVwiK2FbZ10pO2JyZWFrO2Nhc2UgXCJ0YXJnZXRcIjpjYXNlIFwibm9vcGVuZXJcIjpjYXNlIFwibm9yZWZlcnJlclwiOmJyZWFrO1xuZGVmYXVsdDplLnB1c2goZytcIj1cIisoYVtnXT8xOjApKX12YXIgZz1lLmpvaW4oXCIsXCIpOyh5KFwiaVBob25lXCIpJiYheShcImlQb2RcIikmJiF5KFwiaVBhZFwiKXx8eShcImlQYWRcIil8fHkoXCJpUG9kXCIpKSYmZC5uYXZpZ2F0b3ImJmQubmF2aWdhdG9yLnN0YW5kYWxvbmUmJmMmJlwiX3NlbGZcIiE9Yz8oZz1kLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJBXCIpLGZkKGcsXCJIVE1MQW5jaG9yRWxlbWVudFwiKSxiIGluc3RhbmNlb2YgQWN8fGIgaW5zdGFuY2VvZiBBY3x8KGI9Yi5xYj9iLm9iKCk6U3RyaW5nKGIpLHcoQ2MudGVzdChiKSl8fChiPVwiYWJvdXQ6aW52YWxpZCN6Q2xvc3VyZXpcIiksYj1EYyhiKSksZy5ocmVmPUJjKGIpLGcuc2V0QXR0cmlidXRlKFwidGFyZ2V0XCIsYyksYS5ub3JlZmVycmVyJiZnLnNldEF0dHJpYnV0ZShcInJlbFwiLFwibm9yZWZlcnJlclwiKSxhPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudFwiKSxhLmluaXRNb3VzZUV2ZW50KFwiY2xpY2tcIiwhMCwhMCxkLDEpLGcuZGlzcGF0Y2hFdmVudChhKSxcbmc9e30pOmEubm9yZWZlcnJlcj8oZz1kLm9wZW4oXCJcIixjLGcpLGQ9QmMoYiksZyYmKHNiJiZ2KGQsXCI7XCIpJiYoZD1cIidcIitkLnJlcGxhY2UoLycvZyxcIiUyN1wiKStcIidcIiksZy5vcGVuZXI9bnVsbCxhPUhhKFwiYi8xMjAxNDQxMiwgbWV0YSB0YWcgd2l0aCBzYW5pdGl6ZWQgVVJMXCIpLGQ9JzxNRVRBIEhUVFAtRVFVSVY9XCJyZWZyZXNoXCIgY29udGVudD1cIjA7IHVybD0nK3dhKGQpKydcIj4nLENhKEdhKGEpLFwibXVzdCBwcm92aWRlIGp1c3RpZmljYXRpb25cIiksdyghL15bXFxzXFx4YTBdKiQvLnRlc3QoR2EoYSkpLFwibXVzdCBwcm92aWRlIG5vbi1lbXB0eSBqdXN0aWZpY2F0aW9uXCIpLGcuZG9jdW1lbnQud3JpdGUoamQoKG5ldyBpZCkuVGYoZCkpKSxnLmRvY3VtZW50LmNsb3NlKCkpKTooZz1kLm9wZW4oQmMoYiksYyxnKSkmJmEubm9vcGVuZXImJihnLm9wZW5lcj1udWxsKTtpZihnKXRyeXtnLmZvY3VzKCl9Y2F0Y2gobCl7fXJldHVybiBnfSx6Zj1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IEMoZnVuY3Rpb24oYil7dmFyIGM9XG5mdW5jdGlvbigpe0JlKDJFMykudGhlbihmdW5jdGlvbigpe2lmKCFhfHxhLmNsb3NlZCliKCk7ZWxzZSByZXR1cm4gYygpfSl9O3JldHVybiBjKCl9KX0sQWY9L15cXGR7MSwzfVxcLlxcZHsxLDN9XFwuXFxkezEsM31cXC5cXGR7MSwzfSQvLEJmPWZ1bmN0aW9uKCl7dmFyIGE9bnVsbDtyZXR1cm4obmV3IEMoZnVuY3Rpb24oYil7XCJjb21wbGV0ZVwiPT1rLmRvY3VtZW50LnJlYWR5U3RhdGU/YigpOihhPWZ1bmN0aW9uKCl7YigpfSxrYyh3aW5kb3csXCJsb2FkXCIsYSkpfSkpLmcoZnVuY3Rpb24oYil7dGMod2luZG93LFwibG9hZFwiLGEpO3Rocm93IGI7fSl9LERmPWZ1bmN0aW9uKCl7cmV0dXJuIENmKHZvaWQgMCk/QmYoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDKGZ1bmN0aW9uKGEsYil7dmFyIGM9ay5kb2N1bWVudCxkPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtiKEVycm9yKFwiQ29yZG92YSBmcmFtZXdvcmsgaXMgbm90IHJlYWR5LlwiKSl9LDFFMyk7Yy5hZGRFdmVudExpc3RlbmVyKFwiZGV2aWNlcmVhZHlcIixcbmZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGQpO2EoKX0sITEpfSl9KTpFKEVycm9yKFwiQ29yZG92YSBtdXN0IHJ1biBpbiBhbiBBbmRyb2lkIG9yIGlPUyBmaWxlIHNjaGVtZS5cIikpfSxDZj1mdW5jdGlvbihhKXthPWF8fEwoKTtyZXR1cm4hKFwiZmlsZTpcIiE9PUVmKCl8fCFhLnRvTG93ZXJDYXNlKCkubWF0Y2goL2lwaG9uZXxpcGFkfGlwb2R8YW5kcm9pZC8pKX0sRmY9ZnVuY3Rpb24oKXt2YXIgYT1rLndpbmRvdzt0cnl7cmV0dXJuISghYXx8YT09YS50b3ApfWNhdGNoKGIpe3JldHVybiExfX0sR2Y9ZnVuY3Rpb24oKXtyZXR1cm4gZmlyZWJhc2UuSU5URVJOQUwuaGFzT3duUHJvcGVydHkoXCJyZWFjdE5hdGl2ZVwiKT9cIlJlYWN0TmF0aXZlXCI6ZmlyZWJhc2UuSU5URVJOQUwuaGFzT3duUHJvcGVydHkoXCJub2RlXCIpP1wiTm9kZVwiOlwiQnJvd3NlclwifSxIZj1mdW5jdGlvbigpe3ZhciBhPUdmKCk7cmV0dXJuXCJSZWFjdE5hdGl2ZVwiPT09YXx8XCJOb2RlXCI9PT1hfSx1Zj1mdW5jdGlvbihhKXt2YXIgYj1cbmEudG9Mb3dlckNhc2UoKTtpZih2KGIsXCJvcGVyYS9cIil8fHYoYixcIm9wci9cIil8fHYoYixcIm9waW9zL1wiKSlyZXR1cm5cIk9wZXJhXCI7aWYodihiLFwiaWVtb2JpbGVcIikpcmV0dXJuXCJJRU1vYmlsZVwiO2lmKHYoYixcIm1zaWVcIil8fHYoYixcInRyaWRlbnQvXCIpKXJldHVyblwiSUVcIjtpZih2KGIsXCJlZGdlL1wiKSlyZXR1cm5cIkVkZ2VcIjtpZih2KGIsXCJmaXJlZm94L1wiKSlyZXR1cm5cIkZpcmVmb3hcIjtpZih2KGIsXCJzaWxrL1wiKSlyZXR1cm5cIlNpbGtcIjtpZih2KGIsXCJibGFja2JlcnJ5XCIpKXJldHVyblwiQmxhY2tiZXJyeVwiO2lmKHYoYixcIndlYm9zXCIpKXJldHVyblwiV2Vib3NcIjtpZighdihiLFwic2FmYXJpL1wiKXx8dihiLFwiY2hyb21lL1wiKXx8dihiLFwiY3Jpb3MvXCIpfHx2KGIsXCJhbmRyb2lkXCIpKWlmKCF2KGIsXCJjaHJvbWUvXCIpJiYhdihiLFwiY3Jpb3MvXCIpfHx2KGIsXCJlZGdlL1wiKSl7aWYodihiLFwiYW5kcm9pZFwiKSlyZXR1cm5cIkFuZHJvaWRcIjtpZigoYT1hLm1hdGNoKC8oW2EtekEtWlxcZFxcLl0rKVxcL1thLXpBLVpcXGRcXC5dKiQvKSkmJlxuMj09YS5sZW5ndGgpcmV0dXJuIGFbMV19ZWxzZSByZXR1cm5cIkNocm9tZVwiO2Vsc2UgcmV0dXJuXCJTYWZhcmlcIjtyZXR1cm5cIk90aGVyXCJ9LElmPXtGZzpcIkZpcmViYXNlQ29yZS13ZWJcIixIZzpcIkZpcmViYXNlVUktd2ViXCJ9LEpmPWZ1bmN0aW9uKGEsYil7Yj1ifHxbXTt2YXIgYz1bXSxkPXt9LGU7Zm9yKGUgaW4gSWYpZFtJZltlXV09ITA7Zm9yKGU9MDtlPGIubGVuZ3RoO2UrKylcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRbYltlXV0mJihkZWxldGUgZFtiW2VdXSxjLnB1c2goYltlXSkpO2Muc29ydCgpO2I9YztiLmxlbmd0aHx8KGI9W1wiRmlyZWJhc2VDb3JlLXdlYlwiXSk7Yz1HZigpO3JldHVybihcIkJyb3dzZXJcIj09PWM/dWYoTCgpKTpjKStcIi9Kc0NvcmUvXCIrYStcIi9cIitiLmpvaW4oXCIsXCIpfSxMPWZ1bmN0aW9uKCl7cmV0dXJuIGsubmF2aWdhdG9yJiZrLm5hdmlnYXRvci51c2VyQWdlbnR8fFwiXCJ9LE09ZnVuY3Rpb24oYSxiKXthPWEuc3BsaXQoXCIuXCIpO2I9Ynx8aztmb3IodmFyIGM9MDtjPFxuYS5sZW5ndGgmJlwib2JqZWN0XCI9PXR5cGVvZiBiJiZudWxsIT1iO2MrKyliPWJbYVtjXV07YyE9YS5sZW5ndGgmJihiPXZvaWQgMCk7cmV0dXJuIGJ9LExmPWZ1bmN0aW9uKCl7dHJ5e3ZhciBhPWsubG9jYWxTdG9yYWdlLGI9S2YoKTtpZihhKXJldHVybiBhLnNldEl0ZW0oYixcIjFcIiksYS5yZW1vdmVJdGVtKGIpLHFmKCk/ISFrLmluZGV4ZWREQjohMH1jYXRjaChjKXt9cmV0dXJuITF9LE5mPWZ1bmN0aW9uKCl7cmV0dXJuKE1mKCl8fFwiY2hyb21lLWV4dGVuc2lvbjpcIj09PUVmKCl8fENmKCkpJiYhSGYoKSYmTGYoKX0sTWY9ZnVuY3Rpb24oKXtyZXR1cm5cImh0dHA6XCI9PT1FZigpfHxcImh0dHBzOlwiPT09RWYoKX0sRWY9ZnVuY3Rpb24oKXtyZXR1cm4gay5sb2NhdGlvbiYmay5sb2NhdGlvbi5wcm90b2NvbHx8bnVsbH0sT2Y9ZnVuY3Rpb24oYSl7YT1hfHxMKCk7cmV0dXJuIHdmKGEpfHxcIkZpcmVmb3hcIj09dWYoYSk/ITE6ITB9LFBmPWZ1bmN0aW9uKGEpe3JldHVyblwidW5kZWZpbmVkXCI9PT1cbnR5cGVvZiBhP251bGw6SGMoYSl9LFFmPWZ1bmN0aW9uKGEpe3ZhciBiPXt9LGM7Zm9yKGMgaW4gYSlhLmhhc093blByb3BlcnR5KGMpJiZudWxsIT09YVtjXSYmdm9pZCAwIT09YVtjXSYmKGJbY109YVtjXSk7cmV0dXJuIGJ9LFJmPWZ1bmN0aW9uKGEpe2lmKG51bGwhPT1hKXJldHVybiBKU09OLnBhcnNlKGEpfSxLZj1mdW5jdGlvbihhKXtyZXR1cm4gYT9hOlwiXCIrTWF0aC5mbG9vcigxRTkqTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoKX0sU2Y9ZnVuY3Rpb24oYSl7YT1hfHxMKCk7cmV0dXJuXCJTYWZhcmlcIj09dWYoYSl8fGEudG9Mb3dlckNhc2UoKS5tYXRjaCgvaXBob25lfGlwYWR8aXBvZC8pPyExOiEwfSxUZj1mdW5jdGlvbigpe3ZhciBhPWsuX19fanNsO2lmKGEmJmEuSClmb3IodmFyIGIgaW4gYS5IKWlmKGEuSFtiXS5yPWEuSFtiXS5yfHxbXSxhLkhbYl0uTD1hLkhbYl0uTHx8W10sYS5IW2JdLnI9YS5IW2JdLkwuY29uY2F0KCksYS5DUClmb3IodmFyIGM9MDtjPGEuQ1AubGVuZ3RoO2MrKylhLkNQW2NdPVxubnVsbH0sVWY9ZnVuY3Rpb24oKXt2YXIgYT1rLm5hdmlnYXRvcjtyZXR1cm4gYSYmXCJib29sZWFuXCI9PT10eXBlb2YgYS5vbkxpbmUmJihNZigpfHxcImNocm9tZS1leHRlbnNpb246XCI9PT1FZigpfHxcInVuZGVmaW5lZFwiIT09dHlwZW9mIGEuY29ubmVjdGlvbik/YS5vbkxpbmU6ITB9LFZmPWZ1bmN0aW9uKGEsYixjLGQpe2lmKGE+Yil0aHJvdyBFcnJvcihcIlNob3J0IGRlbGF5IHNob3VsZCBiZSBsZXNzIHRoYW4gbG9uZyBkZWxheSFcIik7dGhpcy51Zz1hO3RoaXMuYWc9YjthPWN8fEwoKTtkPWR8fEdmKCk7dGhpcy5XZj13ZihhKXx8XCJSZWFjdE5hdGl2ZVwiPT09ZH07VmYucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLldmP3RoaXMuYWc6dGhpcy51Z307XG52YXIgV2Y9ZnVuY3Rpb24oKXt2YXIgYT1rLmRvY3VtZW50O3JldHVybiBhJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIGEudmlzaWJpbGl0eVN0YXRlP1widmlzaWJsZVwiPT1hLnZpc2liaWxpdHlTdGF0ZTohMH0sWGY9ZnVuY3Rpb24oKXt2YXIgYT1rLmRvY3VtZW50LGI9bnVsbDtyZXR1cm4gV2YoKXx8IWE/RCgpOihuZXcgQyhmdW5jdGlvbihjKXtiPWZ1bmN0aW9uKCl7V2YoKSYmKGEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIixiLCExKSxjKCkpfTthLmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsYiwhMSl9KSkuZyhmdW5jdGlvbihjKXthLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsYiwhMSk7dGhyb3cgYzt9KX0sWWY9ZnVuY3Rpb24oYSl7dHJ5e3ZhciBiPW5ldyBEYXRlKHBhcnNlSW50KGEsMTApKTtpZighaXNOYU4oYi5nZXRUaW1lKCkpJiYhL1teMC05XS8udGVzdChhKSlyZXR1cm4gYi50b1VUQ1N0cmluZygpfWNhdGNoKGMpe31yZXR1cm4gbnVsbH07dmFyIFpmPXt9O3ZhciAkZjt0cnl7dmFyIGFnPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShhZyxcImFiY2RcIix7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6MX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShhZyxcImFiY2RcIix7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6Mn0pOyRmPTI9PWFnLmFiY2R9Y2F0Y2goYSl7JGY9ITF9XG52YXIgTj1mdW5jdGlvbihhLGIsYyl7JGY/T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsYix7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6Y30pOmFbYl09Y30sYmc9ZnVuY3Rpb24oYSxiKXtpZihiKWZvcih2YXIgYyBpbiBiKWIuaGFzT3duUHJvcGVydHkoYykmJk4oYSxjLGJbY10pfSxjZz1mdW5jdGlvbihhKXt2YXIgYj17fTtiZyhiLGEpO3JldHVybiBifSxkZz1mdW5jdGlvbihhKXt2YXIgYj17fSxjO2ZvcihjIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShjKSYmKGJbY109YVtjXSk7cmV0dXJuIGJ9LGVnPWZ1bmN0aW9uKGEsYil7aWYoIWJ8fCFiLmxlbmd0aClyZXR1cm4hMDtpZighYSlyZXR1cm4hMTtmb3IodmFyIGM9MDtjPGIubGVuZ3RoO2MrKyl7dmFyIGQ9YVtiW2NdXTtpZih2b2lkIDA9PT1kfHxudWxsPT09ZHx8XCJcIj09PWQpcmV0dXJuITF9cmV0dXJuITB9LGZnPWZ1bmN0aW9uKGEpe3ZhciBiPWE7aWYoXCJvYmplY3RcIj09dHlwZW9mIGEmJm51bGwhPWEpe2I9XG5cImxlbmd0aFwiaW4gYT9bXTp7fTtmb3IodmFyIGMgaW4gYSlOKGIsYyxmZyhhW2NdKSl9cmV0dXJuIGJ9O3ZhciBnZz1cIm9hdXRoX2NvbnN1bWVyX2tleSBvYXV0aF9ub25jZSBvYXV0aF9zaWduYXR1cmUgb2F1dGhfc2lnbmF0dXJlX21ldGhvZCBvYXV0aF90aW1lc3RhbXAgb2F1dGhfdG9rZW4gb2F1dGhfdmVyc2lvblwiLnNwbGl0KFwiIFwiKSxoZz1bXCJjbGllbnRfaWRcIixcInJlc3BvbnNlX3R5cGVcIixcInNjb3BlXCIsXCJyZWRpcmVjdF91cmlcIixcInN0YXRlXCJdLGlnPXtHZzp7RGM6XCJsb2NhbGVcIixaYjo1MDAsWWI6NjAwLHByb3ZpZGVySWQ6XCJmYWNlYm9vay5jb21cIixVZDpoZ30sSWc6e0RjOm51bGwsWmI6NTAwLFliOjYyMCxwcm92aWRlcklkOlwiZ2l0aHViLmNvbVwiLFVkOmhnfSxKZzp7RGM6XCJobFwiLFpiOjUxNSxZYjo2ODAscHJvdmlkZXJJZDpcImdvb2dsZS5jb21cIixVZDpoZ30sTmc6e0RjOlwibGFuZ1wiLFpiOjQ4NSxZYjo3MDUscHJvdmlkZXJJZDpcInR3aXR0ZXIuY29tXCIsVWQ6Z2d9fSxqZz1mdW5jdGlvbihhKXtmb3IodmFyIGIgaW4gaWcpaWYoaWdbYl0ucHJvdmlkZXJJZD09YSlyZXR1cm4gaWdbYl07XG5yZXR1cm4gbnVsbH07dmFyIE89ZnVuY3Rpb24oYSxiKXt0aGlzLmNvZGU9XCJhdXRoL1wiK2E7dGhpcy5tZXNzYWdlPWJ8fGtnW2FdfHxcIlwifTt0KE8sRXJyb3IpO08ucHJvdG90eXBlLkE9ZnVuY3Rpb24oKXtyZXR1cm57Y29kZTp0aGlzLmNvZGUsbWVzc2FnZTp0aGlzLm1lc3NhZ2V9fTtPLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5BKCl9O1xudmFyIGxnPWZ1bmN0aW9uKGEpe3ZhciBiPWEmJmEuY29kZTtyZXR1cm4gYj9uZXcgTyhiLnN1YnN0cmluZyg1KSxhLm1lc3NhZ2UpOm51bGx9LGtnPXtcImFyZ3VtZW50LWVycm9yXCI6XCJcIixcImFwcC1ub3QtYXV0aG9yaXplZFwiOlwiVGhpcyBhcHAsIGlkZW50aWZpZWQgYnkgdGhlIGRvbWFpbiB3aGVyZSBpdCdzIGhvc3RlZCwgaXMgbm90IGF1dGhvcml6ZWQgdG8gdXNlIEZpcmViYXNlIEF1dGhlbnRpY2F0aW9uIHdpdGggdGhlIHByb3ZpZGVkIEFQSSBrZXkuIFJldmlldyB5b3VyIGtleSBjb25maWd1cmF0aW9uIGluIHRoZSBHb29nbGUgQVBJIGNvbnNvbGUuXCIsXCJhcHAtbm90LWluc3RhbGxlZFwiOlwiVGhlIHJlcXVlc3RlZCBtb2JpbGUgYXBwbGljYXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgaWRlbnRpZmllciAoQW5kcm9pZCBwYWNrYWdlIG5hbWUgb3IgaU9TIGJ1bmRsZSBJRCkgcHJvdmlkZWQgaXMgbm90IGluc3RhbGxlZCBvbiB0aGlzIGRldmljZS5cIixcImNhcHRjaGEtY2hlY2stZmFpbGVkXCI6XCJUaGUgcmVDQVBUQ0hBIHJlc3BvbnNlIHRva2VuIHByb3ZpZGVkIGlzIGVpdGhlciBpbnZhbGlkLCBleHBpcmVkLCBhbHJlYWR5IHVzZWQgb3IgdGhlIGRvbWFpbiBhc3NvY2lhdGVkIHdpdGggaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGxpc3Qgb2Ygd2hpdGVsaXN0ZWQgZG9tYWlucy5cIixcblwiY29kZS1leHBpcmVkXCI6XCJUaGUgU01TIGNvZGUgaGFzIGV4cGlyZWQuIFBsZWFzZSByZS1zZW5kIHRoZSB2ZXJpZmljYXRpb24gY29kZSB0byB0cnkgYWdhaW4uXCIsXCJjb3Jkb3ZhLW5vdC1yZWFkeVwiOlwiQ29yZG92YSBmcmFtZXdvcmsgaXMgbm90IHJlYWR5LlwiLFwiY29ycy11bnN1cHBvcnRlZFwiOlwiVGhpcyBicm93c2VyIGlzIG5vdCBzdXBwb3J0ZWQuXCIsXCJjcmVkZW50aWFsLWFscmVhZHktaW4tdXNlXCI6XCJUaGlzIGNyZWRlbnRpYWwgaXMgYWxyZWFkeSBhc3NvY2lhdGVkIHdpdGggYSBkaWZmZXJlbnQgdXNlciBhY2NvdW50LlwiLFwiY3VzdG9tLXRva2VuLW1pc21hdGNoXCI6XCJUaGUgY3VzdG9tIHRva2VuIGNvcnJlc3BvbmRzIHRvIGEgZGlmZmVyZW50IGF1ZGllbmNlLlwiLFwicmVxdWlyZXMtcmVjZW50LWxvZ2luXCI6XCJUaGlzIG9wZXJhdGlvbiBpcyBzZW5zaXRpdmUgYW5kIHJlcXVpcmVzIHJlY2VudCBhdXRoZW50aWNhdGlvbi4gTG9nIGluIGFnYWluIGJlZm9yZSByZXRyeWluZyB0aGlzIHJlcXVlc3QuXCIsXG5cImR5bmFtaWMtbGluay1ub3QtYWN0aXZhdGVkXCI6XCJQbGVhc2UgYWN0aXZhdGUgRHluYW1pYyBMaW5rcyBpbiB0aGUgRmlyZWJhc2UgQ29uc29sZSBhbmQgYWdyZWUgdG8gdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zLlwiLFwiZW1haWwtYWxyZWFkeS1pbi11c2VcIjpcIlRoZSBlbWFpbCBhZGRyZXNzIGlzIGFscmVhZHkgaW4gdXNlIGJ5IGFub3RoZXIgYWNjb3VudC5cIixcImV4cGlyZWQtYWN0aW9uLWNvZGVcIjpcIlRoZSBhY3Rpb24gY29kZSBoYXMgZXhwaXJlZC4gXCIsXCJjYW5jZWxsZWQtcG9wdXAtcmVxdWVzdFwiOlwiVGhpcyBvcGVyYXRpb24gaGFzIGJlZW4gY2FuY2VsbGVkIGR1ZSB0byBhbm90aGVyIGNvbmZsaWN0aW5nIHBvcHVwIGJlaW5nIG9wZW5lZC5cIixcImludGVybmFsLWVycm9yXCI6XCJBbiBpbnRlcm5hbCBlcnJvciBoYXMgb2NjdXJyZWQuXCIsXCJpbnZhbGlkLWFwcC1jcmVkZW50aWFsXCI6XCJUaGUgcGhvbmUgdmVyaWZpY2F0aW9uIHJlcXVlc3QgY29udGFpbnMgYW4gaW52YWxpZCBhcHBsaWNhdGlvbiB2ZXJpZmllci4gVGhlIHJlQ0FQVENIQSB0b2tlbiByZXNwb25zZSBpcyBlaXRoZXIgaW52YWxpZCBvciBleHBpcmVkLlwiLFxuXCJpbnZhbGlkLWFwcC1pZFwiOlwiVGhlIG1vYmlsZSBhcHAgaWRlbnRpZmllciBpcyBub3QgcmVnaXN0ZWQgZm9yIHRoZSBjdXJyZW50IHByb2plY3QuXCIsXCJpbnZhbGlkLXVzZXItdG9rZW5cIjpcIlRoZSB1c2VyJ3MgY3JlZGVudGlhbCBpcyBubyBsb25nZXIgdmFsaWQuIFRoZSB1c2VyIG11c3Qgc2lnbiBpbiBhZ2Fpbi5cIixcImludmFsaWQtYXV0aC1ldmVudFwiOlwiQW4gaW50ZXJuYWwgZXJyb3IgaGFzIG9jY3VycmVkLlwiLFwiaW52YWxpZC12ZXJpZmljYXRpb24tY29kZVwiOlwiVGhlIFNNUyB2ZXJpZmljYXRpb24gY29kZSB1c2VkIHRvIGNyZWF0ZSB0aGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIGlzIGludmFsaWQuIFBsZWFzZSByZXNlbmQgdGhlIHZlcmlmaWNhdGlvbiBjb2RlIHNtcyBhbmQgYmUgc3VyZSB1c2UgdGhlIHZlcmlmaWNhdGlvbiBjb2RlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLlwiLFwiaW52YWxpZC1jb250aW51ZS11cmlcIjpcIlRoZSBjb250aW51ZSBVUkwgcHJvdmlkZWQgaW4gdGhlIHJlcXVlc3QgaXMgaW52YWxpZC5cIixcblwiaW52YWxpZC1jb3Jkb3ZhLWNvbmZpZ3VyYXRpb25cIjpcIlRoZSBmb2xsb3dpbmcgQ29yZG92YSBwbHVnaW5zIG11c3QgYmUgaW5zdGFsbGVkIHRvIGVuYWJsZSBPQXV0aCBzaWduLWluOiBjb3Jkb3ZhLXBsdWdpbi1idWlsZGluZm8sIGNvcmRvdmEtdW5pdmVyc2FsLWxpbmtzLXBsdWdpbiwgY29yZG92YS1wbHVnaW4tYnJvd3NlcnRhYiwgY29yZG92YS1wbHVnaW4taW5hcHBicm93c2VyIGFuZCBjb3Jkb3ZhLXBsdWdpbi1jdXN0b211cmxzY2hlbWUuXCIsXCJpbnZhbGlkLWN1c3RvbS10b2tlblwiOlwiVGhlIGN1c3RvbSB0b2tlbiBmb3JtYXQgaXMgaW5jb3JyZWN0LiBQbGVhc2UgY2hlY2sgdGhlIGRvY3VtZW50YXRpb24uXCIsXCJpbnZhbGlkLWVtYWlsXCI6XCJUaGUgZW1haWwgYWRkcmVzcyBpcyBiYWRseSBmb3JtYXR0ZWQuXCIsXCJpbnZhbGlkLWFwaS1rZXlcIjpcIllvdXIgQVBJIGtleSBpcyBpbnZhbGlkLCBwbGVhc2UgY2hlY2sgeW91IGhhdmUgY29waWVkIGl0IGNvcnJlY3RseS5cIixcImludmFsaWQtY3JlZGVudGlhbFwiOlwiVGhlIHN1cHBsaWVkIGF1dGggY3JlZGVudGlhbCBpcyBtYWxmb3JtZWQgb3IgaGFzIGV4cGlyZWQuXCIsXG5cImludmFsaWQtcGVyc2lzdGVuY2UtdHlwZVwiOlwiVGhlIHNwZWNpZmllZCBwZXJzaXN0ZW5jZSB0eXBlIGlzIGludmFsaWQuIEl0IGNhbiBvbmx5IGJlIGxvY2FsLCBzZXNzaW9uIG9yIG5vbmUuXCIsXCJpbnZhbGlkLW1lc3NhZ2UtcGF5bG9hZFwiOlwiVGhlIGVtYWlsIHRlbXBsYXRlIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBhY3Rpb24gY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIGluIGl0cyBtZXNzYWdlLiBQbGVhc2UgZml4IGJ5IGdvaW5nIHRvIHRoZSBBdXRoIGVtYWlsIHRlbXBsYXRlcyBzZWN0aW9uIGluIHRoZSBGaXJlYmFzZSBDb25zb2xlLlwiLFwiaW52YWxpZC1vYXV0aC1wcm92aWRlclwiOlwiRW1haWxBdXRoUHJvdmlkZXIgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhpcyBvcGVyYXRpb24uIFRoaXMgb3BlcmF0aW9uIG9ubHkgc3VwcG9ydHMgT0F1dGggcHJvdmlkZXJzLlwiLFwiaW52YWxpZC1vYXV0aC1jbGllbnQtaWRcIjpcIlRoZSBPQXV0aCBjbGllbnQgSUQgcHJvdmlkZWQgaXMgZWl0aGVyIGludmFsaWQgb3IgZG9lcyBub3QgbWF0Y2ggdGhlIHNwZWNpZmllZCBBUEkga2V5LlwiLFxuXCJ1bmF1dGhvcml6ZWQtZG9tYWluXCI6XCJUaGlzIGRvbWFpbiBpcyBub3QgYXV0aG9yaXplZCBmb3IgT0F1dGggb3BlcmF0aW9ucyBmb3IgeW91ciBGaXJlYmFzZSBwcm9qZWN0LiBFZGl0IHRoZSBsaXN0IG9mIGF1dGhvcml6ZWQgZG9tYWlucyBmcm9tIHRoZSBGaXJlYmFzZSBjb25zb2xlLlwiLFwiaW52YWxpZC1hY3Rpb24tY29kZVwiOlwiVGhlIGFjdGlvbiBjb2RlIGlzIGludmFsaWQuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgY29kZSBpcyBtYWxmb3JtZWQsIGV4cGlyZWQsIG9yIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cIixcIndyb25nLXBhc3N3b3JkXCI6XCJUaGUgcGFzc3dvcmQgaXMgaW52YWxpZCBvciB0aGUgdXNlciBkb2VzIG5vdCBoYXZlIGEgcGFzc3dvcmQuXCIsXCJpbnZhbGlkLXBob25lLW51bWJlclwiOlwiVGhlIGZvcm1hdCBvZiB0aGUgcGhvbmUgbnVtYmVyIHByb3ZpZGVkIGlzIGluY29ycmVjdC4gUGxlYXNlIGVudGVyIHRoZSBwaG9uZSBudW1iZXIgaW4gYSBmb3JtYXQgdGhhdCBjYW4gYmUgcGFyc2VkIGludG8gRS4xNjQgZm9ybWF0LiBFLjE2NCBwaG9uZSBudW1iZXJzIGFyZSB3cml0dGVuIGluIHRoZSBmb3JtYXQgWytdW2NvdW50cnkgY29kZV1bc3Vic2NyaWJlciBudW1iZXIgaW5jbHVkaW5nIGFyZWEgY29kZV0uXCIsXG5cImludmFsaWQtcmVjaXBpZW50LWVtYWlsXCI6XCJUaGUgZW1haWwgY29ycmVzcG9uZGluZyB0byB0aGlzIGFjdGlvbiBmYWlsZWQgdG8gc2VuZCBhcyB0aGUgcHJvdmlkZWQgcmVjaXBpZW50IGVtYWlsIGFkZHJlc3MgaXMgaW52YWxpZC5cIixcImludmFsaWQtc2VuZGVyXCI6XCJUaGUgZW1haWwgdGVtcGxhdGUgY29ycmVzcG9uZGluZyB0byB0aGlzIGFjdGlvbiBjb250YWlucyBhbiBpbnZhbGlkIHNlbmRlciBlbWFpbCBvciBuYW1lLiBQbGVhc2UgZml4IGJ5IGdvaW5nIHRvIHRoZSBBdXRoIGVtYWlsIHRlbXBsYXRlcyBzZWN0aW9uIGluIHRoZSBGaXJlYmFzZSBDb25zb2xlLlwiLFwiaW52YWxpZC12ZXJpZmljYXRpb24taWRcIjpcIlRoZSB2ZXJpZmljYXRpb24gSUQgdXNlZCB0byBjcmVhdGUgdGhlIHBob25lIGF1dGggY3JlZGVudGlhbCBpcyBpbnZhbGlkLlwiLFwibWlzc2luZy1hbmRyb2lkLXBrZy1uYW1lXCI6XCJBbiBBbmRyb2lkIFBhY2thZ2UgTmFtZSBtdXN0IGJlIHByb3ZpZGVkIGlmIHRoZSBBbmRyb2lkIEFwcCBpcyByZXF1aXJlZCB0byBiZSBpbnN0YWxsZWQuXCIsXG5cImF1dGgtZG9tYWluLWNvbmZpZy1yZXF1aXJlZFwiOlwiQmUgc3VyZSB0byBpbmNsdWRlIGF1dGhEb21haW4gd2hlbiBjYWxsaW5nIGZpcmViYXNlLmluaXRpYWxpemVBcHAoKSwgYnkgZm9sbG93aW5nIHRoZSBpbnN0cnVjdGlvbnMgaW4gdGhlIEZpcmViYXNlIGNvbnNvbGUuXCIsXCJtaXNzaW5nLWFwcC1jcmVkZW50aWFsXCI6XCJUaGUgcGhvbmUgdmVyaWZpY2F0aW9uIHJlcXVlc3QgaXMgbWlzc2luZyBhbiBhcHBsaWNhdGlvbiB2ZXJpZmllciBhc3NlcnRpb24uIEEgcmVDQVBUQ0hBIHJlc3BvbnNlIHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLlwiLFwibWlzc2luZy12ZXJpZmljYXRpb24tY29kZVwiOlwiVGhlIHBob25lIGF1dGggY3JlZGVudGlhbCB3YXMgY3JlYXRlZCB3aXRoIGFuIGVtcHR5IFNNUyB2ZXJpZmljYXRpb24gY29kZS5cIixcIm1pc3NpbmctY29udGludWUtdXJpXCI6XCJBIGNvbnRpbnVlIFVSTCBtdXN0IGJlIHByb3ZpZGVkIGluIHRoZSByZXF1ZXN0LlwiLFwibWlzc2luZy1pZnJhbWUtc3RhcnRcIjpcIkFuIGludGVybmFsIGVycm9yIGhhcyBvY2N1cnJlZC5cIixcblwibWlzc2luZy1pb3MtYnVuZGxlLWlkXCI6XCJBbiBpT1MgQnVuZGxlIElEIG11c3QgYmUgcHJvdmlkZWQgaWYgYW4gQXBwIFN0b3JlIElEIGlzIHByb3ZpZGVkLlwiLFwibWlzc2luZy1waG9uZS1udW1iZXJcIjpcIlRvIHNlbmQgdmVyaWZpY2F0aW9uIGNvZGVzLCBwcm92aWRlIGEgcGhvbmUgbnVtYmVyIGZvciB0aGUgcmVjaXBpZW50LlwiLFwibWlzc2luZy12ZXJpZmljYXRpb24taWRcIjpcIlRoZSBwaG9uZSBhdXRoIGNyZWRlbnRpYWwgd2FzIGNyZWF0ZWQgd2l0aCBhbiBlbXB0eSB2ZXJpZmljYXRpb24gSUQuXCIsXCJhcHAtZGVsZXRlZFwiOlwiVGhpcyBpbnN0YW5jZSBvZiBGaXJlYmFzZUFwcCBoYXMgYmVlbiBkZWxldGVkLlwiLFwiYWNjb3VudC1leGlzdHMtd2l0aC1kaWZmZXJlbnQtY3JlZGVudGlhbFwiOlwiQW4gYWNjb3VudCBhbHJlYWR5IGV4aXN0cyB3aXRoIHRoZSBzYW1lIGVtYWlsIGFkZHJlc3MgYnV0IGRpZmZlcmVudCBzaWduLWluIGNyZWRlbnRpYWxzLiBTaWduIGluIHVzaW5nIGEgcHJvdmlkZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZW1haWwgYWRkcmVzcy5cIixcblwibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiOlwiQSBuZXR3b3JrIGVycm9yIChzdWNoIGFzIHRpbWVvdXQsIGludGVycnVwdGVkIGNvbm5lY3Rpb24gb3IgdW5yZWFjaGFibGUgaG9zdCkgaGFzIG9jY3VycmVkLlwiLFwibm8tYXV0aC1ldmVudFwiOlwiQW4gaW50ZXJuYWwgZXJyb3IgaGFzIG9jY3VycmVkLlwiLFwibm8tc3VjaC1wcm92aWRlclwiOlwiVXNlciB3YXMgbm90IGxpbmtlZCB0byBhbiBhY2NvdW50IHdpdGggdGhlIGdpdmVuIHByb3ZpZGVyLlwiLFwib3BlcmF0aW9uLW5vdC1hbGxvd2VkXCI6XCJUaGUgZ2l2ZW4gc2lnbi1pbiBwcm92aWRlciBpcyBkaXNhYmxlZCBmb3IgdGhpcyBGaXJlYmFzZSBwcm9qZWN0LiBFbmFibGUgaXQgaW4gdGhlIEZpcmViYXNlIGNvbnNvbGUsIHVuZGVyIHRoZSBzaWduLWluIG1ldGhvZCB0YWIgb2YgdGhlIEF1dGggc2VjdGlvbi5cIixcIm9wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnRcIjonVGhpcyBvcGVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgZW52aXJvbm1lbnQgdGhpcyBhcHBsaWNhdGlvbiBpcyBydW5uaW5nIG9uLiBcImxvY2F0aW9uLnByb3RvY29sXCIgbXVzdCBiZSBodHRwLCBodHRwcyBvciBjaHJvbWUtZXh0ZW5zaW9uIGFuZCB3ZWIgc3RvcmFnZSBtdXN0IGJlIGVuYWJsZWQuJyxcblwicG9wdXAtYmxvY2tlZFwiOlwiVW5hYmxlIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgcG9wdXAuIEl0IG1heSBoYXZlIGJlZW4gYmxvY2tlZCBieSB0aGUgYnJvd3Nlci5cIixcInBvcHVwLWNsb3NlZC1ieS11c2VyXCI6XCJUaGUgcG9wdXAgaGFzIGJlZW4gY2xvc2VkIGJ5IHRoZSB1c2VyIGJlZm9yZSBmaW5hbGl6aW5nIHRoZSBvcGVyYXRpb24uXCIsXCJwcm92aWRlci1hbHJlYWR5LWxpbmtlZFwiOlwiVXNlciBjYW4gb25seSBiZSBsaW5rZWQgdG8gb25lIGlkZW50aXR5IGZvciB0aGUgZ2l2ZW4gcHJvdmlkZXIuXCIsXCJxdW90YS1leGNlZWRlZFwiOlwiVGhlIHByb2plY3QncyBxdW90YSBmb3IgdGhpcyBvcGVyYXRpb24gaGFzIGJlZW4gZXhjZWVkZWQuXCIsXCJyZWRpcmVjdC1jYW5jZWxsZWQtYnktdXNlclwiOlwiVGhlIHJlZGlyZWN0IG9wZXJhdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQgYnkgdGhlIHVzZXIgYmVmb3JlIGZpbmFsaXppbmcuXCIsXCJyZWRpcmVjdC1vcGVyYXRpb24tcGVuZGluZ1wiOlwiQSByZWRpcmVjdCBzaWduLWluIG9wZXJhdGlvbiBpcyBhbHJlYWR5IHBlbmRpbmcuXCIsXG50aW1lb3V0OlwiVGhlIG9wZXJhdGlvbiBoYXMgdGltZWQgb3V0LlwiLFwidXNlci10b2tlbi1leHBpcmVkXCI6XCJUaGUgdXNlcidzIGNyZWRlbnRpYWwgaXMgbm8gbG9uZ2VyIHZhbGlkLiBUaGUgdXNlciBtdXN0IHNpZ24gaW4gYWdhaW4uXCIsXCJ0b28tbWFueS1yZXF1ZXN0c1wiOlwiV2UgaGF2ZSBibG9ja2VkIGFsbCByZXF1ZXN0cyBmcm9tIHRoaXMgZGV2aWNlIGR1ZSB0byB1bnVzdWFsIGFjdGl2aXR5LiBUcnkgYWdhaW4gbGF0ZXIuXCIsXCJ1bmF1dGhvcml6ZWQtY29udGludWUtdXJpXCI6XCJUaGUgZG9tYWluIG9mIHRoZSBjb250aW51ZSBVUkwgaXMgbm90IHdoaXRlbGlzdGVkLiAgUGxlYXNlIHdoaXRlbGlzdCB0aGUgZG9tYWluIGluIHRoZSBGaXJlYmFzZSBjb25zb2xlLlwiLFwidW5zdXBwb3J0ZWQtcGVyc2lzdGVuY2UtdHlwZVwiOlwiVGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgc3BlY2lmaWVkIHBlcnNpc3RlbmNlIHR5cGUuXCIsXCJ1c2VyLWNhbmNlbGxlZFwiOlwiVXNlciBkaWQgbm90IGdyYW50IHlvdXIgYXBwbGljYXRpb24gdGhlIHBlcm1pc3Npb25zIGl0IHJlcXVlc3RlZC5cIixcblwidXNlci1ub3QtZm91bmRcIjpcIlRoZXJlIGlzIG5vIHVzZXIgcmVjb3JkIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBpZGVudGlmaWVyLiBUaGUgdXNlciBtYXkgaGF2ZSBiZWVuIGRlbGV0ZWQuXCIsXCJ1c2VyLWRpc2FibGVkXCI6XCJUaGUgdXNlciBhY2NvdW50IGhhcyBiZWVuIGRpc2FibGVkIGJ5IGFuIGFkbWluaXN0cmF0b3IuXCIsXCJ1c2VyLW1pc21hdGNoXCI6XCJUaGUgc3VwcGxpZWQgY3JlZGVudGlhbHMgZG8gbm90IGNvcnJlc3BvbmQgdG8gdGhlIHByZXZpb3VzbHkgc2lnbmVkIGluIHVzZXIuXCIsXCJ1c2VyLXNpZ25lZC1vdXRcIjpcIlwiLFwid2Vhay1wYXNzd29yZFwiOlwiVGhlIHBhc3N3b3JkIG11c3QgYmUgNiBjaGFyYWN0ZXJzIGxvbmcgb3IgbW9yZS5cIixcIndlYi1zdG9yYWdlLXVuc3VwcG9ydGVkXCI6XCJUaGlzIGJyb3dzZXIgaXMgbm90IHN1cHBvcnRlZCBvciAzcmQgcGFydHkgY29va2llcyBhbmQgZGF0YSBtYXkgYmUgZGlzYWJsZWQuXCJ9O3ZhciBtZz1mdW5jdGlvbihhLGIsYyxkLGUpe3RoaXMubWE9YTt0aGlzLlk9Ynx8bnVsbDt0aGlzLkViPWN8fG51bGw7dGhpcy5ZZD1kfHxudWxsO3RoaXMuYmE9ZXx8bnVsbDtpZih0aGlzLkVifHx0aGlzLmJhKXtpZih0aGlzLkViJiZ0aGlzLmJhKXRocm93IG5ldyBPKFwiaW52YWxpZC1hdXRoLWV2ZW50XCIpO2lmKHRoaXMuRWImJiF0aGlzLllkKXRocm93IG5ldyBPKFwiaW52YWxpZC1hdXRoLWV2ZW50XCIpO31lbHNlIHRocm93IG5ldyBPKFwiaW52YWxpZC1hdXRoLWV2ZW50XCIpO307bWcucHJvdG90eXBlLnRjPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuWWR9O21nLnByb3RvdHlwZS5nZXRFcnJvcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJhfTttZy5wcm90b3R5cGUuQT1mdW5jdGlvbigpe3JldHVybnt0eXBlOnRoaXMubWEsZXZlbnRJZDp0aGlzLlksdXJsUmVzcG9uc2U6dGhpcy5FYixzZXNzaW9uSWQ6dGhpcy5ZZCxlcnJvcjp0aGlzLmJhJiZ0aGlzLmJhLkEoKX19O1xudmFyIG5nPWZ1bmN0aW9uKGEpe2E9YXx8e307cmV0dXJuIGEudHlwZT9uZXcgbWcoYS50eXBlLGEuZXZlbnRJZCxhLnVybFJlc3BvbnNlLGEuc2Vzc2lvbklkLGEuZXJyb3ImJmxnKGEuZXJyb3IpKTpudWxsfTt2YXIgb2c9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmF1dGhvcml6ZWQtZG9tYWluXCIsYz12b2lkIDAsZD1nZihhKTthPWQucGE7ZD1kLnFhO1wiY2hyb21lLWV4dGVuc2lvblwiPT1kP2M9bmEoXCJUaGlzIGNocm9tZSBleHRlbnNpb24gSUQgKGNocm9tZS1leHRlbnNpb246Ly8lcykgaXMgbm90IGF1dGhvcml6ZWQgdG8gcnVuIHRoaXMgb3BlcmF0aW9uLiBBZGQgaXQgdG8gdGhlIE9BdXRoIHJlZGlyZWN0IGRvbWFpbnMgbGlzdCBpbiB0aGUgRmlyZWJhc2UgY29uc29sZSAtPiBBdXRoIHNlY3Rpb24gLT4gU2lnbiBpbiBtZXRob2QgdGFiLlwiLGEpOlwiaHR0cFwiPT1kfHxcImh0dHBzXCI9PWQ/Yz1uYShcIlRoaXMgZG9tYWluICglcykgaXMgbm90IGF1dGhvcml6ZWQgdG8gcnVuIHRoaXMgb3BlcmF0aW9uLiBBZGQgaXQgdG8gdGhlIE9BdXRoIHJlZGlyZWN0IGRvbWFpbnMgbGlzdCBpbiB0aGUgRmlyZWJhc2UgY29uc29sZSAtPiBBdXRoIHNlY3Rpb24gLT4gU2lnbiBpbiBtZXRob2QgdGFiLlwiLGEpOmI9XG5cIm9wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnRcIjtPLmNhbGwodGhpcyxiLGMpfTt0KG9nLE8pO3ZhciBwZz1mdW5jdGlvbihhKXt0aGlzLlpmPWEuc3ViO21hKCk7dGhpcy5NYj1hLmVtYWlsfHxudWxsO3RoaXMuUmQ9YS5wcm92aWRlcl9pZHx8YS5maXJlYmFzZSYmYS5maXJlYmFzZS5zaWduX2luX3Byb3ZpZGVyfHxudWxsO3RoaXMucWY9ISFhLmlzX2Fub255bW91c3x8XCJhbm9ueW1vdXNcIj09dGhpcy5SZH07cGcucHJvdG90eXBlLmdldEVtYWlsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuTWJ9O3BnLnByb3RvdHlwZS5pc0Fub255bW91cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnFmfTt2YXIgcWc9ZnVuY3Rpb24oYSl7YT1hLnNwbGl0KFwiLlwiKTtpZigzIT1hLmxlbmd0aClyZXR1cm4gbnVsbDthPWFbMV07Zm9yKHZhciBiPSg0LWEubGVuZ3RoJTQpJTQsYz0wO2M8YjtjKyspYSs9XCIuXCI7dHJ5e3ZhciBkPUpTT04ucGFyc2UoSGIoYSkpO2lmKGQuc3ViJiZkLmlzcyYmZC5hdWQmJmQuZXhwKXJldHVybiBuZXcgcGcoZCl9Y2F0Y2goZSl7fXJldHVybiBudWxsfTt2YXIgcmc9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS50aGVuKGZ1bmN0aW9uKGEpe2lmKGEuaWRUb2tlbil7dmFyIGM9cWcoYS5pZFRva2VuKTtpZighY3x8YiE9Yy5aZil0aHJvdyBuZXcgTyhcInVzZXItbWlzbWF0Y2hcIik7cmV0dXJuIGF9dGhyb3cgbmV3IE8oXCJ1c2VyLW1pc21hdGNoXCIpO30pLmcoZnVuY3Rpb24oYSl7dGhyb3cgYSYmYS5jb2RlJiZcImF1dGgvdXNlci1ub3QtZm91bmRcIj09YS5jb2RlP25ldyBPKFwidXNlci1taXNtYXRjaFwiKTphO30pfSxzZz1mdW5jdGlvbihhLGIpe2lmKGIuaWRUb2tlbnx8Yi5hY2Nlc3NUb2tlbiliLmlkVG9rZW4mJk4odGhpcyxcImlkVG9rZW5cIixiLmlkVG9rZW4pLGIuYWNjZXNzVG9rZW4mJk4odGhpcyxcImFjY2Vzc1Rva2VuXCIsYi5hY2Nlc3NUb2tlbik7ZWxzZSBpZihiLm9hdXRoVG9rZW4mJmIub2F1dGhUb2tlblNlY3JldClOKHRoaXMsXCJhY2Nlc3NUb2tlblwiLGIub2F1dGhUb2tlbiksTih0aGlzLFwic2VjcmV0XCIsYi5vYXV0aFRva2VuU2VjcmV0KTtcbmVsc2UgdGhyb3cgbmV3IE8oXCJpbnRlcm5hbC1lcnJvclwiLFwiZmFpbGVkIHRvIGNvbnN0cnVjdCBhIGNyZWRlbnRpYWxcIik7Tih0aGlzLFwicHJvdmlkZXJJZFwiLGEpfTtzZy5wcm90b3R5cGUuT2I9ZnVuY3Rpb24oYSl7cmV0dXJuIHRnKGEsdWcodGhpcykpfTtzZy5wcm90b3R5cGUuRmM9ZnVuY3Rpb24oYSxiKXt2YXIgYz11Zyh0aGlzKTtjLmlkVG9rZW49YjtyZXR1cm4gdmcoYSxjKX07c2cucHJvdG90eXBlLkdkPWZ1bmN0aW9uKGEsYil7dmFyIGM9dWcodGhpcyk7cmV0dXJuIHJnKHdnKGEsYyksYil9O3ZhciB1Zz1mdW5jdGlvbihhKXt2YXIgYj17fTthLmlkVG9rZW4mJihiLmlkX3Rva2VuPWEuaWRUb2tlbik7YS5hY2Nlc3NUb2tlbiYmKGIuYWNjZXNzX3Rva2VuPWEuYWNjZXNzVG9rZW4pO2Euc2VjcmV0JiYoYi5vYXV0aF90b2tlbl9zZWNyZXQ9YS5zZWNyZXQpO2IucHJvdmlkZXJJZD1hLnByb3ZpZGVySWQ7cmV0dXJue3Bvc3RCb2R5Om1mKGIpLnRvU3RyaW5nKCkscmVxdWVzdFVyaTpcImh0dHA6Ly9sb2NhbGhvc3RcIn19O1xuc2cucHJvdG90eXBlLkE9ZnVuY3Rpb24oKXt2YXIgYT17cHJvdmlkZXJJZDp0aGlzLnByb3ZpZGVySWR9O3RoaXMuaWRUb2tlbiYmKGEub2F1dGhJZFRva2VuPXRoaXMuaWRUb2tlbik7dGhpcy5hY2Nlc3NUb2tlbiYmKGEub2F1dGhBY2Nlc3NUb2tlbj10aGlzLmFjY2Vzc1Rva2VuKTt0aGlzLnNlY3JldCYmKGEub2F1dGhUb2tlblNlY3JldD10aGlzLnNlY3JldCk7cmV0dXJuIGF9O3ZhciB4Zz1mdW5jdGlvbihhLGIpe3RoaXMua2c9Ynx8W107YmcodGhpcyx7cHJvdmlkZXJJZDphLGlzT0F1dGhQcm92aWRlcjohMH0pO3RoaXMucWU9e307dGhpcy5FZD0oamcoYSl8fHt9KS5EY3x8bnVsbDt0aGlzLm5kPW51bGx9O3hnLnByb3RvdHlwZS5zZXRDdXN0b21QYXJhbWV0ZXJzPWZ1bmN0aW9uKGEpe3RoaXMucWU9a2IoYSk7cmV0dXJuIHRoaXN9O3ZhciBQPWZ1bmN0aW9uKGEpe3hnLmNhbGwodGhpcyxhLGhnKTt0aGlzLlZkPVtdfTt0KFAseGcpO1xuUC5wcm90b3R5cGUuYWRkU2NvcGU9ZnVuY3Rpb24oYSl7VmEodGhpcy5WZCxhKXx8dGhpcy5WZC5wdXNoKGEpO3JldHVybiB0aGlzfTtQLnByb3RvdHlwZS55ZT1mdW5jdGlvbigpe3JldHVybiAkYSh0aGlzLlZkKX07UC5wcm90b3R5cGUuY3JlZGVudGlhbD1mdW5jdGlvbihhLGIpe2lmKCFhJiYhYil0aHJvdyBuZXcgTyhcImFyZ3VtZW50LWVycm9yXCIsXCJjcmVkZW50aWFsIGZhaWxlZDogbXVzdCBwcm92aWRlIHRoZSBJRCB0b2tlbiBhbmQvb3IgdGhlIGFjY2VzcyB0b2tlbi5cIik7cmV0dXJuIG5ldyBzZyh0aGlzLnByb3ZpZGVySWQse2lkVG9rZW46YXx8bnVsbCxhY2Nlc3NUb2tlbjpifHxudWxsfSl9O3ZhciB5Zz1mdW5jdGlvbigpe1AuY2FsbCh0aGlzLFwiZmFjZWJvb2suY29tXCIpfTt0KHlnLFApO04oeWcsXCJQUk9WSURFUl9JRFwiLFwiZmFjZWJvb2suY29tXCIpO1xudmFyIHpnPWZ1bmN0aW9uKGEpe2lmKCFhKXRocm93IG5ldyBPKFwiYXJndW1lbnQtZXJyb3JcIixcImNyZWRlbnRpYWwgZmFpbGVkOiBleHBlY3RlZCAxIGFyZ3VtZW50ICh0aGUgT0F1dGggYWNjZXNzIHRva2VuKS5cIik7dmFyIGI9YTtxKGEpJiYoYj1hLmFjY2Vzc1Rva2VuKTtyZXR1cm4obmV3IHlnKS5jcmVkZW50aWFsKG51bGwsYil9LEFnPWZ1bmN0aW9uKCl7UC5jYWxsKHRoaXMsXCJnaXRodWIuY29tXCIpfTt0KEFnLFApO04oQWcsXCJQUk9WSURFUl9JRFwiLFwiZ2l0aHViLmNvbVwiKTt2YXIgQmc9ZnVuY3Rpb24oYSl7aWYoIWEpdGhyb3cgbmV3IE8oXCJhcmd1bWVudC1lcnJvclwiLFwiY3JlZGVudGlhbCBmYWlsZWQ6IGV4cGVjdGVkIDEgYXJndW1lbnQgKHRoZSBPQXV0aCBhY2Nlc3MgdG9rZW4pLlwiKTt2YXIgYj1hO3EoYSkmJihiPWEuYWNjZXNzVG9rZW4pO3JldHVybihuZXcgQWcpLmNyZWRlbnRpYWwobnVsbCxiKX0sQ2c9ZnVuY3Rpb24oKXtQLmNhbGwodGhpcyxcImdvb2dsZS5jb21cIik7dGhpcy5hZGRTY29wZShcInByb2ZpbGVcIil9O1xudChDZyxQKTtOKENnLFwiUFJPVklERVJfSURcIixcImdvb2dsZS5jb21cIik7dmFyIERnPWZ1bmN0aW9uKGEsYil7dmFyIGM9YTtxKGEpJiYoYz1hLmlkVG9rZW4sYj1hLmFjY2Vzc1Rva2VuKTtyZXR1cm4obmV3IENnKS5jcmVkZW50aWFsKGMsYil9LEVnPWZ1bmN0aW9uKCl7eGcuY2FsbCh0aGlzLFwidHdpdHRlci5jb21cIixnZyl9O3QoRWcseGcpO04oRWcsXCJQUk9WSURFUl9JRFwiLFwidHdpdHRlci5jb21cIik7XG52YXIgRmc9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hO3EoYyl8fChjPXtvYXV0aFRva2VuOmEsb2F1dGhUb2tlblNlY3JldDpifSk7aWYoIWMub2F1dGhUb2tlbnx8IWMub2F1dGhUb2tlblNlY3JldCl0aHJvdyBuZXcgTyhcImFyZ3VtZW50LWVycm9yXCIsXCJjcmVkZW50aWFsIGZhaWxlZDogZXhwZWN0ZWQgMiBhcmd1bWVudHMgKHRoZSBPQXV0aCBhY2Nlc3MgdG9rZW4gYW5kIHNlY3JldCkuXCIpO3JldHVybiBuZXcgc2coXCJ0d2l0dGVyLmNvbVwiLGMpfSxHZz1mdW5jdGlvbihhLGIpe3RoaXMuTWI9YTt0aGlzLkxkPWI7Tih0aGlzLFwicHJvdmlkZXJJZFwiLFwicGFzc3dvcmRcIil9O0dnLnByb3RvdHlwZS5PYj1mdW5jdGlvbihhKXtyZXR1cm4gUShhLEhnLHtlbWFpbDp0aGlzLk1iLHBhc3N3b3JkOnRoaXMuTGR9KX07R2cucHJvdG90eXBlLkZjPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFEoYSxJZyx7aWRUb2tlbjpiLGVtYWlsOnRoaXMuTWIscGFzc3dvcmQ6dGhpcy5MZH0pfTtcbkdnLnByb3RvdHlwZS5HZD1mdW5jdGlvbihhLGIpe3JldHVybiByZyh0aGlzLk9iKGEpLGIpfTtHZy5wcm90b3R5cGUuQT1mdW5jdGlvbigpe3JldHVybntlbWFpbDp0aGlzLk1iLHBhc3N3b3JkOnRoaXMuTGR9fTt2YXIgSmc9ZnVuY3Rpb24oKXtiZyh0aGlzLHtwcm92aWRlcklkOlwicGFzc3dvcmRcIixpc09BdXRoUHJvdmlkZXI6ITF9KX07YmcoSmcse1BST1ZJREVSX0lEOlwicGFzc3dvcmRcIn0pO3ZhciBLZz1mdW5jdGlvbihhKXtpZighKGEudmVyaWZpY2F0aW9uSWQmJmEuJGN8fGEuaGMmJmEucGhvbmVOdW1iZXIpKXRocm93IG5ldyBPKFwiaW50ZXJuYWwtZXJyb3JcIik7dGhpcy5VPWE7Tih0aGlzLFwicHJvdmlkZXJJZFwiLFwicGhvbmVcIil9O0tnLnByb3RvdHlwZS5PYj1mdW5jdGlvbihhKXtyZXR1cm4gYS52ZXJpZnlQaG9uZU51bWJlcihMZyh0aGlzKSl9O0tnLnByb3RvdHlwZS5GYz1mdW5jdGlvbihhLGIpe3ZhciBjPUxnKHRoaXMpO2MuaWRUb2tlbj1iO3JldHVybiBRKGEsTWcsYyl9O1xuS2cucHJvdG90eXBlLkdkPWZ1bmN0aW9uKGEsYil7dmFyIGM9TGcodGhpcyk7Yy5vcGVyYXRpb249XCJSRUFVVEhcIjthPVEoYSxOZyxjKTtyZXR1cm4gcmcoYSxiKX07S2cucHJvdG90eXBlLkE9ZnVuY3Rpb24oKXt2YXIgYT17cHJvdmlkZXJJZDpcInBob25lXCJ9O3RoaXMuVS52ZXJpZmljYXRpb25JZCYmKGEudmVyaWZpY2F0aW9uSWQ9dGhpcy5VLnZlcmlmaWNhdGlvbklkKTt0aGlzLlUuJGMmJihhLnZlcmlmaWNhdGlvbkNvZGU9dGhpcy5VLiRjKTt0aGlzLlUuaGMmJihhLnRlbXBvcmFyeVByb29mPXRoaXMuVS5oYyk7dGhpcy5VLnBob25lTnVtYmVyJiYoYS5waG9uZU51bWJlcj10aGlzLlUucGhvbmVOdW1iZXIpO3JldHVybiBhfTtcbnZhciBMZz1mdW5jdGlvbihhKXtyZXR1cm4gYS5VLmhjJiZhLlUucGhvbmVOdW1iZXI/e3RlbXBvcmFyeVByb29mOmEuVS5oYyxwaG9uZU51bWJlcjphLlUucGhvbmVOdW1iZXJ9OntzZXNzaW9uSW5mbzphLlUudmVyaWZpY2F0aW9uSWQsY29kZTphLlUuJGN9fSxPZz1mdW5jdGlvbihhKXt0cnl7dGhpcy50Zj1hfHxmaXJlYmFzZS5hdXRoKCl9Y2F0Y2goYil7dGhyb3cgbmV3IE8oXCJhcmd1bWVudC1lcnJvclwiLFwiRWl0aGVyIGFuIGluc3RhbmNlIG9mIGZpcmViYXNlLmF1dGguQXV0aCBtdXN0IGJlIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgZmlyZWJhc2UuYXV0aC5QaG9uZUF1dGhQcm92aWRlciBjb25zdHJ1Y3Rvciwgb3IgdGhlIGRlZmF1bHQgZmlyZWJhc2UgQXBwIGluc3RhbmNlIG11c3QgYmUgaW5pdGlhbGl6ZWQgdmlhIGZpcmViYXNlLmluaXRpYWxpemVBcHAoKS5cIik7fWJnKHRoaXMse3Byb3ZpZGVySWQ6XCJwaG9uZVwiLGlzT0F1dGhQcm92aWRlcjohMX0pfTtcbk9nLnByb3RvdHlwZS52ZXJpZnlQaG9uZU51bWJlcj1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMudGYuZjtyZXR1cm4gRChiLnZlcmlmeSgpKS50aGVuKGZ1bmN0aW9uKGQpe2lmKCFtKGQpKXRocm93IG5ldyBPKFwiYXJndW1lbnQtZXJyb3JcIixcIkFuIGltcGxlbWVudGF0aW9uIG9mIGZpcmViYXNlLmF1dGguQXBwbGljYXRpb25WZXJpZmllci5wcm90b3R5cGUudmVyaWZ5KCkgbXVzdCByZXR1cm4gYSBmaXJlYmFzZS5Qcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIHN0cmluZy5cIik7c3dpdGNoKGIudHlwZSl7Y2FzZSBcInJlY2FwdGNoYVwiOnJldHVybiBRKGMsUGcse3Bob25lTnVtYmVyOmEscmVjYXB0Y2hhVG9rZW46ZH0pO2RlZmF1bHQ6dGhyb3cgbmV3IE8oXCJhcmd1bWVudC1lcnJvclwiLCdPbmx5IGZpcmViYXNlLmF1dGguQXBwbGljYXRpb25WZXJpZmllcnMgd2l0aCB0eXBlPVwicmVjYXB0Y2hhXCIgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQuJyk7fX0pfTtcbnZhciBRZz1mdW5jdGlvbihhLGIpe2lmKCFhKXRocm93IG5ldyBPKFwibWlzc2luZy12ZXJpZmljYXRpb24taWRcIik7aWYoIWIpdGhyb3cgbmV3IE8oXCJtaXNzaW5nLXZlcmlmaWNhdGlvbi1jb2RlXCIpO3JldHVybiBuZXcgS2coe3ZlcmlmaWNhdGlvbklkOmEsJGM6Yn0pfTtiZyhPZyx7UFJPVklERVJfSUQ6XCJwaG9uZVwifSk7XG52YXIgUmc9ZnVuY3Rpb24oYSl7aWYoYS50ZW1wb3JhcnlQcm9vZiYmYS5waG9uZU51bWJlcilyZXR1cm4gbmV3IEtnKHtoYzphLnRlbXBvcmFyeVByb29mLHBob25lTnVtYmVyOmEucGhvbmVOdW1iZXJ9KTt2YXIgYj1hJiZhLnByb3ZpZGVySWQ7aWYoIWJ8fFwicGFzc3dvcmRcIj09PWIpcmV0dXJuIG51bGw7dmFyIGM9YSYmYS5vYXV0aEFjY2Vzc1Rva2VuLGQ9YSYmYS5vYXV0aFRva2VuU2VjcmV0O2E9YSYmYS5vYXV0aElkVG9rZW47dHJ5e3N3aXRjaChiKXtjYXNlIFwiZ29vZ2xlLmNvbVwiOnJldHVybiBEZyhhLGMpO2Nhc2UgXCJmYWNlYm9vay5jb21cIjpyZXR1cm4gemcoYyk7Y2FzZSBcImdpdGh1Yi5jb21cIjpyZXR1cm4gQmcoYyk7Y2FzZSBcInR3aXR0ZXIuY29tXCI6cmV0dXJuIEZnKGMsZCk7ZGVmYXVsdDpyZXR1cm4obmV3IFAoYikpLmNyZWRlbnRpYWwoYSxjKX19Y2F0Y2goZSl7cmV0dXJuIG51bGx9fSxTZz1mdW5jdGlvbihhKXtpZighYS5pc09BdXRoUHJvdmlkZXIpdGhyb3cgbmV3IE8oXCJpbnZhbGlkLW9hdXRoLXByb3ZpZGVyXCIpO1xufTt2YXIgVGc9ZnVuY3Rpb24oYSxiLGMpe08uY2FsbCh0aGlzLGEsYyk7YT1ifHx7fTthLmVtYWlsJiZOKHRoaXMsXCJlbWFpbFwiLGEuZW1haWwpO2EucGhvbmVOdW1iZXImJk4odGhpcyxcInBob25lTnVtYmVyXCIsYS5waG9uZU51bWJlcik7YS5jcmVkZW50aWFsJiZOKHRoaXMsXCJjcmVkZW50aWFsXCIsYS5jcmVkZW50aWFsKX07dChUZyxPKTtUZy5wcm90b3R5cGUuQT1mdW5jdGlvbigpe3ZhciBhPXtjb2RlOnRoaXMuY29kZSxtZXNzYWdlOnRoaXMubWVzc2FnZX07dGhpcy5lbWFpbCYmKGEuZW1haWw9dGhpcy5lbWFpbCk7dGhpcy5waG9uZU51bWJlciYmKGEucGhvbmVOdW1iZXI9dGhpcy5waG9uZU51bWJlcik7dmFyIGI9dGhpcy5jcmVkZW50aWFsJiZ0aGlzLmNyZWRlbnRpYWwuQSgpO2ImJm1iKGEsYik7cmV0dXJuIGF9O1RnLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5BKCl9O1xudmFyIFVnPWZ1bmN0aW9uKGEpe2lmKGEuY29kZSl7dmFyIGI9YS5jb2RlfHxcIlwiOzA9PWIuaW5kZXhPZihcImF1dGgvXCIpJiYoYj1iLnN1YnN0cmluZyg1KSk7dmFyIGM9e2NyZWRlbnRpYWw6UmcoYSl9O2lmKGEuZW1haWwpYy5lbWFpbD1hLmVtYWlsO2Vsc2UgaWYoYS5waG9uZU51bWJlciljLnBob25lTnVtYmVyPWEucGhvbmVOdW1iZXI7ZWxzZSByZXR1cm4gbmV3IE8oYixhLm1lc3NhZ2V8fHZvaWQgMCk7cmV0dXJuIG5ldyBUZyhiLGMsYS5tZXNzYWdlKX1yZXR1cm4gbnVsbH07dmFyIFZnPWZ1bmN0aW9uKGEpe3RoaXMuRWc9YX07dChWZyxMYyk7VmcucHJvdG90eXBlLnJjPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB0aGlzLkVnfTtWZy5wcm90b3R5cGUuQ2Q9ZnVuY3Rpb24oKXtyZXR1cm57fX07XG52YXIgUj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9XCJOb2RlXCI9PUdmKCk7ZD1rLlhNTEh0dHBSZXF1ZXN0fHxkJiZmaXJlYmFzZS5JTlRFUk5BTC5ub2RlJiZmaXJlYmFzZS5JTlRFUk5BTC5ub2RlLlhNTEh0dHBSZXF1ZXN0O2lmKCFkKXRocm93IG5ldyBPKFwiaW50ZXJuYWwtZXJyb3JcIixcIlRoZSBYTUxIdHRwUmVxdWVzdCBjb21wYXRpYmlsaXR5IGxpYnJhcnkgd2FzIG5vdCBmb3VuZC5cIik7dGhpcy5tPWE7YT1ifHx7fTt0aGlzLnFnPWEuc2VjdXJlVG9rZW5FbmRwb2ludHx8XCJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZWFwaXMuY29tL3YxL3Rva2VuXCI7dGhpcy5yZz1hLnNlY3VyZVRva2VuVGltZW91dHx8V2c7dGhpcy5QYz1rYihhLnNlY3VyZVRva2VuSGVhZGVyc3x8WGcpO3RoaXMuRGY9YS5maXJlYmFzZUVuZHBvaW50fHxcImh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2lkZW50aXR5dG9vbGtpdC92My9yZWx5aW5ncGFydHkvXCI7dGhpcy5FZj1hLmZpcmViYXNlVGltZW91dHx8XG5ZZzt0aGlzLm1iPWtiKGEuZmlyZWJhc2VIZWFkZXJzfHxaZyk7YyYmKHRoaXMubWJbXCJYLUNsaWVudC1WZXJzaW9uXCJdPWMsdGhpcy5QY1tcIlgtQ2xpZW50LVZlcnNpb25cIl09Yyk7dGhpcy52Zj1uZXcgUWM7dGhpcy5EZz1uZXcgVmcoZCl9LCRnLFdnPW5ldyBWZigzRTQsNkU0KSxYZz17XCJDb250ZW50LVR5cGVcIjpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwifSxZZz1uZXcgVmYoM0U0LDZFNCksWmc9e1wiQ29udGVudC1UeXBlXCI6XCJhcHBsaWNhdGlvbi9qc29uXCJ9LGFoPWZ1bmN0aW9uKGEsYil7Yj9hLm1iW1wiWC1GaXJlYmFzZS1Mb2NhbGVcIl09YjpkZWxldGUgYS5tYltcIlgtRmlyZWJhc2UtTG9jYWxlXCJdfSxiaD1mdW5jdGlvbihhLGIpe2I/KGEubWJbXCJYLUNsaWVudC1WZXJzaW9uXCJdPWIsYS5QY1tcIlgtQ2xpZW50LVZlcnNpb25cIl09Yik6KGRlbGV0ZSBhLm1iW1wiWC1DbGllbnQtVmVyc2lvblwiXSxkZWxldGUgYS5QY1tcIlgtQ2xpZW50LVZlcnNpb25cIl0pfSxkaD1mdW5jdGlvbihhLFxuYixjLGQsZSxmLGcpe1VmKCk/KHZmKCk/YT1yKGEudGcsYSk6KCRnfHwoJGc9bmV3IEMoZnVuY3Rpb24oYSxiKXtjaChhLGIpfSkpLGE9cihhLnNnLGEpKSxhKGIsYyxkLGUsZixnKSk6YyYmYyhudWxsKX07XG5SLnByb3RvdHlwZS50Zz1mdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGc9XCJOb2RlXCI9PUdmKCksbD1IZigpP2c/bmV3IEkodGhpcy5EZyk6bmV3IEk6bmV3IEkodGhpcy52Zik7aWYoZil7bC5EYj1NYXRoLm1heCgwLGYpO3ZhciBuPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtsLmRpc3BhdGNoRXZlbnQoXCJ0aW1lb3V0XCIpfSxmKX1sLmxpc3RlbihcImNvbXBsZXRlXCIsZnVuY3Rpb24oKXtuJiZjbGVhclRpbWVvdXQobik7dmFyIGE9bnVsbDt0cnl7YT1KU09OLnBhcnNlKFJlKHRoaXMpKXx8bnVsbH1jYXRjaCh6Yil7YT1udWxsfWImJmIoYSl9KTtzYyhsLFwicmVhZHlcIixmdW5jdGlvbigpe24mJmNsZWFyVGltZW91dChuKTt0aGlzLk1hfHwodGhpcy5NYT0hMCx0aGlzLmxiKCkpfSk7c2MobCxcInRpbWVvdXRcIixmdW5jdGlvbigpe24mJmNsZWFyVGltZW91dChuKTt0aGlzLk1hfHwodGhpcy5NYT0hMCx0aGlzLmxiKCkpO2ImJmIobnVsbCl9KTtsLnNlbmQoYSxjLGQsZSl9O1xudmFyIGVoPUhhKFwiaHR0cHM6Ly9hcGlzLmdvb2dsZS5jb20vanMvY2xpZW50LmpzP29ubG9hZD0le29ubG9hZH1cIiksZmg9XCJfX2ZjYlwiK01hdGguZmxvb3IoMUU2Kk1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKCksY2g9ZnVuY3Rpb24oYSxiKXtpZigoKHdpbmRvdy5nYXBpfHx7fSkuY2xpZW50fHx7fSkucmVxdWVzdClhKCk7ZWxzZXtrW2ZoXT1mdW5jdGlvbigpeygod2luZG93LmdhcGl8fHt9KS5jbGllbnR8fHt9KS5yZXF1ZXN0P2EoKTpiKEVycm9yKFwiQ09SU19VTlNVUFBPUlRFRFwiKSl9O3ZhciBjPU9hKGVoLHtvbmxvYWQ6Zmh9KTtXZChkZShjKSxmdW5jdGlvbigpe2IoRXJyb3IoXCJDT1JTX1VOU1VQUE9SVEVEXCIpKX0pfX07XG5SLnByb3RvdHlwZS5zZz1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPXRoaXM7JGcudGhlbihmdW5jdGlvbigpe3dpbmRvdy5nYXBpLmNsaWVudC5zZXRBcGlLZXkoZi5tKTt2YXIgZz13aW5kb3cuZ2FwaS5hdXRoLmdldFRva2VuKCk7d2luZG93LmdhcGkuYXV0aC5zZXRUb2tlbihudWxsKTt3aW5kb3cuZ2FwaS5jbGllbnQucmVxdWVzdCh7cGF0aDphLG1ldGhvZDpjLGJvZHk6ZCxoZWFkZXJzOmUsYXV0aFR5cGU6XCJub25lXCIsY2FsbGJhY2s6ZnVuY3Rpb24oYSl7d2luZG93LmdhcGkuYXV0aC5zZXRUb2tlbihnKTtiJiZiKGEpfX0pfSkuZyhmdW5jdGlvbihhKXtiJiZiKHtlcnJvcjp7bWVzc2FnZTphJiZhLm1lc3NhZ2V8fFwiQ09SU19VTlNVUFBPUlRFRFwifX0pfSl9O1xudmFyIGhoPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBDKGZ1bmN0aW9uKGMsZCl7XCJyZWZyZXNoX3Rva2VuXCI9PWIuZ3JhbnRfdHlwZSYmYi5yZWZyZXNoX3Rva2VufHxcImF1dGhvcml6YXRpb25fY29kZVwiPT1iLmdyYW50X3R5cGUmJmIuY29kZT9kaChhLGEucWcrXCI/a2V5PVwiK2VuY29kZVVSSUNvbXBvbmVudChhLm0pLGZ1bmN0aW9uKGEpe2E/YS5lcnJvcj9kKGdoKGEpKTphLmFjY2Vzc190b2tlbiYmYS5yZWZyZXNoX3Rva2VuP2MoYSk6ZChuZXcgTyhcImludGVybmFsLWVycm9yXCIpKTpkKG5ldyBPKFwibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiKSl9LFwiUE9TVFwiLG1mKGIpLnRvU3RyaW5nKCksYS5QYyxhLnJnLmdldCgpKTpkKG5ldyBPKFwiaW50ZXJuYWwtZXJyb3JcIikpfSl9LGloPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZz1nZihhLkRmK2IpO0soZyxcImtleVwiLGEubSk7ZiYmSyhnLFwiY2JcIixtYSgpLnRvU3RyaW5nKCkpO3ZhciBsPVwiR0VUXCI9PWM7aWYobClmb3IodmFyIG4gaW4gZClkLmhhc093blByb3BlcnR5KG4pJiZcbksoZyxuLGRbbl0pO3JldHVybiBuZXcgQyhmdW5jdGlvbihiLGYpe2RoKGEsZy50b1N0cmluZygpLGZ1bmN0aW9uKGEpe2E/YS5lcnJvcj9mKGdoKGEsZXx8e30pKTpiKGEpOmYobmV3IE8oXCJuZXR3b3JrLXJlcXVlc3QtZmFpbGVkXCIpKX0sYyxsP3ZvaWQgMDpIYyhRZihkKSksYS5tYixhLkVmLmdldCgpKX0pfSxqaD1mdW5jdGlvbihhKXtpZigheWMudGVzdChhLmVtYWlsKSl0aHJvdyBuZXcgTyhcImludmFsaWQtZW1haWxcIik7fSxraD1mdW5jdGlvbihhKXtcImVtYWlsXCJpbiBhJiZqaChhKX0sbWg9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gUShhLGxoLHtpZGVudGlmaWVyOmIsY29udGludWVVcmk6TWYoKT9yZigpOlwiaHR0cDovL2xvY2FsaG9zdFwifSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gYS5hbGxQcm92aWRlcnN8fFtdfSl9LG9oPWZ1bmN0aW9uKGEpe3JldHVybiBRKGEsbmgse30pLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGEuYXV0aG9yaXplZERvbWFpbnN8fFtdfSl9LHBoPWZ1bmN0aW9uKGEpe2lmKCFhLmlkVG9rZW4pdGhyb3cgbmV3IE8oXCJpbnRlcm5hbC1lcnJvclwiKTtcbn0scWg9ZnVuY3Rpb24oYSl7aWYoYS5waG9uZU51bWJlcnx8YS50ZW1wb3JhcnlQcm9vZil7aWYoIWEucGhvbmVOdW1iZXJ8fCFhLnRlbXBvcmFyeVByb29mKXRocm93IG5ldyBPKFwiaW50ZXJuYWwtZXJyb3JcIik7fWVsc2V7aWYoIWEuc2Vzc2lvbkluZm8pdGhyb3cgbmV3IE8oXCJtaXNzaW5nLXZlcmlmaWNhdGlvbi1pZFwiKTtpZighYS5jb2RlKXRocm93IG5ldyBPKFwibWlzc2luZy12ZXJpZmljYXRpb24tY29kZVwiKTt9fTtSLnByb3RvdHlwZS5zaWduSW5Bbm9ueW1vdXNseT1mdW5jdGlvbigpe3JldHVybiBRKHRoaXMscmgse30pfTtSLnByb3RvdHlwZS51cGRhdGVFbWFpbD1mdW5jdGlvbihhLGIpe3JldHVybiBRKHRoaXMsc2gse2lkVG9rZW46YSxlbWFpbDpifSl9O1IucHJvdG90eXBlLnVwZGF0ZVBhc3N3b3JkPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFEodGhpcyxJZyx7aWRUb2tlbjphLHBhc3N3b3JkOmJ9KX07dmFyIHRoPXtkaXNwbGF5TmFtZTpcIkRJU1BMQVlfTkFNRVwiLHBob3RvVXJsOlwiUEhPVE9fVVJMXCJ9O1xuUi5wcm90b3R5cGUudXBkYXRlUHJvZmlsZT1mdW5jdGlvbihhLGIpe3ZhciBjPXtpZFRva2VuOmF9LGQ9W107ZWIodGgsZnVuY3Rpb24oYSxmKXt2YXIgZT1iW2ZdO251bGw9PT1lP2QucHVzaChhKTpmIGluIGImJihjW2ZdPWUpfSk7ZC5sZW5ndGgmJihjLmRlbGV0ZUF0dHJpYnV0ZT1kKTtyZXR1cm4gUSh0aGlzLHNoLGMpfTtSLnByb3RvdHlwZS5zZW5kUGFzc3dvcmRSZXNldEVtYWlsPWZ1bmN0aW9uKGEsYil7YT17cmVxdWVzdFR5cGU6XCJQQVNTV09SRF9SRVNFVFwiLGVtYWlsOmF9O21iKGEsYik7cmV0dXJuIFEodGhpcyx1aCxhKX07Ui5wcm90b3R5cGUuc2VuZEVtYWlsVmVyaWZpY2F0aW9uPWZ1bmN0aW9uKGEsYil7YT17cmVxdWVzdFR5cGU6XCJWRVJJRllfRU1BSUxcIixpZFRva2VuOmF9O21iKGEsYik7cmV0dXJuIFEodGhpcyx2aCxhKX07Ui5wcm90b3R5cGUudmVyaWZ5UGhvbmVOdW1iZXI9ZnVuY3Rpb24oYSl7cmV0dXJuIFEodGhpcyx3aCxhKX07XG52YXIgeWg9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBRKGEseGgse2lkVG9rZW46YixkZWxldGVQcm92aWRlcjpjfSl9LHpoPWZ1bmN0aW9uKGEpe2lmKCFhLnJlcXVlc3RVcml8fCFhLnNlc3Npb25JZCYmIWEucG9zdEJvZHkpdGhyb3cgbmV3IE8oXCJpbnRlcm5hbC1lcnJvclwiKTt9LEFoPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7YS5uZWVkQ29uZmlybWF0aW9uPyhhLmNvZGU9XCJhY2NvdW50LWV4aXN0cy13aXRoLWRpZmZlcmVudC1jcmVkZW50aWFsXCIsYj1VZyhhKSk6XCJGRURFUkFURURfVVNFUl9JRF9BTFJFQURZX0xJTktFRFwiPT1hLmVycm9yTWVzc2FnZT8oYS5jb2RlPVwiY3JlZGVudGlhbC1hbHJlYWR5LWluLXVzZVwiLGI9VWcoYSkpOlwiRU1BSUxfRVhJU1RTXCI9PWEuZXJyb3JNZXNzYWdlJiYoYS5jb2RlPVwiZW1haWwtYWxyZWFkeS1pbi11c2VcIixiPVVnKGEpKTtpZihiKXRocm93IGI7aWYoIWEuaWRUb2tlbil0aHJvdyBuZXcgTyhcImludGVybmFsLWVycm9yXCIpO30sdGc9ZnVuY3Rpb24oYSxcbmIpe2IucmV0dXJuSWRwQ3JlZGVudGlhbD0hMDtyZXR1cm4gUShhLEJoLGIpfSx2Zz1mdW5jdGlvbihhLGIpe2IucmV0dXJuSWRwQ3JlZGVudGlhbD0hMDtyZXR1cm4gUShhLENoLGIpfSx3Zz1mdW5jdGlvbihhLGIpe2IucmV0dXJuSWRwQ3JlZGVudGlhbD0hMDtiLmF1dG9DcmVhdGU9ITE7cmV0dXJuIFEoYSxEaCxiKX0sRWg9ZnVuY3Rpb24oYSl7aWYoIWEub29iQ29kZSl0aHJvdyBuZXcgTyhcImludmFsaWQtYWN0aW9uLWNvZGVcIik7fTtSLnByb3RvdHlwZS5jb25maXJtUGFzc3dvcmRSZXNldD1mdW5jdGlvbihhLGIpe3JldHVybiBRKHRoaXMsRmgse29vYkNvZGU6YSxuZXdQYXNzd29yZDpifSl9O1IucHJvdG90eXBlLmNoZWNrQWN0aW9uQ29kZT1mdW5jdGlvbihhKXtyZXR1cm4gUSh0aGlzLEdoLHtvb2JDb2RlOmF9KX07Ui5wcm90b3R5cGUuYXBwbHlBY3Rpb25Db2RlPWZ1bmN0aW9uKGEpe3JldHVybiBRKHRoaXMsSGgse29vYkNvZGU6YX0pfTtcbnZhciBIaD17ZW5kcG9pbnQ6XCJzZXRBY2NvdW50SW5mb1wiLEY6RWgsY2I6XCJlbWFpbFwifSxHaD17ZW5kcG9pbnQ6XCJyZXNldFBhc3N3b3JkXCIsRjpFaCwkOmZ1bmN0aW9uKGEpe2lmKCFhLmVtYWlsfHwhYS5yZXF1ZXN0VHlwZSl0aHJvdyBuZXcgTyhcImludGVybmFsLWVycm9yXCIpO319LEloPXtlbmRwb2ludDpcInNpZ251cE5ld1VzZXJcIixGOmZ1bmN0aW9uKGEpe2poKGEpO2lmKCFhLnBhc3N3b3JkKXRocm93IG5ldyBPKFwid2Vhay1wYXNzd29yZFwiKTt9LCQ6cGgsQWE6ITB9LGxoPXtlbmRwb2ludDpcImNyZWF0ZUF1dGhVcmlcIn0sSmg9e2VuZHBvaW50OlwiZGVsZXRlQWNjb3VudFwiLGFiOltcImlkVG9rZW5cIl19LHhoPXtlbmRwb2ludDpcInNldEFjY291bnRJbmZvXCIsYWI6W1wiaWRUb2tlblwiLFwiZGVsZXRlUHJvdmlkZXJcIl0sRjpmdW5jdGlvbihhKXtpZighaGEoYS5kZWxldGVQcm92aWRlcikpdGhyb3cgbmV3IE8oXCJpbnRlcm5hbC1lcnJvclwiKTt9fSxLaD17ZW5kcG9pbnQ6XCJnZXRBY2NvdW50SW5mb1wifSxcbnZoPXtlbmRwb2ludDpcImdldE9vYkNvbmZpcm1hdGlvbkNvZGVcIixhYjpbXCJpZFRva2VuXCIsXCJyZXF1ZXN0VHlwZVwiXSxGOmZ1bmN0aW9uKGEpe2lmKFwiVkVSSUZZX0VNQUlMXCIhPWEucmVxdWVzdFR5cGUpdGhyb3cgbmV3IE8oXCJpbnRlcm5hbC1lcnJvclwiKTt9LGNiOlwiZW1haWxcIn0sdWg9e2VuZHBvaW50OlwiZ2V0T29iQ29uZmlybWF0aW9uQ29kZVwiLGFiOltcInJlcXVlc3RUeXBlXCJdLEY6ZnVuY3Rpb24oYSl7aWYoXCJQQVNTV09SRF9SRVNFVFwiIT1hLnJlcXVlc3RUeXBlKXRocm93IG5ldyBPKFwiaW50ZXJuYWwtZXJyb3JcIik7amgoYSl9LGNiOlwiZW1haWxcIn0sbmg9e2llOiEwLGVuZHBvaW50OlwiZ2V0UHJvamVjdENvbmZpZ1wiLERlOlwiR0VUXCJ9LExoPXtpZTohMCxlbmRwb2ludDpcImdldFJlY2FwdGNoYVBhcmFtXCIsRGU6XCJHRVRcIiwkOmZ1bmN0aW9uKGEpe2lmKCFhLnJlY2FwdGNoYVNpdGVLZXkpdGhyb3cgbmV3IE8oXCJpbnRlcm5hbC1lcnJvclwiKTt9fSxGaD17ZW5kcG9pbnQ6XCJyZXNldFBhc3N3b3JkXCIsXG5GOkVoLGNiOlwiZW1haWxcIn0sUGc9e2VuZHBvaW50Olwic2VuZFZlcmlmaWNhdGlvbkNvZGVcIixhYjpbXCJwaG9uZU51bWJlclwiLFwicmVjYXB0Y2hhVG9rZW5cIl0sY2I6XCJzZXNzaW9uSW5mb1wifSxzaD17ZW5kcG9pbnQ6XCJzZXRBY2NvdW50SW5mb1wiLGFiOltcImlkVG9rZW5cIl0sRjpraCxBYTohMH0sSWc9e2VuZHBvaW50Olwic2V0QWNjb3VudEluZm9cIixhYjpbXCJpZFRva2VuXCJdLEY6ZnVuY3Rpb24oYSl7a2goYSk7aWYoIWEucGFzc3dvcmQpdGhyb3cgbmV3IE8oXCJ3ZWFrLXBhc3N3b3JkXCIpO30sJDpwaCxBYTohMH0scmg9e2VuZHBvaW50Olwic2lnbnVwTmV3VXNlclwiLCQ6cGgsQWE6ITB9LEJoPXtlbmRwb2ludDpcInZlcmlmeUFzc2VydGlvblwiLEY6emgsJDpBaCxBYTohMH0sRGg9e2VuZHBvaW50OlwidmVyaWZ5QXNzZXJ0aW9uXCIsRjp6aCwkOmZ1bmN0aW9uKGEpe2lmKGEuZXJyb3JNZXNzYWdlJiZcIlVTRVJfTk9UX0ZPVU5EXCI9PWEuZXJyb3JNZXNzYWdlKXRocm93IG5ldyBPKFwidXNlci1ub3QtZm91bmRcIik7XG5pZighYS5pZFRva2VuKXRocm93IG5ldyBPKFwiaW50ZXJuYWwtZXJyb3JcIik7fSxBYTohMH0sQ2g9e2VuZHBvaW50OlwidmVyaWZ5QXNzZXJ0aW9uXCIsRjpmdW5jdGlvbihhKXt6aChhKTtpZighYS5pZFRva2VuKXRocm93IG5ldyBPKFwiaW50ZXJuYWwtZXJyb3JcIik7fSwkOkFoLEFhOiEwfSxNaD17ZW5kcG9pbnQ6XCJ2ZXJpZnlDdXN0b21Ub2tlblwiLEY6ZnVuY3Rpb24oYSl7aWYoIWEudG9rZW4pdGhyb3cgbmV3IE8oXCJpbnZhbGlkLWN1c3RvbS10b2tlblwiKTt9LCQ6cGgsQWE6ITB9LEhnPXtlbmRwb2ludDpcInZlcmlmeVBhc3N3b3JkXCIsRjpmdW5jdGlvbihhKXtqaChhKTtpZighYS5wYXNzd29yZCl0aHJvdyBuZXcgTyhcIndyb25nLXBhc3N3b3JkXCIpO30sJDpwaCxBYTohMH0sd2g9e2VuZHBvaW50OlwidmVyaWZ5UGhvbmVOdW1iZXJcIixGOnFoLCQ6cGh9LE1nPXtlbmRwb2ludDpcInZlcmlmeVBob25lTnVtYmVyXCIsRjpmdW5jdGlvbihhKXtpZighYS5pZFRva2VuKXRocm93IG5ldyBPKFwiaW50ZXJuYWwtZXJyb3JcIik7XG5xaChhKX0sJDpmdW5jdGlvbihhKXtpZihhLnRlbXBvcmFyeVByb29mKXRocm93IGEuY29kZT1cImNyZWRlbnRpYWwtYWxyZWFkeS1pbi11c2VcIixVZyhhKTtwaChhKX19LE5nPXt5Zjp7VVNFUl9OT1RfRk9VTkQ6XCJ1c2VyLW5vdC1mb3VuZFwifSxlbmRwb2ludDpcInZlcmlmeVBob25lTnVtYmVyXCIsRjpxaCwkOnBofSxRPWZ1bmN0aW9uKGEsYixjKXtpZighZWcoYyxiLmFiKSlyZXR1cm4gRShuZXcgTyhcImludGVybmFsLWVycm9yXCIpKTt2YXIgZD1iLkRlfHxcIlBPU1RcIixlO3JldHVybiBEKGMpLnRoZW4oYi5GKS50aGVuKGZ1bmN0aW9uKCl7Yi5BYSYmKGMucmV0dXJuU2VjdXJlVG9rZW49ITApO3JldHVybiBpaChhLGIuZW5kcG9pbnQsZCxjLGIueWYsYi5pZXx8ITEpfSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gZT1hfSkudGhlbihiLiQpLnRoZW4oZnVuY3Rpb24oKXtpZighYi5jYilyZXR1cm4gZTtpZighKGIuY2IgaW4gZSkpdGhyb3cgbmV3IE8oXCJpbnRlcm5hbC1lcnJvclwiKTtyZXR1cm4gZVtiLmNiXX0pfSxcbmdoPWZ1bmN0aW9uKGEsYil7dmFyIGM9KGEuZXJyb3ImJmEuZXJyb3IuZXJyb3JzJiZhLmVycm9yLmVycm9yc1swXXx8e30pLnJlYXNvbnx8XCJcIjt2YXIgZD17a2V5SW52YWxpZDpcImludmFsaWQtYXBpLWtleVwiLGlwUmVmZXJlckJsb2NrZWQ6XCJhcHAtbm90LWF1dGhvcml6ZWRcIn07aWYoYz1kW2NdP25ldyBPKGRbY10pOm51bGwpcmV0dXJuIGM7Yz1hLmVycm9yJiZhLmVycm9yLm1lc3NhZ2V8fFwiXCI7ZD17SU5WQUxJRF9DVVNUT01fVE9LRU46XCJpbnZhbGlkLWN1c3RvbS10b2tlblwiLENSRURFTlRJQUxfTUlTTUFUQ0g6XCJjdXN0b20tdG9rZW4tbWlzbWF0Y2hcIixNSVNTSU5HX0NVU1RPTV9UT0tFTjpcImludGVybmFsLWVycm9yXCIsSU5WQUxJRF9JREVOVElGSUVSOlwiaW52YWxpZC1lbWFpbFwiLE1JU1NJTkdfQ09OVElOVUVfVVJJOlwiaW50ZXJuYWwtZXJyb3JcIixJTlZBTElEX0VNQUlMOlwiaW52YWxpZC1lbWFpbFwiLElOVkFMSURfUEFTU1dPUkQ6XCJ3cm9uZy1wYXNzd29yZFwiLFVTRVJfRElTQUJMRUQ6XCJ1c2VyLWRpc2FibGVkXCIsXG5NSVNTSU5HX1BBU1NXT1JEOlwiaW50ZXJuYWwtZXJyb3JcIixFTUFJTF9FWElTVFM6XCJlbWFpbC1hbHJlYWR5LWluLXVzZVwiLFBBU1NXT1JEX0xPR0lOX0RJU0FCTEVEOlwib3BlcmF0aW9uLW5vdC1hbGxvd2VkXCIsSU5WQUxJRF9JRFBfUkVTUE9OU0U6XCJpbnZhbGlkLWNyZWRlbnRpYWxcIixGRURFUkFURURfVVNFUl9JRF9BTFJFQURZX0xJTktFRDpcImNyZWRlbnRpYWwtYWxyZWFkeS1pbi11c2VcIixJTlZBTElEX01FU1NBR0VfUEFZTE9BRDpcImludmFsaWQtbWVzc2FnZS1wYXlsb2FkXCIsSU5WQUxJRF9SRUNJUElFTlRfRU1BSUw6XCJpbnZhbGlkLXJlY2lwaWVudC1lbWFpbFwiLElOVkFMSURfU0VOREVSOlwiaW52YWxpZC1zZW5kZXJcIixFTUFJTF9OT1RfRk9VTkQ6XCJ1c2VyLW5vdC1mb3VuZFwiLEVYUElSRURfT09CX0NPREU6XCJleHBpcmVkLWFjdGlvbi1jb2RlXCIsSU5WQUxJRF9PT0JfQ09ERTpcImludmFsaWQtYWN0aW9uLWNvZGVcIixNSVNTSU5HX09PQl9DT0RFOlwiaW50ZXJuYWwtZXJyb3JcIixDUkVERU5USUFMX1RPT19PTERfTE9HSU5fQUdBSU46XCJyZXF1aXJlcy1yZWNlbnQtbG9naW5cIixcbklOVkFMSURfSURfVE9LRU46XCJpbnZhbGlkLXVzZXItdG9rZW5cIixUT0tFTl9FWFBJUkVEOlwidXNlci10b2tlbi1leHBpcmVkXCIsVVNFUl9OT1RfRk9VTkQ6XCJ1c2VyLXRva2VuLWV4cGlyZWRcIixDT1JTX1VOU1VQUE9SVEVEOlwiY29ycy11bnN1cHBvcnRlZFwiLERZTkFNSUNfTElOS19OT1RfQUNUSVZBVEVEOlwiZHluYW1pYy1saW5rLW5vdC1hY3RpdmF0ZWRcIixJTlZBTElEX0FQUF9JRDpcImludmFsaWQtYXBwLWlkXCIsVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSOlwidG9vLW1hbnktcmVxdWVzdHNcIixXRUFLX1BBU1NXT1JEOlwid2Vhay1wYXNzd29yZFwiLE9QRVJBVElPTl9OT1RfQUxMT1dFRDpcIm9wZXJhdGlvbi1ub3QtYWxsb3dlZFwiLFVTRVJfQ0FOQ0VMTEVEOlwidXNlci1jYW5jZWxsZWRcIixDQVBUQ0hBX0NIRUNLX0ZBSUxFRDpcImNhcHRjaGEtY2hlY2stZmFpbGVkXCIsSU5WQUxJRF9BUFBfQ1JFREVOVElBTDpcImludmFsaWQtYXBwLWNyZWRlbnRpYWxcIixJTlZBTElEX0NPREU6XCJpbnZhbGlkLXZlcmlmaWNhdGlvbi1jb2RlXCIsXG5JTlZBTElEX1BIT05FX05VTUJFUjpcImludmFsaWQtcGhvbmUtbnVtYmVyXCIsSU5WQUxJRF9TRVNTSU9OX0lORk86XCJpbnZhbGlkLXZlcmlmaWNhdGlvbi1pZFwiLElOVkFMSURfVEVNUE9SQVJZX1BST09GOlwiaW52YWxpZC1jcmVkZW50aWFsXCIsTUlTU0lOR19BUFBfQ1JFREVOVElBTDpcIm1pc3NpbmctYXBwLWNyZWRlbnRpYWxcIixNSVNTSU5HX0NPREU6XCJtaXNzaW5nLXZlcmlmaWNhdGlvbi1jb2RlXCIsTUlTU0lOR19QSE9ORV9OVU1CRVI6XCJtaXNzaW5nLXBob25lLW51bWJlclwiLE1JU1NJTkdfU0VTU0lPTl9JTkZPOlwibWlzc2luZy12ZXJpZmljYXRpb24taWRcIixRVU9UQV9FWENFRURFRDpcInF1b3RhLWV4Y2VlZGVkXCIsU0VTU0lPTl9FWFBJUkVEOlwiY29kZS1leHBpcmVkXCIsSU5WQUxJRF9DT05USU5VRV9VUkk6XCJpbnZhbGlkLWNvbnRpbnVlLXVyaVwiLE1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUU6XCJtaXNzaW5nLWFuZHJvaWQtcGtnLW5hbWVcIixNSVNTSU5HX0lPU19CVU5ETEVfSUQ6XCJtaXNzaW5nLWlvcy1idW5kbGUtaWRcIixcblVOQVVUSE9SSVpFRF9ET01BSU46XCJ1bmF1dGhvcml6ZWQtY29udGludWUtdXJpXCIsSU5WQUxJRF9PQVVUSF9DTElFTlRfSUQ6XCJpbnZhbGlkLW9hdXRoLWNsaWVudC1pZFwifTttYihkLGJ8fHt9KTtiPShiPWMubWF0Y2goL15bXlxcc10rXFxzKjpcXHMqKC4qKSQvKSkmJjE8Yi5sZW5ndGg/YlsxXTp2b2lkIDA7Zm9yKHZhciBlIGluIGQpaWYoMD09PWMuaW5kZXhPZihlKSlyZXR1cm4gbmV3IE8oZFtlXSxiKTshYiYmYSYmKGI9UGYoYSkpO3JldHVybiBuZXcgTyhcImludGVybmFsLWVycm9yXCIsYil9O3ZhciBPaD1mdW5jdGlvbihhKXt0aGlzLkJnPWE7dGhpcy55Yz1udWxsO3RoaXMuSWQ9TmgodGhpcyl9LE5oPWZ1bmN0aW9uKGEpe3JldHVybiBQaCgpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEMoZnVuY3Rpb24oYixjKXtNKFwiZ2FwaS5pZnJhbWVzLmdldENvbnRleHRcIikoKS5vcGVuKHt3aGVyZTpkb2N1bWVudC5ib2R5LHVybDphLkJnLG1lc3NhZ2VIYW5kbGVyc0ZpbHRlcjpNKFwiZ2FwaS5pZnJhbWVzLkNST1NTX09SSUdJTl9JRlJBTUVTX0ZJTFRFUlwiKSxhdHRyaWJ1dGVzOntzdHlsZTp7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIi0xMDBweFwiLHdpZHRoOlwiMXB4XCIsaGVpZ2h0OlwiMXB4XCJ9fSxkb250Y2xlYXI6ITB9LGZ1bmN0aW9uKGQpe2EueWM9ZDthLnljLnJlc3R5bGUoe3NldEhpZGVPbkxlYXZlOiExfSk7dmFyIGU9c2V0VGltZW91dChmdW5jdGlvbigpe2MoRXJyb3IoXCJOZXR3b3JrIEVycm9yXCIpKX0sUWguZ2V0KCkpLGY9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoZSk7XG5iKCl9O2QucGluZyhmKS50aGVuKGYsZnVuY3Rpb24oKXtjKEVycm9yKFwiTmV0d29yayBFcnJvclwiKSl9KX0pfSl9KX07T2gucHJvdG90eXBlLnNlbmRNZXNzYWdlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIHRoaXMuSWQudGhlbihmdW5jdGlvbigpe3JldHVybiBuZXcgQyhmdW5jdGlvbihjKXtiLnljLnNlbmQoYS50eXBlLGEsYyxNKFwiZ2FwaS5pZnJhbWVzLkNST1NTX09SSUdJTl9JRlJBTUVTX0ZJTFRFUlwiKSl9KX0pfTtcbnZhciBSaD1mdW5jdGlvbihhLGIpe2EuSWQudGhlbihmdW5jdGlvbigpe2EueWMucmVnaXN0ZXIoXCJhdXRoRXZlbnRcIixiLE0oXCJnYXBpLmlmcmFtZXMuQ1JPU1NfT1JJR0lOX0lGUkFNRVNfRklMVEVSXCIpKX0pfSxTaD1IYShcImh0dHBzOi8vYXBpcy5nb29nbGUuY29tL2pzL2FwaS5qcz9vbmxvYWQ9JXtvbmxvYWR9XCIpLFRoPW5ldyBWZigzRTQsNkU0KSxRaD1uZXcgVmYoNUUzLDE1RTMpLFVoPW51bGwsUGg9ZnVuY3Rpb24oKXtyZXR1cm4gVWg/VWg6VWg9KG5ldyBDKGZ1bmN0aW9uKGEsYil7aWYoVWYoKSl7dmFyIGM9ZnVuY3Rpb24oKXtUZigpO00oXCJnYXBpLmxvYWRcIikoXCJnYXBpLmlmcmFtZXNcIix7Y2FsbGJhY2s6YSxvbnRpbWVvdXQ6ZnVuY3Rpb24oKXtUZigpO2IoRXJyb3IoXCJOZXR3b3JrIEVycm9yXCIpKX0sdGltZW91dDpUaC5nZXQoKX0pfTtpZihNKFwiZ2FwaS5pZnJhbWVzLklmcmFtZVwiKSlhKCk7ZWxzZSBpZihNKFwiZ2FwaS5sb2FkXCIpKWMoKTtlbHNle3ZhciBkPVwiX19pZnJhbWVmY2JcIitcbk1hdGguZmxvb3IoMUU2Kk1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKCk7a1tkXT1mdW5jdGlvbigpe00oXCJnYXBpLmxvYWRcIik/YygpOmIoRXJyb3IoXCJOZXR3b3JrIEVycm9yXCIpKX07ZD1PYShTaCx7b25sb2FkOmR9KTtEKGRlKGQpKS5nKGZ1bmN0aW9uKCl7YihFcnJvcihcIk5ldHdvcmsgRXJyb3JcIikpfSl9fWVsc2UgYihFcnJvcihcIk5ldHdvcmsgRXJyb3JcIikpfSkpLmcoZnVuY3Rpb24oYSl7VWg9bnVsbDt0aHJvdyBhO30pfTt2YXIgVmg9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuQj1hO3RoaXMubT1iO3RoaXMubz1jO3RoaXMuZmI9bnVsbDt0aGlzLkJhPWhmKHRoaXMuQixcIi9fXy9hdXRoL2lmcmFtZVwiKTtLKHRoaXMuQmEsXCJhcGlLZXlcIix0aGlzLm0pO0sodGhpcy5CYSxcImFwcE5hbWVcIix0aGlzLm8pO3RoaXMuUD1udWxsO3RoaXMuTT1bXX07VmgucHJvdG90eXBlLmFlPWZ1bmN0aW9uKGEpe3RoaXMuZmI9YTtyZXR1cm4gdGhpc307VmgucHJvdG90eXBlLlpkPWZ1bmN0aW9uKGEpe3RoaXMuUD1hO3JldHVybiB0aGlzfTtcblZoLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3RoaXMuZmI/Syh0aGlzLkJhLFwidlwiLHRoaXMuZmIpOnRoaXMuQmEucmVtb3ZlUGFyYW1ldGVyKFwidlwiKTt0aGlzLlA/Syh0aGlzLkJhLFwiZWlkXCIsdGhpcy5QKTp0aGlzLkJhLnJlbW92ZVBhcmFtZXRlcihcImVpZFwiKTt0aGlzLk0ubGVuZ3RoP0sodGhpcy5CYSxcImZ3XCIsdGhpcy5NLmpvaW4oXCIsXCIpKTp0aGlzLkJhLnJlbW92ZVBhcmFtZXRlcihcImZ3XCIpO3JldHVybiB0aGlzLkJhLnRvU3RyaW5nKCl9O3ZhciBXaD1mdW5jdGlvbihhLGIsYyxkLGUpe3RoaXMuQj1hO3RoaXMubT1iO3RoaXMubz1jO3RoaXMuc2Y9ZDt0aGlzLmZiPXRoaXMuWT10aGlzLlRkPW51bGw7dGhpcy54Yj1lO3RoaXMuUD1udWxsfTtXaC5wcm90b3R5cGUuYWU9ZnVuY3Rpb24oYSl7dGhpcy5mYj1hO3JldHVybiB0aGlzfTtXaC5wcm90b3R5cGUuWmQ9ZnVuY3Rpb24oYSl7dGhpcy5QPWE7cmV0dXJuIHRoaXN9O1xuV2gucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGE9aGYodGhpcy5CLFwiL19fL2F1dGgvaGFuZGxlclwiKTtLKGEsXCJhcGlLZXlcIix0aGlzLm0pO0soYSxcImFwcE5hbWVcIix0aGlzLm8pO0soYSxcImF1dGhUeXBlXCIsdGhpcy5zZik7aWYodGhpcy54Yi5pc09BdXRoUHJvdmlkZXIpe3ZhciBiPXRoaXMueGI7dHJ5e3ZhciBjPWZpcmViYXNlLmFwcCh0aGlzLm8pLmF1dGgoKS5pYX1jYXRjaChsKXtjPW51bGx9Yi5uZD1jO0soYSxcInByb3ZpZGVySWRcIix0aGlzLnhiLnByb3ZpZGVySWQpO2I9dGhpcy54YjtjPVFmKGIucWUpO2Zvcih2YXIgZCBpbiBjKWNbZF09Y1tkXS50b1N0cmluZygpO2Q9Yi5rZztjPWtiKGMpO2Zvcih2YXIgZT0wO2U8ZC5sZW5ndGg7ZSsrKXt2YXIgZj1kW2VdO2YgaW4gYyYmZGVsZXRlIGNbZl19Yi5FZCYmYi5uZCYmIWNbYi5FZF0mJihjW2IuRWRdPWIubmQpO2liKGMpfHxLKGEsXCJjdXN0b21QYXJhbWV0ZXJzXCIsUGYoYykpfVwiZnVuY3Rpb25cIj09PXR5cGVvZiB0aGlzLnhiLnllJiZcbihiPXRoaXMueGIueWUoKSxiLmxlbmd0aCYmSyhhLFwic2NvcGVzXCIsYi5qb2luKFwiLFwiKSkpO3RoaXMuVGQ/SyhhLFwicmVkaXJlY3RVcmxcIix0aGlzLlRkKTphLnJlbW92ZVBhcmFtZXRlcihcInJlZGlyZWN0VXJsXCIpO3RoaXMuWT9LKGEsXCJldmVudElkXCIsdGhpcy5ZKTphLnJlbW92ZVBhcmFtZXRlcihcImV2ZW50SWRcIik7dGhpcy5mYj9LKGEsXCJ2XCIsdGhpcy5mYik6YS5yZW1vdmVQYXJhbWV0ZXIoXCJ2XCIpO2lmKHRoaXMubWMpZm9yKHZhciBnIGluIHRoaXMubWMpdGhpcy5tYy5oYXNPd25Qcm9wZXJ0eShnKSYmIWZmKGEsZykmJksoYSxnLHRoaXMubWNbZ10pO3RoaXMuUD9LKGEsXCJlaWRcIix0aGlzLlApOmEucmVtb3ZlUGFyYW1ldGVyKFwiZWlkXCIpO2c9WGgodGhpcy5vKTtnLmxlbmd0aCYmSyhhLFwiZndcIixnLmpvaW4oXCIsXCIpKTtyZXR1cm4gYS50b1N0cmluZygpfTtcbnZhciBYaD1mdW5jdGlvbihhKXt0cnl7cmV0dXJuICRhKGZpcmViYXNlLmFwcChhKS5hdXRoKCkuTSl9Y2F0Y2goYil7cmV0dXJuW119fSxZaD1mdW5jdGlvbihhLGIsYyxkLGUpe3RoaXMuQj1hO3RoaXMubT1iO3RoaXMubz1jO3RoaXMuTGE9ZHx8bnVsbDt0aGlzLlA9ZXx8bnVsbDt0aGlzLmY9dGhpcy55ZD10aGlzLndlPW51bGw7dGhpcy50YT1bXTt0aGlzLkFjPXRoaXMud2E9bnVsbH0sWmg9ZnVuY3Rpb24oYSl7dmFyIGI9cmYoKTtyZXR1cm4gb2goYSkudGhlbihmdW5jdGlvbihhKXthOnt2YXIgYz1nZihiKSxlPWMucWE7Yz1jLnBhO2Zvcih2YXIgZj0wO2Y8YS5sZW5ndGg7ZisrKXt2YXIgZz1hW2ZdO3ZhciBsPWM7dmFyIG49ZTswPT1nLmluZGV4T2YoXCJjaHJvbWUtZXh0ZW5zaW9uOi8vXCIpP2w9Z2YoZykucGE9PWwmJlwiY2hyb21lLWV4dGVuc2lvblwiPT1uOlwiaHR0cFwiIT1uJiZcImh0dHBzXCIhPW4/bD0hMTpBZi50ZXN0KGcpP2w9bD09ZzooZz1nLnNwbGl0KFwiLlwiKS5qb2luKFwiXFxcXC5cIiksXG5sPShuZXcgUmVnRXhwKFwiXiguK1xcXFwuXCIrZytcInxcIitnK1wiKSRcIixcImlcIikpLnRlc3QobCkpO2lmKGwpe2E9ITA7YnJlYWsgYX19YT0hMX1pZighYSl0aHJvdyBuZXcgb2cocmYoKSk7fSl9O2g9WWgucHJvdG90eXBlO2guU2I9ZnVuY3Rpb24oKXtpZih0aGlzLkFjKXJldHVybiB0aGlzLkFjO3ZhciBhPXRoaXM7cmV0dXJuIHRoaXMuQWM9QmYoKS50aGVuKGZ1bmN0aW9uKCl7aWYoIWEueWQpe3ZhciBiPWEuTGEsYz1hLlAsZD1YaChhLm8pO2I9KG5ldyBWaChhLkIsYS5tLGEubykpLmFlKGIpLlpkKGMpO2IuTT0kYShkfHxbXSk7YS55ZD1iLnRvU3RyaW5nKCl9YS54Yz1uZXcgT2goYS55ZCk7JGgoYSl9KX07XG5oLmVjPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1uZXcgTyhcInBvcHVwLWNsb3NlZC1ieS11c2VyXCIpLGU9bmV3IE8oXCJ3ZWItc3RvcmFnZS11bnN1cHBvcnRlZFwiKSxmPXRoaXMsZz0hMTtyZXR1cm4gdGhpcy5SYSgpLnRoZW4oZnVuY3Rpb24oKXthaShmKS50aGVuKGZ1bmN0aW9uKGMpe2N8fChhJiZ4ZihhKSxiKGUpLGc9ITApfSl9KS5nKGZ1bmN0aW9uKCl7fSkudGhlbihmdW5jdGlvbigpe2lmKCFnKXJldHVybiB6ZihhKX0pLnRoZW4oZnVuY3Rpb24oKXtpZighZylyZXR1cm4gQmUoYykudGhlbihmdW5jdGlvbigpe2IoZCl9KX0pfTtoLlllPWZ1bmN0aW9uKCl7dmFyIGE9TCgpO3JldHVybiFPZihhKSYmIVNmKGEpfTtoLkJlPWZ1bmN0aW9uKCl7cmV0dXJuITF9O1xuaC4kYj1mdW5jdGlvbihhLGIsYyxkLGUsZixnKXtpZighYSlyZXR1cm4gRShuZXcgTyhcInBvcHVwLWJsb2NrZWRcIikpO2lmKGcmJiFPZigpKXJldHVybiB0aGlzLlJhKCkuZyhmdW5jdGlvbihiKXt4ZihhKTtlKGIpfSksZCgpLEQoKTt0aGlzLndhfHwodGhpcy53YT1aaChiaSh0aGlzKSkpO3ZhciBsPXRoaXM7cmV0dXJuIHRoaXMud2EudGhlbihmdW5jdGlvbigpe3ZhciBiPWwuUmEoKS5nKGZ1bmN0aW9uKGIpe3hmKGEpO2UoYik7dGhyb3cgYjt9KTtkKCk7cmV0dXJuIGJ9KS50aGVuKGZ1bmN0aW9uKCl7U2coYyk7aWYoIWcpe3ZhciBkPWNpKGwuQixsLm0sbC5vLGIsYyxudWxsLGYsbC5MYSx2b2lkIDAsbC5QKTtzZihkLGEpfX0pLmcoZnVuY3Rpb24oYSl7XCJhdXRoL25ldHdvcmstcmVxdWVzdC1mYWlsZWRcIj09YS5jb2RlJiYobC53YT1udWxsKTt0aHJvdyBhO30pfTtcbnZhciBiaT1mdW5jdGlvbihhKXthLmZ8fChhLndlPWEuTGE/SmYoYS5MYSxYaChhLm8pKTpudWxsLGEuZj1uZXcgUihhLm0sb2YoYS5QKSxhLndlKSk7cmV0dXJuIGEuZn07WWgucHJvdG90eXBlLmFjPWZ1bmN0aW9uKGEsYixjKXt0aGlzLndhfHwodGhpcy53YT1aaChiaSh0aGlzKSkpO3ZhciBkPXRoaXM7cmV0dXJuIHRoaXMud2EudGhlbihmdW5jdGlvbigpe1NnKGIpO3ZhciBlPWNpKGQuQixkLm0sZC5vLGEsYixyZigpLGMsZC5MYSx2b2lkIDAsZC5QKTtzZihlKX0pLmcoZnVuY3Rpb24oYSl7XCJhdXRoL25ldHdvcmstcmVxdWVzdC1mYWlsZWRcIj09YS5jb2RlJiYoZC53YT1udWxsKTt0aHJvdyBhO30pfTtZaC5wcm90b3R5cGUuUmE9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3JldHVybiB0aGlzLlNiKCkudGhlbihmdW5jdGlvbigpe3JldHVybiBhLnhjLklkfSkuZyhmdW5jdGlvbigpe2Eud2E9bnVsbDt0aHJvdyBuZXcgTyhcIm5ldHdvcmstcmVxdWVzdC1mYWlsZWRcIik7fSl9O1xuWWgucHJvdG90eXBlLmJmPWZ1bmN0aW9uKCl7cmV0dXJuITB9O1xudmFyIGNpPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsbCxuLEYpe2E9bmV3IFdoKGEsYixjLGQsZSk7YS5UZD1mO2EuWT1nO2Y9YS5hZShsKTtmLm1jPWtiKG58fG51bGwpO3JldHVybiBmLlpkKEYpLnRvU3RyaW5nKCl9LCRoPWZ1bmN0aW9uKGEpe2lmKCFhLnhjKXRocm93IEVycm9yKFwiSWZjSGFuZGxlciBtdXN0IGJlIGluaXRpYWxpemVkIVwiKTtSaChhLnhjLGZ1bmN0aW9uKGIpe3ZhciBjPXt9O2lmKGImJmIuYXV0aEV2ZW50KXt2YXIgZD0hMTtiPW5nKGIuYXV0aEV2ZW50KTtmb3IoYz0wO2M8YS50YS5sZW5ndGg7YysrKWQ9YS50YVtjXShiKXx8ZDtjPXt9O2Muc3RhdHVzPWQ/XCJBQ0tcIjpcIkVSUk9SXCI7cmV0dXJuIEQoYyl9Yy5zdGF0dXM9XCJFUlJPUlwiO3JldHVybiBEKGMpfSl9LGFpPWZ1bmN0aW9uKGEpe3ZhciBiPXt0eXBlOlwid2ViU3RvcmFnZVN1cHBvcnRcIn07cmV0dXJuIGEuU2IoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGEueGMuc2VuZE1lc3NhZ2UoYil9KS50aGVuKGZ1bmN0aW9uKGEpe2lmKGEmJmEubGVuZ3RoJiZcblwidW5kZWZpbmVkXCIhPT10eXBlb2YgYVswXS53ZWJTdG9yYWdlU3VwcG9ydClyZXR1cm4gYVswXS53ZWJTdG9yYWdlU3VwcG9ydDt0aHJvdyBFcnJvcigpO30pfTtZaC5wcm90b3R5cGUuaWI9ZnVuY3Rpb24oYSl7dGhpcy50YS5wdXNoKGEpfTtZaC5wcm90b3R5cGUuZGM9ZnVuY3Rpb24oYSl7WWEodGhpcy50YSxmdW5jdGlvbihiKXtyZXR1cm4gYj09YX0pfTt2YXIgZGk9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe04odGhpcyxcInR5cGVcIixcInJlY2FwdGNoYVwiKTt0aGlzLmFkPXRoaXMuSWI9bnVsbDt0aGlzLktiPSExO3RoaXMubmU9Yjt0aGlzLkZhPWN8fHt0aGVtZTpcImxpZ2h0XCIsdHlwZTpcImltYWdlXCJ9O3RoaXMuSj1bXTtpZih0aGlzLkZhLnNpdGVrZXkpdGhyb3cgbmV3IE8oXCJhcmd1bWVudC1lcnJvclwiLFwic2l0ZWtleSBzaG91bGQgbm90IGJlIHByb3ZpZGVkIGZvciByZUNBUFRDSEEgYXMgb25lIGlzIGF1dG9tYXRpY2FsbHkgcHJvdmlzaW9uZWQgZm9yIHRoZSBjdXJyZW50IHByb2plY3QuXCIpO3RoaXMuQmM9XCJpbnZpc2libGVcIj09PXRoaXMuRmEuc2l6ZTtpZighbGQoYil8fCF0aGlzLkJjJiZsZChiKS5oYXNDaGlsZE5vZGVzKCkpdGhyb3cgbmV3IE8oXCJhcmd1bWVudC1lcnJvclwiLFwicmVDQVBUQ0hBIGNvbnRhaW5lciBpcyBlaXRoZXIgbm90IGZvdW5kIG9yIGFscmVhZHkgY29udGFpbnMgaW5uZXIgZWxlbWVudHMhXCIpO3RoaXMuZj1uZXcgUihhLFxuZnx8bnVsbCxlfHxudWxsKTt0aGlzLkpmPWR8fGZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O3ZhciBnPXRoaXM7dGhpcy5XYz1bXTt2YXIgbD10aGlzLkZhLmNhbGxiYWNrO3RoaXMuRmEuY2FsbGJhY2s9ZnVuY3Rpb24oYSl7Zy5MYihhKTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgbClsKGEpO2Vsc2UgaWYoXCJzdHJpbmdcIj09PXR5cGVvZiBsKXt2YXIgYj1NKGwsayk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGImJmIoYSl9fTt2YXIgbj10aGlzLkZhW1wiZXhwaXJlZC1jYWxsYmFja1wiXTt0aGlzLkZhW1wiZXhwaXJlZC1jYWxsYmFja1wiXT1mdW5jdGlvbigpe2cuTGIobnVsbCk7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIG4pbigpO2Vsc2UgaWYoXCJzdHJpbmdcIj09PXR5cGVvZiBuKXt2YXIgYT1NKG4sayk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGEmJmEoKX19fTtkaS5wcm90b3R5cGUuTGI9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7Yjx0aGlzLldjLmxlbmd0aDtiKyspdHJ5e3RoaXMuV2NbYl0oYSl9Y2F0Y2goYyl7fX07XG52YXIgZWk9ZnVuY3Rpb24oYSxiKXtZYShhLldjLGZ1bmN0aW9uKGEpe3JldHVybiBhPT1ifSl9O2RpLnByb3RvdHlwZS5jPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7dGhpcy5KLnB1c2goYSk7RWQoYSxmdW5jdGlvbigpe1hhKGIuSixhKX0pO3JldHVybiBhfTtcbmRpLnByb3RvdHlwZS5UYj1mdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIHRoaXMuSWI/dGhpcy5JYjp0aGlzLkliPXRoaXMuYyhEKCkudGhlbihmdW5jdGlvbigpe2lmKE1mKCkpcmV0dXJuIEJmKCk7dGhyb3cgbmV3IE8oXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIsXCJSZWNhcHRjaGFWZXJpZmllciBpcyBvbmx5IHN1cHBvcnRlZCBpbiBhIGJyb3dzZXIgSFRUUC9IVFRQUyBlbnZpcm9ubWVudC5cIik7fSkudGhlbihmdW5jdGlvbigpe3JldHVybiBmaShnaSgpLGEuSmYoKSl9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIFEoYS5mLExoLHt9KX0pLnRoZW4oZnVuY3Rpb24oYil7YS5GYS5zaXRla2V5PWIucmVjYXB0Y2hhU2l0ZUtleX0pLmcoZnVuY3Rpb24oYil7YS5JYj1udWxsO3Rocm93IGI7fSkpfTtcbmRpLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oKXtoaSh0aGlzKTt2YXIgYT10aGlzO3JldHVybiB0aGlzLmModGhpcy5UYigpLnRoZW4oZnVuY3Rpb24oKXtpZihudWxsPT09YS5hZCl7dmFyIGI9YS5uZTtpZighYS5CYyl7dmFyIGM9bGQoYik7Yj1wZChcIkRJVlwiKTtjLmFwcGVuZENoaWxkKGIpfWEuYWQ9Z3JlY2FwdGNoYS5yZW5kZXIoYixhLkZhKX1yZXR1cm4gYS5hZH0pKX07ZGkucHJvdG90eXBlLnZlcmlmeT1mdW5jdGlvbigpe2hpKHRoaXMpO3ZhciBhPXRoaXM7cmV0dXJuIHRoaXMuYyh0aGlzLnJlbmRlcigpLnRoZW4oZnVuY3Rpb24oYil7cmV0dXJuIG5ldyBDKGZ1bmN0aW9uKGMpe3ZhciBkPWdyZWNhcHRjaGEuZ2V0UmVzcG9uc2UoYik7aWYoZCljKGQpO2Vsc2V7dmFyIGU9ZnVuY3Rpb24oYil7YiYmKGVpKGEsZSksYyhiKSl9O2EuV2MucHVzaChlKTthLkJjJiZncmVjYXB0Y2hhLmV4ZWN1dGUoYS5hZCl9fSl9KSl9O1xudmFyIGhpPWZ1bmN0aW9uKGEpe2lmKGEuS2IpdGhyb3cgbmV3IE8oXCJpbnRlcm5hbC1lcnJvclwiLFwiUmVjYXB0Y2hhVmVyaWZpZXIgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkLlwiKTt9O2RpLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe2hpKHRoaXMpO3RoaXMuS2I9ITA7Z2koKS5sZC0tO2Zvcih2YXIgYT0wO2E8dGhpcy5KLmxlbmd0aDthKyspdGhpcy5KW2FdLmNhbmNlbChcIlJlY2FwdGNoYVZlcmlmaWVyIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZC5cIik7aWYoIXRoaXMuQmMpe2E9bGQodGhpcy5uZSk7Zm9yKHZhciBiO2I9YS5maXJzdENoaWxkOylhLnJlbW92ZUNoaWxkKGIpfX07XG52YXIgaWk9SGEoXCJodHRwczovL3d3dy5nb29nbGUuY29tL3JlY2FwdGNoYS9hcGkuanM/b25sb2FkPSV7b25sb2FkfSZyZW5kZXI9ZXhwbGljaXQmaGw9JXtobH1cIiksamk9ZnVuY3Rpb24oKXt0aGlzLmxkPWsuZ3JlY2FwdGNoYT9JbmZpbml0eTowO3RoaXMuQ2U9bnVsbDt0aGlzLmpkPVwiX19yY2JcIitNYXRoLmZsb29yKDFFNipNYXRoLnJhbmRvbSgpKS50b1N0cmluZygpfSxmaT1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgQyhmdW5jdGlvbihjLGQpe2lmKFVmKCkpaWYoIWsuZ3JlY2FwdGNoYXx8YiE9PWEuQ2UmJiFhLmxkKXtrW2EuamRdPWZ1bmN0aW9uKCl7aWYoay5ncmVjYXB0Y2hhKXthLkNlPWI7dmFyIGU9ay5ncmVjYXB0Y2hhLnJlbmRlcjtrLmdyZWNhcHRjaGEucmVuZGVyPWZ1bmN0aW9uKGIsYyl7Yj1lKGIsYyk7YS5sZCsrO3JldHVybiBifTtjKCl9ZWxzZSBkKG5ldyBPKFwiaW50ZXJuYWwtZXJyb3JcIikpO2RlbGV0ZSBrW2EuamRdfTt2YXIgZT1PYShpaSx7b25sb2FkOmEuamQsXG5obDpifHxcIlwifSk7RChkZShlKSkuZyhmdW5jdGlvbigpe2QobmV3IE8oXCJpbnRlcm5hbC1lcnJvclwiLFwiVW5hYmxlIHRvIGxvYWQgZXh0ZXJuYWwgcmVDQVBUQ0hBIGRlcGVuZGVuY2llcyFcIikpfSl9ZWxzZSBjKCk7ZWxzZSBkKG5ldyBPKFwibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiKSl9KX0sa2k9bnVsbCxnaT1mdW5jdGlvbigpe2tpfHwoa2k9bmV3IGppKTtyZXR1cm4ga2l9LGxpPWZ1bmN0aW9uKGEsYixjKXt0cnl7dGhpcy5pPWN8fGZpcmViYXNlLmFwcCgpfWNhdGNoKGYpe3Rocm93IG5ldyBPKFwiYXJndW1lbnQtZXJyb3JcIixcIk5vIGZpcmViYXNlLmFwcC5BcHAgaW5zdGFuY2UgaXMgY3VycmVudGx5IGluaXRpYWxpemVkLlwiKTt9aWYodGhpcy5pLm9wdGlvbnMmJnRoaXMuaS5vcHRpb25zLmFwaUtleSljPXRoaXMuaS5vcHRpb25zLmFwaUtleTtlbHNlIHRocm93IG5ldyBPKFwiaW52YWxpZC1hcGkta2V5XCIpO3ZhciBkPXRoaXMsZT1udWxsO3RyeXtlPSRhKHRoaXMuaS5hdXRoKCkuTSl9Y2F0Y2goZil7fWU9XG5maXJlYmFzZS5TREtfVkVSU0lPTj9KZihmaXJlYmFzZS5TREtfVkVSU0lPTixlKTpudWxsO2RpLmNhbGwodGhpcyxjLGEsYixmdW5jdGlvbigpe3RyeXt2YXIgYT1kLmkuYXV0aCgpLmlhfWNhdGNoKGcpe2E9bnVsbH1yZXR1cm4gYX0sZSxvZihwZikpfTt0KGxpLGRpKTt2YXIgbWk9ZnVuY3Rpb24oYSl7dGhpcy5HPWF8fGZpcmViYXNlLklOVEVSTkFMLnJlYWN0TmF0aXZlJiZmaXJlYmFzZS5JTlRFUk5BTC5yZWFjdE5hdGl2ZS5Bc3luY1N0b3JhZ2U7aWYoIXRoaXMuRyl0aHJvdyBuZXcgTyhcImludGVybmFsLWVycm9yXCIsXCJUaGUgUmVhY3QgTmF0aXZlIGNvbXBhdGliaWxpdHkgbGlicmFyeSB3YXMgbm90IGZvdW5kLlwiKTt9O2g9bWkucHJvdG90eXBlO2guZ2V0PWZ1bmN0aW9uKGEpe3JldHVybiBEKHRoaXMuRy5nZXRJdGVtKGEpKS50aGVuKGZ1bmN0aW9uKGEpe3JldHVybiBhJiZSZihhKX0pfTtoLnNldD1mdW5jdGlvbihhLGIpe3JldHVybiBEKHRoaXMuRy5zZXRJdGVtKGEsUGYoYikpKX07aC5yZW1vdmU9ZnVuY3Rpb24oYSl7cmV0dXJuIEQodGhpcy5HLnJlbW92ZUl0ZW0oYSkpfTtoLmpiPWZ1bmN0aW9uKCl7fTtoLiRhPWZ1bmN0aW9uKCl7fTt2YXIgbmk9ZnVuY3Rpb24oKXt0aGlzLkc9e319O2g9bmkucHJvdG90eXBlO2guZ2V0PWZ1bmN0aW9uKGEpe3JldHVybiBEKHRoaXMuR1thXSl9O2guc2V0PWZ1bmN0aW9uKGEsYil7dGhpcy5HW2FdPWI7cmV0dXJuIEQoKX07aC5yZW1vdmU9ZnVuY3Rpb24oYSl7ZGVsZXRlIHRoaXMuR1thXTtyZXR1cm4gRCgpfTtoLmpiPWZ1bmN0aW9uKCl7fTtoLiRhPWZ1bmN0aW9uKCl7fTt2YXIgcGk9ZnVuY3Rpb24oKXtpZighb2koKSl7aWYoXCJOb2RlXCI9PUdmKCkpdGhyb3cgbmV3IE8oXCJpbnRlcm5hbC1lcnJvclwiLFwiVGhlIExvY2FsU3RvcmFnZSBjb21wYXRpYmlsaXR5IGxpYnJhcnkgd2FzIG5vdCBmb3VuZC5cIik7dGhyb3cgbmV3IE8oXCJ3ZWItc3RvcmFnZS11bnN1cHBvcnRlZFwiKTt9dGhpcy5HPWsubG9jYWxTdG9yYWdlfHxmaXJlYmFzZS5JTlRFUk5BTC5ub2RlLmxvY2FsU3RvcmFnZX0sb2k9ZnVuY3Rpb24oKXt2YXIgYT1cIk5vZGVcIj09R2YoKTthPWsubG9jYWxTdG9yYWdlfHxhJiZmaXJlYmFzZS5JTlRFUk5BTC5ub2RlJiZmaXJlYmFzZS5JTlRFUk5BTC5ub2RlLmxvY2FsU3RvcmFnZTtpZighYSlyZXR1cm4hMTt0cnl7cmV0dXJuIGEuc2V0SXRlbShcIl9fc2FrXCIsXCIxXCIpLGEucmVtb3ZlSXRlbShcIl9fc2FrXCIpLCEwfWNhdGNoKGIpe3JldHVybiExfX07aD1waS5wcm90b3R5cGU7XG5oLmdldD1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3JldHVybiBEKCkudGhlbihmdW5jdGlvbigpe3ZhciBjPWIuRy5nZXRJdGVtKGEpO3JldHVybiBSZihjKX0pfTtoLnNldD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7cmV0dXJuIEQoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGQ9UGYoYik7bnVsbD09PWQ/Yy5yZW1vdmUoYSk6Yy5HLnNldEl0ZW0oYSxkKX0pfTtoLnJlbW92ZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3JldHVybiBEKCkudGhlbihmdW5jdGlvbigpe2IuRy5yZW1vdmVJdGVtKGEpfSl9O2guamI9ZnVuY3Rpb24oYSl7ay53aW5kb3cmJmxjKGsud2luZG93LFwic3RvcmFnZVwiLGEpfTtoLiRhPWZ1bmN0aW9uKGEpe2sud2luZG93JiZ0YyhrLndpbmRvdyxcInN0b3JhZ2VcIixhKX07dmFyIHFpPWZ1bmN0aW9uKCl7dGhpcy5HPXt9fTtoPXFpLnByb3RvdHlwZTtoLmdldD1mdW5jdGlvbigpe3JldHVybiBEKG51bGwpfTtoLnNldD1mdW5jdGlvbigpe3JldHVybiBEKCl9O2gucmVtb3ZlPWZ1bmN0aW9uKCl7cmV0dXJuIEQoKX07aC5qYj1mdW5jdGlvbigpe307aC4kYT1mdW5jdGlvbigpe307dmFyIHNpPWZ1bmN0aW9uKCl7aWYoIXJpKCkpe2lmKFwiTm9kZVwiPT1HZigpKXRocm93IG5ldyBPKFwiaW50ZXJuYWwtZXJyb3JcIixcIlRoZSBTZXNzaW9uU3RvcmFnZSBjb21wYXRpYmlsaXR5IGxpYnJhcnkgd2FzIG5vdCBmb3VuZC5cIik7dGhyb3cgbmV3IE8oXCJ3ZWItc3RvcmFnZS11bnN1cHBvcnRlZFwiKTt9dGhpcy5HPWsuc2Vzc2lvblN0b3JhZ2V8fGZpcmViYXNlLklOVEVSTkFMLm5vZGUuc2Vzc2lvblN0b3JhZ2V9LHJpPWZ1bmN0aW9uKCl7dmFyIGE9XCJOb2RlXCI9PUdmKCk7YT1rLnNlc3Npb25TdG9yYWdlfHxhJiZmaXJlYmFzZS5JTlRFUk5BTC5ub2RlJiZmaXJlYmFzZS5JTlRFUk5BTC5ub2RlLnNlc3Npb25TdG9yYWdlO2lmKCFhKXJldHVybiExO3RyeXtyZXR1cm4gYS5zZXRJdGVtKFwiX19zYWtcIixcIjFcIiksYS5yZW1vdmVJdGVtKFwiX19zYWtcIiksITB9Y2F0Y2goYil7cmV0dXJuITF9fTtoPXNpLnByb3RvdHlwZTtcbmguZ2V0PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIEQoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGM9Yi5HLmdldEl0ZW0oYSk7cmV0dXJuIFJmKGMpfSl9O2guc2V0PWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcztyZXR1cm4gRCgpLnRoZW4oZnVuY3Rpb24oKXt2YXIgZD1QZihiKTtudWxsPT09ZD9jLnJlbW92ZShhKTpjLkcuc2V0SXRlbShhLGQpfSl9O2gucmVtb3ZlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIEQoKS50aGVuKGZ1bmN0aW9uKCl7Yi5HLnJlbW92ZUl0ZW0oYSl9KX07aC5qYj1mdW5jdGlvbigpe307aC4kYT1mdW5jdGlvbigpe307dmFyIHRpPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtpZighd2luZG93LmluZGV4ZWREQil0aHJvdyBuZXcgTyhcIndlYi1zdG9yYWdlLXVuc3VwcG9ydGVkXCIpO3RoaXMuemY9YTt0aGlzLkhkPWI7dGhpcy5tZD1jO3RoaXMuZmY9ZDt0aGlzLmdiPWU7dGhpcy5OPXt9O3RoaXMuZmM9W107dGhpcy5XYj0wO3RoaXMuUmY9Znx8ay5pbmRleGVkREJ9LHVpLHZpPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgQyhmdW5jdGlvbihiLGMpe3ZhciBkPWEuUmYub3BlbihhLnpmLGEuZ2IpO2Qub25lcnJvcj1mdW5jdGlvbihhKXtjKEVycm9yKGEudGFyZ2V0LmVycm9yQ29kZSkpfTtkLm9udXBncmFkZW5lZWRlZD1mdW5jdGlvbihiKXtiPWIudGFyZ2V0LnJlc3VsdDt0cnl7Yi5jcmVhdGVPYmplY3RTdG9yZShhLkhkLHtrZXlQYXRoOmEubWR9KX1jYXRjaChmKXtjKGYpfX07ZC5vbnN1Y2Nlc3M9ZnVuY3Rpb24oYSl7YihhLnRhcmdldC5yZXN1bHQpfX0pfSx3aT1mdW5jdGlvbihhKXthLkdlfHwoYS5HZT1cbnZpKGEpKTtyZXR1cm4gYS5HZX0seGk9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi5vYmplY3RTdG9yZShhLkhkKX0semk9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBiLnRyYW5zYWN0aW9uKFthLkhkXSxjP1wicmVhZHdyaXRlXCI6XCJyZWFkb25seVwiKX0sQWk9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBDKGZ1bmN0aW9uKGIsYyl7YS5vbnN1Y2Nlc3M9ZnVuY3Rpb24oYSl7YSYmYS50YXJnZXQ/YihhLnRhcmdldC5yZXN1bHQpOmIoKX07YS5vbmVycm9yPWZ1bmN0aW9uKGEpe2MoRXJyb3IoYS50YXJnZXQuZXJyb3JDb2RlKSl9fSl9O2g9dGkucHJvdG90eXBlO1xuaC5zZXQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz0hMSxkLGU9dGhpcztyZXR1cm4gRWQod2kodGhpcykudGhlbihmdW5jdGlvbihiKXtkPWI7Yj14aShlLHppKGUsZCwhMCkpO3JldHVybiBBaShiLmdldChhKSl9KS50aGVuKGZ1bmN0aW9uKGYpe3ZhciBnPXhpKGUsemkoZSxkLCEwKSk7aWYoZilyZXR1cm4gZi52YWx1ZT1iLEFpKGcucHV0KGYpKTtlLldiKys7Yz0hMDtmPXt9O2ZbZS5tZF09YTtmW2UuZmZdPWI7cmV0dXJuIEFpKGcuYWRkKGYpKX0pLnRoZW4oZnVuY3Rpb24oKXtlLk5bYV09Yn0pLGZ1bmN0aW9uKCl7YyYmZS5XYi0tfSl9O2guZ2V0PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIHdpKHRoaXMpLnRoZW4oZnVuY3Rpb24oYyl7cmV0dXJuIEFpKHhpKGIsemkoYixjLCExKSkuZ2V0KGEpKX0pLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGEmJmEudmFsdWV9KX07XG5oLnJlbW92ZT1mdW5jdGlvbihhKXt2YXIgYj0hMSxjPXRoaXM7cmV0dXJuIEVkKHdpKHRoaXMpLnRoZW4oZnVuY3Rpb24oZCl7Yj0hMDtjLldiKys7cmV0dXJuIEFpKHhpKGMsemkoYyxkLCEwKSlbXCJkZWxldGVcIl0oYSkpfSkudGhlbihmdW5jdGlvbigpe2RlbGV0ZSBjLk5bYV19KSxmdW5jdGlvbigpe2ImJmMuV2ItLX0pfTtcbmgueGc9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3JldHVybiB3aSh0aGlzKS50aGVuKGZ1bmN0aW9uKGIpe3ZhciBjPXhpKGEsemkoYSxiLCExKSk7cmV0dXJuIGMuZ2V0QWxsP0FpKGMuZ2V0QWxsKCkpOm5ldyBDKGZ1bmN0aW9uKGEsYil7dmFyIGQ9W10sZT1jLm9wZW5DdXJzb3IoKTtlLm9uc3VjY2Vzcz1mdW5jdGlvbihiKXsoYj1iLnRhcmdldC5yZXN1bHQpPyhkLnB1c2goYi52YWx1ZSksYltcImNvbnRpbnVlXCJdKCkpOmEoZCl9O2Uub25lcnJvcj1mdW5jdGlvbihhKXtiKEVycm9yKGEudGFyZ2V0LmVycm9yQ29kZSkpfX0pfSkudGhlbihmdW5jdGlvbihiKXt2YXIgYz17fSxkPVtdO2lmKDA9PWEuV2Ipe2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspY1tiW2RdW2EubWRdXT1iW2RdW2EuZmZdO2Q9dGYoYS5OLGMpO2EuTj1jfXJldHVybiBkfSl9O2guamI9ZnVuY3Rpb24oYSl7MD09dGhpcy5mYy5sZW5ndGgmJnRoaXMuY2UoKTt0aGlzLmZjLnB1c2goYSl9O1xuaC4kYT1mdW5jdGlvbihhKXtZYSh0aGlzLmZjLGZ1bmN0aW9uKGIpe3JldHVybiBiPT1hfSk7MD09dGhpcy5mYy5sZW5ndGgmJnRoaXMuU2MoKX07aC5jZT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7dGhpcy5TYygpO3ZhciBiPWZ1bmN0aW9uKCl7YS5OZD1CZSg4MDApLnRoZW4ocihhLnhnLGEpKS50aGVuKGZ1bmN0aW9uKGIpezA8Yi5sZW5ndGgmJngoYS5mYyxmdW5jdGlvbihhKXthKGIpfSl9KS50aGVuKGIpLmcoZnVuY3Rpb24oYSl7XCJTVE9QX0VWRU5UXCIhPWEubWVzc2FnZSYmYigpfSk7cmV0dXJuIGEuTmR9O2IoKX07aC5TYz1mdW5jdGlvbigpe3RoaXMuTmQmJnRoaXMuTmQuY2FuY2VsKFwiU1RPUF9FVkVOVFwiKX07dmFyIEVpPWZ1bmN0aW9uKCl7dGhpcy5zZT17QnJvd3NlcjpCaSxOb2RlOkNpLFJlYWN0TmF0aXZlOkRpfVtHZigpXX0sRmksQmk9e0Q6cGksZWU6c2l9LENpPXtEOnBpLGVlOnNpfSxEaT17RDptaSxlZTpxaX07dmFyIEdpPWZ1bmN0aW9uKGEpe3RoaXMuQmQoYSl9O1xuR2kucHJvdG90eXBlLkJkPWZ1bmN0aW9uKGEpe3ZhciBiPWEudXJsO2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgYil0aHJvdyBuZXcgTyhcIm1pc3NpbmctY29udGludWUtdXJpXCIpO2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYnx8XCJzdHJpbmdcIj09PXR5cGVvZiBiJiYhYi5sZW5ndGgpdGhyb3cgbmV3IE8oXCJpbnZhbGlkLWNvbnRpbnVlLXVyaVwiKTt0aGlzLnVmPWI7dGhpcy5nZT10aGlzLm5jPW51bGw7dGhpcy5IZT0hMTt2YXIgYz1hLmFuZHJvaWQ7aWYoYyYmXCJvYmplY3RcIj09PXR5cGVvZiBjKXtiPWMucGFja2FnZU5hbWU7dmFyIGQ9Yy5pbnN0YWxsQXBwO2M9Yy5taW5pbXVtVmVyc2lvbjtpZihcInN0cmluZ1wiPT09dHlwZW9mIGImJmIubGVuZ3RoKXt0aGlzLm5jPWI7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkJiZcImJvb2xlYW5cIiE9PXR5cGVvZiBkKXRocm93IG5ldyBPKFwiYXJndW1lbnQtZXJyb3JcIixcImluc3RhbGxBcHAgcHJvcGVydHkgbXVzdCBiZSBhIGJvb2xlYW4gd2hlbiBzcGVjaWZpZWQuXCIpO3RoaXMuSGU9XG4hIWQ7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjJiYoXCJzdHJpbmdcIiE9PXR5cGVvZiBjfHxcInN0cmluZ1wiPT09dHlwZW9mIGMmJiFjLmxlbmd0aCkpdGhyb3cgbmV3IE8oXCJhcmd1bWVudC1lcnJvclwiLFwibWluaW11bVZlcnNpb24gcHJvcGVydHkgbXVzdCBiZSBhIG5vbiBlbXB0eSBzdHJpbmcgd2hlbiBzcGVjaWZpZWQuXCIpO3RoaXMuZ2U9Y3x8bnVsbH1lbHNle2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYil0aHJvdyBuZXcgTyhcImFyZ3VtZW50LWVycm9yXCIsXCJwYWNrYWdlTmFtZSBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uIGVtcHR5IHN0cmluZyB3aGVuIHNwZWNpZmllZC5cIik7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkfHxcInVuZGVmaW5lZFwiIT09dHlwZW9mIGMpdGhyb3cgbmV3IE8oXCJtaXNzaW5nLWFuZHJvaWQtcGtnLW5hbWVcIik7fX1lbHNlIGlmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYyl0aHJvdyBuZXcgTyhcImFyZ3VtZW50LWVycm9yXCIsXCJhbmRyb2lkIHByb3BlcnR5IG11c3QgYmUgYSBub24gbnVsbCBvYmplY3Qgd2hlbiBzcGVjaWZpZWQuXCIpO1xudGhpcy54ZD1udWxsO2lmKChiPWEuaU9TKSYmXCJvYmplY3RcIj09PXR5cGVvZiBiKWlmKGI9Yi5idW5kbGVJZCxcInN0cmluZ1wiPT09dHlwZW9mIGImJmIubGVuZ3RoKXRoaXMueGQ9YjtlbHNle2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYil0aHJvdyBuZXcgTyhcImFyZ3VtZW50LWVycm9yXCIsXCJidW5kbGVJZCBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uIGVtcHR5IHN0cmluZyB3aGVuIHNwZWNpZmllZC5cIik7fWVsc2UgaWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBiKXRocm93IG5ldyBPKFwiYXJndW1lbnQtZXJyb3JcIixcImlPUyBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uIG51bGwgb2JqZWN0IHdoZW4gc3BlY2lmaWVkLlwiKTthPWEuaGFuZGxlQ29kZUluQXBwO2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYSYmXCJib29sZWFuXCIhPT10eXBlb2YgYSl0aHJvdyBuZXcgTyhcImFyZ3VtZW50LWVycm9yXCIsXCJoYW5kbGVDb2RlSW5BcHAgcHJvcGVydHkgbXVzdCBiZSBhIGJvb2xlYW4gd2hlbiBzcGVjaWZpZWQuXCIpO1xuaWYoKHRoaXMubGU9ISFhKSYmIXRoaXMueGQmJiF0aGlzLm5jKXRocm93IG5ldyBPKFwiYXJndW1lbnQtZXJyb3JcIixcImhhbmRsZUNvZGVJbkFwcCBwcm9wZXJ0eSBjYW4ndCBiZSB0cnVlIHdoZW4gbm8gbW9iaWxlIGFwcGxpY2F0aW9uIGlzIHByb3ZpZGVkLlwiKTt9O3ZhciBIaT1mdW5jdGlvbihhKXt2YXIgYj17fTtiLmNvbnRpbnVlVXJsPWEudWY7Yi5jYW5IYW5kbGVDb2RlSW5BcHA9YS5sZTtpZihiLmFuZHJvaWRQYWNrYWdlTmFtZT1hLm5jKWIuYW5kcm9pZE1pbmltdW1WZXJzaW9uPWEuZ2UsYi5hbmRyb2lkSW5zdGFsbEFwcD1hLkhlO2IuaU9TQnVuZGxlSWQ9YS54ZDtmb3IodmFyIGMgaW4gYiludWxsPT09YltjXSYmZGVsZXRlIGJbY107cmV0dXJuIGJ9O3ZhciBJaT1mdW5jdGlvbihhLGIpe3RoaXMueGY9YjtOKHRoaXMsXCJ2ZXJpZmljYXRpb25JZFwiLGEpfTtJaS5wcm90b3R5cGUuY29uZmlybT1mdW5jdGlvbihhKXthPVFnKHRoaXMudmVyaWZpY2F0aW9uSWQsYSk7cmV0dXJuIHRoaXMueGYoYSl9O3ZhciBKaT1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4obmV3IE9nKGEpKS52ZXJpZnlQaG9uZU51bWJlcihiLGMpLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBJaShhLGQpfSl9O3ZhciBLaT1mdW5jdGlvbihhKXt2YXIgYj17fSxjPWEuZW1haWwsZD1hLm5ld0VtYWlsO2E9YS5yZXF1ZXN0VHlwZTtpZighY3x8IWEpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHByb3ZpZGVyIHVzZXIgaW5mbyFcIik7Yi5mcm9tRW1haWw9ZHx8bnVsbDtiLmVtYWlsPWM7Tih0aGlzLFwib3BlcmF0aW9uXCIsYSk7Tih0aGlzLFwiZGF0YVwiLGZnKGIpKX07dmFyIExpPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt0aGlzLmZnPWE7dGhpcy5tZz1iO3RoaXMuS2Y9Yzt0aGlzLkdjPWQ7dGhpcy5mZT1lO3RoaXMubmc9ISFmO3RoaXMudWI9bnVsbDt0aGlzLlNhPXRoaXMuR2M7aWYodGhpcy5mZTx0aGlzLkdjKXRocm93IEVycm9yKFwiUHJvYWN0aXZlIHJlZnJlc2ggbG93ZXIgYm91bmQgZ3JlYXRlciB0aGFuIHVwcGVyIGJvdW5kIVwiKTt9O0xpLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe3RoaXMuU2E9dGhpcy5HYztNaSh0aGlzLCEwKX07XG52YXIgTmk9ZnVuY3Rpb24oYSxiKXtpZihiKXJldHVybiBhLlNhPWEuR2MsYS5LZigpO2I9YS5TYTthLlNhKj0yO2EuU2E+YS5mZSYmKGEuU2E9YS5mZSk7cmV0dXJuIGJ9LE1pPWZ1bmN0aW9uKGEsYil7YS5zdG9wKCk7YS51Yj1CZShOaShhLGIpKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGEubmc/RCgpOlhmKCl9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGEuZmcoKX0pLnRoZW4oZnVuY3Rpb24oKXtNaShhLCEwKX0pLmcoZnVuY3Rpb24oYil7YS5tZyhiKSYmTWkoYSwhMSl9KX07TGkucHJvdG90eXBlLnN0b3A9ZnVuY3Rpb24oKXt0aGlzLnViJiYodGhpcy51Yi5jYW5jZWwoKSx0aGlzLnViPW51bGwpfTt2YXIgVWk9ZnVuY3Rpb24oYSl7dmFyIGI9e307YltcImZhY2Vib29rLmNvbVwiXT1PaTtiW1wiZ29vZ2xlLmNvbVwiXT1QaTtiW1wiZ2l0aHViLmNvbVwiXT1RaTtiW1widHdpdHRlci5jb21cIl09Umk7dmFyIGM9YSYmYS5wcm92aWRlcklkO3RyeXtpZihjKXJldHVybiBiW2NdP25ldyBiW2NdKGEpOm5ldyBTaShhKTtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGEuaWRUb2tlbilyZXR1cm4gbmV3IFRpKGEpfWNhdGNoKGQpe31yZXR1cm4gbnVsbH0sVGk9ZnVuY3Rpb24oYSl7dmFyIGI9YS5wcm92aWRlcklkO2lmKCFiJiZhLmlkVG9rZW4pe3ZhciBjPXFnKGEuaWRUb2tlbik7YyYmYy5SZCYmKGI9Yy5SZCl9aWYoIWIpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGFkZGl0aW9uYWwgdXNlciBpbmZvIVwiKTthPSEhYS5pc05ld1VzZXI7Tih0aGlzLFwicHJvdmlkZXJJZFwiLGIpO04odGhpcyxcImlzTmV3VXNlclwiLGEpfSxTaT1mdW5jdGlvbihhKXtUaS5jYWxsKHRoaXMsYSk7YT1SZihhLnJhd1VzZXJJbmZvfHxcInt9XCIpO1xuTih0aGlzLFwicHJvZmlsZVwiLGZnKGF8fHt9KSl9O3QoU2ksVGkpO3ZhciBPaT1mdW5jdGlvbihhKXtTaS5jYWxsKHRoaXMsYSk7aWYoXCJmYWNlYm9vay5jb21cIiE9dGhpcy5wcm92aWRlcklkKXRocm93IEVycm9yKFwiSW52YWxpZCBwcm92aWRlciBpZCFcIik7fTt0KE9pLFNpKTt2YXIgUWk9ZnVuY3Rpb24oYSl7U2kuY2FsbCh0aGlzLGEpO2lmKFwiZ2l0aHViLmNvbVwiIT10aGlzLnByb3ZpZGVySWQpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHByb3ZpZGVyIGlkIVwiKTtOKHRoaXMsXCJ1c2VybmFtZVwiLHRoaXMucHJvZmlsZSYmdGhpcy5wcm9maWxlLmxvZ2lufHxudWxsKX07dChRaSxTaSk7dmFyIFBpPWZ1bmN0aW9uKGEpe1NpLmNhbGwodGhpcyxhKTtpZihcImdvb2dsZS5jb21cIiE9dGhpcy5wcm92aWRlcklkKXRocm93IEVycm9yKFwiSW52YWxpZCBwcm92aWRlciBpZCFcIik7fTt0KFBpLFNpKTtcbnZhciBSaT1mdW5jdGlvbihhKXtTaS5jYWxsKHRoaXMsYSk7aWYoXCJ0d2l0dGVyLmNvbVwiIT10aGlzLnByb3ZpZGVySWQpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHByb3ZpZGVyIGlkIVwiKTtOKHRoaXMsXCJ1c2VybmFtZVwiLGEuc2NyZWVuTmFtZXx8bnVsbCl9O3QoUmksU2kpO3ZhciBWaT17TE9DQUw6XCJsb2NhbFwiLE5PTkU6XCJub25lXCIsU0VTU0lPTjpcInNlc3Npb25cIn0sV2k9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IE8oXCJpbnZhbGlkLXBlcnNpc3RlbmNlLXR5cGVcIiksYz1uZXcgTyhcInVuc3VwcG9ydGVkLXBlcnNpc3RlbmNlLXR5cGVcIik7YTp7Zm9yKGQgaW4gVmkpaWYoVmlbZF09PWEpe3ZhciBkPSEwO2JyZWFrIGF9ZD0hMX1pZighZHx8XCJzdHJpbmdcIiE9PXR5cGVvZiBhKXRocm93IGI7c3dpdGNoKEdmKCkpe2Nhc2UgXCJSZWFjdE5hdGl2ZVwiOmlmKFwic2Vzc2lvblwiPT09YSl0aHJvdyBjO2JyZWFrO2Nhc2UgXCJOb2RlXCI6aWYoXCJub25lXCIhPT1hKXRocm93IGM7YnJlYWs7ZGVmYXVsdDppZighTGYoKSYmXCJub25lXCIhPT1hKXRocm93IGM7fX0sWGk9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5NZT1hO3RoaXMuWGQ9Yjt0aGlzLm9nPWM7dGhpcy5WZT1kO3RoaXMuUz17fTtGaXx8KEZpPW5ldyBFaSk7YT1GaTt0cnl7aWYocWYoKSl7dWl8fCh1aT1uZXcgdGkoXCJmaXJlYmFzZUxvY2FsU3RvcmFnZURiXCIsXG5cImZpcmViYXNlTG9jYWxTdG9yYWdlXCIsXCJmYmFzZV9rZXlcIixcInZhbHVlXCIsMSkpO3ZhciBlPXVpfWVsc2UgZT1uZXcgYS5zZS5EO3RoaXMuU2U9ZX1jYXRjaChmKXt0aGlzLlNlPW5ldyBuaSx0aGlzLlZlPSEwfXRyeXt0aGlzLmFmPW5ldyBhLnNlLmVlfWNhdGNoKGYpe3RoaXMuYWY9bmV3IG5pfXRoaXMuUWY9bmV3IG5pO3RoaXMuZGU9cih0aGlzLlplLHRoaXMpO3RoaXMuTj17fX0sWWksWmk9ZnVuY3Rpb24oKXtZaXx8KFlpPW5ldyBYaShcImZpcmViYXNlXCIsXCI6XCIsIVNmKEwoKSkmJkZmKCk/ITA6ITEsT2YoKSkpO3JldHVybiBZaX0sJGk9ZnVuY3Rpb24oYSxiKXtzd2l0Y2goYil7Y2FzZSBcInNlc3Npb25cIjpyZXR1cm4gYS5hZjtjYXNlIFwibm9uZVwiOnJldHVybiBhLlFmO2RlZmF1bHQ6cmV0dXJuIGEuU2V9fTtoPVhpLnByb3RvdHlwZTtoLmNhPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuTWUrdGhpcy5YZCthLm5hbWUrKGI/dGhpcy5YZCtiOlwiXCIpfTtcbmguZ2V0PWZ1bmN0aW9uKGEsYil7cmV0dXJuICRpKHRoaXMsYS5EKS5nZXQodGhpcy5jYShhLGIpKX07aC5yZW1vdmU9ZnVuY3Rpb24oYSxiKXtiPXRoaXMuY2EoYSxiKTtcImxvY2FsXCI9PWEuRCYmKHRoaXMuTltiXT1udWxsKTtyZXR1cm4gJGkodGhpcyxhLkQpLnJlbW92ZShiKX07aC5zZXQ9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuY2EoYSxjKSxlPXRoaXMsZj0kaSh0aGlzLGEuRCk7cmV0dXJuIGYuc2V0KGQsYikudGhlbihmdW5jdGlvbigpe3JldHVybiBmLmdldChkKX0pLnRoZW4oZnVuY3Rpb24oYil7XCJsb2NhbFwiPT1hLkQmJihlLk5bZF09Yil9KX07XG5oLmFkZExpc3RlbmVyPWZ1bmN0aW9uKGEsYixjKXthPXRoaXMuY2EoYSxiKTtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGsubG9jYWxTdG9yYWdlJiZcImZ1bmN0aW9uXCI9PT10eXBlb2Ygay5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSYmKHRoaXMuTlthXT1rLmxvY2FsU3RvcmFnZS5nZXRJdGVtKGEpKTtpYih0aGlzLlMpJiZ0aGlzLmNlKCk7dGhpcy5TW2FdfHwodGhpcy5TW2FdPVtdKTt0aGlzLlNbYV0ucHVzaChjKX07aC5yZW1vdmVMaXN0ZW5lcj1mdW5jdGlvbihhLGIsYyl7YT10aGlzLmNhKGEsYik7dGhpcy5TW2FdJiYoWWEodGhpcy5TW2FdLGZ1bmN0aW9uKGEpe3JldHVybiBhPT1jfSksMD09dGhpcy5TW2FdLmxlbmd0aCYmZGVsZXRlIHRoaXMuU1thXSk7aWIodGhpcy5TKSYmdGhpcy5TYygpfTtoLmNlPWZ1bmN0aW9uKCl7JGkodGhpcyxcImxvY2FsXCIpLmpiKHRoaXMuZGUpO3RoaXMuVmV8fHFmKCl8fGFqKHRoaXMpfTtcbnZhciBhaj1mdW5jdGlvbihhKXtiaihhKTthLkZkPXNldEludGVydmFsKGZ1bmN0aW9uKCl7Zm9yKHZhciBiIGluIGEuUyl7dmFyIGM9ay5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShiKSxkPWEuTltiXTtjIT1kJiYoYS5OW2JdPWMsYz1uZXcgWWIoe3R5cGU6XCJzdG9yYWdlXCIsa2V5OmIsdGFyZ2V0OndpbmRvdyxvbGRWYWx1ZTpkLG5ld1ZhbHVlOmMsTWQ6ITB9KSxhLlplKGMpKX19LDFFMyl9LGJqPWZ1bmN0aW9uKGEpe2EuRmQmJihjbGVhckludGVydmFsKGEuRmQpLGEuRmQ9bnVsbCl9O1hpLnByb3RvdHlwZS5TYz1mdW5jdGlvbigpeyRpKHRoaXMsXCJsb2NhbFwiKS4kYSh0aGlzLmRlKTtiaih0aGlzKX07XG5YaS5wcm90b3R5cGUuWmU9ZnVuY3Rpb24oYSl7aWYoYSYmYS5IZil7dmFyIGI9YS5SLmtleTtpZihudWxsPT1iKWZvcih2YXIgYyBpbiB0aGlzLlMpe3ZhciBkPXRoaXMuTltjXTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGQmJihkPW51bGwpO3ZhciBlPWsubG9jYWxTdG9yYWdlLmdldEl0ZW0oYyk7ZSE9PWQmJih0aGlzLk5bY109ZSx0aGlzLmhkKGMpKX1lbHNlIGlmKDA9PWIuaW5kZXhPZih0aGlzLk1lK3RoaXMuWGQpJiZ0aGlzLlNbYl0pe1widW5kZWZpbmVkXCIhPT10eXBlb2YgYS5SLk1kPyRpKHRoaXMsXCJsb2NhbFwiKS4kYSh0aGlzLmRlKTpiaih0aGlzKTtpZih0aGlzLm9nKWlmKGM9ay5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShiKSxkPWEuUi5uZXdWYWx1ZSxkIT09YyludWxsIT09ZD9rLmxvY2FsU3RvcmFnZS5zZXRJdGVtKGIsZCk6ay5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShiKTtlbHNlIGlmKHRoaXMuTltiXT09PWQmJlwidW5kZWZpbmVkXCI9PT10eXBlb2YgYS5SLk1kKXJldHVybjtcbnZhciBmPXRoaXM7Yz1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYS5SLk1kfHxmLk5bYl0hPT1rLmxvY2FsU3RvcmFnZS5nZXRJdGVtKGIpKWYuTltiXT1rLmxvY2FsU3RvcmFnZS5nZXRJdGVtKGIpLGYuaGQoYil9O3omJkNiJiYxMD09Q2ImJmsubG9jYWxTdG9yYWdlLmdldEl0ZW0oYikhPT1hLlIubmV3VmFsdWUmJmEuUi5uZXdWYWx1ZSE9PWEuUi5vbGRWYWx1ZT9zZXRUaW1lb3V0KGMsMTApOmMoKX19ZWxzZSB4KGEscih0aGlzLmhkLHRoaXMpKX07WGkucHJvdG90eXBlLmhkPWZ1bmN0aW9uKGEpe3RoaXMuU1thXSYmeCh0aGlzLlNbYV0sZnVuY3Rpb24oYSl7YSgpfSl9O3ZhciBjaj1mdW5jdGlvbihhLGIpe3RoaXMuaj1hO3RoaXMuaD1ifHxaaSgpfSxkaj17bmFtZTpcImF1dGhFdmVudFwiLEQ6XCJsb2NhbFwifSxlaj1mdW5jdGlvbihhKXtyZXR1cm4gYS5oLmdldChkaixhLmopLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIG5nKGEpfSl9O2NqLnByb3RvdHlwZS5pYj1mdW5jdGlvbihhKXt0aGlzLmguYWRkTGlzdGVuZXIoZGosdGhpcy5qLGEpfTtjai5wcm90b3R5cGUuZGM9ZnVuY3Rpb24oYSl7dGhpcy5oLnJlbW92ZUxpc3RlbmVyKGRqLHRoaXMuaixhKX07dmFyIGZqPWZ1bmN0aW9uKGEpe3RoaXMuaD1hfHxaaSgpfSxnaj17bmFtZTpcInNlc3Npb25JZFwiLEQ6XCJzZXNzaW9uXCJ9O2ZqLnByb3RvdHlwZS50Yz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5oLmdldChnaixhKX07dmFyIGhqPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcpe3RoaXMuQj1hO3RoaXMubT1iO3RoaXMubz1jO3RoaXMuTGE9ZHx8bnVsbDt0aGlzLlA9Z3x8bnVsbDt0aGlzLiRlPWIrXCI6XCIrYzt0aGlzLnBnPW5ldyBmajt0aGlzLnhlPW5ldyBjaih0aGlzLiRlKTt0aGlzLkFkPW51bGw7dGhpcy50YT1bXTt0aGlzLlZmPWV8fDUwMDt0aGlzLmlnPWZ8fDJFMzt0aGlzLlJiPXRoaXMuSmM9bnVsbH0saWo9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBPKFwiaW52YWxpZC1jb3Jkb3ZhLWNvbmZpZ3VyYXRpb25cIixhKX07XG5oai5wcm90b3R5cGUuUmE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5UYj90aGlzLlRiOnRoaXMuVGI9RGYoKS50aGVuKGZ1bmN0aW9uKCl7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIE0oXCJ1bml2ZXJzYWxMaW5rcy5zdWJzY3JpYmVcIixrKSl0aHJvdyBpaihcImNvcmRvdmEtdW5pdmVyc2FsLWxpbmtzLXBsdWdpbiBpcyBub3QgaW5zdGFsbGVkXCIpO2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgTShcIkJ1aWxkSW5mby5wYWNrYWdlTmFtZVwiLGspKXRocm93IGlqKFwiY29yZG92YS1wbHVnaW4tYnVpbGRpbmZvIGlzIG5vdCBpbnN0YWxsZWRcIik7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIE0oXCJjb3Jkb3ZhLnBsdWdpbnMuYnJvd3NlcnRhYi5vcGVuVXJsXCIsaykpdGhyb3cgaWooXCJjb3Jkb3ZhLXBsdWdpbi1icm93c2VydGFiIGlzIG5vdCBpbnN0YWxsZWRcIik7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIE0oXCJjb3Jkb3ZhLkluQXBwQnJvd3Nlci5vcGVuXCIsaykpdGhyb3cgaWooXCJjb3Jkb3ZhLXBsdWdpbi1pbmFwcGJyb3dzZXIgaXMgbm90IGluc3RhbGxlZFwiKTtcbn0sZnVuY3Rpb24oKXt0aHJvdyBuZXcgTyhcImNvcmRvdmEtbm90LXJlYWR5XCIpO30pfTt2YXIgamo9ZnVuY3Rpb24oKXtmb3IodmFyIGE9MjAsYj1bXTswPGE7KWIucHVzaChcIjEyMzQ1Njc4OTBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIuY2hhckF0KE1hdGguZmxvb3IoNjIqTWF0aC5yYW5kb20oKSkpKSxhLS07cmV0dXJuIGIuam9pbihcIlwiKX0sa2o9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IFNiO2IudXBkYXRlKGEpO3JldHVybiBhYihiLmRpZ2VzdCgpKX07aD1oai5wcm90b3R5cGU7aC5lYz1mdW5jdGlvbihhLGIpe2IobmV3IE8oXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIpKTtyZXR1cm4gRCgpfTtoLiRiPWZ1bmN0aW9uKCl7cmV0dXJuIEUobmV3IE8oXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIpKX07aC5iZj1mdW5jdGlvbigpe3JldHVybiExfTtoLlllPWZ1bmN0aW9uKCl7cmV0dXJuITB9O1xuaC5CZT1mdW5jdGlvbigpe3JldHVybiEwfTtcbmguYWM9ZnVuY3Rpb24oYSxiLGMpe2lmKHRoaXMuSmMpcmV0dXJuIEUobmV3IE8oXCJyZWRpcmVjdC1vcGVyYXRpb24tcGVuZGluZ1wiKSk7dmFyIGQ9dGhpcyxlPWsuZG9jdW1lbnQsZj1udWxsLGc9bnVsbCxsPW51bGwsbj1udWxsO3JldHVybiB0aGlzLkpjPUVkKEQoKS50aGVuKGZ1bmN0aW9uKCl7U2coYik7cmV0dXJuIGxqKGQpfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBtaihkLGEsYixjKX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4obmV3IEMoZnVuY3Rpb24oYSxiKXtnPWZ1bmN0aW9uKCl7dmFyIGI9TShcImNvcmRvdmEucGx1Z2lucy5icm93c2VydGFiLmNsb3NlXCIsayk7YSgpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBiJiZiKCk7ZC5SYiYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGQuUmIuY2xvc2UmJihkLlJiLmNsb3NlKCksZC5SYj1udWxsKTtyZXR1cm4hMX07ZC5pYihnKTtsPWZ1bmN0aW9uKCl7Znx8KGY9QmUoZC5pZykudGhlbihmdW5jdGlvbigpe2IobmV3IE8oXCJyZWRpcmVjdC1jYW5jZWxsZWQtYnktdXNlclwiKSl9KSl9O249XG5mdW5jdGlvbigpe1dmKCkmJmwoKX07ZS5hZGRFdmVudExpc3RlbmVyKFwicmVzdW1lXCIsbCwhMSk7TCgpLnRvTG93ZXJDYXNlKCkubWF0Y2goL2FuZHJvaWQvKXx8ZS5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLG4sITEpfSkpLmcoZnVuY3Rpb24oYSl7cmV0dXJuIG5qKGQpLnRoZW4oZnVuY3Rpb24oKXt0aHJvdyBhO30pfSl9KSxmdW5jdGlvbigpe2wmJmUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc3VtZVwiLGwsITEpO24mJmUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIixuLCExKTtmJiZmLmNhbmNlbCgpO2cmJmQuZGMoZyk7ZC5KYz1udWxsfSl9O1xudmFyIG1qPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWpqKCksZj1uZXcgbWcoYixkLG51bGwsZSxuZXcgTyhcIm5vLWF1dGgtZXZlbnRcIikpLGc9TShcIkJ1aWxkSW5mby5wYWNrYWdlTmFtZVwiLGspO2lmKFwic3RyaW5nXCIhPT10eXBlb2YgZyl0aHJvdyBuZXcgTyhcImludmFsaWQtY29yZG92YS1jb25maWd1cmF0aW9uXCIpO3ZhciBsPU0oXCJCdWlsZEluZm8uZGlzcGxheU5hbWVcIixrKSxuPXt9O2lmKEwoKS50b0xvd2VyQ2FzZSgpLm1hdGNoKC9pcGhvbmV8aXBhZHxpcG9kLykpbi5pYmk9ZztlbHNlIGlmKEwoKS50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hbmRyb2lkLykpbi5hcG49ZztlbHNlIHJldHVybiBFKG5ldyBPKFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiKSk7bCYmKG4uYXBwRGlzcGxheU5hbWU9bCk7ZT1raihlKTtuLnNlc3Npb25JZD1lO3ZhciBGPWNpKGEuQixhLm0sYS5vLGIsYyxudWxsLGQsYS5MYSxuLGEuUCk7cmV0dXJuIGEuUmEoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGI9XG5hLiRlO3JldHVybiBhLnBnLmguc2V0KGRqLGYuQSgpLGIpfSkudGhlbihmdW5jdGlvbigpe3ZhciBiPU0oXCJjb3Jkb3ZhLnBsdWdpbnMuYnJvd3NlcnRhYi5pc0F2YWlsYWJsZVwiLGspO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBiKXRocm93IG5ldyBPKFwiaW52YWxpZC1jb3Jkb3ZhLWNvbmZpZ3VyYXRpb25cIik7dmFyIGM9bnVsbDtiKGZ1bmN0aW9uKGIpe2lmKGIpe2M9TShcImNvcmRvdmEucGx1Z2lucy5icm93c2VydGFiLm9wZW5VcmxcIixrKTtpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgYyl0aHJvdyBuZXcgTyhcImludmFsaWQtY29yZG92YS1jb25maWd1cmF0aW9uXCIpO2MoRil9ZWxzZXtjPU0oXCJjb3Jkb3ZhLkluQXBwQnJvd3Nlci5vcGVuXCIsayk7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIGMpdGhyb3cgbmV3IE8oXCJpbnZhbGlkLWNvcmRvdmEtY29uZmlndXJhdGlvblwiKTtiPWM7dmFyIGQ9TCgpO2Q9ISghZC5tYXRjaCgvKGlQYWR8aVBob25lfGlQb2QpLipPUyA3X1xcZC9pKSYmIWQubWF0Y2goLyhpUGFkfGlQaG9uZXxpUG9kKS4qT1MgOF9cXGQvaSkpO1xuYS5SYj1iKEYsZD9cIl9ibGFua1wiOlwiX3N5c3RlbVwiLFwibG9jYXRpb249eWVzXCIpfX0pfSl9O2hqLnByb3RvdHlwZS5MYj1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPHRoaXMudGEubGVuZ3RoO2IrKyl0cnl7dGhpcy50YVtiXShhKX1jYXRjaChjKXt9fTtcbnZhciBsaj1mdW5jdGlvbihhKXthLkFkfHwoYS5BZD1hLlJhKCkudGhlbihmdW5jdGlvbigpe3JldHVybiBuZXcgQyhmdW5jdGlvbihiKXt2YXIgYz1mdW5jdGlvbihkKXtiKGQpO2EuZGMoYyk7cmV0dXJuITF9O2EuaWIoYyk7b2ooYSl9KX0pKTtyZXR1cm4gYS5BZH0sbmo9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbDtyZXR1cm4gZWooYS54ZSkudGhlbihmdW5jdGlvbihjKXtiPWM7Yz1hLnhlO3JldHVybiBjLmgucmVtb3ZlKGRqLGMuail9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KX0sb2o9ZnVuY3Rpb24oYSl7dmFyIGI9TShcInVuaXZlcnNhbExpbmtzLnN1YnNjcmliZVwiLGspO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBiKXRocm93IG5ldyBPKFwiaW52YWxpZC1jb3Jkb3ZhLWNvbmZpZ3VyYXRpb25cIik7dmFyIGM9bmV3IG1nKFwidW5rbm93blwiLG51bGwsbnVsbCxudWxsLG5ldyBPKFwibm8tYXV0aC1ldmVudFwiKSksZD0hMSxlPUJlKGEuVmYpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gbmooYSkudGhlbihmdW5jdGlvbigpe2R8fFxuYS5MYihjKX0pfSksZj1mdW5jdGlvbihiKXtkPSEwO2UmJmUuY2FuY2VsKCk7bmooYSkudGhlbihmdW5jdGlvbihkKXt2YXIgZT1jO2lmKGQmJmImJmIudXJsKXtlPW51bGw7dmFyIGY9Yi51cmw7dmFyIGc9Z2YoZiksbD1mZihnLFwibGlua1wiKSxuPWZmKGdmKGwpLFwibGlua1wiKTtnPWZmKGcsXCJkZWVwX2xpbmtfaWRcIik7Zj1mZihnZihnKSxcImxpbmtcIil8fGd8fG58fGx8fGY7LTEhPWYuaW5kZXhPZihcIi9fXy9hdXRoL2NhbGxiYWNrXCIpJiYoZT1nZihmKSxlPVJmKGZmKGUsXCJmaXJlYmFzZUVycm9yXCIpfHxudWxsKSxlPShlPVwib2JqZWN0XCI9PT10eXBlb2YgZT9sZyhlKTpudWxsKT9uZXcgbWcoZC5tYSxkLlksbnVsbCxudWxsLGUpOm5ldyBtZyhkLm1hLGQuWSxmLGQudGMoKSkpO2U9ZXx8Y31hLkxiKGUpfSl9LGc9ay5oYW5kbGVPcGVuVVJMO2suaGFuZGxlT3BlblVSTD1mdW5jdGlvbihhKXswPT1hLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihNKFwiQnVpbGRJbmZvLnBhY2thZ2VOYW1lXCIsaykudG9Mb3dlckNhc2UoKStcblwiOi8vXCIpJiZmKHt1cmw6YX0pO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnKXRyeXtnKGEpfWNhdGNoKG4pe2NvbnNvbGUuZXJyb3Iobil9fTtiKG51bGwsZil9O2hqLnByb3RvdHlwZS5pYj1mdW5jdGlvbihhKXt0aGlzLnRhLnB1c2goYSk7bGoodGhpcykuZyhmdW5jdGlvbihiKXtcImF1dGgvaW52YWxpZC1jb3Jkb3ZhLWNvbmZpZ3VyYXRpb25cIj09PWIuY29kZSYmKGI9bmV3IG1nKFwidW5rbm93blwiLG51bGwsbnVsbCxudWxsLG5ldyBPKFwibm8tYXV0aC1ldmVudFwiKSksYShiKSl9KX07aGoucHJvdG90eXBlLmRjPWZ1bmN0aW9uKGEpe1lhKHRoaXMudGEsZnVuY3Rpb24oYil7cmV0dXJuIGI9PWF9KX07dmFyIHBqPWZ1bmN0aW9uKGEpe3RoaXMuaj1hO3RoaXMuaD1aaSgpfSxxaj17bmFtZTpcInBlbmRpbmdSZWRpcmVjdFwiLEQ6XCJzZXNzaW9uXCJ9LHJqPWZ1bmN0aW9uKGEpe3JldHVybiBhLmguc2V0KHFqLFwicGVuZGluZ1wiLGEuail9LHNqPWZ1bmN0aW9uKGEpe3JldHVybiBhLmgucmVtb3ZlKHFqLGEuail9LHRqPWZ1bmN0aW9uKGEpe3JldHVybiBhLmguZ2V0KHFqLGEuaikudGhlbihmdW5jdGlvbihhKXtyZXR1cm5cInBlbmRpbmdcIj09YX0pfTt2YXIgeGo9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuQj1hO3RoaXMubT1iO3RoaXMubz1jO3RoaXMuZ2M9W107dGhpcy5zYj0hMTt0aGlzLmVkPXIodGhpcy52ZCx0aGlzKTt0aGlzLlhhPW5ldyB1aih0aGlzKTt0aGlzLk9kPW5ldyB2aih0aGlzKTt0aGlzLlhiPW5ldyBwaih0aGlzLm0rXCI6XCIrdGhpcy5vKTt0aGlzLklhPXt9O3RoaXMuSWEudW5rbm93bj10aGlzLlhhO3RoaXMuSWEuc2lnbkluVmlhUmVkaXJlY3Q9dGhpcy5YYTt0aGlzLklhLmxpbmtWaWFSZWRpcmVjdD10aGlzLlhhO3RoaXMuSWEucmVhdXRoVmlhUmVkaXJlY3Q9dGhpcy5YYTt0aGlzLklhLnNpZ25JblZpYVBvcHVwPXRoaXMuT2Q7dGhpcy5JYS5saW5rVmlhUG9wdXA9dGhpcy5PZDt0aGlzLklhLnJlYXV0aFZpYVBvcHVwPXRoaXMuT2Q7dGhpcy5aPXdqKHRoaXMuQix0aGlzLm0sdGhpcy5vLHBmKX0sd2o9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9ZmlyZWJhc2UuU0RLX1ZFUlNJT058fG51bGw7cmV0dXJuIENmKCk/bmV3IGhqKGEsXG5iLGMsZSx2b2lkIDAsdm9pZCAwLGQpOm5ldyBZaChhLGIsYyxlLGQpfTt4ai5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLnNiPSExO3RoaXMuWi5kYyh0aGlzLmVkKTt0aGlzLlo9d2oodGhpcy5CLHRoaXMubSx0aGlzLm8pfTt4ai5wcm90b3R5cGUuU2I9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3RoaXMuc2J8fCh0aGlzLnNiPSEwLHRoaXMuWi5pYih0aGlzLmVkKSk7dmFyIGI9dGhpcy5aO3JldHVybiB0aGlzLlouUmEoKS5nKGZ1bmN0aW9uKGMpe2EuWj09YiYmYS5yZXNldCgpO3Rocm93IGM7fSl9O3ZhciBBaj1mdW5jdGlvbihhKXthLlouWWUoKSYmYS5TYigpLmcoZnVuY3Rpb24oYil7dmFyIGM9bmV3IG1nKFwidW5rbm93blwiLG51bGwsbnVsbCxudWxsLG5ldyBPKFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiKSk7eWooYikmJmEudmQoYyl9KTthLlouQmUoKXx8emooYS5YYSl9O1xueGoucHJvdG90eXBlLnN1YnNjcmliZT1mdW5jdGlvbihhKXtWYSh0aGlzLmdjLGEpfHx0aGlzLmdjLnB1c2goYSk7aWYoIXRoaXMuc2Ipe3ZhciBiPXRoaXM7dGoodGhpcy5YYikudGhlbihmdW5jdGlvbihhKXthP3NqKGIuWGIpLnRoZW4oZnVuY3Rpb24oKXtiLlNiKCkuZyhmdW5jdGlvbihhKXt2YXIgYz1uZXcgbWcoXCJ1bmtub3duXCIsbnVsbCxudWxsLG51bGwsbmV3IE8oXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIpKTt5aihhKSYmYi52ZChjKX0pfSk6QWooYil9KS5nKGZ1bmN0aW9uKCl7QWooYil9KX19O3hqLnByb3RvdHlwZS51bnN1YnNjcmliZT1mdW5jdGlvbihhKXtZYSh0aGlzLmdjLGZ1bmN0aW9uKGIpe3JldHVybiBiPT1hfSl9O1xueGoucHJvdG90eXBlLnZkPWZ1bmN0aW9uKGEpe2lmKCFhKXRocm93IG5ldyBPKFwiaW52YWxpZC1hdXRoLWV2ZW50XCIpO2Zvcih2YXIgYj0hMSxjPTA7Yzx0aGlzLmdjLmxlbmd0aDtjKyspe3ZhciBkPXRoaXMuZ2NbY107aWYoZC5rZShhLm1hLGEuWSkpeyhiPXRoaXMuSWFbYS5tYV0pJiZiLlRlKGEsZCk7Yj0hMDticmVha319emoodGhpcy5YYSk7cmV0dXJuIGJ9O3ZhciBCaj1uZXcgVmYoMkUzLDFFNCksQ2o9bmV3IFZmKDNFNCw2RTQpO3hqLnByb3RvdHlwZS5nZXRSZWRpcmVjdFJlc3VsdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLlhhLmdldFJlZGlyZWN0UmVzdWx0KCl9O3hqLnByb3RvdHlwZS4kYj1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPXRoaXM7cmV0dXJuIHRoaXMuWi4kYihhLGIsYyxmdW5jdGlvbigpe2Yuc2J8fChmLnNiPSEwLGYuWi5pYihmLmVkKSl9LGZ1bmN0aW9uKCl7Zi5yZXNldCgpfSxkLGUpfTtcbnZhciB5aj1mdW5jdGlvbihhKXtyZXR1cm4gYSYmXCJhdXRoL2NvcmRvdmEtbm90LXJlYWR5XCI9PWEuY29kZT8hMDohMX07eGoucHJvdG90eXBlLmFjPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLGU7cmV0dXJuIHJqKHRoaXMuWGIpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZC5aLmFjKGEsYixjKS5nKGZ1bmN0aW9uKGEpe2lmKHlqKGEpKXRocm93IG5ldyBPKFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiKTtlPWE7cmV0dXJuIHNqKGQuWGIpLnRoZW4oZnVuY3Rpb24oKXt0aHJvdyBlO30pfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBkLlouYmYoKT9uZXcgQyhmdW5jdGlvbigpe30pOnNqKGQuWGIpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZC5nZXRSZWRpcmVjdFJlc3VsdCgpfSkudGhlbihmdW5jdGlvbigpe30pLmcoZnVuY3Rpb24oKXt9KX0pfSl9O1xueGoucHJvdG90eXBlLmVjPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiB0aGlzLlouZWMoYyxmdW5jdGlvbihjKXthLmJiKGIsbnVsbCxjLGQpfSxCai5nZXQoKSl9O3ZhciBEaj17fSxFaj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YitcIjpcIitjO0RqW2RdfHwoRGpbZF09bmV3IHhqKGEsYixjKSk7cmV0dXJuIERqW2RdfSx1aj1mdW5jdGlvbihhKXt0aGlzLmg9YTt0aGlzLkFiPW51bGw7dGhpcy5jYz1bXTt0aGlzLmJjPVtdO3RoaXMueWI9bnVsbDt0aGlzLlNkPSExfTt1ai5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLkFiPW51bGw7dGhpcy55YiYmKHRoaXMueWIuY2FuY2VsKCksdGhpcy55Yj1udWxsKX07XG51ai5wcm90b3R5cGUuVGU9ZnVuY3Rpb24oYSxiKXtpZighYSlyZXR1cm4gRShuZXcgTyhcImludmFsaWQtYXV0aC1ldmVudFwiKSk7dGhpcy5yZXNldCgpO3RoaXMuU2Q9ITA7dmFyIGM9YS5tYSxkPWEuWSxlPWEuZ2V0RXJyb3IoKSYmXCJhdXRoL3dlYi1zdG9yYWdlLXVuc3VwcG9ydGVkXCI9PWEuZ2V0RXJyb3IoKS5jb2RlLGY9YS5nZXRFcnJvcigpJiZcImF1dGgvb3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiPT1hLmdldEVycm9yKCkuY29kZTtcInVua25vd25cIiE9Y3x8ZXx8Zj9hPWEuYmE/dGhpcy5QZChhLGIpOmIuTmIoYyxkKT90aGlzLlFkKGEsYik6RShuZXcgTyhcImludmFsaWQtYXV0aC1ldmVudFwiKSk6KEZqKHRoaXMsITEsbnVsbCxudWxsKSxhPUQoKSk7cmV0dXJuIGF9O3ZhciB6aj1mdW5jdGlvbihhKXthLlNkfHwoYS5TZD0hMCxGaihhLCExLG51bGwsbnVsbCkpfTtcbnVqLnByb3RvdHlwZS5QZD1mdW5jdGlvbihhKXtGaih0aGlzLCEwLG51bGwsYS5nZXRFcnJvcigpKTtyZXR1cm4gRCgpfTt1ai5wcm90b3R5cGUuUWQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO2I9Yi5OYihhLm1hLGEuWSk7dmFyIGQ9YS5FYixlPWEudGMoKSxmPSEhYS5tYS5tYXRjaCgvUmVkaXJlY3QkLyk7cmV0dXJuIGIoZCxlKS50aGVuKGZ1bmN0aW9uKGEpe0ZqKGMsZixhLG51bGwpfSkuZyhmdW5jdGlvbihhKXtGaihjLGYsbnVsbCxhKX0pfTtcbnZhciBHaj1mdW5jdGlvbihhLGIpe2EuQWI9ZnVuY3Rpb24oKXtyZXR1cm4gRShiKX07aWYoYS5iYy5sZW5ndGgpZm9yKHZhciBjPTA7YzxhLmJjLmxlbmd0aDtjKyspYS5iY1tjXShiKX0sSGo9ZnVuY3Rpb24oYSxiKXthLkFiPWZ1bmN0aW9uKCl7cmV0dXJuIEQoYil9O2lmKGEuY2MubGVuZ3RoKWZvcih2YXIgYz0wO2M8YS5jYy5sZW5ndGg7YysrKWEuY2NbY10oYil9LEZqPWZ1bmN0aW9uKGEsYixjLGQpe2I/ZD9HaihhLGQpOkhqKGEsYyk6SGooYSx7dXNlcjpudWxsfSk7YS5jYz1bXTthLmJjPVtdfTt1ai5wcm90b3R5cGUuZ2V0UmVkaXJlY3RSZXN1bHQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3JldHVybiBuZXcgQyhmdW5jdGlvbihiLGMpe2EuQWI/YS5BYigpLnRoZW4oYixjKTooYS5jYy5wdXNoKGIpLGEuYmMucHVzaChjKSxJaihhKSl9KX07XG52YXIgSWo9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IE8oXCJ0aW1lb3V0XCIpO2EueWImJmEueWIuY2FuY2VsKCk7YS55Yj1CZShDai5nZXQoKSkudGhlbihmdW5jdGlvbigpe2EuQWJ8fEZqKGEsITAsbnVsbCxiKX0pfSx2aj1mdW5jdGlvbihhKXt0aGlzLmg9YX07dmoucHJvdG90eXBlLlRlPWZ1bmN0aW9uKGEsYil7aWYoIWEpcmV0dXJuIEUobmV3IE8oXCJpbnZhbGlkLWF1dGgtZXZlbnRcIikpO3ZhciBjPWEubWEsZD1hLlk7cmV0dXJuIGEuYmE/dGhpcy5QZChhLGIpOmIuTmIoYyxkKT90aGlzLlFkKGEsYik6RShuZXcgTyhcImludmFsaWQtYXV0aC1ldmVudFwiKSl9O3ZqLnByb3RvdHlwZS5QZD1mdW5jdGlvbihhLGIpe2IuYmIoYS5tYSxudWxsLGEuZ2V0RXJyb3IoKSxhLlkpO3JldHVybiBEKCl9O1xudmoucHJvdG90eXBlLlFkPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5ZLGQ9YS5tYSxlPWIuTmIoZCxjKSxmPWEuRWI7YT1hLnRjKCk7cmV0dXJuIGUoZixhKS50aGVuKGZ1bmN0aW9uKGEpe2IuYmIoZCxhLG51bGwsYyl9KS5nKGZ1bmN0aW9uKGEpe2IuYmIoZCxudWxsLGEsYyl9KX07dmFyIEpqPWZ1bmN0aW9uKGEpe3RoaXMuZj1hO3RoaXMuSmE9dGhpcy5mYT1udWxsO3RoaXMuTmE9MH07SmoucHJvdG90eXBlLkE9ZnVuY3Rpb24oKXtyZXR1cm57YXBpS2V5OnRoaXMuZi5tLHJlZnJlc2hUb2tlbjp0aGlzLmZhLGFjY2Vzc1Rva2VuOnRoaXMuSmEsZXhwaXJhdGlvblRpbWU6dGhpcy5OYX19O1xudmFyIExqPWZ1bmN0aW9uKGEsYil7dmFyIGM9Yi5pZFRva2VuLGQ9Yi5yZWZyZXNoVG9rZW47Yj1LaihiLmV4cGlyZXNJbik7YS5KYT1jO2EuTmE9YjthLmZhPWR9LEtqPWZ1bmN0aW9uKGEpe3JldHVybiBtYSgpKzFFMypwYXJzZUludChhLDEwKX0sTWo9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gaGgoYS5mLGIpLnRoZW4oZnVuY3Rpb24oYil7YS5KYT1iLmFjY2Vzc190b2tlbjthLk5hPUtqKGIuZXhwaXJlc19pbik7YS5mYT1iLnJlZnJlc2hfdG9rZW47cmV0dXJue2FjY2Vzc1Rva2VuOmEuSmEsZXhwaXJhdGlvblRpbWU6YS5OYSxyZWZyZXNoVG9rZW46YS5mYX19KS5nKGZ1bmN0aW9uKGIpe1wiYXV0aC91c2VyLXRva2VuLWV4cGlyZWRcIj09Yi5jb2RlJiYoYS5mYT1udWxsKTt0aHJvdyBiO30pfTtcbkpqLnByb3RvdHlwZS5nZXRUb2tlbj1mdW5jdGlvbihhKXthPSEhYTtyZXR1cm4gdGhpcy5KYSYmIXRoaXMuZmE/RShuZXcgTyhcInVzZXItdG9rZW4tZXhwaXJlZFwiKSk6YXx8IXRoaXMuSmF8fG1hKCk+dGhpcy5OYS0zRTQ/dGhpcy5mYT9Naih0aGlzLHtncmFudF90eXBlOlwicmVmcmVzaF90b2tlblwiLHJlZnJlc2hfdG9rZW46dGhpcy5mYX0pOkQobnVsbCk6RCh7YWNjZXNzVG9rZW46dGhpcy5KYSxleHBpcmF0aW9uVGltZTp0aGlzLk5hLHJlZnJlc2hUb2tlbjp0aGlzLmZhfSl9O3ZhciBOaj1mdW5jdGlvbihhLGIpe3RoaXMucGU9YXx8bnVsbDt0aGlzLkplPWJ8fG51bGw7YmcodGhpcyx7bGFzdFNpZ25JblRpbWU6WWYoYnx8bnVsbCksY3JlYXRpb25UaW1lOllmKGF8fG51bGwpfSl9O05qLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgTmoodGhpcy5wZSx0aGlzLkplKX07TmoucHJvdG90eXBlLkE9ZnVuY3Rpb24oKXtyZXR1cm57bGFzdExvZ2luQXQ6dGhpcy5KZSxjcmVhdGVkQXQ6dGhpcy5wZX19O3ZhciBPaj1mdW5jdGlvbihhLGIsYyxkLGUsZil7YmcodGhpcyx7dWlkOmEsZGlzcGxheU5hbWU6ZHx8bnVsbCxwaG90b1VSTDplfHxudWxsLGVtYWlsOmN8fG51bGwscGhvbmVOdW1iZXI6Znx8bnVsbCxwcm92aWRlcklkOmJ9KX0sUGo9ZnVuY3Rpb24oYSxiKXtCLmNhbGwodGhpcyxhKTtmb3IodmFyIGMgaW4gYil0aGlzW2NdPWJbY119O3QoUGosQik7XG52YXIgUz1mdW5jdGlvbihhLGIsYyl7dGhpcy5KPVtdO3RoaXMubT1hLmFwaUtleTt0aGlzLm89YS5hcHBOYW1lO3RoaXMuQj1hLmF1dGhEb21haW58fG51bGw7YT1maXJlYmFzZS5TREtfVkVSU0lPTj9KZihmaXJlYmFzZS5TREtfVkVSU0lPTik6bnVsbDt0aGlzLmY9bmV3IFIodGhpcy5tLG9mKHBmKSxhKTt0aGlzLnJhPW5ldyBKaih0aGlzLmYpO1FqKHRoaXMsYi5pZFRva2VuKTtMaih0aGlzLnJhLGIpO04odGhpcyxcInJlZnJlc2hUb2tlblwiLHRoaXMucmEuZmEpO1JqKHRoaXMsY3x8e30pO0cuY2FsbCh0aGlzKTt0aGlzLktjPSExO3RoaXMuQiYmTmYoKSYmKHRoaXMudj1Faih0aGlzLkIsdGhpcy5tLHRoaXMubykpO3RoaXMuUmM9W107dGhpcy5zYT1udWxsO3RoaXMud2I9U2oodGhpcyk7dGhpcy5HYj1yKHRoaXMud2QsdGhpcyk7dmFyIGQ9dGhpczt0aGlzLmlhPW51bGw7dGhpcy5QZT1mdW5jdGlvbihhKXtkLkNiKGEubGFuZ3VhZ2VDb2RlKX07dGhpcy5EZD1udWxsO3RoaXMuTT1cbltdO3RoaXMuT2U9ZnVuY3Rpb24oYSl7VGooZCxhLkZmKX07dGhpcy5zZD1udWxsfTt0KFMsRyk7Uy5wcm90b3R5cGUuQ2I9ZnVuY3Rpb24oYSl7dGhpcy5pYT1hO2FoKHRoaXMuZixhKX07dmFyIFVqPWZ1bmN0aW9uKGEsYil7YS5EZCYmdGMoYS5EZCxcImxhbmd1YWdlQ29kZUNoYW5nZWRcIixhLlBlKTsoYS5EZD1iKSYmbGMoYixcImxhbmd1YWdlQ29kZUNoYW5nZWRcIixhLlBlKX0sVGo9ZnVuY3Rpb24oYSxiKXthLk09YjtiaChhLmYsZmlyZWJhc2UuU0RLX1ZFUlNJT04/SmYoZmlyZWJhc2UuU0RLX1ZFUlNJT04sYS5NKTpudWxsKX0sVmo9ZnVuY3Rpb24oYSxiKXthLnNkJiZ0YyhhLnNkLFwiZnJhbWV3b3JrQ2hhbmdlZFwiLGEuT2UpOyhhLnNkPWIpJiZsYyhiLFwiZnJhbWV3b3JrQ2hhbmdlZFwiLGEuT2UpfTtTLnByb3RvdHlwZS53ZD1mdW5jdGlvbigpe3RoaXMud2IudWImJih0aGlzLndiLnN0b3AoKSx0aGlzLndiLnN0YXJ0KCkpfTtcbnZhciBXaj1mdW5jdGlvbihhKXt0cnl7cmV0dXJuIGZpcmViYXNlLmFwcChhLm8pLmF1dGgoKX1jYXRjaChiKXt0aHJvdyBuZXcgTyhcImludGVybmFsLWVycm9yXCIsXCJObyBmaXJlYmFzZS5hdXRoLkF1dGggaW5zdGFuY2UgaXMgYXZhaWxhYmxlIGZvciB0aGUgRmlyZWJhc2UgQXBwICdcIithLm8rXCInIVwiKTt9fSxTaj1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IExpKGZ1bmN0aW9uKCl7cmV0dXJuIGEuZ2V0SWRUb2tlbighMCl9LGZ1bmN0aW9uKGEpe3JldHVybiBhJiZcImF1dGgvbmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiPT1hLmNvZGU/ITA6ITF9LGZ1bmN0aW9uKCl7dmFyIGI9YS5yYS5OYS1tYSgpLTNFNTtyZXR1cm4gMDxiP2I6MH0sM0U0LDk2RTQsITEpfSxYaj1mdW5jdGlvbihhKXthLktifHxhLndiLnVifHwoYS53Yi5zdGFydCgpLHRjKGEsXCJ0b2tlbkNoYW5nZWRcIixhLkdiKSxsYyhhLFwidG9rZW5DaGFuZ2VkXCIsYS5HYikpfSxZaj1mdW5jdGlvbihhKXt0YyhhLFwidG9rZW5DaGFuZ2VkXCIsXG5hLkdiKTthLndiLnN0b3AoKX0sUWo9ZnVuY3Rpb24oYSxiKXthLkllPWI7TihhLFwiX2xhdFwiLGIpfSxaaj1mdW5jdGlvbihhLGIpe1lhKGEuUmMsZnVuY3Rpb24oYSl7cmV0dXJuIGE9PWJ9KX0sYWs9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGM9MDtjPGEuUmMubGVuZ3RoO2MrKyliLnB1c2goYS5SY1tjXShhKSk7cmV0dXJuIEJkKGIpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYX0pfSxiaz1mdW5jdGlvbihhKXthLnYmJiFhLktjJiYoYS5LYz0hMCxhLnYuc3Vic2NyaWJlKGEpKX0sUmo9ZnVuY3Rpb24oYSxiKXtiZyhhLHt1aWQ6Yi51aWQsZGlzcGxheU5hbWU6Yi5kaXNwbGF5TmFtZXx8bnVsbCxwaG90b1VSTDpiLnBob3RvVVJMfHxudWxsLGVtYWlsOmIuZW1haWx8fG51bGwsZW1haWxWZXJpZmllZDpiLmVtYWlsVmVyaWZpZWR8fCExLHBob25lTnVtYmVyOmIucGhvbmVOdW1iZXJ8fG51bGwsaXNBbm9ueW1vdXM6Yi5pc0Fub255bW91c3x8ITEsbWV0YWRhdGE6bmV3IE5qKGIuY3JlYXRlZEF0LFxuYi5sYXN0TG9naW5BdCkscHJvdmlkZXJEYXRhOltdfSl9O04oUy5wcm90b3R5cGUsXCJwcm92aWRlcklkXCIsXCJmaXJlYmFzZVwiKTt2YXIgY2s9ZnVuY3Rpb24oKXt9LGRrPWZ1bmN0aW9uKGEpe3JldHVybiBEKCkudGhlbihmdW5jdGlvbigpe2lmKGEuS2IpdGhyb3cgbmV3IE8oXCJhcHAtZGVsZXRlZFwiKTt9KX0sZWs9ZnVuY3Rpb24oYSl7cmV0dXJuIFJhKGEucHJvdmlkZXJEYXRhLGZ1bmN0aW9uKGEpe3JldHVybiBhLnByb3ZpZGVySWR9KX0sZ2s9ZnVuY3Rpb24oYSxiKXtiJiYoZmsoYSxiLnByb3ZpZGVySWQpLGEucHJvdmlkZXJEYXRhLnB1c2goYikpfSxmaz1mdW5jdGlvbihhLGIpe1lhKGEucHJvdmlkZXJEYXRhLGZ1bmN0aW9uKGEpe3JldHVybiBhLnByb3ZpZGVySWQ9PWJ9KX0saGs9ZnVuY3Rpb24oYSxiLGMpeyhcInVpZFwiIT1ifHxjKSYmYS5oYXNPd25Qcm9wZXJ0eShiKSYmTihhLGIsYyl9O1xuUy5wcm90b3R5cGUuY29weT1mdW5jdGlvbihhKXt2YXIgYj10aGlzO2IhPWEmJihiZyh0aGlzLHt1aWQ6YS51aWQsZGlzcGxheU5hbWU6YS5kaXNwbGF5TmFtZSxwaG90b1VSTDphLnBob3RvVVJMLGVtYWlsOmEuZW1haWwsZW1haWxWZXJpZmllZDphLmVtYWlsVmVyaWZpZWQscGhvbmVOdW1iZXI6YS5waG9uZU51bWJlcixpc0Fub255bW91czphLmlzQW5vbnltb3VzLHByb3ZpZGVyRGF0YTpbXX0pLGEubWV0YWRhdGE/Tih0aGlzLFwibWV0YWRhdGFcIixhLm1ldGFkYXRhLmNsb25lKCkpOk4odGhpcyxcIm1ldGFkYXRhXCIsbmV3IE5qKSx4KGEucHJvdmlkZXJEYXRhLGZ1bmN0aW9uKGEpe2drKGIsYSl9KSx0aGlzLnJhPWEucmEsTih0aGlzLFwicmVmcmVzaFRva2VuXCIsdGhpcy5yYS5mYSkpfTtTLnByb3RvdHlwZS5yZWxvYWQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3JldHVybiB0aGlzLmMoZGsodGhpcykudGhlbihmdW5jdGlvbigpe3JldHVybiBpayhhKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGFrKGEpfSkudGhlbihjayl9KSl9O1xudmFyIGlrPWZ1bmN0aW9uKGEpe3JldHVybiBhLmdldElkVG9rZW4oKS50aGVuKGZ1bmN0aW9uKGIpe3ZhciBjPWEuaXNBbm9ueW1vdXM7cmV0dXJuIGprKGEsYikudGhlbihmdW5jdGlvbigpe2N8fGhrKGEsXCJpc0Fub255bW91c1wiLCExKTtyZXR1cm4gYn0pfSl9O1MucHJvdG90eXBlLmdldElkVG9rZW49ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gdGhpcy5jKGRrKHRoaXMpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYi5yYS5nZXRUb2tlbihhKX0pLnRoZW4oZnVuY3Rpb24oYSl7aWYoIWEpdGhyb3cgbmV3IE8oXCJpbnRlcm5hbC1lcnJvclwiKTthLmFjY2Vzc1Rva2VuIT1iLkllJiYoUWooYixhLmFjY2Vzc1Rva2VuKSxiLlRhKCkpO2hrKGIsXCJyZWZyZXNoVG9rZW5cIixhLnJlZnJlc2hUb2tlbik7cmV0dXJuIGEuYWNjZXNzVG9rZW59KSl9O1xuUy5wcm90b3R5cGUuZ2V0VG9rZW49ZnVuY3Rpb24oYSl7WmZbXCJmaXJlYmFzZS5Vc2VyLnByb3RvdHlwZS5nZXRUb2tlbiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGZpcmViYXNlLlVzZXIucHJvdG90eXBlLmdldElkVG9rZW4gaW5zdGVhZC5cIl18fChaZltcImZpcmViYXNlLlVzZXIucHJvdG90eXBlLmdldFRva2VuIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgZmlyZWJhc2UuVXNlci5wcm90b3R5cGUuZ2V0SWRUb2tlbiBpbnN0ZWFkLlwiXT0hMCxcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBjb25zb2xlLndhcm4mJmNvbnNvbGUud2FybihcImZpcmViYXNlLlVzZXIucHJvdG90eXBlLmdldFRva2VuIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgZmlyZWJhc2UuVXNlci5wcm90b3R5cGUuZ2V0SWRUb2tlbiBpbnN0ZWFkLlwiKSk7cmV0dXJuIHRoaXMuZ2V0SWRUb2tlbihhKX07XG52YXIga2s9ZnVuY3Rpb24oYSxiKXtiLmlkVG9rZW4mJmEuSWUhPWIuaWRUb2tlbiYmKExqKGEucmEsYiksYS5UYSgpLFFqKGEsYi5pZFRva2VuKSxoayhhLFwicmVmcmVzaFRva2VuXCIsYS5yYS5mYSkpfTtTLnByb3RvdHlwZS5UYT1mdW5jdGlvbigpe3RoaXMuZGlzcGF0Y2hFdmVudChuZXcgUGooXCJ0b2tlbkNoYW5nZWRcIikpfTt2YXIgams9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gUShhLmYsS2gse2lkVG9rZW46Yn0pLnRoZW4ocihhLmdnLGEpKX07XG5TLnByb3RvdHlwZS5nZz1mdW5jdGlvbihhKXthPWEudXNlcnM7aWYoIWF8fCFhLmxlbmd0aCl0aHJvdyBuZXcgTyhcImludGVybmFsLWVycm9yXCIpO2E9YVswXTtSaih0aGlzLHt1aWQ6YS5sb2NhbElkLGRpc3BsYXlOYW1lOmEuZGlzcGxheU5hbWUscGhvdG9VUkw6YS5waG90b1VybCxlbWFpbDphLmVtYWlsLGVtYWlsVmVyaWZpZWQ6ISFhLmVtYWlsVmVyaWZpZWQscGhvbmVOdW1iZXI6YS5waG9uZU51bWJlcixsYXN0TG9naW5BdDphLmxhc3RMb2dpbkF0LGNyZWF0ZWRBdDphLmNyZWF0ZWRBdH0pO2Zvcih2YXIgYj1sayhhKSxjPTA7YzxiLmxlbmd0aDtjKyspZ2sodGhpcyxiW2NdKTtoayh0aGlzLFwiaXNBbm9ueW1vdXNcIiwhKHRoaXMuZW1haWwmJmEucGFzc3dvcmRIYXNoKSYmISh0aGlzLnByb3ZpZGVyRGF0YSYmdGhpcy5wcm92aWRlckRhdGEubGVuZ3RoKSl9O1xudmFyIGxrPWZ1bmN0aW9uKGEpe3JldHVybihhPWEucHJvdmlkZXJVc2VySW5mbykmJmEubGVuZ3RoP1JhKGEsZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBPaihhLnJhd0lkLGEucHJvdmlkZXJJZCxhLmVtYWlsLGEuZGlzcGxheU5hbWUsYS5waG90b1VybCxhLnBob25lTnVtYmVyKX0pOltdfTtTLnByb3RvdHlwZS5yZWF1dGhlbnRpY2F0ZUFuZFJldHJpZXZlRGF0YVdpdGhDcmVkZW50aWFsPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1udWxsO3JldHVybiB0aGlzLmMoYS5HZCh0aGlzLmYsdGhpcy51aWQpLnRoZW4oZnVuY3Rpb24oYSl7a2soYixhKTtjPW1rKGIsYSxcInJlYXV0aGVudGljYXRlXCIpO2Iuc2E9bnVsbDtyZXR1cm4gYi5yZWxvYWQoKX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gY30pLCEwKX07Uy5wcm90b3R5cGUucmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5yZWF1dGhlbnRpY2F0ZUFuZFJldHJpZXZlRGF0YVdpdGhDcmVkZW50aWFsKGEpLnRoZW4oZnVuY3Rpb24oKXt9KX07XG52YXIgbms9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gaWsoYSkudGhlbihmdW5jdGlvbigpe2lmKFZhKGVrKGEpLGIpKXJldHVybiBhayhhKS50aGVuKGZ1bmN0aW9uKCl7dGhyb3cgbmV3IE8oXCJwcm92aWRlci1hbHJlYWR5LWxpbmtlZFwiKTt9KX0pfTtTLnByb3RvdHlwZS5saW5rQW5kUmV0cmlldmVEYXRhV2l0aENyZWRlbnRpYWw9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPW51bGw7cmV0dXJuIHRoaXMuYyhuayh0aGlzLGEucHJvdmlkZXJJZCkudGhlbihmdW5jdGlvbigpe3JldHVybiBiLmdldElkVG9rZW4oKX0pLnRoZW4oZnVuY3Rpb24oYyl7cmV0dXJuIGEuRmMoYi5mLGMpfSkudGhlbihmdW5jdGlvbihhKXtjPW1rKGIsYSxcImxpbmtcIik7cmV0dXJuIG9rKGIsYSl9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSl9O1MucHJvdG90eXBlLmxpbmtXaXRoQ3JlZGVudGlhbD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5saW5rQW5kUmV0cmlldmVEYXRhV2l0aENyZWRlbnRpYWwoYSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gYS51c2VyfSl9O1xuUy5wcm90b3R5cGUubGlua1dpdGhQaG9uZU51bWJlcj1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7cmV0dXJuIHRoaXMuYyhuayh0aGlzLFwicGhvbmVcIikudGhlbihmdW5jdGlvbigpe3JldHVybiBKaShXaihjKSxhLGIscihjLmxpbmtBbmRSZXRyaWV2ZURhdGFXaXRoQ3JlZGVudGlhbCxjKSl9KSl9O1MucHJvdG90eXBlLnJlYXV0aGVudGljYXRlV2l0aFBob25lTnVtYmVyPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcztyZXR1cm4gdGhpcy5jKEQoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIEppKFdqKGMpLGEsYixyKGMucmVhdXRoZW50aWNhdGVBbmRSZXRyaWV2ZURhdGFXaXRoQ3JlZGVudGlhbCxjKSl9KSwhMCl9O3ZhciBtaz1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9UmcoYik7Yj1VaShiKTtyZXR1cm4gY2coe3VzZXI6YSxjcmVkZW50aWFsOmQsYWRkaXRpb25hbFVzZXJJbmZvOmIsb3BlcmF0aW9uVHlwZTpjfSl9LG9rPWZ1bmN0aW9uKGEsYil7a2soYSxiKTtyZXR1cm4gYS5yZWxvYWQoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KX07XG5oPVMucHJvdG90eXBlO2gudXBkYXRlRW1haWw9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gdGhpcy5jKHRoaXMuZ2V0SWRUb2tlbigpLnRoZW4oZnVuY3Rpb24oYyl7cmV0dXJuIGIuZi51cGRhdGVFbWFpbChjLGEpfSkudGhlbihmdW5jdGlvbihhKXtrayhiLGEpO3JldHVybiBiLnJlbG9hZCgpfSkpfTtoLnVwZGF0ZVBob25lTnVtYmVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIHRoaXMuYyh0aGlzLmdldElkVG9rZW4oKS50aGVuKGZ1bmN0aW9uKGMpe3JldHVybiBhLkZjKGIuZixjKX0pLnRoZW4oZnVuY3Rpb24oYSl7a2soYixhKTtyZXR1cm4gYi5yZWxvYWQoKX0pKX07aC51cGRhdGVQYXNzd29yZD1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3JldHVybiB0aGlzLmModGhpcy5nZXRJZFRva2VuKCkudGhlbihmdW5jdGlvbihjKXtyZXR1cm4gYi5mLnVwZGF0ZVBhc3N3b3JkKGMsYSl9KS50aGVuKGZ1bmN0aW9uKGEpe2trKGIsYSk7cmV0dXJuIGIucmVsb2FkKCl9KSl9O1xuaC51cGRhdGVQcm9maWxlPWZ1bmN0aW9uKGEpe2lmKHZvaWQgMD09PWEuZGlzcGxheU5hbWUmJnZvaWQgMD09PWEucGhvdG9VUkwpcmV0dXJuIGRrKHRoaXMpO3ZhciBiPXRoaXM7cmV0dXJuIHRoaXMuYyh0aGlzLmdldElkVG9rZW4oKS50aGVuKGZ1bmN0aW9uKGMpe3JldHVybiBiLmYudXBkYXRlUHJvZmlsZShjLHtkaXNwbGF5TmFtZTphLmRpc3BsYXlOYW1lLHBob3RvVXJsOmEucGhvdG9VUkx9KX0pLnRoZW4oZnVuY3Rpb24oYSl7a2soYixhKTtoayhiLFwiZGlzcGxheU5hbWVcIixhLmRpc3BsYXlOYW1lfHxudWxsKTtoayhiLFwicGhvdG9VUkxcIixhLnBob3RvVXJsfHxudWxsKTt4KGIucHJvdmlkZXJEYXRhLGZ1bmN0aW9uKGEpe1wicGFzc3dvcmRcIj09PWEucHJvdmlkZXJJZCYmKE4oYSxcImRpc3BsYXlOYW1lXCIsYi5kaXNwbGF5TmFtZSksTihhLFwicGhvdG9VUkxcIixiLnBob3RvVVJMKSl9KTtyZXR1cm4gYWsoYil9KS50aGVuKGNrKSl9O1xuaC51bmxpbms9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gdGhpcy5jKGlrKHRoaXMpLnRoZW4oZnVuY3Rpb24oYyl7cmV0dXJuIFZhKGVrKGIpLGEpP3loKGIuZixjLFthXSkudGhlbihmdW5jdGlvbihhKXt2YXIgYz17fTt4KGEucHJvdmlkZXJVc2VySW5mb3x8W10sZnVuY3Rpb24oYSl7Y1thLnByb3ZpZGVySWRdPSEwfSk7eChlayhiKSxmdW5jdGlvbihhKXtjW2FdfHxmayhiLGEpfSk7Y1tPZy5QUk9WSURFUl9JRF18fE4oYixcInBob25lTnVtYmVyXCIsbnVsbCk7cmV0dXJuIGFrKGIpfSk6YWsoYikudGhlbihmdW5jdGlvbigpe3Rocm93IG5ldyBPKFwibm8tc3VjaC1wcm92aWRlclwiKTt9KX0pKX07XG5oW1wiZGVsZXRlXCJdPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztyZXR1cm4gdGhpcy5jKHRoaXMuZ2V0SWRUb2tlbigpLnRoZW4oZnVuY3Rpb24oYil7cmV0dXJuIFEoYS5mLEpoLHtpZFRva2VuOmJ9KX0pLnRoZW4oZnVuY3Rpb24oKXthLmRpc3BhdGNoRXZlbnQobmV3IFBqKFwidXNlckRlbGV0ZWRcIikpfSkpLnRoZW4oZnVuY3Rpb24oKXtmb3IodmFyIGI9MDtiPGEuSi5sZW5ndGg7YisrKWEuSltiXS5jYW5jZWwoXCJhcHAtZGVsZXRlZFwiKTtVaihhLG51bGwpO1ZqKGEsbnVsbCk7YS5KPVtdO2EuS2I9ITA7WWooYSk7TihhLFwicmVmcmVzaFRva2VuXCIsbnVsbCk7YS52JiZhLnYudW5zdWJzY3JpYmUoYSl9KX07XG5oLmtlPWZ1bmN0aW9uKGEsYil7cmV0dXJuXCJsaW5rVmlhUG9wdXBcIj09YSYmKHRoaXMubGF8fG51bGwpPT1iJiZ0aGlzLmthfHxcInJlYXV0aFZpYVBvcHVwXCI9PWEmJih0aGlzLmxhfHxudWxsKT09YiYmdGhpcy5rYXx8XCJsaW5rVmlhUmVkaXJlY3RcIj09YSYmKHRoaXMuSGF8fG51bGwpPT1ifHxcInJlYXV0aFZpYVJlZGlyZWN0XCI9PWEmJih0aGlzLkhhfHxudWxsKT09Yj8hMDohMX07aC5iYj1mdW5jdGlvbihhLGIsYyxkKXtcImxpbmtWaWFQb3B1cFwiIT1hJiZcInJlYXV0aFZpYVBvcHVwXCIhPWF8fGQhPSh0aGlzLmxhfHxudWxsKXx8KGMmJnRoaXMuVmE/dGhpcy5WYShjKTpiJiYhYyYmdGhpcy5rYSYmdGhpcy5rYShiKSx0aGlzLksmJih0aGlzLksuY2FuY2VsKCksdGhpcy5LPW51bGwpLGRlbGV0ZSB0aGlzLmthLGRlbGV0ZSB0aGlzLlZhKX07XG5oLk5iPWZ1bmN0aW9uKGEsYil7cmV0dXJuXCJsaW5rVmlhUG9wdXBcIj09YSYmYj09KHRoaXMubGF8fG51bGwpP3IodGhpcy51ZSx0aGlzKTpcInJlYXV0aFZpYVBvcHVwXCI9PWEmJmI9PSh0aGlzLmxhfHxudWxsKT9yKHRoaXMudmUsdGhpcyk6XCJsaW5rVmlhUmVkaXJlY3RcIj09YSYmKHRoaXMuSGF8fG51bGwpPT1iP3IodGhpcy51ZSx0aGlzKTpcInJlYXV0aFZpYVJlZGlyZWN0XCI9PWEmJih0aGlzLkhhfHxudWxsKT09Yj9yKHRoaXMudmUsdGhpcyk6bnVsbH07aC5zYz1mdW5jdGlvbigpe3JldHVybiBLZih0aGlzLnVpZCtcIjo6OlwiKX07aC5saW5rV2l0aFBvcHVwPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIHBrKHRoaXMsXCJsaW5rVmlhUG9wdXBcIixhLGZ1bmN0aW9uKCl7cmV0dXJuIG5rKGIsYS5wcm92aWRlcklkKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGFrKGIpfSl9LCExKX07XG5oLnJlYXV0aGVudGljYXRlV2l0aFBvcHVwPWZ1bmN0aW9uKGEpe3JldHVybiBwayh0aGlzLFwicmVhdXRoVmlhUG9wdXBcIixhLGZ1bmN0aW9uKCl7cmV0dXJuIEQoKX0sITApfTtcbnZhciBwaz1mdW5jdGlvbihhLGIsYyxkLGUpe2lmKCFOZigpKXJldHVybiBFKG5ldyBPKFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiKSk7aWYoYS5zYSYmIWUpcmV0dXJuIEUoYS5zYSk7dmFyIGY9amcoYy5wcm92aWRlcklkKSxnPWEuc2MoKSxsPW51bGw7KCFPZigpfHxGZigpKSYmYS5CJiZjLmlzT0F1dGhQcm92aWRlciYmKGw9Y2koYS5CLGEubSxhLm8sYixjLG51bGwsZyxmaXJlYmFzZS5TREtfVkVSU0lPTnx8bnVsbCkpO3ZhciBuPXlmKGwsZiYmZi5aYixmJiZmLlliKTtkPWQoKS50aGVuKGZ1bmN0aW9uKCl7cWsoYSk7aWYoIWUpcmV0dXJuIGEuZ2V0SWRUb2tlbigpLnRoZW4oZnVuY3Rpb24oKXt9KX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYS52LiRiKG4sYixjLGcsISFsKX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEMoZnVuY3Rpb24oYyxkKXthLmJiKGIsbnVsbCxuZXcgTyhcImNhbmNlbGxlZC1wb3B1cC1yZXF1ZXN0XCIpLGEubGF8fFxubnVsbCk7YS5rYT1jO2EuVmE9ZDthLmxhPWc7YS5LPWEudi5lYyhhLGIsbixnKX0pfSkudGhlbihmdW5jdGlvbihhKXtuJiZ4ZihuKTtyZXR1cm4gYT9jZyhhKTpudWxsfSkuZyhmdW5jdGlvbihhKXtuJiZ4ZihuKTt0aHJvdyBhO30pO3JldHVybiBhLmMoZCxlKX07Uy5wcm90b3R5cGUubGlua1dpdGhSZWRpcmVjdD1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3JldHVybiByayh0aGlzLFwibGlua1ZpYVJlZGlyZWN0XCIsYSxmdW5jdGlvbigpe3JldHVybiBuayhiLGEucHJvdmlkZXJJZCl9LCExKX07Uy5wcm90b3R5cGUucmVhdXRoZW50aWNhdGVXaXRoUmVkaXJlY3Q9ZnVuY3Rpb24oYSl7cmV0dXJuIHJrKHRoaXMsXCJyZWF1dGhWaWFSZWRpcmVjdFwiLGEsZnVuY3Rpb24oKXtyZXR1cm4gRCgpfSwhMCl9O1xudmFyIHJrPWZ1bmN0aW9uKGEsYixjLGQsZSl7aWYoIU5mKCkpcmV0dXJuIEUobmV3IE8oXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIpKTtpZihhLnNhJiYhZSlyZXR1cm4gRShhLnNhKTt2YXIgZj1udWxsLGc9YS5zYygpO2Q9ZCgpLnRoZW4oZnVuY3Rpb24oKXtxayhhKTtpZighZSlyZXR1cm4gYS5nZXRJZFRva2VuKCkudGhlbihmdW5jdGlvbigpe30pfSkudGhlbihmdW5jdGlvbigpe2EuSGE9ZztyZXR1cm4gYWsoYSl9KS50aGVuKGZ1bmN0aW9uKGIpe2EuWWEmJihiPWEuWWEsYj1iLmguc2V0KHNrLGEuQSgpLGIuaikpO3JldHVybiBifSkudGhlbihmdW5jdGlvbigpe3JldHVybiBhLnYuYWMoYixjLGcpfSkuZyhmdW5jdGlvbihiKXtmPWI7aWYoYS5ZYSlyZXR1cm4gdGsoYS5ZYSk7dGhyb3cgZjt9KS50aGVuKGZ1bmN0aW9uKCl7aWYoZil0aHJvdyBmO30pO3JldHVybiBhLmMoZCxlKX0scWs9ZnVuY3Rpb24oYSl7aWYoIWEudnx8IWEuS2Mpe2lmKGEudiYmXG4hYS5LYyl0aHJvdyBuZXcgTyhcImludGVybmFsLWVycm9yXCIpO3Rocm93IG5ldyBPKFwiYXV0aC1kb21haW4tY29uZmlnLXJlcXVpcmVkXCIpO319O1MucHJvdG90eXBlLnVlPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpczt0aGlzLksmJih0aGlzLksuY2FuY2VsKCksdGhpcy5LPW51bGwpO3ZhciBkPW51bGwsZT10aGlzLmdldElkVG9rZW4oKS50aGVuKGZ1bmN0aW9uKGQpe3JldHVybiB2ZyhjLmYse3JlcXVlc3RVcmk6YSxzZXNzaW9uSWQ6YixpZFRva2VuOmR9KX0pLnRoZW4oZnVuY3Rpb24oYSl7ZD1tayhjLGEsXCJsaW5rXCIpO3JldHVybiBvayhjLGEpfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBkfSk7cmV0dXJuIHRoaXMuYyhlKX07XG5TLnByb3RvdHlwZS52ZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7dGhpcy5LJiYodGhpcy5LLmNhbmNlbCgpLHRoaXMuSz1udWxsKTt2YXIgZD1udWxsLGU9RCgpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gcmcod2coYy5mLHtyZXF1ZXN0VXJpOmEsc2Vzc2lvbklkOmJ9KSxjLnVpZCl9KS50aGVuKGZ1bmN0aW9uKGEpe2Q9bWsoYyxhLFwicmVhdXRoZW50aWNhdGVcIik7a2soYyxhKTtjLnNhPW51bGw7cmV0dXJuIGMucmVsb2FkKCl9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGR9KTtyZXR1cm4gdGhpcy5jKGUsITApfTtcblMucHJvdG90eXBlLnNlbmRFbWFpbFZlcmlmaWNhdGlvbj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9bnVsbDtyZXR1cm4gdGhpcy5jKHRoaXMuZ2V0SWRUb2tlbigpLnRoZW4oZnVuY3Rpb24oYil7Yz1iO3JldHVyblwidW5kZWZpbmVkXCI9PT10eXBlb2YgYXx8aWIoYSk/e306SGkobmV3IEdpKGEpKX0pLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGIuZi5zZW5kRW1haWxWZXJpZmljYXRpb24oYyxhKX0pLnRoZW4oZnVuY3Rpb24oYSl7aWYoYi5lbWFpbCE9YSlyZXR1cm4gYi5yZWxvYWQoKX0pLnRoZW4oZnVuY3Rpb24oKXt9KSl9O1MucHJvdG90eXBlLmM9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGQ9dWsodGhpcyxhLGIpO3RoaXMuSi5wdXNoKGQpO0VkKGQsZnVuY3Rpb24oKXtYYShjLkosZCl9KTtyZXR1cm4gZH07XG52YXIgdWs9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBhLnNhJiYhYz8oYi5jYW5jZWwoKSxFKGEuc2EpKTpiLmcoZnVuY3Rpb24oYil7IWJ8fFwiYXV0aC91c2VyLWRpc2FibGVkXCIhPWIuY29kZSYmXCJhdXRoL3VzZXItdG9rZW4tZXhwaXJlZFwiIT1iLmNvZGV8fChhLnNhfHxhLmRpc3BhdGNoRXZlbnQobmV3IFBqKFwidXNlckludmFsaWRhdGVkXCIpKSxhLnNhPWIpO3Rocm93IGI7fSl9O1MucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLkEoKX07XG5TLnByb3RvdHlwZS5BPWZ1bmN0aW9uKCl7dmFyIGE9e3VpZDp0aGlzLnVpZCxkaXNwbGF5TmFtZTp0aGlzLmRpc3BsYXlOYW1lLHBob3RvVVJMOnRoaXMucGhvdG9VUkwsZW1haWw6dGhpcy5lbWFpbCxlbWFpbFZlcmlmaWVkOnRoaXMuZW1haWxWZXJpZmllZCxwaG9uZU51bWJlcjp0aGlzLnBob25lTnVtYmVyLGlzQW5vbnltb3VzOnRoaXMuaXNBbm9ueW1vdXMscHJvdmlkZXJEYXRhOltdLGFwaUtleTp0aGlzLm0sYXBwTmFtZTp0aGlzLm8sYXV0aERvbWFpbjp0aGlzLkIsc3RzVG9rZW5NYW5hZ2VyOnRoaXMucmEuQSgpLHJlZGlyZWN0RXZlbnRJZDp0aGlzLkhhfHxudWxsfTt0aGlzLm1ldGFkYXRhJiZtYihhLHRoaXMubWV0YWRhdGEuQSgpKTt4KHRoaXMucHJvdmlkZXJEYXRhLGZ1bmN0aW9uKGIpe2EucHJvdmlkZXJEYXRhLnB1c2goZGcoYikpfSk7cmV0dXJuIGF9O1xudmFyIHZrPWZ1bmN0aW9uKGEpe2lmKCFhLmFwaUtleSlyZXR1cm4gbnVsbDt2YXIgYj17YXBpS2V5OmEuYXBpS2V5LGF1dGhEb21haW46YS5hdXRoRG9tYWluLGFwcE5hbWU6YS5hcHBOYW1lfSxjPXt9O2lmKGEuc3RzVG9rZW5NYW5hZ2VyJiZhLnN0c1Rva2VuTWFuYWdlci5hY2Nlc3NUb2tlbiYmYS5zdHNUb2tlbk1hbmFnZXIuZXhwaXJhdGlvblRpbWUpYy5pZFRva2VuPWEuc3RzVG9rZW5NYW5hZ2VyLmFjY2Vzc1Rva2VuLGMucmVmcmVzaFRva2VuPWEuc3RzVG9rZW5NYW5hZ2VyLnJlZnJlc2hUb2tlbnx8bnVsbCxjLmV4cGlyZXNJbj0oYS5zdHNUb2tlbk1hbmFnZXIuZXhwaXJhdGlvblRpbWUtbWEoKSkvMUUzO2Vsc2UgcmV0dXJuIG51bGw7dmFyIGQ9bmV3IFMoYixjLGEpO2EucHJvdmlkZXJEYXRhJiZ4KGEucHJvdmlkZXJEYXRhLGZ1bmN0aW9uKGEpe2EmJmdrKGQsY2coYSkpfSk7YS5yZWRpcmVjdEV2ZW50SWQmJihkLkhhPWEucmVkaXJlY3RFdmVudElkKTtyZXR1cm4gZH0sXG53az1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1uZXcgUyhhLGIpO2MmJihlLllhPWMpO2QmJlRqKGUsZCk7cmV0dXJuIGUucmVsb2FkKCkudGhlbihmdW5jdGlvbigpe3JldHVybiBlfSl9O3ZhciB4az1mdW5jdGlvbihhKXt0aGlzLmo9YTt0aGlzLmg9WmkoKX0sc2s9e25hbWU6XCJyZWRpcmVjdFVzZXJcIixEOlwic2Vzc2lvblwifSx0az1mdW5jdGlvbihhKXtyZXR1cm4gYS5oLnJlbW92ZShzayxhLmopfSx5az1mdW5jdGlvbihhLGIpe3JldHVybiBhLmguZ2V0KHNrLGEuaikudGhlbihmdW5jdGlvbihhKXthJiZiJiYoYS5hdXRoRG9tYWluPWIpO3JldHVybiB2ayhhfHx7fSl9KX07dmFyIEFrPWZ1bmN0aW9uKGEsYil7dGhpcy5qPWE7dGhpcy5oPWJ8fFppKCk7dGhpcy5PPW51bGw7dGhpcy5KZD10aGlzLkJkKCk7dGhpcy5oLmFkZExpc3RlbmVyKHprKFwibG9jYWxcIiksdGhpcy5qLHIodGhpcy52Zyx0aGlzKSl9O0FrLnByb3RvdHlwZS52Zz1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj16ayhcImxvY2FsXCIpO0JrKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gRCgpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYS5PJiZcImxvY2FsXCIhPWEuTy5EP2EuaC5nZXQoYixhLmopOm51bGx9KS50aGVuKGZ1bmN0aW9uKGMpe2lmKGMpcmV0dXJuIENrKGEsXCJsb2NhbFwiKS50aGVuKGZ1bmN0aW9uKCl7YS5PPWJ9KX0pfSl9O3ZhciBDaz1mdW5jdGlvbihhLGIpe3ZhciBjPVtdLGQ7Zm9yKGQgaW4gVmkpVmlbZF0hPT1iJiZjLnB1c2goYS5oLnJlbW92ZSh6ayhWaVtkXSksYS5qKSk7Yy5wdXNoKGEuaC5yZW1vdmUoRGssYS5qKSk7cmV0dXJuIEFkKGMpfTtcbkFrLnByb3RvdHlwZS5CZD1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj16ayhcImxvY2FsXCIpLGM9emsoXCJzZXNzaW9uXCIpLGQ9emsoXCJub25lXCIpO3JldHVybiB0aGlzLmguZ2V0KGMsdGhpcy5qKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBlP2M6YS5oLmdldChkLGEuaikudGhlbihmdW5jdGlvbihjKXtyZXR1cm4gYz9kOmEuaC5nZXQoYixhLmopLnRoZW4oZnVuY3Rpb24oYyl7cmV0dXJuIGM/YjphLmguZ2V0KERrLGEuaikudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gYT96ayhhKTpifSl9KX0pfSkudGhlbihmdW5jdGlvbihiKXthLk89YjtyZXR1cm4gQ2soYSxiLkQpfSkuZyhmdW5jdGlvbigpe2EuT3x8KGEuTz1iKX0pfTt2YXIgRGs9e25hbWU6XCJwZXJzaXN0ZW5jZVwiLEQ6XCJzZXNzaW9uXCJ9LHprPWZ1bmN0aW9uKGEpe3JldHVybntuYW1lOlwiYXV0aFVzZXJcIixEOmF9fTtcbkFrLnByb3RvdHlwZS5zZXRQZXJzaXN0ZW5jZT1mdW5jdGlvbihhKXt2YXIgYj1udWxsLGM9dGhpcztXaShhKTtyZXR1cm4gQmsodGhpcyxmdW5jdGlvbigpe3JldHVybiBhIT1jLk8uRD9jLmguZ2V0KGMuTyxjLmopLnRoZW4oZnVuY3Rpb24oZCl7Yj1kO3JldHVybiBDayhjLGEpfSkudGhlbihmdW5jdGlvbigpe2MuTz16ayhhKTtpZihiKXJldHVybiBjLmguc2V0KGMuTyxiLGMuail9KTpEKCl9KX07XG52YXIgRWs9ZnVuY3Rpb24oYSl7cmV0dXJuIEJrKGEsZnVuY3Rpb24oKXtyZXR1cm4gYS5oLnNldChEayxhLk8uRCxhLmopfSl9LEZrPWZ1bmN0aW9uKGEsYil7cmV0dXJuIEJrKGEsZnVuY3Rpb24oKXtyZXR1cm4gYS5oLnNldChhLk8sYi5BKCksYS5qKX0pfSxHaz1mdW5jdGlvbihhKXtyZXR1cm4gQmsoYSxmdW5jdGlvbigpe3JldHVybiBhLmgucmVtb3ZlKGEuTyxhLmopfSl9LEhrPWZ1bmN0aW9uKGEsYil7cmV0dXJuIEJrKGEsZnVuY3Rpb24oKXtyZXR1cm4gYS5oLmdldChhLk8sYS5qKS50aGVuKGZ1bmN0aW9uKGEpe2EmJmImJihhLmF1dGhEb21haW49Yik7cmV0dXJuIHZrKGF8fHt9KX0pfSl9LEJrPWZ1bmN0aW9uKGEsYil7YS5KZD1hLkpkLnRoZW4oYixiKTtyZXR1cm4gYS5KZH07dmFyIFQ9ZnVuY3Rpb24oYSl7dGhpcy5FYT0hMTtOKHRoaXMsXCJhcHBcIixhKTtpZih0aGlzLmkoKS5vcHRpb25zJiZ0aGlzLmkoKS5vcHRpb25zLmFwaUtleSlhPWZpcmViYXNlLlNES19WRVJTSU9OP0pmKGZpcmViYXNlLlNES19WRVJTSU9OKTpudWxsLHRoaXMuZj1uZXcgUih0aGlzLmkoKS5vcHRpb25zJiZ0aGlzLmkoKS5vcHRpb25zLmFwaUtleSxvZihwZiksYSk7ZWxzZSB0aHJvdyBuZXcgTyhcImludmFsaWQtYXBpLWtleVwiKTt0aGlzLko9W107dGhpcy5LYT1bXTt0aGlzLkZiPVtdO3RoaXMuY2c9ZmlyZWJhc2UuSU5URVJOQUwuY3JlYXRlU3Vic2NyaWJlKHIodGhpcy5TZix0aGlzKSk7dGhpcy5rYz12b2lkIDA7dGhpcy5lZz1maXJlYmFzZS5JTlRFUk5BTC5jcmVhdGVTdWJzY3JpYmUocih0aGlzLlVmLHRoaXMpKTtJayh0aGlzLG51bGwpO2E9dGhpcy5pKCkub3B0aW9ucy5hcGlLZXk7dmFyIGI9dGhpcy5pKCkubmFtZTt0aGlzLm5hPW5ldyBBayhhK1wiOlwiK2IpO2E9dGhpcy5pKCkub3B0aW9ucy5hcGlLZXk7XG5iPXRoaXMuaSgpLm5hbWU7dGhpcy56Yj1uZXcgeGsoYStcIjpcIitiKTt0aGlzLm9jPXRoaXMuYyhKayh0aGlzKSk7dGhpcy55YT10aGlzLmMoS2sodGhpcykpO3RoaXMuQ2M9ITE7dGhpcy51ZD1yKHRoaXMud2csdGhpcyk7dGhpcy5lZj1yKHRoaXMucGIsdGhpcyk7dGhpcy5HYj1yKHRoaXMud2QsdGhpcyk7dGhpcy5jZj1yKHRoaXMuT2YsdGhpcyk7dGhpcy5kZj1yKHRoaXMuUGYsdGhpcyk7TGsodGhpcyk7dGhpcy5JTlRFUk5BTD17fTt0aGlzLklOVEVSTkFMW1wiZGVsZXRlXCJdPXIodGhpc1tcImRlbGV0ZVwiXSx0aGlzKTt0aGlzLklOVEVSTkFMLmxvZ0ZyYW1ld29yaz1yKHRoaXMuJGYsdGhpcyk7dGhpcy5PYT0wO0cuY2FsbCh0aGlzKTtNayh0aGlzKTt0aGlzLk09W119O3QoVCxHKTt2YXIgTms9ZnVuY3Rpb24oYSl7Qi5jYWxsKHRoaXMsXCJsYW5ndWFnZUNvZGVDaGFuZ2VkXCIpO3RoaXMubGFuZ3VhZ2VDb2RlPWF9O3QoTmssQik7XG52YXIgT2s9ZnVuY3Rpb24oYSl7Qi5jYWxsKHRoaXMsXCJmcmFtZXdvcmtDaGFuZ2VkXCIpO3RoaXMuRmY9YX07dChPayxCKTtULnByb3RvdHlwZS5zZXRQZXJzaXN0ZW5jZT1mdW5jdGlvbihhKXthPXRoaXMubmEuc2V0UGVyc2lzdGVuY2UoYSk7cmV0dXJuIHRoaXMuYyhhKX07VC5wcm90b3R5cGUuQ2I9ZnVuY3Rpb24oYSl7dGhpcy5pYT09PWF8fHRoaXMuRWF8fCh0aGlzLmlhPWEsYWgodGhpcy5mLHRoaXMuaWEpLHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTmsodGhpcy5pYSkpKX07VC5wcm90b3R5cGUudXNlRGV2aWNlTGFuZ3VhZ2U9ZnVuY3Rpb24oKXt2YXIgYT1rLm5hdmlnYXRvcjt0aGlzLkNiKGE/YS5sYW5ndWFnZXMmJmEubGFuZ3VhZ2VzWzBdfHxhLmxhbmd1YWdlfHxhLnVzZXJMYW5ndWFnZXx8bnVsbDpudWxsKX07XG5ULnByb3RvdHlwZS4kZj1mdW5jdGlvbihhKXt0aGlzLk0ucHVzaChhKTtiaCh0aGlzLmYsZmlyZWJhc2UuU0RLX1ZFUlNJT04/SmYoZmlyZWJhc2UuU0RLX1ZFUlNJT04sdGhpcy5NKTpudWxsKTt0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE9rKHRoaXMuTSkpfTt2YXIgTWs9ZnVuY3Rpb24oYSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsXCJsY1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pYX0sc2V0OmZ1bmN0aW9uKGEpe3RoaXMuQ2IoYSl9LGVudW1lcmFibGU6ITF9KTthLmlhPW51bGx9O1QucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnthcGlLZXk6dGhpcy5pKCkub3B0aW9ucy5hcGlLZXksYXV0aERvbWFpbjp0aGlzLmkoKS5vcHRpb25zLmF1dGhEb21haW4sYXBwTmFtZTp0aGlzLmkoKS5uYW1lLGN1cnJlbnRVc2VyOlUodGhpcykmJlUodGhpcykuQSgpfX07XG52YXIgUGs9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuQWZ8fEUobmV3IE8oXCJhdXRoLWRvbWFpbi1jb25maWctcmVxdWlyZWRcIikpfSxMaz1mdW5jdGlvbihhKXt2YXIgYj1hLmkoKS5vcHRpb25zLmF1dGhEb21haW4sYz1hLmkoKS5vcHRpb25zLmFwaUtleTtiJiZOZigpJiYoYS5BZj1hLm9jLnRoZW4oZnVuY3Rpb24oKXtpZighYS5FYSl7YS52PUVqKGIsYyxhLmkoKS5uYW1lKTthLnYuc3Vic2NyaWJlKGEpO1UoYSkmJmJrKFUoYSkpO2lmKGEuWmEpe2JrKGEuWmEpO3ZhciBkPWEuWmE7ZC5DYihhLmlhKTtVaihkLGEpO2Q9YS5aYTtUaihkLGEuTSk7VmooZCxhKTthLlphPW51bGx9cmV0dXJuIGEudn19KSl9O2g9VC5wcm90b3R5cGU7aC5rZT1mdW5jdGlvbihhLGIpe3N3aXRjaChhKXtjYXNlIFwidW5rbm93blwiOmNhc2UgXCJzaWduSW5WaWFSZWRpcmVjdFwiOnJldHVybiEwO2Nhc2UgXCJzaWduSW5WaWFQb3B1cFwiOnJldHVybiB0aGlzLmxhPT1iJiYhIXRoaXMua2E7ZGVmYXVsdDpyZXR1cm4hMX19O1xuaC5iYj1mdW5jdGlvbihhLGIsYyxkKXtcInNpZ25JblZpYVBvcHVwXCI9PWEmJnRoaXMubGE9PWQmJihjJiZ0aGlzLlZhP3RoaXMuVmEoYyk6YiYmIWMmJnRoaXMua2EmJnRoaXMua2EoYiksdGhpcy5LJiYodGhpcy5LLmNhbmNlbCgpLHRoaXMuSz1udWxsKSxkZWxldGUgdGhpcy5rYSxkZWxldGUgdGhpcy5WYSl9O2guTmI9ZnVuY3Rpb24oYSxiKXtyZXR1cm5cInNpZ25JblZpYVJlZGlyZWN0XCI9PWF8fFwic2lnbkluVmlhUG9wdXBcIj09YSYmdGhpcy5sYT09YiYmdGhpcy5rYT9yKHRoaXMuQ2YsdGhpcyk6bnVsbH07XG5oLkNmPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpczthPXtyZXF1ZXN0VXJpOmEsc2Vzc2lvbklkOmJ9O3RoaXMuSyYmKHRoaXMuSy5jYW5jZWwoKSx0aGlzLks9bnVsbCk7dmFyIGQ9bnVsbCxlPW51bGwsZj10ZyhjLmYsYSkudGhlbihmdW5jdGlvbihhKXtkPVJnKGEpO2U9VWkoYSk7cmV0dXJuIGF9KTthPWMub2MudGhlbihmdW5jdGlvbigpe3JldHVybiBmfSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gUWsoYyxhKX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gY2coe3VzZXI6VShjKSxjcmVkZW50aWFsOmQsYWRkaXRpb25hbFVzZXJJbmZvOmUsb3BlcmF0aW9uVHlwZTpcInNpZ25JblwifSl9KTtyZXR1cm4gdGhpcy5jKGEpfTtoLnNjPWZ1bmN0aW9uKCl7cmV0dXJuIEtmKCl9O1xuaC5zaWduSW5XaXRoUG9wdXA9ZnVuY3Rpb24oYSl7aWYoIU5mKCkpcmV0dXJuIEUobmV3IE8oXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIpKTt2YXIgYj10aGlzLGM9amcoYS5wcm92aWRlcklkKSxkPXRoaXMuc2MoKSxlPW51bGw7KCFPZigpfHxGZigpKSYmdGhpcy5pKCkub3B0aW9ucy5hdXRoRG9tYWluJiZhLmlzT0F1dGhQcm92aWRlciYmKGU9Y2kodGhpcy5pKCkub3B0aW9ucy5hdXRoRG9tYWluLHRoaXMuaSgpLm9wdGlvbnMuYXBpS2V5LHRoaXMuaSgpLm5hbWUsXCJzaWduSW5WaWFQb3B1cFwiLGEsbnVsbCxkLGZpcmViYXNlLlNES19WRVJTSU9OfHxudWxsKSk7dmFyIGY9eWYoZSxjJiZjLlpiLGMmJmMuWWIpO2M9UGsodGhpcykudGhlbihmdW5jdGlvbihiKXtyZXR1cm4gYi4kYihmLFwic2lnbkluVmlhUG9wdXBcIixhLGQsISFlKX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEMoZnVuY3Rpb24oYSxjKXtiLmJiKFwic2lnbkluVmlhUG9wdXBcIixcbm51bGwsbmV3IE8oXCJjYW5jZWxsZWQtcG9wdXAtcmVxdWVzdFwiKSxiLmxhKTtiLmthPWE7Yi5WYT1jO2IubGE9ZDtiLks9Yi52LmVjKGIsXCJzaWduSW5WaWFQb3B1cFwiLGYsZCl9KX0pLnRoZW4oZnVuY3Rpb24oYSl7ZiYmeGYoZik7cmV0dXJuIGE/Y2coYSk6bnVsbH0pLmcoZnVuY3Rpb24oYSl7ZiYmeGYoZik7dGhyb3cgYTt9KTtyZXR1cm4gdGhpcy5jKGMpfTtoLnNpZ25JbldpdGhSZWRpcmVjdD1mdW5jdGlvbihhKXtpZighTmYoKSlyZXR1cm4gRShuZXcgTyhcIm9wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnRcIikpO3ZhciBiPXRoaXMsYz1Qayh0aGlzKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIEVrKGIubmEpfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBiLnYuYWMoXCJzaWduSW5WaWFSZWRpcmVjdFwiLGEpfSk7cmV0dXJuIHRoaXMuYyhjKX07XG5oLmdldFJlZGlyZWN0UmVzdWx0PWZ1bmN0aW9uKCl7aWYoIU5mKCkpcmV0dXJuIEUobmV3IE8oXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIpKTt2YXIgYT10aGlzLGI9UGsodGhpcykudGhlbihmdW5jdGlvbigpe3JldHVybiBhLnYuZ2V0UmVkaXJlY3RSZXN1bHQoKX0pLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGE/Y2coYSk6bnVsbH0pO3JldHVybiB0aGlzLmMoYil9O1xudmFyIFFrPWZ1bmN0aW9uKGEsYil7dmFyIGM9e307Yy5hcGlLZXk9YS5pKCkub3B0aW9ucy5hcGlLZXk7Yy5hdXRoRG9tYWluPWEuaSgpLm9wdGlvbnMuYXV0aERvbWFpbjtjLmFwcE5hbWU9YS5pKCkubmFtZTtyZXR1cm4gYS5vYy50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHdrKGMsYixhLnpiLCRhKGEuTSkpfSkudGhlbihmdW5jdGlvbihiKXtpZihVKGEpJiZiLnVpZD09VShhKS51aWQpcmV0dXJuIFUoYSkuY29weShiKSxhLnBiKGIpO0lrKGEsYik7YmsoYik7cmV0dXJuIGEucGIoYil9KS50aGVuKGZ1bmN0aW9uKCl7YS5UYSgpfSl9LElrPWZ1bmN0aW9uKGEsYil7VShhKSYmKFpqKFUoYSksYS5lZiksdGMoVShhKSxcInRva2VuQ2hhbmdlZFwiLGEuR2IpLHRjKFUoYSksXCJ1c2VyRGVsZXRlZFwiLGEuY2YpLHRjKFUoYSksXCJ1c2VySW52YWxpZGF0ZWRcIixhLmRmKSxZaihVKGEpKSk7YiYmKGIuUmMucHVzaChhLmVmKSxsYyhiLFwidG9rZW5DaGFuZ2VkXCIsYS5HYiksbGMoYixcInVzZXJEZWxldGVkXCIsXG5hLmNmKSxsYyhiLFwidXNlckludmFsaWRhdGVkXCIsYS5kZiksMDxhLk9hJiZYaihiKSk7TihhLFwiY3VycmVudFVzZXJcIixiKTtiJiYoYi5DYihhLmlhKSxVaihiLGEpLFRqKGIsYS5NKSxWaihiLGEpKX07VC5wcm90b3R5cGUuc2lnbk91dD1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj10aGlzLnlhLnRoZW4oZnVuY3Rpb24oKXtpZighVShhKSlyZXR1cm4gRCgpO0lrKGEsbnVsbCk7cmV0dXJuIEdrKGEubmEpLnRoZW4oZnVuY3Rpb24oKXthLlRhKCl9KX0pO3JldHVybiB0aGlzLmMoYil9O1xudmFyIFJrPWZ1bmN0aW9uKGEpe3ZhciBiPWEuaSgpLm9wdGlvbnMuYXV0aERvbWFpbjtiPXlrKGEuemIsYikudGhlbihmdW5jdGlvbihiKXtpZihhLlphPWIpYi5ZYT1hLnpiO3JldHVybiB0ayhhLnpiKX0pO3JldHVybiBhLmMoYil9LEprPWZ1bmN0aW9uKGEpe3ZhciBiPWEuaSgpLm9wdGlvbnMuYXV0aERvbWFpbixjPVJrKGEpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gSGsoYS5uYSxiKX0pLnRoZW4oZnVuY3Rpb24oYil7cmV0dXJuIGI/KGIuWWE9YS56YixhLlphJiYoYS5aYS5IYXx8bnVsbCk9PShiLkhhfHxudWxsKT9iOmIucmVsb2FkKCkudGhlbihmdW5jdGlvbigpe3JldHVybiBGayhhLm5hLGIpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYn0pfSkuZyhmdW5jdGlvbihjKXtyZXR1cm5cImF1dGgvbmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiPT1jLmNvZGU/YjpHayhhLm5hKX0pKTpudWxsfSkudGhlbihmdW5jdGlvbihiKXtJayhhLGJ8fG51bGwpfSk7cmV0dXJuIGEuYyhjKX0sS2s9XG5mdW5jdGlvbihhKXtyZXR1cm4gYS5vYy50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGEuZ2V0UmVkaXJlY3RSZXN1bHQoKX0pLmcoZnVuY3Rpb24oKXt9KS50aGVuKGZ1bmN0aW9uKCl7aWYoIWEuRWEpcmV0dXJuIGEudWQoKX0pLmcoZnVuY3Rpb24oKXt9KS50aGVuKGZ1bmN0aW9uKCl7aWYoIWEuRWEpe2EuQ2M9ITA7dmFyIGI9YS5uYTtiLmguYWRkTGlzdGVuZXIoemsoXCJsb2NhbFwiKSxiLmosYS51ZCl9fSl9O2g9VC5wcm90b3R5cGU7XG5oLndnPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPXRoaXMuaSgpLm9wdGlvbnMuYXV0aERvbWFpbjtyZXR1cm4gSGsodGhpcy5uYSxiKS50aGVuKGZ1bmN0aW9uKGIpe2lmKCFhLkVhKXt2YXIgYztpZihjPVUoYSkmJmIpe2M9VShhKS51aWQ7dmFyIGU9Yi51aWQ7Yz12b2lkIDA9PT1jfHxudWxsPT09Y3x8XCJcIj09PWN8fHZvaWQgMD09PWV8fG51bGw9PT1lfHxcIlwiPT09ZT8hMTpjPT1lfWlmKGMpcmV0dXJuIFUoYSkuY29weShiKSxVKGEpLmdldElkVG9rZW4oKTtpZihVKGEpfHxiKUlrKGEsYiksYiYmKGJrKGIpLGIuWWE9YS56YiksYS52JiZhLnYuc3Vic2NyaWJlKGEpLGEuVGEoKX19KX07aC5wYj1mdW5jdGlvbihhKXtyZXR1cm4gRmsodGhpcy5uYSxhKX07aC53ZD1mdW5jdGlvbigpe3RoaXMuVGEoKTt0aGlzLnBiKFUodGhpcykpfTtoLk9mPWZ1bmN0aW9uKCl7dGhpcy5zaWduT3V0KCl9O2guUGY9ZnVuY3Rpb24oKXt0aGlzLnNpZ25PdXQoKX07XG52YXIgU2s9ZnVuY3Rpb24oYSxiKXt2YXIgYz1udWxsLGQ9bnVsbDtyZXR1cm4gYS5jKGIudGhlbihmdW5jdGlvbihiKXtjPVJnKGIpO2Q9VWkoYik7cmV0dXJuIFFrKGEsYil9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGNnKHt1c2VyOlUoYSksY3JlZGVudGlhbDpjLGFkZGl0aW9uYWxVc2VySW5mbzpkLG9wZXJhdGlvblR5cGU6XCJzaWduSW5cIn0pfSkpfTtoPVQucHJvdG90eXBlO2guU2Y9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczt0aGlzLmFkZEF1dGhUb2tlbkxpc3RlbmVyKGZ1bmN0aW9uKCl7YS5uZXh0KFUoYikpfSl9O2guVWY9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztUayh0aGlzLGZ1bmN0aW9uKCl7YS5uZXh0KFUoYikpfSl9O1xuaC5vbklkVG9rZW5DaGFuZ2VkPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzO3RoaXMuQ2MmJmZpcmViYXNlLlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKXtwKGEpP2EoVShkKSk6cChhLm5leHQpJiZhLm5leHQoVShkKSl9KTtyZXR1cm4gdGhpcy5jZyhhLGIsYyl9O2gub25BdXRoU3RhdGVDaGFuZ2VkPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzO3RoaXMuQ2MmJmZpcmViYXNlLlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKXtkLmtjPWQuZ2V0VWlkKCk7cChhKT9hKFUoZCkpOnAoYS5uZXh0KSYmYS5uZXh0KFUoZCkpfSk7cmV0dXJuIHRoaXMuZWcoYSxiLGMpfTtoLklmPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz10aGlzLnlhLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gVShiKT9VKGIpLmdldElkVG9rZW4oYSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm57YWNjZXNzVG9rZW46YX19KTpudWxsfSk7cmV0dXJuIHRoaXMuYyhjKX07XG5oLnNpZ25JbldpdGhDdXN0b21Ub2tlbj1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3JldHVybiB0aGlzLnlhLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gU2soYixRKGIuZixNaCx7dG9rZW46YX0pKX0pLnRoZW4oZnVuY3Rpb24oYSl7YT1hLnVzZXI7aGsoYSxcImlzQW5vbnltb3VzXCIsITEpO3JldHVybiBiLnBiKGEpfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBVKGIpfSl9O2guc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO3JldHVybiB0aGlzLnlhLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gU2soYyxRKGMuZixIZyx7ZW1haWw6YSxwYXNzd29yZDpifSkpfSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gYS51c2VyfSl9O2guY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcztyZXR1cm4gdGhpcy55YS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIFNrKGMsUShjLmYsSWgse2VtYWlsOmEscGFzc3dvcmQ6Yn0pKX0pLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGEudXNlcn0pfTtcbmguc2lnbkluV2l0aENyZWRlbnRpYWw9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuc2lnbkluQW5kUmV0cmlldmVEYXRhV2l0aENyZWRlbnRpYWwoYSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gYS51c2VyfSl9O2guc2lnbkluQW5kUmV0cmlldmVEYXRhV2l0aENyZWRlbnRpYWw9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gdGhpcy55YS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIFNrKGIsYS5PYihiLmYpKX0pfTtoLnNpZ25JbkFub255bW91c2x5PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztyZXR1cm4gdGhpcy55YS50aGVuKGZ1bmN0aW9uKCl7dmFyIGI9VShhKTtyZXR1cm4gYiYmYi5pc0Fub255bW91cz9iOlNrKGEsYS5mLnNpZ25JbkFub255bW91c2x5KCkpLnRoZW4oZnVuY3Rpb24oYil7Yj1iLnVzZXI7aGsoYixcImlzQW5vbnltb3VzXCIsITApO3JldHVybiBhLnBiKGIpfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBVKGEpfSl9KX07aC5pPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXBwfTtcbnZhciBVPWZ1bmN0aW9uKGEpe3JldHVybiBhLmN1cnJlbnRVc2VyfTtULnByb3RvdHlwZS5nZXRVaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gVSh0aGlzKSYmVSh0aGlzKS51aWR8fG51bGx9O3ZhciBVaz1mdW5jdGlvbihhKXtyZXR1cm4gVShhKSYmVShhKS5fbGF0fHxudWxsfTtoPVQucHJvdG90eXBlO2guVGE9ZnVuY3Rpb24oKXtpZih0aGlzLkNjKXtmb3IodmFyIGE9MDthPHRoaXMuS2EubGVuZ3RoO2ErKylpZih0aGlzLkthW2FdKXRoaXMuS2FbYV0oVWsodGhpcykpO2lmKHRoaXMua2MhPT10aGlzLmdldFVpZCgpJiZ0aGlzLkZiLmxlbmd0aClmb3IodGhpcy5rYz10aGlzLmdldFVpZCgpLGE9MDthPHRoaXMuRmIubGVuZ3RoO2ErKylpZih0aGlzLkZiW2FdKXRoaXMuRmJbYV0oVWsodGhpcykpfX07aC5wZj1mdW5jdGlvbihhKXt0aGlzLmFkZEF1dGhUb2tlbkxpc3RlbmVyKGEpO3RoaXMuT2ErKzswPHRoaXMuT2EmJlUodGhpcykmJlhqKFUodGhpcykpfTtcbmguamc9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczt4KHRoaXMuS2EsZnVuY3Rpb24oYyl7Yz09YSYmYi5PYS0tfSk7MD50aGlzLk9hJiYodGhpcy5PYT0wKTswPT10aGlzLk9hJiZVKHRoaXMpJiZZaihVKHRoaXMpKTt0aGlzLnJlbW92ZUF1dGhUb2tlbkxpc3RlbmVyKGEpfTtoLmFkZEF1dGhUb2tlbkxpc3RlbmVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7dGhpcy5LYS5wdXNoKGEpO3RoaXMuYyh0aGlzLnlhLnRoZW4oZnVuY3Rpb24oKXtiLkVhfHxWYShiLkthLGEpJiZhKFVrKGIpKX0pKX07aC5yZW1vdmVBdXRoVG9rZW5MaXN0ZW5lcj1mdW5jdGlvbihhKXtZYSh0aGlzLkthLGZ1bmN0aW9uKGIpe3JldHVybiBiPT1hfSl9O3ZhciBUaz1mdW5jdGlvbihhLGIpe2EuRmIucHVzaChiKTthLmMoYS55YS50aGVuKGZ1bmN0aW9uKCl7IWEuRWEmJlZhKGEuRmIsYikmJmEua2MhPT1hLmdldFVpZCgpJiYoYS5rYz1hLmdldFVpZCgpLGIoVWsoYSkpKX0pKX07aD1ULnByb3RvdHlwZTtcbmhbXCJkZWxldGVcIl09ZnVuY3Rpb24oKXt0aGlzLkVhPSEwO2Zvcih2YXIgYT0wO2E8dGhpcy5KLmxlbmd0aDthKyspdGhpcy5KW2FdLmNhbmNlbChcImFwcC1kZWxldGVkXCIpO3RoaXMuSj1bXTt0aGlzLm5hJiYoYT10aGlzLm5hLGEuaC5yZW1vdmVMaXN0ZW5lcih6ayhcImxvY2FsXCIpLGEuaix0aGlzLnVkKSk7dGhpcy52JiZ0aGlzLnYudW5zdWJzY3JpYmUodGhpcyk7cmV0dXJuIGZpcmViYXNlLlByb21pc2UucmVzb2x2ZSgpfTtoLmM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczt0aGlzLkoucHVzaChhKTtFZChhLGZ1bmN0aW9uKCl7WGEoYi5KLGEpfSk7cmV0dXJuIGF9O2guZmV0Y2hQcm92aWRlcnNGb3JFbWFpbD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5jKG1oKHRoaXMuZixhKSl9O2gudmVyaWZ5UGFzc3dvcmRSZXNldENvZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuY2hlY2tBY3Rpb25Db2RlKGEpLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGEuZGF0YS5lbWFpbH0pfTtcbmguY29uZmlybVBhc3N3b3JkUmVzZXQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5jKHRoaXMuZi5jb25maXJtUGFzc3dvcmRSZXNldChhLGIpLnRoZW4oZnVuY3Rpb24oKXt9KSl9O2guY2hlY2tBY3Rpb25Db2RlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmModGhpcy5mLmNoZWNrQWN0aW9uQ29kZShhKS50aGVuKGZ1bmN0aW9uKGEpe3JldHVybiBuZXcgS2koYSl9KSl9O2guYXBwbHlBY3Rpb25Db2RlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmModGhpcy5mLmFwcGx5QWN0aW9uQ29kZShhKS50aGVuKGZ1bmN0aW9uKCl7fSkpfTtoLnNlbmRQYXNzd29yZFJlc2V0RW1haWw9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO3JldHVybiB0aGlzLmMoRCgpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm5cInVuZGVmaW5lZFwiPT09dHlwZW9mIGJ8fGliKGIpP3t9OkhpKG5ldyBHaShiKSl9KS50aGVuKGZ1bmN0aW9uKGIpe3JldHVybiBjLmYuc2VuZFBhc3N3b3JkUmVzZXRFbWFpbChhLGIpfSkudGhlbihmdW5jdGlvbigpe30pKX07XG5oLnNpZ25JbldpdGhQaG9uZU51bWJlcj1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmMoSmkodGhpcyxhLGIscih0aGlzLnNpZ25JbkFuZFJldHJpZXZlRGF0YVdpdGhDcmVkZW50aWFsLHRoaXMpKSl9O3ZhciBXaz1mdW5jdGlvbihhLGIsYyxkKXthOntjPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGMpO3ZhciBlPTA7Zm9yKHZhciBmPSExLGc9MDtnPGIubGVuZ3RoO2crKylpZihiW2ddLm9wdGlvbmFsKWY9ITA7ZWxzZXtpZihmKXRocm93IG5ldyBPKFwiaW50ZXJuYWwtZXJyb3JcIixcIkFyZ3VtZW50IHZhbGlkYXRvciBlbmNvdW50ZXJlZCBhIHJlcXVpcmVkIGFyZ3VtZW50IGFmdGVyIGFuIG9wdGlvbmFsIGFyZ3VtZW50LlwiKTtlKyt9Zj1iLmxlbmd0aDtpZihjLmxlbmd0aDxlfHxmPGMubGVuZ3RoKWQ9XCJFeHBlY3RlZCBcIisoZT09Zj8xPT1lP1wiMSBhcmd1bWVudFwiOmUrXCIgYXJndW1lbnRzXCI6ZStcIi1cIitmK1wiIGFyZ3VtZW50c1wiKStcIiBidXQgZ290IFwiK2MubGVuZ3RoK1wiLlwiO2Vsc2V7Zm9yKGU9MDtlPGMubGVuZ3RoO2UrKylpZihmPWJbZV0ub3B0aW9uYWwmJnZvaWQgMD09PWNbZV0sIWJbZV0uVyhjW2VdKSYmIWYpe2I9YltlXTtpZigwPmV8fGU+PVZrLmxlbmd0aCl0aHJvdyBuZXcgTyhcImludGVybmFsLWVycm9yXCIsXG5cIkFyZ3VtZW50IHZhbGlkYXRvciByZWNlaXZlZCBhbiB1bnN1cHBvcnRlZCBudW1iZXIgb2YgYXJndW1lbnRzLlwiKTtjPVZrW2VdO2Q9KGQ/XCJcIjpjK1wiIGFyZ3VtZW50IFwiKSsoYi5uYW1lPydcIicrYi5uYW1lKydcIiAnOlwiXCIpK1wibXVzdCBiZSBcIitiLlYrXCIuXCI7YnJlYWsgYX1kPW51bGx9fWlmKGQpdGhyb3cgbmV3IE8oXCJhcmd1bWVudC1lcnJvclwiLGErXCIgZmFpbGVkOiBcIitkKTt9LFZrPVwiRmlyc3QgU2Vjb25kIFRoaXJkIEZvdXJ0aCBGaWZ0aCBTaXh0aCBTZXZlbnRoIEVpZ2h0aCBOaW50aFwiLnNwbGl0KFwiIFwiKSxWPWZ1bmN0aW9uKGEsYil7cmV0dXJue25hbWU6YXx8XCJcIixWOlwiYSB2YWxpZCBzdHJpbmdcIixvcHRpb25hbDohIWIsVzptfX0sWGs9ZnVuY3Rpb24oKXtyZXR1cm57bmFtZTpcIm9wdF9mb3JjZVJlZnJlc2hcIixWOlwiYSBib29sZWFuXCIsb3B0aW9uYWw6ITAsVzpjYX19LFc9ZnVuY3Rpb24oYSxiKXtyZXR1cm57bmFtZTphfHxcIlwiLFY6XCJhIHZhbGlkIG9iamVjdFwiLG9wdGlvbmFsOiEhYixcblc6cX19LFlrPWZ1bmN0aW9uKGEsYil7cmV0dXJue25hbWU6YXx8XCJcIixWOlwiYSBmdW5jdGlvblwiLG9wdGlvbmFsOiEhYixXOnB9fSxaaz1mdW5jdGlvbihhLGIpe3JldHVybntuYW1lOmF8fFwiXCIsVjpcIm51bGxcIixvcHRpb25hbDohIWIsVzpmYX19LCRrPWZ1bmN0aW9uKCl7cmV0dXJue25hbWU6XCJcIixWOlwiYW4gSFRNTCBlbGVtZW50XCIsb3B0aW9uYWw6ITEsVzpmdW5jdGlvbihhKXtyZXR1cm4hIShhJiZhIGluc3RhbmNlb2YgRWxlbWVudCl9fX0sYWw9ZnVuY3Rpb24oKXtyZXR1cm57bmFtZTpcImF1dGhcIixWOlwiYW4gaW5zdGFuY2Ugb2YgRmlyZWJhc2UgQXV0aFwiLG9wdGlvbmFsOiEwLFc6ZnVuY3Rpb24oYSl7cmV0dXJuISEoYSYmYSBpbnN0YW5jZW9mIFQpfX19LGJsPWZ1bmN0aW9uKCl7cmV0dXJue25hbWU6XCJhcHBcIixWOlwiYW4gaW5zdGFuY2Ugb2YgRmlyZWJhc2UgQXBwXCIsb3B0aW9uYWw6ITAsVzpmdW5jdGlvbihhKXtyZXR1cm4hIShhJiZhIGluc3RhbmNlb2YgZmlyZWJhc2UuYXBwLkFwcCl9fX0sXG5jbD1mdW5jdGlvbihhKXtyZXR1cm57bmFtZTphP2ErXCJDcmVkZW50aWFsXCI6XCJjcmVkZW50aWFsXCIsVjphP1wiYSB2YWxpZCBcIithK1wiIGNyZWRlbnRpYWxcIjpcImEgdmFsaWQgY3JlZGVudGlhbFwiLG9wdGlvbmFsOiExLFc6ZnVuY3Rpb24oYil7aWYoIWIpcmV0dXJuITE7dmFyIGM9IWF8fGIucHJvdmlkZXJJZD09PWE7cmV0dXJuISghYi5PYnx8IWMpfX19LGRsPWZ1bmN0aW9uKCl7cmV0dXJue25hbWU6XCJhdXRoUHJvdmlkZXJcIixWOlwiYSB2YWxpZCBBdXRoIHByb3ZpZGVyXCIsb3B0aW9uYWw6ITEsVzpmdW5jdGlvbihhKXtyZXR1cm4hIShhJiZhLnByb3ZpZGVySWQmJmEuaGFzT3duUHJvcGVydHkmJmEuaGFzT3duUHJvcGVydHkoXCJpc09BdXRoUHJvdmlkZXJcIikpfX19LGVsPWZ1bmN0aW9uKCl7cmV0dXJue25hbWU6XCJhcHBsaWNhdGlvblZlcmlmaWVyXCIsVjpcImFuIGltcGxlbWVudGF0aW9uIG9mIGZpcmViYXNlLmF1dGguQXBwbGljYXRpb25WZXJpZmllclwiLG9wdGlvbmFsOiExLFc6ZnVuY3Rpb24oYSl7cmV0dXJuISEoYSYmXG5tKGEudHlwZSkmJnAoYS52ZXJpZnkpKX19fSxYPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybntuYW1lOmN8fFwiXCIsVjphLlYrXCIgb3IgXCIrYi5WLG9wdGlvbmFsOiEhZCxXOmZ1bmN0aW9uKGMpe3JldHVybiBhLlcoYyl8fGIuVyhjKX19fTt2YXIgWT1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYyBpbiBiKXt2YXIgZD1iW2NdLm5hbWU7YVtkXT1mbChkLGFbY10sYltjXS5hKX19LFo9ZnVuY3Rpb24oYSxiLGMsZCl7YVtiXT1mbChiLGMsZCl9LGZsPWZ1bmN0aW9uKGEsYixjKXtpZighYylyZXR1cm4gYjt2YXIgZD1nbChhKTthPWZ1bmN0aW9uKCl7dmFyIGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtXayhkLGMsYSk7cmV0dXJuIGIuYXBwbHkodGhpcyxhKX07Zm9yKHZhciBlIGluIGIpYVtlXT1iW2VdO2ZvcihlIGluIGIucHJvdG90eXBlKWEucHJvdG90eXBlW2VdPWIucHJvdG90eXBlW2VdO3JldHVybiBhfSxnbD1mdW5jdGlvbihhKXthPWEuc3BsaXQoXCIuXCIpO3JldHVybiBhW2EubGVuZ3RoLTFdfTtZKFQucHJvdG90eXBlLHthcHBseUFjdGlvbkNvZGU6e25hbWU6XCJhcHBseUFjdGlvbkNvZGVcIixhOltWKFwiY29kZVwiKV19LGNoZWNrQWN0aW9uQ29kZTp7bmFtZTpcImNoZWNrQWN0aW9uQ29kZVwiLGE6W1YoXCJjb2RlXCIpXX0sY29uZmlybVBhc3N3b3JkUmVzZXQ6e25hbWU6XCJjb25maXJtUGFzc3dvcmRSZXNldFwiLGE6W1YoXCJjb2RlXCIpLFYoXCJuZXdQYXNzd29yZFwiKV19LGNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZDp7bmFtZTpcImNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZFwiLGE6W1YoXCJlbWFpbFwiKSxWKFwicGFzc3dvcmRcIildfSxmZXRjaFByb3ZpZGVyc0ZvckVtYWlsOntuYW1lOlwiZmV0Y2hQcm92aWRlcnNGb3JFbWFpbFwiLGE6W1YoXCJlbWFpbFwiKV19LGdldFJlZGlyZWN0UmVzdWx0OntuYW1lOlwiZ2V0UmVkaXJlY3RSZXN1bHRcIixhOltdfSxvbkF1dGhTdGF0ZUNoYW5nZWQ6e25hbWU6XCJvbkF1dGhTdGF0ZUNoYW5nZWRcIixhOltYKFcoKSxZaygpLFwibmV4dE9yT2JzZXJ2ZXJcIiksXG5ZayhcIm9wdF9lcnJvclwiLCEwKSxZayhcIm9wdF9jb21wbGV0ZWRcIiwhMCldfSxvbklkVG9rZW5DaGFuZ2VkOntuYW1lOlwib25JZFRva2VuQ2hhbmdlZFwiLGE6W1goVygpLFlrKCksXCJuZXh0T3JPYnNlcnZlclwiKSxZayhcIm9wdF9lcnJvclwiLCEwKSxZayhcIm9wdF9jb21wbGV0ZWRcIiwhMCldfSxzZW5kUGFzc3dvcmRSZXNldEVtYWlsOntuYW1lOlwic2VuZFBhc3N3b3JkUmVzZXRFbWFpbFwiLGE6W1YoXCJlbWFpbFwiKSxYKFcoXCJvcHRfYWN0aW9uQ29kZVNldHRpbmdzXCIsITApLFprKG51bGwsITApLFwib3B0X2FjdGlvbkNvZGVTZXR0aW5nc1wiLCEwKV19LHNldFBlcnNpc3RlbmNlOntuYW1lOlwic2V0UGVyc2lzdGVuY2VcIixhOltWKFwicGVyc2lzdGVuY2VcIildfSxzaWduSW5BbmRSZXRyaWV2ZURhdGFXaXRoQ3JlZGVudGlhbDp7bmFtZTpcInNpZ25JbkFuZFJldHJpZXZlRGF0YVdpdGhDcmVkZW50aWFsXCIsYTpbY2woKV19LHNpZ25JbkFub255bW91c2x5OntuYW1lOlwic2lnbkluQW5vbnltb3VzbHlcIixhOltdfSxcbnNpZ25JbldpdGhDcmVkZW50aWFsOntuYW1lOlwic2lnbkluV2l0aENyZWRlbnRpYWxcIixhOltjbCgpXX0sc2lnbkluV2l0aEN1c3RvbVRva2VuOntuYW1lOlwic2lnbkluV2l0aEN1c3RvbVRva2VuXCIsYTpbVihcInRva2VuXCIpXX0sc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQ6e25hbWU6XCJzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZFwiLGE6W1YoXCJlbWFpbFwiKSxWKFwicGFzc3dvcmRcIildfSxzaWduSW5XaXRoUGhvbmVOdW1iZXI6e25hbWU6XCJzaWduSW5XaXRoUGhvbmVOdW1iZXJcIixhOltWKFwicGhvbmVOdW1iZXJcIiksZWwoKV19LHNpZ25JbldpdGhQb3B1cDp7bmFtZTpcInNpZ25JbldpdGhQb3B1cFwiLGE6W2RsKCldfSxzaWduSW5XaXRoUmVkaXJlY3Q6e25hbWU6XCJzaWduSW5XaXRoUmVkaXJlY3RcIixhOltkbCgpXX0sc2lnbk91dDp7bmFtZTpcInNpZ25PdXRcIixhOltdfSx0b0pTT046e25hbWU6XCJ0b0pTT05cIixhOltWKG51bGwsITApXX0sdXNlRGV2aWNlTGFuZ3VhZ2U6e25hbWU6XCJ1c2VEZXZpY2VMYW5ndWFnZVwiLFxuYTpbXX0sdmVyaWZ5UGFzc3dvcmRSZXNldENvZGU6e25hbWU6XCJ2ZXJpZnlQYXNzd29yZFJlc2V0Q29kZVwiLGE6W1YoXCJjb2RlXCIpXX19KTsoZnVuY3Rpb24oYSxiKXtmb3IodmFyIGMgaW4gYil7dmFyIGQ9YltjXS5uYW1lO2lmKGQhPT1jKXt2YXIgZT1iW2NdLnJmO09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGQse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW2NdfSxzZXQ6ZnVuY3Rpb24oYSl7V2soZCxbZV0sW2FdLCEwKTt0aGlzW2NdPWF9LGVudW1lcmFibGU6ITB9KX19fSkoVC5wcm90b3R5cGUse2xjOntuYW1lOlwibGFuZ3VhZ2VDb2RlXCIscmY6WChWKCksWmsoKSxcImxhbmd1YWdlQ29kZVwiKX19KTtULlBlcnNpc3RlbmNlPVZpO1QuUGVyc2lzdGVuY2UuTE9DQUw9XCJsb2NhbFwiO1QuUGVyc2lzdGVuY2UuU0VTU0lPTj1cInNlc3Npb25cIjtULlBlcnNpc3RlbmNlLk5PTkU9XCJub25lXCI7XG5ZKFMucHJvdG90eXBlLHtcImRlbGV0ZVwiOntuYW1lOlwiZGVsZXRlXCIsYTpbXX0sZ2V0SWRUb2tlbjp7bmFtZTpcImdldElkVG9rZW5cIixhOltYaygpXX0sZ2V0VG9rZW46e25hbWU6XCJnZXRUb2tlblwiLGE6W1hrKCldfSxsaW5rQW5kUmV0cmlldmVEYXRhV2l0aENyZWRlbnRpYWw6e25hbWU6XCJsaW5rQW5kUmV0cmlldmVEYXRhV2l0aENyZWRlbnRpYWxcIixhOltjbCgpXX0sbGlua1dpdGhDcmVkZW50aWFsOntuYW1lOlwibGlua1dpdGhDcmVkZW50aWFsXCIsYTpbY2woKV19LGxpbmtXaXRoUGhvbmVOdW1iZXI6e25hbWU6XCJsaW5rV2l0aFBob25lTnVtYmVyXCIsYTpbVihcInBob25lTnVtYmVyXCIpLGVsKCldfSxsaW5rV2l0aFBvcHVwOntuYW1lOlwibGlua1dpdGhQb3B1cFwiLGE6W2RsKCldfSxsaW5rV2l0aFJlZGlyZWN0OntuYW1lOlwibGlua1dpdGhSZWRpcmVjdFwiLGE6W2RsKCldfSxyZWF1dGhlbnRpY2F0ZUFuZFJldHJpZXZlRGF0YVdpdGhDcmVkZW50aWFsOntuYW1lOlwicmVhdXRoZW50aWNhdGVBbmRSZXRyaWV2ZURhdGFXaXRoQ3JlZGVudGlhbFwiLFxuYTpbY2woKV19LHJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWw6e25hbWU6XCJyZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsXCIsYTpbY2woKV19LHJlYXV0aGVudGljYXRlV2l0aFBob25lTnVtYmVyOntuYW1lOlwicmVhdXRoZW50aWNhdGVXaXRoUGhvbmVOdW1iZXJcIixhOltWKFwicGhvbmVOdW1iZXJcIiksZWwoKV19LHJlYXV0aGVudGljYXRlV2l0aFBvcHVwOntuYW1lOlwicmVhdXRoZW50aWNhdGVXaXRoUG9wdXBcIixhOltkbCgpXX0scmVhdXRoZW50aWNhdGVXaXRoUmVkaXJlY3Q6e25hbWU6XCJyZWF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdFwiLGE6W2RsKCldfSxyZWxvYWQ6e25hbWU6XCJyZWxvYWRcIixhOltdfSxzZW5kRW1haWxWZXJpZmljYXRpb246e25hbWU6XCJzZW5kRW1haWxWZXJpZmljYXRpb25cIixhOltYKFcoXCJvcHRfYWN0aW9uQ29kZVNldHRpbmdzXCIsITApLFprKG51bGwsITApLFwib3B0X2FjdGlvbkNvZGVTZXR0aW5nc1wiLCEwKV19LHRvSlNPTjp7bmFtZTpcInRvSlNPTlwiLGE6W1YobnVsbCxcbiEwKV19LHVubGluazp7bmFtZTpcInVubGlua1wiLGE6W1YoXCJwcm92aWRlclwiKV19LHVwZGF0ZUVtYWlsOntuYW1lOlwidXBkYXRlRW1haWxcIixhOltWKFwiZW1haWxcIildfSx1cGRhdGVQYXNzd29yZDp7bmFtZTpcInVwZGF0ZVBhc3N3b3JkXCIsYTpbVihcInBhc3N3b3JkXCIpXX0sdXBkYXRlUGhvbmVOdW1iZXI6e25hbWU6XCJ1cGRhdGVQaG9uZU51bWJlclwiLGE6W2NsKFwicGhvbmVcIildfSx1cGRhdGVQcm9maWxlOntuYW1lOlwidXBkYXRlUHJvZmlsZVwiLGE6W1coXCJwcm9maWxlXCIpXX19KTtZKEMucHJvdG90eXBlLHtnOntuYW1lOlwiY2F0Y2hcIn0sdGhlbjp7bmFtZTpcInRoZW5cIn19KTtZKElpLnByb3RvdHlwZSx7Y29uZmlybTp7bmFtZTpcImNvbmZpcm1cIixhOltWKFwidmVyaWZpY2F0aW9uQ29kZVwiKV19fSk7WihKZyxcImNyZWRlbnRpYWxcIixmdW5jdGlvbihhLGIpe3JldHVybiBuZXcgR2coYSxiKX0sW1YoXCJlbWFpbFwiKSxWKFwicGFzc3dvcmRcIildKTtcblkoeWcucHJvdG90eXBlLHthZGRTY29wZTp7bmFtZTpcImFkZFNjb3BlXCIsYTpbVihcInNjb3BlXCIpXX0sc2V0Q3VzdG9tUGFyYW1ldGVyczp7bmFtZTpcInNldEN1c3RvbVBhcmFtZXRlcnNcIixhOltXKFwiY3VzdG9tT0F1dGhQYXJhbWV0ZXJzXCIpXX19KTtaKHlnLFwiY3JlZGVudGlhbFwiLHpnLFtYKFYoKSxXKCksXCJ0b2tlblwiKV0pO1koQWcucHJvdG90eXBlLHthZGRTY29wZTp7bmFtZTpcImFkZFNjb3BlXCIsYTpbVihcInNjb3BlXCIpXX0sc2V0Q3VzdG9tUGFyYW1ldGVyczp7bmFtZTpcInNldEN1c3RvbVBhcmFtZXRlcnNcIixhOltXKFwiY3VzdG9tT0F1dGhQYXJhbWV0ZXJzXCIpXX19KTtaKEFnLFwiY3JlZGVudGlhbFwiLEJnLFtYKFYoKSxXKCksXCJ0b2tlblwiKV0pO1koQ2cucHJvdG90eXBlLHthZGRTY29wZTp7bmFtZTpcImFkZFNjb3BlXCIsYTpbVihcInNjb3BlXCIpXX0sc2V0Q3VzdG9tUGFyYW1ldGVyczp7bmFtZTpcInNldEN1c3RvbVBhcmFtZXRlcnNcIixhOltXKFwiY3VzdG9tT0F1dGhQYXJhbWV0ZXJzXCIpXX19KTtcblooQ2csXCJjcmVkZW50aWFsXCIsRGcsW1goVigpLFgoVygpLFprKCkpLFwiaWRUb2tlblwiKSxYKFYoKSxaaygpLFwiYWNjZXNzVG9rZW5cIiwhMCldKTtZKEVnLnByb3RvdHlwZSx7c2V0Q3VzdG9tUGFyYW1ldGVyczp7bmFtZTpcInNldEN1c3RvbVBhcmFtZXRlcnNcIixhOltXKFwiY3VzdG9tT0F1dGhQYXJhbWV0ZXJzXCIpXX19KTtaKEVnLFwiY3JlZGVudGlhbFwiLEZnLFtYKFYoKSxXKCksXCJ0b2tlblwiKSxWKFwic2VjcmV0XCIsITApXSk7WShQLnByb3RvdHlwZSx7YWRkU2NvcGU6e25hbWU6XCJhZGRTY29wZVwiLGE6W1YoXCJzY29wZVwiKV19LGNyZWRlbnRpYWw6e25hbWU6XCJjcmVkZW50aWFsXCIsYTpbWChWKCksWmsoKSxcImlkVG9rZW5cIiwhMCksWChWKCksWmsoKSxcImFjY2Vzc1Rva2VuXCIsITApXX0sc2V0Q3VzdG9tUGFyYW1ldGVyczp7bmFtZTpcInNldEN1c3RvbVBhcmFtZXRlcnNcIixhOltXKFwiY3VzdG9tT0F1dGhQYXJhbWV0ZXJzXCIpXX19KTtcblooT2csXCJjcmVkZW50aWFsXCIsUWcsW1YoXCJ2ZXJpZmljYXRpb25JZFwiKSxWKFwidmVyaWZpY2F0aW9uQ29kZVwiKV0pO1koT2cucHJvdG90eXBlLHt2ZXJpZnlQaG9uZU51bWJlcjp7bmFtZTpcInZlcmlmeVBob25lTnVtYmVyXCIsYTpbVihcInBob25lTnVtYmVyXCIpLGVsKCldfX0pO1koTy5wcm90b3R5cGUse3RvSlNPTjp7bmFtZTpcInRvSlNPTlwiLGE6W1YobnVsbCwhMCldfX0pO1koVGcucHJvdG90eXBlLHt0b0pTT046e25hbWU6XCJ0b0pTT05cIixhOltWKG51bGwsITApXX19KTtZKG9nLnByb3RvdHlwZSx7dG9KU09OOntuYW1lOlwidG9KU09OXCIsYTpbVihudWxsLCEwKV19fSk7WShsaS5wcm90b3R5cGUse2NsZWFyOntuYW1lOlwiY2xlYXJcIixhOltdfSxyZW5kZXI6e25hbWU6XCJyZW5kZXJcIixhOltdfSx2ZXJpZnk6e25hbWU6XCJ2ZXJpZnlcIixhOltdfX0pO1xuKGZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBmaXJlYmFzZSYmZmlyZWJhc2UuSU5URVJOQUwmJmZpcmViYXNlLklOVEVSTkFMLnJlZ2lzdGVyU2VydmljZSl7dmFyIGE9e0F1dGg6VCxFcnJvcjpPfTtaKGEsXCJFbWFpbEF1dGhQcm92aWRlclwiLEpnLFtdKTtaKGEsXCJGYWNlYm9va0F1dGhQcm92aWRlclwiLHlnLFtdKTtaKGEsXCJHaXRodWJBdXRoUHJvdmlkZXJcIixBZyxbXSk7WihhLFwiR29vZ2xlQXV0aFByb3ZpZGVyXCIsQ2csW10pO1ooYSxcIlR3aXR0ZXJBdXRoUHJvdmlkZXJcIixFZyxbXSk7WihhLFwiT0F1dGhQcm92aWRlclwiLFAsW1YoXCJwcm92aWRlcklkXCIpXSk7WihhLFwiUGhvbmVBdXRoUHJvdmlkZXJcIixPZyxbYWwoKV0pO1ooYSxcIlJlY2FwdGNoYVZlcmlmaWVyXCIsbGksW1goVigpLCRrKCksXCJyZWNhcHRjaGFDb250YWluZXJcIiksVyhcInJlY2FwdGNoYVBhcmFtZXRlcnNcIiwhMCksYmwoKV0pO2ZpcmViYXNlLklOVEVSTkFMLnJlZ2lzdGVyU2VydmljZShcImF1dGhcIixmdW5jdGlvbihhLFxuYyl7YT1uZXcgVChhKTtjKHtJTlRFUk5BTDp7Z2V0VWlkOnIoYS5nZXRVaWQsYSksZ2V0VG9rZW46cihhLklmLGEpLGFkZEF1dGhUb2tlbkxpc3RlbmVyOnIoYS5wZixhKSxyZW1vdmVBdXRoVG9rZW5MaXN0ZW5lcjpyKGEuamcsYSl9fSk7cmV0dXJuIGF9LGEsZnVuY3Rpb24oYSxjKXtpZihcImNyZWF0ZVwiPT09YSl0cnl7Yy5hdXRoKCl9Y2F0Y2goZCl7fX0pO2ZpcmViYXNlLklOVEVSTkFMLmV4dGVuZE5hbWVzcGFjZSh7VXNlcjpTfSl9ZWxzZSB0aHJvdyBFcnJvcihcIkNhbm5vdCBmaW5kIHRoZSBmaXJlYmFzZSBuYW1lc3BhY2U7IGJlIHN1cmUgdG8gaW5jbHVkZSBmaXJlYmFzZS1hcHAuanMgYmVmb3JlIHRoaXMgbGlicmFyeS5cIik7fSkoKTt9KS5jYWxsKHRoaXMpO1xufSkuY2FsbCh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2F1dGgvZGlzdC9hdXRoLmpzXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IGZpcmViYXNlIGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgRGF0YWJhc2UgfSBmcm9tICcuL3NyYy9hcGkvRGF0YWJhc2UnO1xuaW1wb3J0IHsgUXVlcnkgfSBmcm9tICcuL3NyYy9hcGkvUXVlcnknO1xuaW1wb3J0IHsgUmVmZXJlbmNlIH0gZnJvbSAnLi9zcmMvYXBpL1JlZmVyZW5jZSc7XG5pbXBvcnQgeyBlbmFibGVMb2dnaW5nIH0gZnJvbSAnLi9zcmMvY29yZS91dGlsL3V0aWwnO1xuaW1wb3J0IHsgUmVwb01hbmFnZXIgfSBmcm9tICcuL3NyYy9jb3JlL1JlcG9NYW5hZ2VyJztcbmltcG9ydCAqIGFzIElOVEVSTkFMIGZyb20gJy4vc3JjL2FwaS9pbnRlcm5hbCc7XG5pbXBvcnQgKiBhcyBURVNUX0FDQ0VTUyBmcm9tICcuL3NyYy9hcGkvdGVzdF9hY2Nlc3MnO1xuaW1wb3J0IHsgaXNOb2RlU2RrIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRGF0YWJhc2UoaW5zdGFuY2UpIHtcbiAgICAvLyBSZWdpc3RlciB0aGUgRGF0YWJhc2UgU2VydmljZSB3aXRoIHRoZSAnZmlyZWJhc2UnIG5hbWVzcGFjZS5cbiAgICB2YXIgbmFtZXNwYWNlID0gaW5zdGFuY2UuSU5URVJOQUwucmVnaXN0ZXJTZXJ2aWNlKCdkYXRhYmFzZScsIGZ1bmN0aW9uIChhcHAsIHVudXNlZCwgdXJsKSB7IHJldHVybiBSZXBvTWFuYWdlci5nZXRJbnN0YW5jZSgpLmRhdGFiYXNlRnJvbUFwcChhcHAsIHVybCk7IH0sIFxuICAgIC8vIGZpcmViYXNlLmRhdGFiYXNlIG5hbWVzcGFjZSBwcm9wZXJ0aWVzXG4gICAge1xuICAgICAgICBSZWZlcmVuY2U6IFJlZmVyZW5jZSxcbiAgICAgICAgUXVlcnk6IFF1ZXJ5LFxuICAgICAgICBEYXRhYmFzZTogRGF0YWJhc2UsXG4gICAgICAgIGVuYWJsZUxvZ2dpbmc6IGVuYWJsZUxvZ2dpbmcsXG4gICAgICAgIElOVEVSTkFMOiBJTlRFUk5BTCxcbiAgICAgICAgU2VydmVyVmFsdWU6IERhdGFiYXNlLlNlcnZlclZhbHVlLFxuICAgICAgICBURVNUX0FDQ0VTUzogVEVTVF9BQ0NFU1NcbiAgICB9LCBudWxsLCB0cnVlKTtcbiAgICBpZiAoaXNOb2RlU2RrKCkpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBuYW1lc3BhY2U7XG4gICAgfVxufVxucmVnaXN0ZXJEYXRhYmFzZShmaXJlYmFzZSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyB2YWxpZGF0ZUFyZ0NvdW50IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xudmFyIFRyYW5zYWN0aW9uUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEEgdHlwZSBmb3IgdGhlIHJlc29sdmUgdmFsdWUgb2YgRmlyZWJhc2UudHJhbnNhY3Rpb24uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGRpY3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbW1pdHRlZFxuICAgICAqIEBwYXJhbSB7RGF0YVNuYXBzaG90fSBzbmFwc2hvdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyYW5zYWN0aW9uUmVzdWx0KGNvbW1pdHRlZCwgc25hcHNob3QpIHtcbiAgICAgICAgdGhpcy5jb21taXR0ZWQgPSBjb21taXR0ZWQ7XG4gICAgICAgIHRoaXMuc25hcHNob3QgPSBzbmFwc2hvdDtcbiAgICB9XG4gICAgLy8gRG8gbm90IGNyZWF0ZSBwdWJsaWMgZG9jdW1lbnRhdGlvbi4gVGhpcyBpcyBpbnRlbmRlZCB0byBtYWtlIEpTT04gc2VyaWFsaXphdGlvbiB3b3JrIGJ1dCBpcyBvdGhlcndpc2UgdW5uZWNlc3NhcnlcbiAgICAvLyBmb3IgZW5kLXVzZXJzXG4gICAgVHJhbnNhY3Rpb25SZXN1bHQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnVHJhbnNhY3Rpb25SZXN1bHQudG9KU09OJywgMCwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB7IGNvbW1pdHRlZDogdGhpcy5jb21taXR0ZWQsIHNuYXBzaG90OiB0aGlzLnNuYXBzaG90LnRvSlNPTigpIH07XG4gICAgfTtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXN1bHQ7XG59KCkpO1xuZXhwb3J0IHsgVHJhbnNhY3Rpb25SZXN1bHQgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvYXBpL1RyYW5zYWN0aW9uUmVzdWx0LmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgV2ViU29ja2V0Q29ubmVjdGlvbiB9IGZyb20gJy4uL3JlYWx0aW1lL1dlYlNvY2tldENvbm5lY3Rpb24nO1xuaW1wb3J0IHsgQnJvd3NlclBvbGxDb25uZWN0aW9uIH0gZnJvbSAnLi4vcmVhbHRpbWUvQnJvd3NlclBvbGxDb25uZWN0aW9uJztcbi8qKlxuICogSU5URVJOQUwgbWV0aG9kcyBmb3IgaW50ZXJuYWwtdXNlIG9ubHkgKHRlc3RzLCBldGMuKS5cbiAqXG4gKiBDdXN0b21lcnMgc2hvdWxkbid0IHVzZSB0aGVzZSBvciBlbHNlIHNob3VsZCBiZSBhd2FyZSB0aGF0IHRoZXkgY291bGQgYnJlYWsgYXQgYW55IHRpbWUuXG4gKlxuICogQGNvbnN0XG4gKi9cbmV4cG9ydCB2YXIgZm9yY2VMb25nUG9sbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3coKTtcbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VBbGxvdygpO1xufTtcbmV4cG9ydCB2YXIgZm9yY2VXZWJTb2NrZXRzID0gZnVuY3Rpb24gKCkge1xuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZURpc2FsbG93KCk7XG59O1xuLyogVXNlZCBieSBBcHAgTWFuYWdlciAqL1xuZXhwb3J0IHZhciBpc1dlYlNvY2tldHNBdmFpbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFdlYlNvY2tldENvbm5lY3Rpb25bJ2lzQXZhaWxhYmxlJ10oKTtcbn07XG5leHBvcnQgdmFyIHNldFNlY3VyaXR5RGVidWdDYWxsYmFjayA9IGZ1bmN0aW9uIChyZWYsIGNhbGxiYWNrKSB7XG4gICAgcmVmLnJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fLnNlY3VyaXR5RGVidWdDYWxsYmFja18gPSBjYWxsYmFjaztcbn07XG5leHBvcnQgdmFyIHN0YXRzID0gZnVuY3Rpb24gKHJlZiwgc2hvd0RlbHRhKSB7XG4gICAgcmVmLnJlcG8uc3RhdHMoc2hvd0RlbHRhKTtcbn07XG5leHBvcnQgdmFyIHN0YXRzSW5jcmVtZW50Q291bnRlciA9IGZ1bmN0aW9uIChyZWYsIG1ldHJpYykge1xuICAgIHJlZi5yZXBvLnN0YXRzSW5jcmVtZW50Q291bnRlcihtZXRyaWMpO1xufTtcbmV4cG9ydCB2YXIgZGF0YVVwZGF0ZUNvdW50ID0gZnVuY3Rpb24gKHJlZikge1xuICAgIHJldHVybiByZWYucmVwby5kYXRhVXBkYXRlQ291bnQ7XG59O1xuZXhwb3J0IHZhciBpbnRlcmNlcHRTZXJ2ZXJEYXRhID0gZnVuY3Rpb24gKHJlZiwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcmVmLnJlcG8uaW50ZXJjZXB0U2VydmVyRGF0YV8oY2FsbGJhY2spO1xufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvYXBpL2ludGVybmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgdmFsaWRhdGVBcmdDb3VudCwgdmFsaWRhdGVDYWxsYmFjayB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IHZhbGlkYXRlV3JpdGFibGVQYXRoLCB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZywgdmFsaWRhdGVQcmlvcml0eSwgdmFsaWRhdGVGaXJlYmFzZU1lcmdlRGF0YUFyZyB9IGZyb20gJy4uL2NvcmUvdXRpbC92YWxpZGF0aW9uJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi9jb3JlL3V0aWwvdXRpbCc7XG5pbXBvcnQgeyBEZWZlcnJlZCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBPbkRpc2Nvbm5lY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUmVwb30gcmVwb19cbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoX1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE9uRGlzY29ubmVjdChyZXBvXywgcGF0aF8pIHtcbiAgICAgICAgdGhpcy5yZXBvXyA9IHJlcG9fO1xuICAgICAgICB0aGlzLnBhdGhfID0gcGF0aF87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yKT19IG9uQ29tcGxldGVcbiAgICAgKiBAcmV0dXJuIHshZmlyZWJhc2UuUHJvbWlzZX1cbiAgICAgKi9cbiAgICBPbkRpc2Nvbm5lY3QucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIChvbkNvbXBsZXRlKSB7XG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ09uRGlzY29ubmVjdC5jYW5jZWwnLCAwLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFsaWRhdGVDYWxsYmFjaygnT25EaXNjb25uZWN0LmNhbmNlbCcsIDEsIG9uQ29tcGxldGUsIHRydWUpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5yZXBvXy5vbkRpc2Nvbm5lY3RDYW5jZWwodGhpcy5wYXRoXywgZGVmZXJyZWQud3JhcENhbGxiYWNrKG9uQ29tcGxldGUpKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvcik9fSBvbkNvbXBsZXRlXG4gICAgICogQHJldHVybiB7IWZpcmViYXNlLlByb21pc2V9XG4gICAgICovXG4gICAgT25EaXNjb25uZWN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAob25Db21wbGV0ZSkge1xuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdPbkRpc2Nvbm5lY3QucmVtb3ZlJywgMCwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdPbkRpc2Nvbm5lY3QucmVtb3ZlJywgdGhpcy5wYXRoXyk7XG4gICAgICAgIHZhbGlkYXRlQ2FsbGJhY2soJ09uRGlzY29ubmVjdC5yZW1vdmUnLCAxLCBvbkNvbXBsZXRlLCB0cnVlKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMucmVwb18ub25EaXNjb25uZWN0U2V0KHRoaXMucGF0aF8sIG51bGwsIGRlZmVycmVkLndyYXBDYWxsYmFjayhvbkNvbXBsZXRlKSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yKT19IG9uQ29tcGxldGVcbiAgICAgKiBAcmV0dXJuIHshZmlyZWJhc2UuUHJvbWlzZX1cbiAgICAgKi9cbiAgICBPbkRpc2Nvbm5lY3QucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSwgb25Db21wbGV0ZSkge1xuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdPbkRpc2Nvbm5lY3Quc2V0JywgMSwgMiwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdPbkRpc2Nvbm5lY3Quc2V0JywgdGhpcy5wYXRoXyk7XG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdPbkRpc2Nvbm5lY3Quc2V0JywgMSwgdmFsdWUsIHRoaXMucGF0aF8sIGZhbHNlKTtcbiAgICAgICAgdmFsaWRhdGVDYWxsYmFjaygnT25EaXNjb25uZWN0LnNldCcsIDIsIG9uQ29tcGxldGUsIHRydWUpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5yZXBvXy5vbkRpc2Nvbm5lY3RTZXQodGhpcy5wYXRoXywgdmFsdWUsIGRlZmVycmVkLndyYXBDYWxsYmFjayhvbkNvbXBsZXRlKSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xudWxsfSBwcmlvcml0eVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yKT19IG9uQ29tcGxldGVcbiAgICAgKiBAcmV0dXJuIHshZmlyZWJhc2UuUHJvbWlzZX1cbiAgICAgKi9cbiAgICBPbkRpc2Nvbm5lY3QucHJvdG90eXBlLnNldFdpdGhQcmlvcml0eSA9IGZ1bmN0aW9uICh2YWx1ZSwgcHJpb3JpdHksIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnT25EaXNjb25uZWN0LnNldFdpdGhQcmlvcml0eScsIDIsIDMsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnT25EaXNjb25uZWN0LnNldFdpdGhQcmlvcml0eScsIHRoaXMucGF0aF8pO1xuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnT25EaXNjb25uZWN0LnNldFdpdGhQcmlvcml0eScsIDEsIHZhbHVlLCB0aGlzLnBhdGhfLCBmYWxzZSk7XG4gICAgICAgIHZhbGlkYXRlUHJpb3JpdHkoJ09uRGlzY29ubmVjdC5zZXRXaXRoUHJpb3JpdHknLCAyLCBwcmlvcml0eSwgZmFsc2UpO1xuICAgICAgICB2YWxpZGF0ZUNhbGxiYWNrKCdPbkRpc2Nvbm5lY3Quc2V0V2l0aFByaW9yaXR5JywgMywgb25Db21wbGV0ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnJlcG9fLm9uRGlzY29ubmVjdFNldFdpdGhQcmlvcml0eSh0aGlzLnBhdGhfLCB2YWx1ZSwgcHJpb3JpdHksIGRlZmVycmVkLndyYXBDYWxsYmFjayhvbkNvbXBsZXRlKSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBvYmplY3RUb01lcmdlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IpPX0gb25Db21wbGV0ZVxuICAgICAqIEByZXR1cm4geyFmaXJlYmFzZS5Qcm9taXNlfVxuICAgICAqL1xuICAgIE9uRGlzY29ubmVjdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG9iamVjdFRvTWVyZ2UsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnT25EaXNjb25uZWN0LnVwZGF0ZScsIDEsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnT25EaXNjb25uZWN0LnVwZGF0ZScsIHRoaXMucGF0aF8pO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3RUb01lcmdlKSkge1xuICAgICAgICAgICAgdmFyIG5ld09iamVjdFRvTWVyZ2UgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0VG9NZXJnZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIG5ld09iamVjdFRvTWVyZ2VbJycgKyBpXSA9IG9iamVjdFRvTWVyZ2VbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmplY3RUb01lcmdlID0gbmV3T2JqZWN0VG9NZXJnZTtcbiAgICAgICAgICAgIHdhcm4oJ1Bhc3NpbmcgYW4gQXJyYXkgdG8gZmlyZWJhc2UuZGF0YWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlKCkgaXMgZGVwcmVjYXRlZC4gVXNlIHNldCgpIGlmIHlvdSB3YW50IHRvIG92ZXJ3cml0ZSB0aGUgJyArXG4gICAgICAgICAgICAgICAgJ2V4aXN0aW5nIGRhdGEsIG9yIGFuIE9iamVjdCB3aXRoIGludGVnZXIga2V5cyBpZiB5b3UgcmVhbGx5IGRvIHdhbnQgdG8gb25seSB1cGRhdGUgc29tZSBvZiB0aGUgY2hpbGRyZW4uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZU1lcmdlRGF0YUFyZygnT25EaXNjb25uZWN0LnVwZGF0ZScsIDEsIG9iamVjdFRvTWVyZ2UsIHRoaXMucGF0aF8sIGZhbHNlKTtcbiAgICAgICAgdmFsaWRhdGVDYWxsYmFjaygnT25EaXNjb25uZWN0LnVwZGF0ZScsIDIsIG9uQ29tcGxldGUsIHRydWUpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5yZXBvXy5vbkRpc2Nvbm5lY3RVcGRhdGUodGhpcy5wYXRoXywgb2JqZWN0VG9NZXJnZSwgZGVmZXJyZWQud3JhcENhbGxiYWNrKG9uQ29tcGxldGUpKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICByZXR1cm4gT25EaXNjb25uZWN0O1xufSgpKTtcbmV4cG9ydCB7IE9uRGlzY29ubmVjdCB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9hcGkvb25EaXNjb25uZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgUmVwb0luZm8gfSBmcm9tICcuLi9jb3JlL1JlcG9JbmZvJztcbmltcG9ydCB7IFBlcnNpc3RlbnRDb25uZWN0aW9uIH0gZnJvbSAnLi4vY29yZS9QZXJzaXN0ZW50Q29ubmVjdGlvbic7XG5pbXBvcnQgeyBSZXBvTWFuYWdlciB9IGZyb20gJy4uL2NvcmUvUmVwb01hbmFnZXInO1xuaW1wb3J0IHsgQ29ubmVjdGlvbiB9IGZyb20gJy4uL3JlYWx0aW1lL0Nvbm5lY3Rpb24nO1xuZXhwb3J0IHZhciBEYXRhQ29ubmVjdGlvbiA9IFBlcnNpc3RlbnRDb25uZWN0aW9uO1xuLyoqXG4gKiBAcGFyYW0geyFzdHJpbmd9IHBhdGhTdHJpbmdcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKil9IG9uQ29tcGxldGVcbiAqL1xuUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnNpbXBsZUxpc3RlbiA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBvbkNvbXBsZXRlKSB7XG4gICAgdGhpcy5zZW5kUmVxdWVzdCgncScsIHsgcDogcGF0aFN0cmluZyB9LCBvbkNvbXBsZXRlKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7Kn0gZGF0YVxuICogQHBhcmFtIHtmdW5jdGlvbigqKX0gb25FY2hvXG4gKi9cblBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5lY2hvID0gZnVuY3Rpb24gKGRhdGEsIG9uRWNobykge1xuICAgIHRoaXMuc2VuZFJlcXVlc3QoJ2VjaG8nLCB7IGQ6IGRhdGEgfSwgb25FY2hvKTtcbn07XG4vLyBSZWFsVGltZUNvbm5lY3Rpb24gcHJvcGVydGllcyB0aGF0IHdlIHVzZSBpbiB0ZXN0cy5cbmV4cG9ydCB2YXIgUmVhbFRpbWVDb25uZWN0aW9uID0gQ29ubmVjdGlvbjtcbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbigpOiBzdHJpbmd9IG5ld0hhc2hcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCl9XG4gKi9cbmV4cG9ydCB2YXIgaGlqYWNrSGFzaCA9IGZ1bmN0aW9uIChuZXdIYXNoKSB7XG4gICAgdmFyIG9sZFB1dCA9IFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5wdXQ7XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBkYXRhLCBvcHRfb25Db21wbGV0ZSwgb3B0X2hhc2gpIHtcbiAgICAgICAgaWYgKG9wdF9oYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdF9oYXNoID0gbmV3SGFzaCgpO1xuICAgICAgICB9XG4gICAgICAgIG9sZFB1dC5jYWxsKHRoaXMsIHBhdGhTdHJpbmcsIGRhdGEsIG9wdF9vbkNvbXBsZXRlLCBvcHRfaGFzaCk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUucHV0ID0gb2xkUHV0O1xuICAgIH07XG59O1xuLyoqXG4gKiBAdHlwZSB7ZnVuY3Rpb24obmV3OlJlcG9JbmZvLCAhc3RyaW5nLCBib29sZWFuLCAhc3RyaW5nLCBib29sZWFuKTogdW5kZWZpbmVkfVxuICovXG5leHBvcnQgdmFyIENvbm5lY3Rpb25UYXJnZXQgPSBSZXBvSW5mbztcbi8qKlxuICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gKiBAcmV0dXJuIHshc3RyaW5nfVxuICovXG5leHBvcnQgdmFyIHF1ZXJ5SWRlbnRpZmllciA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgIHJldHVybiBxdWVyeS5xdWVyeUlkZW50aWZpZXIoKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7IVF1ZXJ5fSBmaXJlYmFzZVJlZlxuICogQHJldHVybiB7IU9iamVjdH1cbiAqL1xuZXhwb3J0IHZhciBsaXN0ZW5zID0gZnVuY3Rpb24gKGZpcmViYXNlUmVmKSB7XG4gICAgcmV0dXJuIGZpcmViYXNlUmVmLnJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fLmxpc3RlbnNfO1xufTtcbi8qKlxuICogRm9yY2VzIHRoZSBSZXBvTWFuYWdlciB0byBjcmVhdGUgUmVwb3MgdGhhdCB1c2UgUmVhZG9ubHlSZXN0Q2xpZW50IGluc3RlYWQgb2YgUGVyc2lzdGVudENvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBmb3JjZVJlc3RDbGllbnRcbiAqL1xuZXhwb3J0IHZhciBmb3JjZVJlc3RDbGllbnQgPSBmdW5jdGlvbiAoZm9yY2VSZXN0Q2xpZW50KSB7XG4gICAgUmVwb01hbmFnZXIuZ2V0SW5zdGFuY2UoKS5mb3JjZVJlc3RDbGllbnQoZm9yY2VSZXN0Q2xpZW50KTtcbn07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2FwaS90ZXN0X2FjY2Vzcy5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGxvZywgd2FybiB9IGZyb20gJy4vdXRpbC91dGlsJztcbi8qKlxuICogQWJzdHJhY3Rpb24gYXJvdW5kIEZpcmViYXNlQXBwJ3MgdG9rZW4gZmV0Y2hpbmcgY2FwYWJpbGl0aWVzLlxuICovXG52YXIgQXV0aFRva2VuUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshRmlyZWJhc2VBcHB9IGFwcF9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBdXRoVG9rZW5Qcm92aWRlcihhcHBfKSB7XG4gICAgICAgIHRoaXMuYXBwXyA9IGFwcF87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VSZWZyZXNoXG4gICAgICogQHJldHVybiB7IVByb21pc2U8RmlyZWJhc2VBdXRoVG9rZW5EYXRhPn1cbiAgICAgKi9cbiAgICBBdXRoVG9rZW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0VG9rZW4gPSBmdW5jdGlvbiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcF9bJ0lOVEVSTkFMJ11bJ2dldFRva2VuJ10oZm9yY2VSZWZyZXNoKS50aGVuKG51bGwsIFxuICAgICAgICAvLyAuY2F0Y2hcbiAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBOZWVkIHRvIGZpZ3VyZSBvdXQgYWxsIHRoZSBjYXNlcyB0aGlzIGlzIHJhaXNlZCBhbmQgd2hldGhlclxuICAgICAgICAgICAgLy8gdGhpcyBtYWtlcyBzZW5zZS5cbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5jb2RlID09PSAnYXV0aC90b2tlbi1ub3QtaW5pdGlhbGl6ZWQnKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdHb3QgYXV0aC90b2tlbi1ub3QtaW5pdGlhbGl6ZWQgZXJyb3IuICBUcmVhdGluZyBhcyBudWxsIHRva2VuLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBdXRoVG9rZW5Qcm92aWRlci5wcm90b3R5cGUuYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAvLyBUT0RPOiBXZSBtaWdodCB3YW50IHRvIHdyYXAgdGhlIGxpc3RlbmVyIGFuZCBjYWxsIGl0IHdpdGggbm8gYXJncyB0b1xuICAgICAgICAvLyBhdm9pZCBhIGxlYWt5IGFic3RyYWN0aW9uLCBidXQgdGhhdCBtYWtlcyByZW1vdmluZyB0aGUgbGlzdGVuZXIgaGFyZGVyLlxuICAgICAgICB0aGlzLmFwcF9bJ0lOVEVSTkFMJ11bJ2FkZEF1dGhUb2tlbkxpc3RlbmVyJ10obGlzdGVuZXIpO1xuICAgIH07XG4gICAgQXV0aFRva2VuUHJvdmlkZXIucHJvdG90eXBlLnJlbW92ZVRva2VuQ2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5hcHBfWydJTlRFUk5BTCddWydyZW1vdmVBdXRoVG9rZW5MaXN0ZW5lciddKGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIEF1dGhUb2tlblByb3ZpZGVyLnByb3RvdHlwZS5ub3RpZnlGb3JJbnZhbGlkVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnUHJvdmlkZWQgYXV0aGVudGljYXRpb24gY3JlZGVudGlhbHMgZm9yIHRoZSBhcHAgbmFtZWQgXCInICtcbiAgICAgICAgICAgIHRoaXMuYXBwXy5uYW1lICtcbiAgICAgICAgICAgICdcIiBhcmUgaW52YWxpZC4gVGhpcyB1c3VhbGx5IGluZGljYXRlcyB5b3VyIGFwcCB3YXMgbm90ICcgK1xuICAgICAgICAgICAgJ2luaXRpYWxpemVkIGNvcnJlY3RseS4gJztcbiAgICAgICAgaWYgKCdjcmVkZW50aWFsJyBpbiB0aGlzLmFwcF8ub3B0aW9ucykge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XG4gICAgICAgICAgICAgICAgJ01ha2Ugc3VyZSB0aGUgXCJjcmVkZW50aWFsXCIgcHJvcGVydHkgcHJvdmlkZWQgdG8gaW5pdGlhbGl6ZUFwcCgpICcgK1xuICAgICAgICAgICAgICAgICAgICAnaXMgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhlIHNwZWNpZmllZCBcImRhdGFiYXNlVVJMXCIgYW5kIGlzIGZyb20gdGhlIGNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgICAgICdwcm9qZWN0Lic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ3NlcnZpY2VBY2NvdW50JyBpbiB0aGlzLmFwcF8ub3B0aW9ucykge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XG4gICAgICAgICAgICAgICAgJ01ha2Ugc3VyZSB0aGUgXCJzZXJ2aWNlQWNjb3VudFwiIHByb3BlcnR5IHByb3ZpZGVkIHRvIGluaXRpYWxpemVBcHAoKSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2lzIGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoZSBzcGVjaWZpZWQgXCJkYXRhYmFzZVVSTFwiIGFuZCBpcyBmcm9tIHRoZSBjb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICAgICAncHJvamVjdC4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XG4gICAgICAgICAgICAgICAgJ01ha2Ugc3VyZSB0aGUgXCJhcGlLZXlcIiBhbmQgXCJkYXRhYmFzZVVSTFwiIHByb3BlcnRpZXMgcHJvdmlkZWQgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICdpbml0aWFsaXplQXBwKCkgbWF0Y2ggdGhlIHZhbHVlcyBwcm92aWRlZCBmb3IgeW91ciBhcHAgYXQgJyArXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2NvbnNvbGUuZmlyZWJhc2UuZ29vZ2xlLmNvbS8uJztcbiAgICAgICAgfVxuICAgICAgICB3YXJuKGVycm9yTWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gQXV0aFRva2VuUHJvdmlkZXI7XG59KCkpO1xuZXhwb3J0IHsgQXV0aFRva2VuUHJvdmlkZXIgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9BdXRoVG9rZW5Qcm92aWRlci5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IEltbXV0YWJsZVRyZWUgfSBmcm9tICcuL3V0aWwvSW1tdXRhYmxlVHJlZSc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi91dGlsL1BhdGgnO1xuaW1wb3J0IHsgZm9yRWFjaCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IE5hbWVkTm9kZSB9IGZyb20gJy4vc25hcC9Ob2RlJztcbmltcG9ydCB7IFBSSU9SSVRZX0lOREVYIH0gZnJvbSAnLi9zbmFwL2luZGV4ZXMvUHJpb3JpdHlJbmRleCc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG4vKipcbiAqIFRoaXMgY2xhc3MgaG9sZHMgYSBjb2xsZWN0aW9uIG9mIHdyaXRlcyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIG5vZGVzIGluIHVuaXNvbi4gSXQgYWJzdHJhY3RzIGF3YXkgdGhlIGxvZ2ljIHdpdGhcbiAqIGRlYWxpbmcgd2l0aCBwcmlvcml0eSB3cml0ZXMgYW5kIG11bHRpcGxlIG5lc3RlZCB3cml0ZXMuIEF0IGFueSBnaXZlbiBwYXRoIHRoZXJlIGlzIG9ubHkgYWxsb3dlZCB0byBiZSBvbmUgd3JpdGVcbiAqIG1vZGlmeWluZyB0aGF0IHBhdGguIEFueSB3cml0ZSB0byBhbiBleGlzdGluZyBwYXRoIG9yIHNoYWRvd2luZyBhbiBleGlzdGluZyBwYXRoIHdpbGwgbW9kaWZ5IHRoYXQgZXhpc3Rpbmcgd3JpdGVcbiAqIHRvIHJlZmxlY3QgdGhlIHdyaXRlIGFkZGVkLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHshSW1tdXRhYmxlVHJlZS48IU5vZGU+fSB3cml0ZVRyZWVcbiAqL1xudmFyIENvbXBvdW5kV3JpdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcG91bmRXcml0ZSh3cml0ZVRyZWVfKSB7XG4gICAgICAgIHRoaXMud3JpdGVUcmVlXyA9IHdyaXRlVHJlZV87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHJldHVybiB7IUNvbXBvdW5kV3JpdGV9XG4gICAgICovXG4gICAgQ29tcG91bmRXcml0ZS5wcm90b3R5cGUuYWRkV3JpdGUgPSBmdW5jdGlvbiAocGF0aCwgbm9kZSkge1xuICAgICAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShuZXcgSW1tdXRhYmxlVHJlZShub2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcm9vdG1vc3QgPSB0aGlzLndyaXRlVHJlZV8uZmluZFJvb3RNb3N0VmFsdWVBbmRQYXRoKHBhdGgpO1xuICAgICAgICAgICAgaWYgKHJvb3Rtb3N0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdE1vc3RQYXRoID0gcm9vdG1vc3QucGF0aDtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSByb290bW9zdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXRpdmVQYXRoID0gUGF0aC5yZWxhdGl2ZVBhdGgocm9vdE1vc3RQYXRoLCBwYXRoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnVwZGF0ZUNoaWxkKHJlbGF0aXZlUGF0aCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKHRoaXMud3JpdGVUcmVlXy5zZXQocm9vdE1vc3RQYXRoLCB2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnRyZWUgPSBuZXcgSW1tdXRhYmxlVHJlZShub2RlKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3V3JpdGVUcmVlID0gdGhpcy53cml0ZVRyZWVfLnNldFRyZWUocGF0aCwgc3VidHJlZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKG5ld1dyaXRlVHJlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywgIU5vZGU+fSB1cGRhdGVzXG4gICAgICogQHJldHVybiB7IUNvbXBvdW5kV3JpdGV9XG4gICAgICovXG4gICAgQ29tcG91bmRXcml0ZS5wcm90b3R5cGUuYWRkV3JpdGVzID0gZnVuY3Rpb24gKHBhdGgsIHVwZGF0ZXMpIHtcbiAgICAgICAgdmFyIG5ld1dyaXRlID0gdGhpcztcbiAgICAgICAgZm9yRWFjaCh1cGRhdGVzLCBmdW5jdGlvbiAoY2hpbGRLZXksIG5vZGUpIHtcbiAgICAgICAgICAgIG5ld1dyaXRlID0gbmV3V3JpdGUuYWRkV3JpdGUocGF0aC5jaGlsZChjaGlsZEtleSksIG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld1dyaXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2lsbCByZW1vdmUgYSB3cml0ZSBhdCB0aGUgZ2l2ZW4gcGF0aCBhbmQgZGVlcGVyIHBhdGhzLiBUaGlzIHdpbGwgPGVtPm5vdDwvZW0+IG1vZGlmeSBhIHdyaXRlIGF0IGEgaGlnaGVyXG4gICAgICogbG9jYXRpb24sIHdoaWNoIG11c3QgYmUgcmVtb3ZlZCBieSBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGggdGhhdCBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aCBUaGUgcGF0aCBhdCB3aGljaCBhIHdyaXRlIGFuZCBhbGwgZGVlcGVyIHdyaXRlcyBzaG91bGQgYmUgcmVtb3ZlZFxuICAgICAqIEByZXR1cm4geyFDb21wb3VuZFdyaXRlfSBUaGUgbmV3IENvbXBvdW5kV3JpdGUgd2l0aCB0aGUgcmVtb3ZlZCBwYXRoXG4gICAgICovXG4gICAgQ29tcG91bmRXcml0ZS5wcm90b3R5cGUucmVtb3ZlV3JpdGUgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBDb21wb3VuZFdyaXRlLkVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5ld1dyaXRlVHJlZSA9IHRoaXMud3JpdGVUcmVlXy5zZXRUcmVlKHBhdGgsIEltbXV0YWJsZVRyZWUuRW1wdHkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKG5ld1dyaXRlVHJlZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIENvbXBvdW5kV3JpdGUgd2lsbCBmdWxseSBvdmVyd3JpdGUgYSBub2RlIGF0IGEgZ2l2ZW4gbG9jYXRpb24gYW5kIGNhbiB0aGVyZWZvcmUgYmVcbiAgICAgKiBjb25zaWRlcmVkIFwiY29tcGxldGVcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGggVGhlIHBhdGggdG8gY2hlY2sgZm9yXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGVyZSBpcyBhIGNvbXBsZXRlIHdyaXRlIGF0IHRoYXQgcGF0aFxuICAgICAqL1xuICAgIENvbXBvdW5kV3JpdGUucHJvdG90eXBlLmhhc0NvbXBsZXRlV3JpdGUgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wbGV0ZU5vZGUocGF0aCkgIT0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBub2RlIGZvciBhIHBhdGggaWYgYW5kIG9ubHkgaWYgdGhlIG5vZGUgaXMgYSBcImNvbXBsZXRlXCIgb3ZlcndyaXRlIGF0IHRoYXQgcGF0aC4gVGhpcyB3aWxsIG5vdCBhZ2dyZWdhdGVcbiAgICAgKiB3cml0ZXMgZnJvbSBkZWVwZXIgcGF0aHMsIGJ1dCB3aWxsIHJldHVybiBjaGlsZCBub2RlcyBmcm9tIGEgbW9yZSBzaGFsbG93IHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoIFRoZSBwYXRoIHRvIGdldCBhIGNvbXBsZXRlIHdyaXRlXG4gICAgICogQHJldHVybiB7P05vZGV9IFRoZSBub2RlIGlmIGNvbXBsZXRlIGF0IHRoYXQgcGF0aCwgb3IgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgQ29tcG91bmRXcml0ZS5wcm90b3R5cGUuZ2V0Q29tcGxldGVOb2RlID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHJvb3Rtb3N0ID0gdGhpcy53cml0ZVRyZWVfLmZpbmRSb290TW9zdFZhbHVlQW5kUGF0aChwYXRoKTtcbiAgICAgICAgaWYgKHJvb3Rtb3N0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRlVHJlZV9cbiAgICAgICAgICAgICAgICAuZ2V0KHJvb3Rtb3N0LnBhdGgpXG4gICAgICAgICAgICAgICAgLmdldENoaWxkKFBhdGgucmVsYXRpdmVQYXRoKHJvb3Rtb3N0LnBhdGgsIHBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBjaGlsZHJlbiB0aGF0IGFyZSBndWFyYW50ZWVkIHRvIGJlIGEgY29tcGxldGUgb3ZlcndyaXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IUFycmF5LjxOYW1lZE5vZGU+fSBBIGxpc3Qgb2YgYWxsIGNvbXBsZXRlIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIENvbXBvdW5kV3JpdGUucHJvdG90eXBlLmdldENvbXBsZXRlQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMud3JpdGVUcmVlXy52YWx1ZTtcbiAgICAgICAgaWYgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgaXQncyBhIGxlYWYgbm9kZSwgaXQgaGFzIG5vIGNoaWxkcmVuOyBzbyBub3RoaW5nIHRvIGRvLlxuICAgICAgICAgICAgaWYgKCFub2RlLmlzTGVhZk5vZGUoKSkge1xuICAgICAgICAgICAgICAgIG5vZGUuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCBmdW5jdGlvbiAoY2hpbGROYW1lLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChuZXcgTmFtZWROb2RlKGNoaWxkTmFtZSwgY2hpbGROb2RlKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlVHJlZV8uY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbChmdW5jdGlvbiAoY2hpbGROYW1lLCBjaGlsZFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRUcmVlLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChuZXcgTmFtZWROb2RlKGNoaWxkTmFtZSwgY2hpbGRUcmVlLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEByZXR1cm4geyFDb21wb3VuZFdyaXRlfVxuICAgICAqL1xuICAgIENvbXBvdW5kV3JpdGUucHJvdG90eXBlLmNoaWxkQ29tcG91bmRXcml0ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2hhZG93aW5nTm9kZSA9IHRoaXMuZ2V0Q29tcGxldGVOb2RlKHBhdGgpO1xuICAgICAgICAgICAgaWYgKHNoYWRvd2luZ05vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShuZXcgSW1tdXRhYmxlVHJlZShzaGFkb3dpbmdOb2RlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUodGhpcy53cml0ZVRyZWVfLnN1YnRyZWUocGF0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBDb21wb3VuZFdyaXRlIGlzIGVtcHR5IGFuZCB0aGVyZWZvcmUgZG9lcyBub3QgbW9kaWZ5IGFueSBub2Rlcy5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgQ29tcG91bmRXcml0ZSBpcyBlbXB0eVxuICAgICAqL1xuICAgIENvbXBvdW5kV3JpdGUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlVHJlZV8uaXNFbXB0eSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGlzIENvbXBvdW5kV3JpdGUgdG8gYSBub2RlLiBUaGUgbm9kZSBpcyByZXR1cm5lZCB3aXRoIGFsbCB3cml0ZXMgZnJvbSB0aGlzIENvbXBvdW5kV3JpdGUgYXBwbGllZCB0byB0aGVcbiAgICAgKiBub2RlXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZSBUaGUgbm9kZSB0byBhcHBseSB0aGlzIENvbXBvdW5kV3JpdGUgdG9cbiAgICAgKiBAcmV0dXJuIHshTm9kZX0gVGhlIG5vZGUgd2l0aCBhbGwgd3JpdGVzIGFwcGxpZWRcbiAgICAgKi9cbiAgICBDb21wb3VuZFdyaXRlLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBDb21wb3VuZFdyaXRlLmFwcGx5U3VidHJlZVdyaXRlXyhQYXRoLkVtcHR5LCB0aGlzLndyaXRlVHJlZV8sIG5vZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFDb21wb3VuZFdyaXRlfVxuICAgICAqL1xuICAgIENvbXBvdW5kV3JpdGUuRW1wdHkgPSBuZXcgQ29tcG91bmRXcml0ZShuZXcgSW1tdXRhYmxlVHJlZShudWxsKSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcmVsYXRpdmVQYXRoXG4gICAgICogQHBhcmFtIHshSW1tdXRhYmxlVHJlZS48IU5vZGU+fSB3cml0ZVRyZWVcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHJldHVybiB7IU5vZGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDb21wb3VuZFdyaXRlLmFwcGx5U3VidHJlZVdyaXRlXyA9IGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIHdyaXRlVHJlZSwgbm9kZSkge1xuICAgICAgICBpZiAod3JpdGVUcmVlLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHRoZXJlIGEgd3JpdGUgaXMgYWx3YXlzIGEgbGVhZiwgd2UncmUgZG9uZSBoZXJlXG4gICAgICAgICAgICByZXR1cm4gbm9kZS51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGgsIHdyaXRlVHJlZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdHlXcml0ZV8xID0gbnVsbDtcbiAgICAgICAgICAgIHdyaXRlVHJlZS5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uIChjaGlsZEtleSwgY2hpbGRUcmVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkS2V5ID09PSAnLnByaW9yaXR5Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwcmlvcml0aWVzIGF0IHRoZSBlbmQgc28gd2UgZG9uJ3QgdXBkYXRlIHByaW9yaXRpZXMgZm9yIGVpdGhlciBlbXB0eSBub2RlcyBvciBmb3JnZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYXBwbHkgcHJpb3JpdGllcyB0byBlbXB0eSBub2RlcyB0aGF0IGFyZSBsYXRlciBmaWxsZWRcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGNoaWxkVHJlZS52YWx1ZSAhPT0gbnVsbCwgJ1ByaW9yaXR5IHdyaXRlcyBtdXN0IGFsd2F5cyBiZSBsZWFmIG5vZGVzJyk7XG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5V3JpdGVfMSA9IGNoaWxkVHJlZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBDb21wb3VuZFdyaXRlLmFwcGx5U3VidHJlZVdyaXRlXyhyZWxhdGl2ZVBhdGguY2hpbGQoY2hpbGRLZXkpLCBjaGlsZFRyZWUsIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcHJpb3JpdHkgd3JpdGUsIHdlIG9ubHkgYXBwbHkgaXQgaWYgdGhlIG5vZGUgaXMgbm90IGVtcHR5XG4gICAgICAgICAgICBpZiAoIW5vZGUuZ2V0Q2hpbGQocmVsYXRpdmVQYXRoKS5pc0VtcHR5KCkgJiYgcHJpb3JpdHlXcml0ZV8xICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUudXBkYXRlQ2hpbGQocmVsYXRpdmVQYXRoLmNoaWxkKCcucHJpb3JpdHknKSwgcHJpb3JpdHlXcml0ZV8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcG91bmRXcml0ZTtcbn0oKSk7XG5leHBvcnQgeyBDb21wb3VuZFdyaXRlIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvQ29tcG91bmRXcml0ZS5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgbG9nV3JhcHBlciwgd2FybiB9IGZyb20gJy4vdXRpbC91dGlsJztcbmltcG9ydCB7IGpzb25FdmFsIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgc2FmZUdldCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IHF1ZXJ5c3RyaW5nIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgU2VydmVyQWN0aW9ucyB9IGZyb20gJy4vU2VydmVyQWN0aW9ucyc7XG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIFNlcnZlckFjdGlvbnMgdGhhdCBjb21tdW5pY2F0ZXMgd2l0aCB0aGUgc2VydmVyIHZpYSBSRVNUIHJlcXVlc3RzLlxuICogVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGZvciBjb21wYXRpYmlsaXR5IHdpdGggY3Jhd2xlcnMsIHdoZXJlIHdlIGRvbid0IHdhbnQgdG8gc3BpbiB1cCBhIGZ1bGxcbiAqIHBlcnNpc3RlbnQgY29ubmVjdGlvbiAodXNpbmcgV2ViU29ja2V0cyBvciBsb25nLXBvbGxpbmcpXG4gKi9cbnZhciBSZWFkb25seVJlc3RDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlYWRvbmx5UmVzdENsaWVudCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFSZXBvSW5mb30gcmVwb0luZm9fIERhdGEgYWJvdXQgdGhlIG5hbWVzcGFjZSB3ZSBhcmUgY29ubmVjdGluZyB0b1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nLCAqLCBib29sZWFuLCA/bnVtYmVyKX0gb25EYXRhVXBkYXRlXyBBIGNhbGxiYWNrIGZvciBuZXcgZGF0YSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgKiBAcGFyYW0ge0F1dGhUb2tlblByb3ZpZGVyfSBhdXRoVG9rZW5Qcm92aWRlcl9cbiAgICAgKiBAaW1wbGVtZW50cyB7U2VydmVyQWN0aW9uc31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZWFkb25seVJlc3RDbGllbnQocmVwb0luZm9fLCBvbkRhdGFVcGRhdGVfLCBhdXRoVG9rZW5Qcm92aWRlcl8pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xuICAgICAgICBfdGhpcy5vbkRhdGFVcGRhdGVfID0gb25EYXRhVXBkYXRlXztcbiAgICAgICAgX3RoaXMuYXV0aFRva2VuUHJvdmlkZXJfID0gYXV0aFRva2VuUHJvdmlkZXJfO1xuICAgICAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKC4uLlsqXSl9ICovXG4gICAgICAgIF90aGlzLmxvZ18gPSBsb2dXcmFwcGVyKCdwOnJlc3Q6Jyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBkb24ndCBhY3R1YWxseSBuZWVkIHRvIHRyYWNrIGxpc3RlbnMsIGV4Y2VwdCB0byBwcmV2ZW50IHVzIGNhbGxpbmcgYW4gb25Db21wbGV0ZSBmb3IgYSBsaXN0ZW5cbiAgICAgICAgICogdGhhdCdzIGJlZW4gcmVtb3ZlZC4gOi0vXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlIHshT2JqZWN0LjxzdHJpbmcsICFPYmplY3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubGlzdGVuc18gPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZWFkb25seVJlc3RDbGllbnQucHJvdG90eXBlLnJlcG9ydFN0YXRzID0gZnVuY3Rpb24gKHN0YXRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgICAqIEBwYXJhbSB7P251bWJlcj19IHRhZ1xuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJlYWRvbmx5UmVzdENsaWVudC5nZXRMaXN0ZW5JZF8gPSBmdW5jdGlvbiAocXVlcnksIHRhZykge1xuICAgICAgICBpZiAodGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAndGFnJCcgKyB0YWc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnQocXVlcnkuZ2V0UXVlcnlQYXJhbXMoKS5pc0RlZmF1bHQoKSwgXCJzaG91bGQgaGF2ZSBhIHRhZyBpZiBpdCdzIG5vdCBhIGRlZmF1bHQgcXVlcnkuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5LnBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgUmVhZG9ubHlSZXN0Q2xpZW50LnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAocXVlcnksIGN1cnJlbnRIYXNoRm4sIHRhZywgb25Db21wbGV0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcGF0aFN0cmluZyA9IHF1ZXJ5LnBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5sb2dfKCdMaXN0ZW4gY2FsbGVkIGZvciAnICsgcGF0aFN0cmluZyArICcgJyArIHF1ZXJ5LnF1ZXJ5SWRlbnRpZmllcigpKTtcbiAgICAgICAgLy8gTWFyayB0aGlzIGxpc3RlbmVyIHNvIHdlIGNhbiB0ZWxsIGlmIGl0J3MgcmVtb3ZlZC5cbiAgICAgICAgdmFyIGxpc3RlbklkID0gUmVhZG9ubHlSZXN0Q2xpZW50LmdldExpc3RlbklkXyhxdWVyeSwgdGFnKTtcbiAgICAgICAgdmFyIHRoaXNMaXN0ZW4gPSB7fTtcbiAgICAgICAgdGhpcy5saXN0ZW5zX1tsaXN0ZW5JZF0gPSB0aGlzTGlzdGVuO1xuICAgICAgICB2YXIgcXVlcnlTdHJpbmdQYXJhbWF0ZXJzID0gcXVlcnlcbiAgICAgICAgICAgIC5nZXRRdWVyeVBhcmFtcygpXG4gICAgICAgICAgICAudG9SZXN0UXVlcnlTdHJpbmdQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHRoaXMucmVzdFJlcXVlc3RfKHBhdGhTdHJpbmcgKyAnLmpzb24nLCBxdWVyeVN0cmluZ1BhcmFtYXRlcnMsIGZ1bmN0aW9uIChlcnJvciwgcmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChlcnJvciA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25EYXRhVXBkYXRlXyhwYXRoU3RyaW5nLCBkYXRhLCAvKmlzTWVyZ2U9Ki8gZmFsc2UsIHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2FmZUdldChfdGhpcy5saXN0ZW5zXywgbGlzdGVuSWQpID09PSB0aGlzTGlzdGVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1c18xO1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzXzEgPSAnb2snO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvciA9PSA0MDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzXzEgPSAncGVybWlzc2lvbl9kZW5pZWQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzXzEgPSAncmVzdF9lcnJvcjonICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uQ29tcGxldGUoc3RhdHVzXzEsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIFJlYWRvbmx5UmVzdENsaWVudC5wcm90b3R5cGUudW5saXN0ZW4gPSBmdW5jdGlvbiAocXVlcnksIHRhZykge1xuICAgICAgICB2YXIgbGlzdGVuSWQgPSBSZWFkb25seVJlc3RDbGllbnQuZ2V0TGlzdGVuSWRfKHF1ZXJ5LCB0YWcpO1xuICAgICAgICBkZWxldGUgdGhpcy5saXN0ZW5zX1tsaXN0ZW5JZF07XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBSZWFkb25seVJlc3RDbGllbnQucHJvdG90eXBlLnJlZnJlc2hBdXRoVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgLy8gbm8tb3Agc2luY2Ugd2UganVzdCBhbHdheXMgY2FsbCBnZXRUb2tlbi5cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgUkVTVCByZXF1ZXN0IHRvIHRoZSBnaXZlbiBwYXRoLCB3aXRoIHRoZSBwcm92aWRlZCBxdWVyeSBzdHJpbmcgcGFyYW1ldGVycyxcbiAgICAgKiBhbmQgYW55IGF1dGggY3JlZGVudGlhbHMgd2UgaGF2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gcGF0aFN0cmluZ1xuICAgICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCAqPn0gcXVlcnlTdHJpbmdQYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb24oP251bWJlciwgKj0pfSBjYWxsYmFja1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmVhZG9ubHlSZXN0Q2xpZW50LnByb3RvdHlwZS5yZXN0UmVxdWVzdF8gPSBmdW5jdGlvbiAocGF0aFN0cmluZywgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAocXVlcnlTdHJpbmdQYXJhbWV0ZXJzID09PSB2b2lkIDApIHsgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzID0ge307IH1cbiAgICAgICAgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzWydmb3JtYXQnXSA9ICdleHBvcnQnO1xuICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyX1xuICAgICAgICAgICAgLmdldFRva2VuKC8qZm9yY2VSZWZyZXNoPSovIGZhbHNlKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGF1dGhUb2tlbkRhdGEpIHtcbiAgICAgICAgICAgIHZhciBhdXRoVG9rZW4gPSBhdXRoVG9rZW5EYXRhICYmIGF1dGhUb2tlbkRhdGEuYWNjZXNzVG9rZW47XG4gICAgICAgICAgICBpZiAoYXV0aFRva2VuKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzWydhdXRoJ10gPSBhdXRoVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdXJsID0gKF90aGlzLnJlcG9JbmZvXy5zZWN1cmUgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nKSArXG4gICAgICAgICAgICAgICAgX3RoaXMucmVwb0luZm9fLmhvc3QgK1xuICAgICAgICAgICAgICAgIHBhdGhTdHJpbmcgK1xuICAgICAgICAgICAgICAgICc/JyArXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmcocXVlcnlTdHJpbmdQYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIF90aGlzLmxvZ18oJ1NlbmRpbmcgUkVTVCByZXF1ZXN0IGZvciAnICsgdXJsKTtcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ18oJ1JFU1QgUmVzcG9uc2UgZm9yICcgKyB1cmwgKyAnIHJlY2VpdmVkLiBzdGF0dXM6JywgeGhyLnN0YXR1cywgJ3Jlc3BvbnNlOicsIHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0ganNvbkV2YWwoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ZhaWxlZCB0byBwYXJzZSBKU09OIHJlc3BvbnNlIGZvciAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDQwMSBhbmQgNDA0IGFyZSBleHBlY3RlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzICE9PSA0MDEgJiYgeGhyLnN0YXR1cyAhPT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybignR290IHVuc3VjY2Vzc2Z1bCBSRVNUIHJlc3BvbnNlIGZvciAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBTdGF0dXM6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHhoci5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgLyphc3luY2hyb25vdXM9Ki8gdHJ1ZSk7XG4gICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSZWFkb25seVJlc3RDbGllbnQ7XG59KFNlcnZlckFjdGlvbnMpKTtcbmV4cG9ydCB7IFJlYWRvbmx5UmVzdENsaWVudCB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL1JlYWRvbmx5UmVzdENsaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IFJlZmVyZW5jZSB9IGZyb20gJy4uL2FwaS9SZWZlcmVuY2UnO1xuaW1wb3J0IHsgRGF0YVNuYXBzaG90IH0gZnJvbSAnLi4vYXBpL0RhdGFTbmFwc2hvdCc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi91dGlsL1BhdGgnO1xuaW1wb3J0IHsgVHJlZSB9IGZyb20gJy4vdXRpbC9UcmVlJztcbmltcG9ydCB7IFBSSU9SSVRZX0lOREVYIH0gZnJvbSAnLi9zbmFwL2luZGV4ZXMvUHJpb3JpdHlJbmRleCc7XG5pbXBvcnQgeyBMVUlER2VuZXJhdG9yLCB3YXJuLCBleGNlcHRpb25HdWFyZCB9IGZyb20gJy4vdXRpbC91dGlsJztcbmltcG9ydCB7IHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QgfSBmcm9tICcuL3V0aWwvU2VydmVyVmFsdWVzJztcbmltcG9ydCB7IGlzVmFsaWRQcmlvcml0eSwgdmFsaWRhdGVGaXJlYmFzZURhdGEgfSBmcm9tICcuL3V0aWwvdmFsaWRhdGlvbic7XG5pbXBvcnQgeyBjb250YWlucywgc2FmZUdldCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IG5vZGVGcm9tSlNPTiB9IGZyb20gJy4vc25hcC9ub2RlRnJvbUpTT04nO1xuaW1wb3J0IHsgQ2hpbGRyZW5Ob2RlIH0gZnJvbSAnLi9zbmFwL0NoaWxkcmVuTm9kZSc7XG5pbXBvcnQgeyBSZXBvIH0gZnJvbSAnLi9SZXBvJztcbi8vIFRPRE86IFRoaXMgaXMgcHJldHR5IG1lc3N5LiAgSWRlYWxseSwgYSBsb3Qgb2YgdGhpcyB3b3VsZCBtb3ZlIGludG8gRmlyZWJhc2VEYXRhLCBvciBhIHRyYW5zYWN0aW9uLXNwZWNpZmljXG4vLyBjb21wb25lbnQgdXNlZCBieSBGaXJlYmFzZURhdGEsIGJ1dCBpdCBoYXMgdGllcyB0byB1c2VyIGNhbGxiYWNrcyAodHJhbnNhY3Rpb24gdXBkYXRlIGFuZCBvbkNvbXBsZXRlKSBhcyB3ZWxsXG4vLyBhcyB0aGUgcmVhbHRpbWUgY29ubmVjdGlvbiAodG8gc2VuZCB0cmFuc2FjdGlvbnMgdG8gdGhlIHNlcnZlcikuICBTbyB0aGF0IGFsbCBuZWVkcyB0byBiZSBkZWNvdXBsZWQgZmlyc3QuXG4vLyBGb3Igbm93IGl0J3MgcGFydCBvZiBSZXBvLCBidXQgaW4gaXRzIG93biBmaWxlLlxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIFRyYW5zYWN0aW9uU3RhdHVzO1xuKGZ1bmN0aW9uIChUcmFuc2FjdGlvblN0YXR1cykge1xuICAgIC8vIFdlJ3ZlIHJ1biB0aGUgdHJhbnNhY3Rpb24gYW5kIHVwZGF0ZWQgdHJhbnNhY3Rpb25SZXN1bHREYXRhXyB3aXRoIHRoZSByZXN1bHQsIGJ1dCBpdCBpc24ndCBjdXJyZW50bHkgc2VudCB0byB0aGVcbiAgICAvLyBzZXJ2ZXIuIEEgdHJhbnNhY3Rpb24gd2lsbCBnbyBmcm9tIFJVTiAtPiBTRU5UIC0+IFJVTiBpZiBpdCBjb21lcyBiYWNrIGZyb20gdGhlIHNlcnZlciBhcyByZWplY3RlZCBkdWUgdG9cbiAgICAvLyBtaXNtYXRjaGVkIGhhc2guXG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJSVU5cIl0gPSAwXSA9IFwiUlVOXCI7XG4gICAgLy8gV2UndmUgcnVuIHRoZSB0cmFuc2FjdGlvbiBhbmQgc2VudCBpdCB0byB0aGUgc2VydmVyIGFuZCBpdCdzIGN1cnJlbnRseSBvdXRzdGFuZGluZyAoaGFzbid0IGNvbWUgYmFjayBhcyBhY2NlcHRlZFxuICAgIC8vIG9yIHJlamVjdGVkIHlldCkuXG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJTRU5UXCJdID0gMV0gPSBcIlNFTlRcIjtcbiAgICAvLyBUZW1wb3Jhcnkgc3RhdGUgdXNlZCB0byBtYXJrIGNvbXBsZXRlZCB0cmFuc2FjdGlvbnMgKHdoZXRoZXIgc3VjY2Vzc2Z1bCBvciBhYm9ydGVkKS4gIFRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlXG4gICAgLy8gcmVtb3ZlZCB3aGVuIHdlIGdldCBhIGNoYW5jZSB0byBwcnVuZSBjb21wbGV0ZWQgb25lcy5cbiAgICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIkNPTVBMRVRFRFwiXSA9IDJdID0gXCJDT01QTEVURURcIjtcbiAgICAvLyBVc2VkIHdoZW4gYW4gYWxyZWFkeS1zZW50IHRyYW5zYWN0aW9uIG5lZWRzIHRvIGJlIGFib3J0ZWQgKGUuZy4gZHVlIHRvIGEgY29uZmxpY3Rpbmcgc2V0KCkgY2FsbCB0aGF0IHdhcyBtYWRlKS5cbiAgICAvLyBJZiBpdCBjb21lcyBiYWNrIGFzIHVuc3VjY2Vzc2Z1bCwgd2UnbGwgYWJvcnQgaXQuXG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJTRU5UX05FRURTX0FCT1JUXCJdID0gM10gPSBcIlNFTlRfTkVFRFNfQUJPUlRcIjtcbiAgICAvLyBUZW1wb3Jhcnkgc3RhdGUgdXNlZCB0byBtYXJrIHRyYW5zYWN0aW9ucyB0aGF0IG5lZWQgdG8gYmUgYWJvcnRlZC5cbiAgICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIk5FRURTX0FCT1JUXCJdID0gNF0gPSBcIk5FRURTX0FCT1JUXCI7XG59KShUcmFuc2FjdGlvblN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzIHx8IChUcmFuc2FjdGlvblN0YXR1cyA9IHt9KSk7XG4vKipcbiAqIElmIGEgdHJhbnNhY3Rpb24gZG9lcyBub3Qgc3VjY2VlZCBhZnRlciAyNSByZXRyaWVzLCB3ZSBhYm9ydCBpdC4gIEFtb25nIG90aGVyIHRoaW5ncyB0aGlzIGVuc3VyZSB0aGF0IGlmIHRoZXJlJ3NcbiAqIGV2ZXIgYSBidWcgY2F1c2luZyBhIG1pc21hdGNoIGJldHdlZW4gY2xpZW50IC8gc2VydmVyIGhhc2hlcyBmb3Igc29tZSBkYXRhLCB3ZSB3b24ndCByZXRyeSBpbmRlZmluaXRlbHkuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKiBAcHJpdmF0ZVxuICovXG5SZXBvLk1BWF9UUkFOU0FDVElPTl9SRVRSSUVTXyA9IDI1O1xuLyoqXG4gKiBTZXR1cCB0aGUgdHJhbnNhY3Rpb24gZGF0YSBzdHJ1Y3R1cmVzXG4gKiBAcHJpdmF0ZVxuICovXG5SZXBvLnByb3RvdHlwZS50cmFuc2FjdGlvbnNfaW5pdF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogU3RvcmVzIHF1ZXVlcyBvZiBvdXRzdGFuZGluZyB0cmFuc2FjdGlvbnMgZm9yIEZpcmViYXNlIGxvY2F0aW9ucy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHshVHJlZS48QXJyYXkuPCFUcmFuc2FjdGlvbj4+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50cmFuc2FjdGlvblF1ZXVlVHJlZV8gPSBuZXcgVHJlZSgpO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0cmFuc2FjdGlvbiwgYWRkcyBpdCB0byB0aGUgdHJhbnNhY3Rpb25zIHdlJ3JlIHRyYWNraW5nLCBhbmQgc2VuZHMgaXQgdG8gdGhlIHNlcnZlciBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoIFBhdGggYXQgd2hpY2ggdG8gZG8gdHJhbnNhY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCopOip9IHRyYW5zYWN0aW9uVXBkYXRlIFVwZGF0ZSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKD9FcnJvciwgYm9vbGVhbiwgP0RhdGFTbmFwc2hvdCl9IG9uQ29tcGxldGUgQ29tcGxldGlvbiBjYWxsYmFjay5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXBwbHlMb2NhbGx5IFdoZXRoZXIgb3Igbm90IHRvIG1ha2UgaW50ZXJtZWRpYXRlIHJlc3VsdHMgdmlzaWJsZVxuICovXG5SZXBvLnByb3RvdHlwZS5zdGFydFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHBhdGgsIHRyYW5zYWN0aW9uVXBkYXRlLCBvbkNvbXBsZXRlLCBhcHBseUxvY2FsbHkpIHtcbiAgICB0aGlzLmxvZ18oJ3RyYW5zYWN0aW9uIG9uICcgKyBwYXRoKTtcbiAgICAvLyBBZGQgYSB3YXRjaCB0byBtYWtlIHN1cmUgd2UgZ2V0IHNlcnZlciB1cGRhdGVzLlxuICAgIHZhciB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHZhciB3YXRjaFJlZiA9IG5ldyBSZWZlcmVuY2UodGhpcywgcGF0aCk7XG4gICAgd2F0Y2hSZWYub24oJ3ZhbHVlJywgdmFsdWVDYWxsYmFjayk7XG4gICAgdmFyIHVud2F0Y2hlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2F0Y2hSZWYub2ZmKCd2YWx1ZScsIHZhbHVlQ2FsbGJhY2spO1xuICAgIH07XG4gICAgLy8gSW5pdGlhbGl6ZSB0cmFuc2FjdGlvbi5cbiAgICB2YXIgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIHVwZGF0ZTogdHJhbnNhY3Rpb25VcGRhdGUsXG4gICAgICAgIG9uQ29tcGxldGU6IG9uQ29tcGxldGUsXG4gICAgICAgIC8vIE9uZSBvZiBUcmFuc2FjdGlvblN0YXR1cyBlbnVtcy5cbiAgICAgICAgc3RhdHVzOiBudWxsLFxuICAgICAgICAvLyBVc2VkIHdoZW4gY29tYmluaW5nIHRyYW5zYWN0aW9ucyBhdCBkaWZmZXJlbnQgbG9jYXRpb25zIHRvIGZpZ3VyZSBvdXQgd2hpY2ggb25lIGdvZXMgZmlyc3QuXG4gICAgICAgIG9yZGVyOiBMVUlER2VuZXJhdG9yKCksXG4gICAgICAgIC8vIFdoZXRoZXIgdG8gcmFpc2UgbG9jYWwgZXZlbnRzIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAgICBhcHBseUxvY2FsbHk6IGFwcGx5TG9jYWxseSxcbiAgICAgICAgLy8gQ291bnQgb2YgaG93IG1hbnkgdGltZXMgd2UndmUgcmV0cmllZCB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgIHJldHJ5Q291bnQ6IDAsXG4gICAgICAgIC8vIEZ1bmN0aW9uIHRvIGNhbGwgdG8gY2xlYW4gdXAgb3VyIC5vbigpIGxpc3RlbmVyLlxuICAgICAgICB1bndhdGNoZXI6IHVud2F0Y2hlcixcbiAgICAgICAgLy8gU3RvcmVzIHdoeSBhIHRyYW5zYWN0aW9uIHdhcyBhYm9ydGVkLlxuICAgICAgICBhYm9ydFJlYXNvbjogbnVsbCxcbiAgICAgICAgY3VycmVudFdyaXRlSWQ6IG51bGwsXG4gICAgICAgIGN1cnJlbnRJbnB1dFNuYXBzaG90OiBudWxsLFxuICAgICAgICBjdXJyZW50T3V0cHV0U25hcHNob3RSYXc6IG51bGwsXG4gICAgICAgIGN1cnJlbnRPdXRwdXRTbmFwc2hvdFJlc29sdmVkOiBudWxsXG4gICAgfTtcbiAgICAvLyBSdW4gdHJhbnNhY3Rpb24gaW5pdGlhbGx5LlxuICAgIHZhciBjdXJyZW50U3RhdGUgPSB0aGlzLmdldExhdGVzdFN0YXRlXyhwYXRoKTtcbiAgICB0cmFuc2FjdGlvbi5jdXJyZW50SW5wdXRTbmFwc2hvdCA9IGN1cnJlbnRTdGF0ZTtcbiAgICB2YXIgbmV3VmFsID0gdHJhbnNhY3Rpb24udXBkYXRlKGN1cnJlbnRTdGF0ZS52YWwoKSk7XG4gICAgaWYgKG5ld1ZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEFib3J0IHRyYW5zYWN0aW9uLlxuICAgICAgICB0cmFuc2FjdGlvbi51bndhdGNoZXIoKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmF3ID0gbnVsbDtcbiAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQgPSBudWxsO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24ub25Db21wbGV0ZSkge1xuICAgICAgICAgICAgLy8gV2UganVzdCBzZXQgdGhlIGlucHV0IHNuYXBzaG90LCBzbyB0aGlzIGNhc3Qgc2hvdWxkIGJlIHNhZmVcbiAgICAgICAgICAgIHZhciBzbmFwc2hvdCA9IG5ldyBEYXRhU25hcHNob3QodHJhbnNhY3Rpb24uY3VycmVudElucHV0U25hcHNob3QsIG5ldyBSZWZlcmVuY2UodGhpcywgdHJhbnNhY3Rpb24ucGF0aCksIFBSSU9SSVRZX0lOREVYKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uQ29tcGxldGUobnVsbCwgZmFsc2UsIHNuYXBzaG90KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGEoJ3RyYW5zYWN0aW9uIGZhaWxlZDogRGF0YSByZXR1cm5lZCAnLCBuZXdWYWwsIHRyYW5zYWN0aW9uLnBhdGgpO1xuICAgICAgICAvLyBNYXJrIGFzIHJ1biBhbmQgYWRkIHRvIG91ciBxdWV1ZS5cbiAgICAgICAgdHJhbnNhY3Rpb24uc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuUlVOO1xuICAgICAgICB2YXIgcXVldWVOb2RlID0gdGhpcy50cmFuc2FjdGlvblF1ZXVlVHJlZV8uc3ViVHJlZShwYXRoKTtcbiAgICAgICAgdmFyIG5vZGVRdWV1ZSA9IHF1ZXVlTm9kZS5nZXRWYWx1ZSgpIHx8IFtdO1xuICAgICAgICBub2RlUXVldWUucHVzaCh0cmFuc2FjdGlvbik7XG4gICAgICAgIHF1ZXVlTm9kZS5zZXRWYWx1ZShub2RlUXVldWUpO1xuICAgICAgICAvLyBVcGRhdGUgdmlzaWJsZURhdGEgYW5kIHJhaXNlIGV2ZW50c1xuICAgICAgICAvLyBOb3RlOiBXZSBpbnRlbnRpb25hbGx5IHJhaXNlIGV2ZW50cyBhZnRlciB1cGRhdGluZyBhbGwgb2Ygb3VyIHRyYW5zYWN0aW9uIHN0YXRlLCBzaW5jZSB0aGUgdXNlciBjb3VsZFxuICAgICAgICAvLyBzdGFydCBuZXcgdHJhbnNhY3Rpb25zIGZyb20gdGhlIGV2ZW50IGNhbGxiYWNrcy5cbiAgICAgICAgdmFyIHByaW9yaXR5Rm9yTm9kZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdWYWwgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBuZXdWYWwgIT09IG51bGwgJiZcbiAgICAgICAgICAgIGNvbnRhaW5zKG5ld1ZhbCwgJy5wcmlvcml0eScpKSB7XG4gICAgICAgICAgICBwcmlvcml0eUZvck5vZGUgPSBzYWZlR2V0KG5ld1ZhbCwgJy5wcmlvcml0eScpO1xuICAgICAgICAgICAgYXNzZXJ0KGlzVmFsaWRQcmlvcml0eShwcmlvcml0eUZvck5vZGUpLCAnSW52YWxpZCBwcmlvcml0eSByZXR1cm5lZCBieSB0cmFuc2FjdGlvbi4gJyArXG4gICAgICAgICAgICAgICAgJ1ByaW9yaXR5IG11c3QgYmUgYSB2YWxpZCBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbC4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRoaXMuc2VydmVyU3luY1RyZWVfLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUocGF0aCkgfHxcbiAgICAgICAgICAgICAgICBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgICAgIHByaW9yaXR5Rm9yTm9kZSA9IGN1cnJlbnROb2RlLmdldFByaW9yaXR5KCkudmFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJpb3JpdHlGb3JOb2RlIC8qKiBAdHlwZSB7bnVsbHxudW1iZXJ8c3RyaW5nfSAqLyA9IHByaW9yaXR5Rm9yTm9kZTtcbiAgICAgICAgdmFyIHNlcnZlclZhbHVlcyA9IHRoaXMuZ2VuZXJhdGVTZXJ2ZXJWYWx1ZXMoKTtcbiAgICAgICAgdmFyIG5ld05vZGVVbnJlc29sdmVkID0gbm9kZUZyb21KU09OKG5ld1ZhbCwgcHJpb3JpdHlGb3JOb2RlKTtcbiAgICAgICAgdmFyIG5ld05vZGUgPSByZXNvbHZlRGVmZXJyZWRWYWx1ZVNuYXBzaG90KG5ld05vZGVVbnJlc29sdmVkLCBzZXJ2ZXJWYWx1ZXMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSYXcgPSBuZXdOb2RlVW5yZXNvbHZlZDtcbiAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQgPSBuZXdOb2RlO1xuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCA9IHRoaXMuZ2V0TmV4dFdyaXRlSWRfKCk7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLnNlcnZlclN5bmNUcmVlXy5hcHBseVVzZXJPdmVyd3JpdGUocGF0aCwgbmV3Tm9kZSwgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQsIHRyYW5zYWN0aW9uLmFwcGx5TG9jYWxseSk7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZV8ucmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChwYXRoLCBldmVudHMpO1xuICAgICAgICB0aGlzLnNlbmRSZWFkeVRyYW5zYWN0aW9uc18oKTtcbiAgICB9XG59O1xuLyoqXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+PX0gZXhjbHVkZVNldHMgQSBzcGVjaWZpYyBzZXQgdG8gZXhjbHVkZVxuICogQHJldHVybiB7Tm9kZX1cbiAqIEBwcml2YXRlXG4gKi9cblJlcG8ucHJvdG90eXBlLmdldExhdGVzdFN0YXRlXyA9IGZ1bmN0aW9uIChwYXRoLCBleGNsdWRlU2V0cykge1xuICAgIHJldHVybiAodGhpcy5zZXJ2ZXJTeW5jVHJlZV8uY2FsY0NvbXBsZXRlRXZlbnRDYWNoZShwYXRoLCBleGNsdWRlU2V0cykgfHxcbiAgICAgICAgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xufTtcbi8qKlxuICogU2VuZHMgYW55IGFscmVhZHktcnVuIHRyYW5zYWN0aW9ucyB0aGF0IGFyZW4ndCB3YWl0aW5nIGZvciBvdXRzdGFuZGluZyB0cmFuc2FjdGlvbnMgdG9cbiAqIGNvbXBsZXRlLlxuICpcbiAqIEV4dGVybmFsbHkgaXQncyBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIGJ1dCBpdCBjYWxscyBpdHNlbGYgcmVjdXJzaXZlbHkgd2l0aCBhIHBhcnRpY3VsYXJcbiAqIHRyYW5zYWN0aW9uUXVldWVUcmVlIG5vZGUgdG8gcmVjdXJzZSB0aHJvdWdoIHRoZSB0cmVlLlxuICpcbiAqIEBwYXJhbSB7VHJlZS48QXJyYXkuPFRyYW5zYWN0aW9uPj49fSBub2RlICB0cmFuc2FjdGlvblF1ZXVlVHJlZSBub2RlIHRvIHN0YXJ0IGF0LlxuICogQHByaXZhdGVcbiAqL1xuUmVwby5wcm90b3R5cGUuc2VuZFJlYWR5VHJhbnNhY3Rpb25zXyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7IG5vZGUgPSB0aGlzLnRyYW5zYWN0aW9uUXVldWVUcmVlXzsgfVxuICAgIC8vIEJlZm9yZSByZWN1cnNpbmcsIG1ha2Ugc3VyZSBhbnkgY29tcGxldGVkIHRyYW5zYWN0aW9ucyBhcmUgcmVtb3ZlZC5cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgdGhpcy5wcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZV8obm9kZSk7XG4gICAgfVxuICAgIGlmIChub2RlLmdldFZhbHVlKCkgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uUXVldWVfKG5vZGUpO1xuICAgICAgICBhc3NlcnQocXVldWUubGVuZ3RoID4gMCwgJ1NlbmRpbmcgemVybyBsZW5ndGggdHJhbnNhY3Rpb24gcXVldWUnKTtcbiAgICAgICAgdmFyIGFsbFJ1biA9IHF1ZXVlLmV2ZXJ5KGZ1bmN0aW9uICh0cmFuc2FjdGlvbikgeyByZXR1cm4gdHJhbnNhY3Rpb24uc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5SVU47IH0pO1xuICAgICAgICAvLyBJZiB0aGV5J3JlIGFsbCBydW4gKGFuZCBub3Qgc2VudCksIHdlIGNhbiBzZW5kIHRoZW0uICBFbHNlLCB3ZSBtdXN0IHdhaXQuXG4gICAgICAgIGlmIChhbGxSdW4pIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZFRyYW5zYWN0aW9uUXVldWVfKG5vZGUucGF0aCgpLCBxdWV1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgIG5vZGUuZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIF90aGlzLnNlbmRSZWFkeVRyYW5zYWN0aW9uc18oY2hpbGROb2RlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbi8qKlxuICogR2l2ZW4gYSBsaXN0IG9mIHJ1biB0cmFuc2FjdGlvbnMsIHNlbmQgdGhlbSB0byB0aGUgc2VydmVyIGFuZCB0aGVuIGhhbmRsZSB0aGUgcmVzdWx0IChzdWNjZXNzIG9yIGZhaWx1cmUpLlxuICpcbiAqIEBwYXJhbSB7IVBhdGh9IHBhdGggVGhlIGxvY2F0aW9uIG9mIHRoZSBxdWV1ZS5cbiAqIEBwYXJhbSB7IUFycmF5LjxUcmFuc2FjdGlvbj59IHF1ZXVlIFF1ZXVlIG9mIHRyYW5zYWN0aW9ucyB1bmRlciB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuUmVwby5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uUXVldWVfID0gZnVuY3Rpb24gKHBhdGgsIHF1ZXVlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAvLyBNYXJrIHRyYW5zYWN0aW9ucyBhcyBzZW50IGFuZCBpbmNyZW1lbnQgcmV0cnkgY291bnQhXG4gICAgdmFyIHNldHNUb0lnbm9yZSA9IHF1ZXVlLm1hcChmdW5jdGlvbiAodHhuKSB7XG4gICAgICAgIHJldHVybiB0eG4uY3VycmVudFdyaXRlSWQ7XG4gICAgfSk7XG4gICAgdmFyIGxhdGVzdFN0YXRlID0gdGhpcy5nZXRMYXRlc3RTdGF0ZV8ocGF0aCwgc2V0c1RvSWdub3JlKTtcbiAgICB2YXIgc25hcFRvU2VuZCA9IGxhdGVzdFN0YXRlO1xuICAgIHZhciBsYXRlc3RIYXNoID0gbGF0ZXN0U3RhdGUuaGFzaCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHR4biA9IHF1ZXVlW2ldO1xuICAgICAgICBhc3NlcnQodHhuLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuUlVOLCAndHJ5VG9TZW5kVHJhbnNhY3Rpb25RdWV1ZV86IGl0ZW1zIGluIHF1ZXVlIHNob3VsZCBhbGwgYmUgcnVuLicpO1xuICAgICAgICB0eG4uc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuU0VOVDtcbiAgICAgICAgdHhuLnJldHJ5Q291bnQrKztcbiAgICAgICAgdmFyIHJlbGF0aXZlUGF0aCA9IFBhdGgucmVsYXRpdmVQYXRoKHBhdGgsIHR4bi5wYXRoKTtcbiAgICAgICAgLy8gSWYgd2UndmUgZ290dGVuIHRvIHRoaXMgcG9pbnQsIHRoZSBvdXRwdXQgc25hcHNob3QgbXVzdCBiZSBkZWZpbmVkLlxuICAgICAgICBzbmFwVG9TZW5kID0gc25hcFRvU2VuZC51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGggLyoqQHR5cGUgeyFOb2RlfSAqLywgdHhuLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJhdyk7XG4gICAgfVxuICAgIHZhciBkYXRhVG9TZW5kID0gc25hcFRvU2VuZC52YWwodHJ1ZSk7XG4gICAgdmFyIHBhdGhUb1NlbmQgPSBwYXRoO1xuICAgIC8vIFNlbmQgdGhlIHB1dC5cbiAgICB0aGlzLnNlcnZlcl8ucHV0KHBhdGhUb1NlbmQudG9TdHJpbmcoKSwgZGF0YVRvU2VuZCwgZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgICBfdGhpcy5sb2dfKCd0cmFuc2FjdGlvbiBwdXQgcmVzcG9uc2UnLCB7XG4gICAgICAgICAgICBwYXRoOiBwYXRoVG9TZW5kLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1c1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xuICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XG4gICAgICAgICAgICAvLyBRdWV1ZSB1cCB0aGUgY2FsbGJhY2tzIGFuZCBmaXJlIHRoZW0gYWZ0ZXIgY2xlYW5pbmcgdXAgYWxsIG9mIG91ciB0cmFuc2FjdGlvbiBzdGF0ZSwgc2luY2VcbiAgICAgICAgICAgIC8vIHRoZSBjYWxsYmFjayBjb3VsZCB0cmlnZ2VyIG1vcmUgdHJhbnNhY3Rpb25zIG9yIHNldHMuXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuQ09NUExFVEVEO1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoX3RoaXMuc2VydmVyU3luY1RyZWVfLmFja1VzZXJXcml0ZShxdWV1ZVtpXS5jdXJyZW50V3JpdGVJZCkpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtpXS5vbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5ldmVyIHVuc2V0IHRoZSBvdXRwdXQgc25hcHNob3QsIGFuZCBnaXZlbiB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gaXMgY29tcGxldGUsIGl0IHNob3VsZCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBxdWV1ZVtpXS5jdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZiA9IG5ldyBSZWZlcmVuY2UoX3RoaXMsIHF1ZXVlW2ldLnBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc25hcHNob3QgPSBuZXcgRGF0YVNuYXBzaG90KG5vZGUsIHJlZiwgUFJJT1JJVFlfSU5ERVgpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaChxdWV1ZVtpXS5vbkNvbXBsZXRlLmJpbmQobnVsbCwgbnVsbCwgdHJ1ZSwgc25hcHNob3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXVldWVbaV0udW53YXRjaGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgcmVtb3ZlIHRoZSBjb21wbGV0ZWQgdHJhbnNhY3Rpb25zLlxuICAgICAgICAgICAgX3RoaXMucHJ1bmVDb21wbGV0ZWRUcmFuc2FjdGlvbnNCZWxvd05vZGVfKF90aGlzLnRyYW5zYWN0aW9uUXVldWVUcmVlXy5zdWJUcmVlKHBhdGgpKTtcbiAgICAgICAgICAgIC8vIFRoZXJlIG1heSBiZSBwZW5kaW5nIHRyYW5zYWN0aW9ucyB0aGF0IHdlIGNhbiBub3cgc2VuZC5cbiAgICAgICAgICAgIF90aGlzLnNlbmRSZWFkeVRyYW5zYWN0aW9uc18oKTtcbiAgICAgICAgICAgIF90aGlzLmV2ZW50UXVldWVfLnJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocGF0aCwgZXZlbnRzKTtcbiAgICAgICAgICAgIC8vIEZpbmFsbHksIHRyaWdnZXIgb25Db21wbGV0ZSBjYWxsYmFja3MuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGV4Y2VwdGlvbkd1YXJkKGNhbGxiYWNrc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0cmFuc2FjdGlvbnMgYXJlIG5vIGxvbmdlciBzZW50LiAgVXBkYXRlIHRoZWlyIHN0YXR1cyBhcHByb3ByaWF0ZWx5LlxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ2RhdGFzdGFsZScpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtpXS5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlNFTlRfTkVFRFNfQUJPUlQpXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5ORUVEU19BQk9SVDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuUlVOO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdhcm4oJ3RyYW5zYWN0aW9uIGF0ICcgKyBwYXRoVG9TZW5kLnRvU3RyaW5nKCkgKyAnIGZhaWxlZDogJyArIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5ORUVEU19BQk9SVDtcbiAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0uYWJvcnRSZWFzb24gPSBzdGF0dXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucmVydW5UcmFuc2FjdGlvbnNfKHBhdGgpO1xuICAgICAgICB9XG4gICAgfSwgbGF0ZXN0SGFzaCk7XG59O1xuLyoqXG4gKiBGaW5kcyBhbGwgdHJhbnNhY3Rpb25zIGRlcGVuZGVudCBvbiB0aGUgZGF0YSBhdCBjaGFuZ2VkUGF0aCBhbmQgcmVydW5zIHRoZW0uXG4gKlxuICogU2hvdWxkIGJlIGNhbGxlZCBhbnkgdGltZSBjYWNoZWQgZGF0YSBjaGFuZ2VzLlxuICpcbiAqIFJldHVybiB0aGUgaGlnaGVzdCBwYXRoIHRoYXQgd2FzIGFmZmVjdGVkIGJ5IHJlcnVubmluZyB0cmFuc2FjdGlvbnMuICBUaGlzIGlzIHRoZSBwYXRoIGF0IHdoaWNoIGV2ZW50cyBuZWVkIHRvXG4gKiBiZSByYWlzZWQgZm9yLlxuICpcbiAqIEBwYXJhbSB7IVBhdGh9IGNoYW5nZWRQYXRoIFRoZSBwYXRoIGluIG1lcmdlZERhdGEgdGhhdCBjaGFuZ2VkLlxuICogQHJldHVybiB7IVBhdGh9IFRoZSByb290bW9zdCBwYXRoIHRoYXQgd2FzIGFmZmVjdGVkIGJ5IHJlcnVubmluZyB0cmFuc2FjdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5SZXBvLnByb3RvdHlwZS5yZXJ1blRyYW5zYWN0aW9uc18gPSBmdW5jdGlvbiAoY2hhbmdlZFBhdGgpIHtcbiAgICB2YXIgcm9vdE1vc3RUcmFuc2FjdGlvbk5vZGUgPSB0aGlzLmdldEFuY2VzdG9yVHJhbnNhY3Rpb25Ob2RlXyhjaGFuZ2VkUGF0aCk7XG4gICAgdmFyIHBhdGggPSByb290TW9zdFRyYW5zYWN0aW9uTm9kZS5wYXRoKCk7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uUXVldWVfKHJvb3RNb3N0VHJhbnNhY3Rpb25Ob2RlKTtcbiAgICB0aGlzLnJlcnVuVHJhbnNhY3Rpb25RdWV1ZV8ocXVldWUsIHBhdGgpO1xuICAgIHJldHVybiBwYXRoO1xufTtcbi8qKlxuICogRG9lcyBhbGwgdGhlIHdvcmsgb2YgcmVydW5uaW5nIHRyYW5zYWN0aW9ucyAoYXMgd2VsbCBhcyBjbGVhbnMgdXAgYWJvcnRlZCB0cmFuc2FjdGlvbnMgYW5kIHdoYXRub3QpLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPFRyYW5zYWN0aW9uPn0gcXVldWUgVGhlIHF1ZXVlIG9mIHRyYW5zYWN0aW9ucyB0byBydW4uXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoIFRoZSBwYXRoIHRoZSBxdWV1ZSBpcyBmb3IuXG4gKiBAcHJpdmF0ZVxuICovXG5SZXBvLnByb3RvdHlwZS5yZXJ1blRyYW5zYWN0aW9uUXVldWVfID0gZnVuY3Rpb24gKHF1ZXVlLCBwYXRoKSB7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG8hXG4gICAgfVxuICAgIC8vIFF1ZXVlIHVwIHRoZSBjYWxsYmFja3MgYW5kIGZpcmUgdGhlbSBhZnRlciBjbGVhbmluZyB1cCBhbGwgb2Ygb3VyIHRyYW5zYWN0aW9uIHN0YXRlLCBzaW5jZVxuICAgIC8vIHRoZSBjYWxsYmFjayBjb3VsZCB0cmlnZ2VyIG1vcmUgdHJhbnNhY3Rpb25zIG9yIHNldHMuXG4gICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICAgIHZhciBldmVudHMgPSBbXTtcbiAgICAvLyBJZ25vcmUgYWxsIG9mIHRoZSBzZXRzIHdlJ3JlIGdvaW5nIHRvIHJlLXJ1bi5cbiAgICB2YXIgdHhuc1RvUmVydW4gPSBxdWV1ZS5maWx0ZXIoZnVuY3Rpb24gKHEpIHtcbiAgICAgICAgcmV0dXJuIHEuc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5SVU47XG4gICAgfSk7XG4gICAgdmFyIHNldHNUb0lnbm9yZSA9IHR4bnNUb1JlcnVuLm1hcChmdW5jdGlvbiAocSkge1xuICAgICAgICByZXR1cm4gcS5jdXJyZW50V3JpdGVJZDtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IHF1ZXVlW2ldO1xuICAgICAgICB2YXIgcmVsYXRpdmVQYXRoID0gUGF0aC5yZWxhdGl2ZVBhdGgocGF0aCwgdHJhbnNhY3Rpb24ucGF0aCk7XG4gICAgICAgIHZhciBhYm9ydFRyYW5zYWN0aW9uID0gZmFsc2UsIGFib3J0UmVhc29uID0gdm9pZCAwO1xuICAgICAgICBhc3NlcnQocmVsYXRpdmVQYXRoICE9PSBudWxsLCAncmVydW5UcmFuc2FjdGlvbnNVbmRlck5vZGVfOiByZWxhdGl2ZVBhdGggc2hvdWxkIG5vdCBiZSBudWxsLicpO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24uc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5ORUVEU19BQk9SVCkge1xuICAgICAgICAgICAgYWJvcnRUcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICBhYm9ydFJlYXNvbiA9IHRyYW5zYWN0aW9uLmFib3J0UmVhc29uO1xuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdCh0aGlzLnNlcnZlclN5bmNUcmVlXy5hY2tVc2VyV3JpdGUodHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmFuc2FjdGlvbi5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlJVTikge1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnJldHJ5Q291bnQgPj0gUmVwby5NQVhfVFJBTlNBQ1RJT05fUkVUUklFU18pIHtcbiAgICAgICAgICAgICAgICBhYm9ydFRyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhYm9ydFJlYXNvbiA9ICdtYXhyZXRyeSc7XG4gICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdCh0aGlzLnNlcnZlclN5bmNUcmVlXy5hY2tVc2VyV3JpdGUodHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQsIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSByZXJ1bnMgYSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRoaXMuZ2V0TGF0ZXN0U3RhdGVfKHRyYW5zYWN0aW9uLnBhdGgsIHNldHNUb0lnbm9yZSk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudElucHV0U25hcHNob3QgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RGF0YSA9IHF1ZXVlW2ldLnVwZGF0ZShjdXJyZW50Tm9kZS52YWwoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0RhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YSgndHJhbnNhY3Rpb24gZmFpbGVkOiBEYXRhIHJldHVybmVkICcsIG5ld0RhdGEsIHRyYW5zYWN0aW9uLnBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RGF0YU5vZGUgPSBub2RlRnJvbUpTT04obmV3RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNFeHBsaWNpdFByaW9yaXR5ID0gdHlwZW9mIG5ld0RhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zKG5ld0RhdGEsICcucHJpb3JpdHknKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNFeHBsaWNpdFByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHRoZSBvbGQgcHJpb3JpdHkgaWYgdGhlcmUgd2Fzbid0IGEgcHJpb3JpdHkgZXhwbGljaXRseSBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhTm9kZSA9IG5ld0RhdGFOb2RlLnVwZGF0ZVByaW9yaXR5KGN1cnJlbnROb2RlLmdldFByaW9yaXR5KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbGRXcml0ZUlkID0gdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXJ2ZXJWYWx1ZXMgPSB0aGlzLmdlbmVyYXRlU2VydmVyVmFsdWVzKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlUmVzb2x2ZWQgPSByZXNvbHZlRGVmZXJyZWRWYWx1ZVNuYXBzaG90KG5ld0RhdGFOb2RlLCBzZXJ2ZXJWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSYXcgPSBuZXdEYXRhTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQgPSBuZXdOb2RlUmVzb2x2ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkID0gdGhpcy5nZXROZXh0V3JpdGVJZF8oKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTXV0YXRlcyBzZXRzVG9JZ25vcmUgaW4gcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgc2V0c1RvSWdub3JlLnNwbGljZShzZXRzVG9JZ25vcmUuaW5kZXhPZihvbGRXcml0ZUlkKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQodGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYXBwbHlVc2VyT3ZlcndyaXRlKHRyYW5zYWN0aW9uLnBhdGgsIG5ld05vZGVSZXNvbHZlZCwgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQsIHRyYW5zYWN0aW9uLmFwcGx5TG9jYWxseSkpO1xuICAgICAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHRoaXMuc2VydmVyU3luY1RyZWVfLmFja1VzZXJXcml0ZShvbGRXcml0ZUlkLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhYm9ydFRyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRSZWFzb24gPSAnbm9kYXRhJztcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdCh0aGlzLnNlcnZlclN5bmNUcmVlXy5hY2tVc2VyV3JpdGUodHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQsIHRydWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHBhdGgsIGV2ZW50cyk7XG4gICAgICAgIGV2ZW50cyA9IFtdO1xuICAgICAgICBpZiAoYWJvcnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgLy8gQWJvcnQuXG4gICAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5DT01QTEVURUQ7XG4gICAgICAgICAgICAvLyBSZW1vdmluZyBhIGxpc3RlbmVyIGNhbiB0cmlnZ2VyIHBydW5pbmcgd2hpY2ggY2FuIG11Y2sgd2l0aCBtZXJnZWREYXRhL3Zpc2libGVEYXRhIChhcyBpdCBwcnVuZXMgZGF0YSkuXG4gICAgICAgICAgICAvLyBTbyBkZWZlciB0aGUgdW53YXRjaGVyIHVudGlsIHdlJ3JlIGRvbmUuXG4gICAgICAgICAgICAoZnVuY3Rpb24gKHVud2F0Y2hlcikge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodW53YXRjaGVyLCBNYXRoLmZsb29yKDApKTtcbiAgICAgICAgICAgIH0pKHF1ZXVlW2ldLnVud2F0Y2hlcik7XG4gICAgICAgICAgICBpZiAocXVldWVbaV0ub25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChhYm9ydFJlYXNvbiA9PT0gJ25vZGF0YScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZiA9IG5ldyBSZWZlcmVuY2UodGhpcywgcXVldWVbaV0ucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHNldCB0aGlzIGZpZWxkIGltbWVkaWF0ZWx5LCBzbyBpdCdzIHNhZmUgdG8gY2FzdCB0byBhbiBhY3R1YWwgc25hcHNob3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RJbnB1dCAvKiogQHR5cGUgeyFOb2RlfSAqLyA9IHF1ZXVlW2ldLmN1cnJlbnRJbnB1dFNuYXBzaG90O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc25hcHNob3QgPSBuZXcgRGF0YVNuYXBzaG90KGxhc3RJbnB1dCwgcmVmLCBQUklPUklUWV9JTkRFWCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKHF1ZXVlW2ldLm9uQ29tcGxldGUuYmluZChudWxsLCBudWxsLCBmYWxzZSwgc25hcHNob3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKHF1ZXVlW2ldLm9uQ29tcGxldGUuYmluZChudWxsLCBuZXcgRXJyb3IoYWJvcnRSZWFzb24pLCBmYWxzZSwgbnVsbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDbGVhbiB1cCBjb21wbGV0ZWQgdHJhbnNhY3Rpb25zLlxuICAgIHRoaXMucHJ1bmVDb21wbGV0ZWRUcmFuc2FjdGlvbnNCZWxvd05vZGVfKHRoaXMudHJhbnNhY3Rpb25RdWV1ZVRyZWVfKTtcbiAgICAvLyBOb3cgZmlyZSBjYWxsYmFja3MsIG5vdyB0aGF0IHdlJ3JlIGluIGEgZ29vZCwga25vd24gc3RhdGUuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXhjZXB0aW9uR3VhcmQoY2FsbGJhY2tzW2ldKTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHNlbmQgdGhlIHRyYW5zYWN0aW9uIHJlc3VsdCB0byB0aGUgc2VydmVyLlxuICAgIHRoaXMuc2VuZFJlYWR5VHJhbnNhY3Rpb25zXygpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgcm9vdG1vc3QgYW5jZXN0b3Igbm9kZSBvZiB0aGUgc3BlY2lmaWVkIHBhdGggdGhhdCBoYXMgYSBwZW5kaW5nIHRyYW5zYWN0aW9uIG9uIGl0LCBvciBqdXN0IHJldHVybnNcbiAqIHRoZSBub2RlIGZvciB0aGUgZ2l2ZW4gcGF0aCBpZiB0aGVyZSBhcmUgbm8gcGVuZGluZyB0cmFuc2FjdGlvbnMgb24gYW55IGFuY2VzdG9yLlxuICpcbiAqIEBwYXJhbSB7IVBhdGh9IHBhdGggVGhlIGxvY2F0aW9uIHRvIHN0YXJ0IGF0LlxuICogQHJldHVybiB7IVRyZWUuPEFycmF5LjwhVHJhbnNhY3Rpb24+Pn0gVGhlIHJvb3Rtb3N0IG5vZGUgd2l0aCBhIHRyYW5zYWN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuUmVwby5wcm90b3R5cGUuZ2V0QW5jZXN0b3JUcmFuc2FjdGlvbk5vZGVfID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgZnJvbnQ7XG4gICAgLy8gU3RhcnQgYXQgdGhlIHJvb3QgYW5kIHdhbGsgZGVlcGVyIGludG8gdGhlIHRyZWUgdG93YXJkcyBwYXRoIHVudGlsIHdlIGZpbmQgYSBub2RlIHdpdGggcGVuZGluZyB0cmFuc2FjdGlvbnMuXG4gICAgdmFyIHRyYW5zYWN0aW9uTm9kZSA9IHRoaXMudHJhbnNhY3Rpb25RdWV1ZVRyZWVfO1xuICAgIHdoaWxlICgoZnJvbnQgPSBwYXRoLmdldEZyb250KCkpICE9PSBudWxsICYmXG4gICAgICAgIHRyYW5zYWN0aW9uTm9kZS5nZXRWYWx1ZSgpID09PSBudWxsKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uTm9kZSA9IHRyYW5zYWN0aW9uTm9kZS5zdWJUcmVlKGZyb250KTtcbiAgICAgICAgcGF0aCA9IHBhdGgucG9wRnJvbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uTm9kZTtcbn07XG4vKipcbiAqIEJ1aWxkcyB0aGUgcXVldWUgb2YgYWxsIHRyYW5zYWN0aW9ucyBhdCBvciBiZWxvdyB0aGUgc3BlY2lmaWVkIHRyYW5zYWN0aW9uTm9kZS5cbiAqXG4gKiBAcGFyYW0geyFUcmVlLjxBcnJheS48VHJhbnNhY3Rpb24+Pn0gdHJhbnNhY3Rpb25Ob2RlXG4gKiBAcmV0dXJuIHtBcnJheS48VHJhbnNhY3Rpb24+fSBUaGUgZ2VuZXJhdGVkIHF1ZXVlLlxuICogQHByaXZhdGVcbiAqL1xuUmVwby5wcm90b3R5cGUuYnVpbGRUcmFuc2FjdGlvblF1ZXVlXyA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbk5vZGUpIHtcbiAgICAvLyBXYWxrIGFueSBjaGlsZCB0cmFuc2FjdGlvbiBxdWV1ZXMgYW5kIGFnZ3JlZ2F0ZSB0aGVtIGludG8gYSBzaW5nbGUgcXVldWUuXG4gICAgdmFyIHRyYW5zYWN0aW9uUXVldWUgPSBbXTtcbiAgICB0aGlzLmFnZ3JlZ2F0ZVRyYW5zYWN0aW9uUXVldWVzRm9yTm9kZV8odHJhbnNhY3Rpb25Ob2RlLCB0cmFuc2FjdGlvblF1ZXVlKTtcbiAgICAvLyBTb3J0IHRoZW0gYnkgdGhlIG9yZGVyIHRoZSB0cmFuc2FjdGlvbnMgd2VyZSBjcmVhdGVkLlxuICAgIHRyYW5zYWN0aW9uUXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uUXVldWU7XG59O1xuLyoqXG4gKiBAcGFyYW0geyFUcmVlLjxBcnJheS48VHJhbnNhY3Rpb24+Pn0gbm9kZVxuICogQHBhcmFtIHtBcnJheS48VHJhbnNhY3Rpb24+fSBxdWV1ZVxuICogQHByaXZhdGVcbiAqL1xuUmVwby5wcm90b3R5cGUuYWdncmVnYXRlVHJhbnNhY3Rpb25RdWV1ZXNGb3JOb2RlXyA9IGZ1bmN0aW9uIChub2RlLCBxdWV1ZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIG5vZGVRdWV1ZSA9IG5vZGUuZ2V0VmFsdWUoKTtcbiAgICBpZiAobm9kZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZVF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKG5vZGVRdWV1ZVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbm9kZS5mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIF90aGlzLmFnZ3JlZ2F0ZVRyYW5zYWN0aW9uUXVldWVzRm9yTm9kZV8oY2hpbGQsIHF1ZXVlKTtcbiAgICB9KTtcbn07XG4vKipcbiAqIFJlbW92ZSBDT01QTEVURUQgdHJhbnNhY3Rpb25zIGF0IG9yIGJlbG93IHRoaXMgbm9kZSBpbiB0aGUgdHJhbnNhY3Rpb25RdWV1ZVRyZWVfLlxuICpcbiAqIEBwYXJhbSB7IVRyZWUuPEFycmF5LjwhVHJhbnNhY3Rpb24+Pn0gbm9kZVxuICogQHByaXZhdGVcbiAqL1xuUmVwby5wcm90b3R5cGUucHJ1bmVDb21wbGV0ZWRUcmFuc2FjdGlvbnNCZWxvd05vZGVfID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBxdWV1ZSA9IG5vZGUuZ2V0VmFsdWUoKTtcbiAgICBpZiAocXVldWUpIHtcbiAgICAgICAgdmFyIHRvID0gMDtcbiAgICAgICAgZm9yICh2YXIgZnJvbSA9IDA7IGZyb20gPCBxdWV1ZS5sZW5ndGg7IGZyb20rKykge1xuICAgICAgICAgICAgaWYgKHF1ZXVlW2Zyb21dLnN0YXR1cyAhPT0gVHJhbnNhY3Rpb25TdGF0dXMuQ09NUExFVEVEKSB7XG4gICAgICAgICAgICAgICAgcXVldWVbdG9dID0gcXVldWVbZnJvbV07XG4gICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZS5sZW5ndGggPSB0bztcbiAgICAgICAgbm9kZS5zZXRWYWx1ZShxdWV1ZS5sZW5ndGggPiAwID8gcXVldWUgOiBudWxsKTtcbiAgICB9XG4gICAgbm9kZS5mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICBfdGhpcy5wcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZV8oY2hpbGROb2RlKTtcbiAgICB9KTtcbn07XG4vKipcbiAqIEFib3J0cyBhbGwgdHJhbnNhY3Rpb25zIG9uIGFuY2VzdG9ycyBvciBkZXNjZW5kYW50cyBvZiB0aGUgc3BlY2lmaWVkIHBhdGguICBDYWxsZWQgd2hlbiBkb2luZyBhIHNldCgpIG9yIHVwZGF0ZSgpXG4gKiBzaW5jZSB3ZSBjb25zaWRlciB0aGVtIGluY29tcGF0aWJsZSB3aXRoIHRyYW5zYWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoIFBhdGggZm9yIHdoaWNoIHdlIHdhbnQgdG8gYWJvcnQgcmVsYXRlZCB0cmFuc2FjdGlvbnMuXG4gKiBAcmV0dXJuIHshUGF0aH1cbiAqIEBwcml2YXRlXG4gKi9cblJlcG8ucHJvdG90eXBlLmFib3J0VHJhbnNhY3Rpb25zXyA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgYWZmZWN0ZWRQYXRoID0gdGhpcy5nZXRBbmNlc3RvclRyYW5zYWN0aW9uTm9kZV8ocGF0aCkucGF0aCgpO1xuICAgIHZhciB0cmFuc2FjdGlvbk5vZGUgPSB0aGlzLnRyYW5zYWN0aW9uUXVldWVUcmVlXy5zdWJUcmVlKHBhdGgpO1xuICAgIHRyYW5zYWN0aW9uTm9kZS5mb3JFYWNoQW5jZXN0b3IoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgX3RoaXMuYWJvcnRUcmFuc2FjdGlvbnNPbk5vZGVfKG5vZGUpO1xuICAgIH0pO1xuICAgIHRoaXMuYWJvcnRUcmFuc2FjdGlvbnNPbk5vZGVfKHRyYW5zYWN0aW9uTm9kZSk7XG4gICAgdHJhbnNhY3Rpb25Ob2RlLmZvckVhY2hEZXNjZW5kYW50KGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIF90aGlzLmFib3J0VHJhbnNhY3Rpb25zT25Ob2RlXyhub2RlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWZmZWN0ZWRQYXRoO1xufTtcbi8qKlxuICogQWJvcnQgdHJhbnNhY3Rpb25zIHN0b3JlZCBpbiB0aGlzIHRyYW5zYWN0aW9uIHF1ZXVlIG5vZGUuXG4gKlxuICogQHBhcmFtIHshVHJlZS48QXJyYXkuPFRyYW5zYWN0aW9uPj59IG5vZGUgTm9kZSB0byBhYm9ydCB0cmFuc2FjdGlvbnMgZm9yLlxuICogQHByaXZhdGVcbiAqL1xuUmVwby5wcm90b3R5cGUuYWJvcnRUcmFuc2FjdGlvbnNPbk5vZGVfID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgcXVldWUgPSBub2RlLmdldFZhbHVlKCk7XG4gICAgaWYgKHF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFF1ZXVlIHVwIHRoZSBjYWxsYmFja3MgYW5kIGZpcmUgdGhlbSBhZnRlciBjbGVhbmluZyB1cCBhbGwgb2Ygb3VyIHRyYW5zYWN0aW9uIHN0YXRlLCBzaW5jZVxuICAgICAgICAvLyB0aGUgY2FsbGJhY2sgY291bGQgdHJpZ2dlciBtb3JlIHRyYW5zYWN0aW9ucyBvciBzZXRzLlxuICAgICAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgICAgIC8vIEdvIHRocm91Z2ggcXVldWUuICBBbnkgYWxyZWFkeS1zZW50IHRyYW5zYWN0aW9ucyBtdXN0IGJlIG1hcmtlZCBmb3IgYWJvcnQsIHdoaWxlIHRoZSB1bnNlbnQgb25lc1xuICAgICAgICAvLyBjYW4gYmUgaW1tZWRpYXRlbHkgYWJvcnRlZCBhbmQgcmVtb3ZlZC5cbiAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xuICAgICAgICB2YXIgbGFzdFNlbnQgPSAtMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHF1ZXVlW2ldLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuU0VOVF9ORUVEU19BQk9SVCkge1xuICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgbWFya2VkLiAgTm8gYWN0aW9uIG5lZWRlZC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHF1ZXVlW2ldLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuU0VOVCkge1xuICAgICAgICAgICAgICAgIGFzc2VydChsYXN0U2VudCA9PT0gaSAtIDEsICdBbGwgU0VOVCBpdGVtcyBzaG91bGQgYmUgYXQgYmVnaW5uaW5nIG9mIHF1ZXVlLicpO1xuICAgICAgICAgICAgICAgIGxhc3RTZW50ID0gaTtcbiAgICAgICAgICAgICAgICAvLyBNYXJrIHRyYW5zYWN0aW9uIGZvciBhYm9ydCB3aGVuIGl0IGNvbWVzIGJhY2suXG4gICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuU0VOVF9ORUVEU19BQk9SVDtcbiAgICAgICAgICAgICAgICBxdWV1ZVtpXS5hYm9ydFJlYXNvbiA9ICdzZXQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHF1ZXVlW2ldLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuUlVOLCAnVW5leHBlY3RlZCB0cmFuc2FjdGlvbiBzdGF0dXMgaW4gYWJvcnQnKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gYWJvcnQgaXQgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgcXVldWVbaV0udW53YXRjaGVyKCk7XG4gICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdCh0aGlzLnNlcnZlclN5bmNUcmVlXy5hY2tVc2VyV3JpdGUocXVldWVbaV0uY3VycmVudFdyaXRlSWQsIHRydWUpKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWVbaV0ub25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc25hcHNob3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaChxdWV1ZVtpXS5vbkNvbXBsZXRlLmJpbmQobnVsbCwgbmV3IEVycm9yKCdzZXQnKSwgZmFsc2UsIHNuYXBzaG90KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0U2VudCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCB3YWl0aW5nIGZvciBhbnkgc2VudCB0cmFuc2FjdGlvbnMuICBXZSBjYW4gY2xlYXIgdGhlIHF1ZXVlLlxuICAgICAgICAgICAgbm9kZS5zZXRWYWx1ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdHJhbnNhY3Rpb25zIHdlIGFib3J0ZWQuXG4gICAgICAgICAgICBxdWV1ZS5sZW5ndGggPSBsYXN0U2VudCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IGZpcmUgdGhlIGNhbGxiYWNrcy5cbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKG5vZGUucGF0aCgpLCBldmVudHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZXhjZXB0aW9uR3VhcmQoY2FsbGJhY2tzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvUmVwb190cmFuc2FjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IENoaWxkcmVuTm9kZSB9IGZyb20gJy4vc25hcC9DaGlsZHJlbk5vZGUnO1xuLyoqXG4gKiBNdXRhYmxlIG9iamVjdCB3aGljaCBiYXNpY2FsbHkganVzdCBzdG9yZXMgYSByZWZlcmVuY2UgdG8gdGhlIFwibGF0ZXN0XCIgaW1tdXRhYmxlIHNuYXBzaG90LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU25hcHNob3RIb2xkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU25hcHNob3RIb2xkZXIoKSB7XG4gICAgICAgIHRoaXMucm9vdE5vZGVfID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XG4gICAgfVxuICAgIFNuYXBzaG90SG9sZGVyLnByb3RvdHlwZS5nZXROb2RlID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdE5vZGVfLmdldENoaWxkKHBhdGgpO1xuICAgIH07XG4gICAgU25hcHNob3RIb2xkZXIucHJvdG90eXBlLnVwZGF0ZVNuYXBzaG90ID0gZnVuY3Rpb24gKHBhdGgsIG5ld1NuYXBzaG90Tm9kZSkge1xuICAgICAgICB0aGlzLnJvb3ROb2RlXyA9IHRoaXMucm9vdE5vZGVfLnVwZGF0ZUNoaWxkKHBhdGgsIG5ld1NuYXBzaG90Tm9kZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU25hcHNob3RIb2xkZXI7XG59KCkpO1xuZXhwb3J0IHsgU25hcHNob3RIb2xkZXIgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9TbmFwc2hvdEhvbGRlci5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IGVycm9yRm9yU2VydmVyQ29kZSB9IGZyb20gJy4vdXRpbC91dGlsJztcbmltcG9ydCB7IEFja1VzZXJXcml0ZSB9IGZyb20gJy4vb3BlcmF0aW9uL0Fja1VzZXJXcml0ZSc7XG5pbXBvcnQgeyBDaGlsZHJlbk5vZGUgfSBmcm9tICcuL3NuYXAvQ2hpbGRyZW5Ob2RlJztcbmltcG9ydCB7IGZvckVhY2gsIHNhZmVHZXQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBJbW11dGFibGVUcmVlIH0gZnJvbSAnLi91dGlsL0ltbXV0YWJsZVRyZWUnO1xuaW1wb3J0IHsgTGlzdGVuQ29tcGxldGUgfSBmcm9tICcuL29wZXJhdGlvbi9MaXN0ZW5Db21wbGV0ZSc7XG5pbXBvcnQgeyBNZXJnZSB9IGZyb20gJy4vb3BlcmF0aW9uL01lcmdlJztcbmltcG9ydCB7IE9wZXJhdGlvblNvdXJjZSB9IGZyb20gJy4vb3BlcmF0aW9uL09wZXJhdGlvbic7XG5pbXBvcnQgeyBPdmVyd3JpdGUgfSBmcm9tICcuL29wZXJhdGlvbi9PdmVyd3JpdGUnO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4vdXRpbC9QYXRoJztcbmltcG9ydCB7IFN5bmNQb2ludCB9IGZyb20gJy4vU3luY1BvaW50JztcbmltcG9ydCB7IFdyaXRlVHJlZSB9IGZyb20gJy4vV3JpdGVUcmVlJztcbi8qKlxuICogU3luY1RyZWUgaXMgdGhlIGNlbnRyYWwgY2xhc3MgZm9yIG1hbmFnaW5nIGV2ZW50IGNhbGxiYWNrIHJlZ2lzdHJhdGlvbiwgZGF0YSBjYWNoaW5nLCB2aWV3c1xuICogKHF1ZXJ5IHByb2Nlc3NpbmcpLCBhbmQgZXZlbnQgZ2VuZXJhdGlvbi4gIFRoZXJlIGFyZSB0eXBpY2FsbHkgdHdvIFN5bmNUcmVlIGluc3RhbmNlcyBmb3JcbiAqIGVhY2ggUmVwbywgb25lIGZvciB0aGUgbm9ybWFsIEZpcmViYXNlIGRhdGEsIGFuZCBvbmUgZm9yIHRoZSAuaW5mbyBkYXRhLlxuICpcbiAqIEl0IGhhcyBhIG51bWJlciBvZiByZXNwb25zaWJpbGl0aWVzLCBpbmNsdWRpbmc6XG4gKiAgLSBUcmFja2luZyBhbGwgdXNlciBldmVudCBjYWxsYmFja3MgKHJlZ2lzdGVyZWQgdmlhIGFkZEV2ZW50UmVnaXN0cmF0aW9uKCkgYW5kIHJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKCkpLlxuICogIC0gQXBwbHlpbmcgYW5kIGNhY2hpbmcgZGF0YSBjaGFuZ2VzIGZvciB1c2VyIHNldCgpLCB0cmFuc2FjdGlvbigpLCBhbmQgdXBkYXRlKCkgY2FsbHNcbiAqICAgIChhcHBseVVzZXJPdmVyd3JpdGUoKSwgYXBwbHlVc2VyTWVyZ2UoKSkuXG4gKiAgLSBBcHBseWluZyBhbmQgY2FjaGluZyBkYXRhIGNoYW5nZXMgZm9yIHNlcnZlciBkYXRhIGNoYW5nZXMgKGFwcGx5U2VydmVyT3ZlcndyaXRlKCksXG4gKiAgICBhcHBseVNlcnZlck1lcmdlKCkpLlxuICogIC0gR2VuZXJhdGluZyB1c2VyLWZhY2luZyBldmVudHMgZm9yIHNlcnZlciBhbmQgdXNlciBjaGFuZ2VzIChhbGwgb2YgdGhlIGFwcGx5KiBtZXRob2RzXG4gKiAgICByZXR1cm4gdGhlIHNldCBvZiBldmVudHMgdGhhdCBuZWVkIHRvIGJlIHJhaXNlZCBhcyBhIHJlc3VsdCkuXG4gKiAgLSBNYWludGFpbmluZyB0aGUgYXBwcm9wcmlhdGUgc2V0IG9mIHNlcnZlciBsaXN0ZW5zIHRvIGVuc3VyZSB3ZSBhcmUgYWx3YXlzIHN1YnNjcmliZWRcbiAqICAgIHRvIHRoZSBjb3JyZWN0IHNldCBvZiBwYXRocyBhbmQgcXVlcmllcyB0byBzYXRpc2Z5IHRoZSBjdXJyZW50IHNldCBvZiB1c2VyIGV2ZW50XG4gKiAgICBjYWxsYmFja3MgKGxpc3RlbnMgYXJlIHN0YXJ0ZWQvc3RvcHBlZCB1c2luZyB0aGUgcHJvdmlkZWQgbGlzdGVuUHJvdmlkZXIpLlxuICpcbiAqIE5PVEU6IEFsdGhvdWdoIFN5bmNUcmVlIHRyYWNrcyBldmVudCBjYWxsYmFja3MgYW5kIGNhbGN1bGF0ZXMgZXZlbnRzIHRvIHJhaXNlLCB0aGUgYWN0dWFsXG4gKiBldmVudHMgYXJlIHJldHVybmVkIHRvIHRoZSBjYWxsZXIgcmF0aGVyIHRoYW4gcmFpc2VkIHN5bmNocm9ub3VzbHkuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTeW5jVHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFMaXN0ZW5Qcm92aWRlcn0gbGlzdGVuUHJvdmlkZXJfIFVzZWQgYnkgU3luY1RyZWUgdG8gc3RhcnQgLyBzdG9wIGxpc3RlbmluZ1xuICAgICAqICAgdG8gc2VydmVyIGRhdGEuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3luY1RyZWUobGlzdGVuUHJvdmlkZXJfKSB7XG4gICAgICAgIHRoaXMubGlzdGVuUHJvdmlkZXJfID0gbGlzdGVuUHJvdmlkZXJfO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJlZSBvZiBTeW5jUG9pbnRzLiAgVGhlcmUncyBhIFN5bmNQb2ludCBhdCBhbnkgbG9jYXRpb24gdGhhdCBoYXMgMSBvciBtb3JlIHZpZXdzLlxuICAgICAgICAgKiBAdHlwZSB7IUltbXV0YWJsZVRyZWUuPCFTeW5jUG9pbnQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zeW5jUG9pbnRUcmVlXyA9IEltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHRyZWUgb2YgYWxsIHBlbmRpbmcgdXNlciB3cml0ZXMgKHVzZXItaW5pdGlhdGVkIHNldCgpJ3MsIHRyYW5zYWN0aW9uKCkncywgdXBkYXRlKCkncywgZXRjLikuXG4gICAgICAgICAqIEB0eXBlIHshV3JpdGVUcmVlfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nV3JpdGVUcmVlXyA9IG5ldyBXcml0ZVRyZWUoKTtcbiAgICAgICAgdGhpcy50YWdUb1F1ZXJ5TWFwXyA9IHt9O1xuICAgICAgICB0aGlzLnF1ZXJ5VG9UYWdNYXBfID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBkYXRhIGNoYW5nZXMgZm9yIGEgdXNlci1nZW5lcmF0ZWQgc2V0KCkgb3IgdHJhbnNhY3Rpb24oKSBjYWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5ld0RhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd3JpdGVJZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHZpc2libGVcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYXBwbHlVc2VyT3ZlcndyaXRlID0gZnVuY3Rpb24gKHBhdGgsIG5ld0RhdGEsIHdyaXRlSWQsIHZpc2libGUpIHtcbiAgICAgICAgLy8gUmVjb3JkIHBlbmRpbmcgd3JpdGUuXG4gICAgICAgIHRoaXMucGVuZGluZ1dyaXRlVHJlZV8uYWRkT3ZlcndyaXRlKHBhdGgsIG5ld0RhdGEsIHdyaXRlSWQsIHZpc2libGUpO1xuICAgICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhuZXcgT3ZlcndyaXRlKE9wZXJhdGlvblNvdXJjZS5Vc2VyLCBwYXRoLCBuZXdEYXRhKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBkYXRhIGZyb20gYSB1c2VyLWdlbmVyYXRlZCB1cGRhdGUoKSBjYWxsXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsICFOb2RlPn0gY2hhbmdlZENoaWxkcmVuXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB3cml0ZUlkXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fSBFdmVudHMgdG8gcmFpc2UuXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLmFwcGx5VXNlck1lcmdlID0gZnVuY3Rpb24gKHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVJZCkge1xuICAgICAgICAvLyBSZWNvcmQgcGVuZGluZyBtZXJnZS5cbiAgICAgICAgdGhpcy5wZW5kaW5nV3JpdGVUcmVlXy5hZGRNZXJnZShwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpO1xuICAgICAgICB2YXIgY2hhbmdlVHJlZSA9IEltbXV0YWJsZVRyZWUuZnJvbU9iamVjdChjaGFuZ2VkQ2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18obmV3IE1lcmdlKE9wZXJhdGlvblNvdXJjZS5Vc2VyLCBwYXRoLCBjaGFuZ2VUcmVlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBY2tub3dsZWRnZSBhIHBlbmRpbmcgdXNlciB3cml0ZSB0aGF0IHdhcyBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBhcHBseVVzZXJPdmVyd3JpdGUoKSBvciBhcHBseVVzZXJNZXJnZSgpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB3cml0ZUlkXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcmV2ZXJ0IFRydWUgaWYgdGhlIGdpdmVuIHdyaXRlIGZhaWxlZCBhbmQgbmVlZHMgdG8gYmUgcmV2ZXJ0ZWRcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYWNrVXNlcldyaXRlID0gZnVuY3Rpb24gKHdyaXRlSWQsIHJldmVydCkge1xuICAgICAgICBpZiAocmV2ZXJ0ID09PSB2b2lkIDApIHsgcmV2ZXJ0ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHdyaXRlID0gdGhpcy5wZW5kaW5nV3JpdGVUcmVlXy5nZXRXcml0ZSh3cml0ZUlkKTtcbiAgICAgICAgdmFyIG5lZWRUb1JlZXZhbHVhdGUgPSB0aGlzLnBlbmRpbmdXcml0ZVRyZWVfLnJlbW92ZVdyaXRlKHdyaXRlSWQpO1xuICAgICAgICBpZiAoIW5lZWRUb1JlZXZhbHVhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhZmZlY3RlZFRyZWVfMSA9IEltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICAgICAgICBpZiAod3JpdGUuc25hcCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gb3ZlcndyaXRlXG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRUcmVlXzEgPSBhZmZlY3RlZFRyZWVfMS5zZXQoUGF0aC5FbXB0eSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKHdyaXRlLmNoaWxkcmVuLCBmdW5jdGlvbiAocGF0aFN0cmluZywgbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZFRyZWVfMSA9IGFmZmVjdGVkVHJlZV8xLnNldChuZXcgUGF0aChwYXRoU3RyaW5nKSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18obmV3IEFja1VzZXJXcml0ZSh3cml0ZS5wYXRoLCBhZmZlY3RlZFRyZWVfMSwgcmV2ZXJ0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IG5ldyBzZXJ2ZXIgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCBwYXRoLi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBuZXdEYXRhXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fSBFdmVudHMgdG8gcmFpc2UuXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLmFwcGx5U2VydmVyT3ZlcndyaXRlID0gZnVuY3Rpb24gKHBhdGgsIG5ld0RhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKG5ldyBPdmVyd3JpdGUoT3BlcmF0aW9uU291cmNlLlNlcnZlciwgcGF0aCwgbmV3RGF0YSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbHkgbmV3IHNlcnZlciBkYXRhIHRvIGJlIG1lcmdlZCBpbiBhdCB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsICFOb2RlPn0gY2hhbmdlZENoaWxkcmVuXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fSBFdmVudHMgdG8gcmFpc2UuXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLmFwcGx5U2VydmVyTWVyZ2UgPSBmdW5jdGlvbiAocGF0aCwgY2hhbmdlZENoaWxkcmVuKSB7XG4gICAgICAgIHZhciBjaGFuZ2VUcmVlID0gSW1tdXRhYmxlVHJlZS5mcm9tT2JqZWN0KGNoYW5nZWRDaGlsZHJlbik7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhuZXcgTWVyZ2UoT3BlcmF0aW9uU291cmNlLlNlcnZlciwgcGF0aCwgY2hhbmdlVHJlZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbHkgYSBsaXN0ZW4gY29tcGxldGUgZm9yIGEgcXVlcnlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYXBwbHlMaXN0ZW5Db21wbGV0ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhuZXcgTGlzdGVuQ29tcGxldGUoT3BlcmF0aW9uU291cmNlLlNlcnZlciwgcGF0aCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbHkgbmV3IHNlcnZlciBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIHRhZ2dlZCBxdWVyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBzbmFwXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB0YWdcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYXBwbHlUYWdnZWRRdWVyeU92ZXJ3cml0ZSA9IGZ1bmN0aW9uIChwYXRoLCBzbmFwLCB0YWcpIHtcbiAgICAgICAgdmFyIHF1ZXJ5S2V5ID0gdGhpcy5xdWVyeUtleUZvclRhZ18odGFnKTtcbiAgICAgICAgaWYgKHF1ZXJ5S2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByID0gU3luY1RyZWUucGFyc2VRdWVyeUtleV8ocXVlcnlLZXkpO1xuICAgICAgICAgICAgdmFyIHF1ZXJ5UGF0aCA9IHIucGF0aCwgcXVlcnlJZCA9IHIucXVlcnlJZDtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVBhdGggPSBQYXRoLnJlbGF0aXZlUGF0aChxdWVyeVBhdGgsIHBhdGgpO1xuICAgICAgICAgICAgdmFyIG9wID0gbmV3IE92ZXJ3cml0ZShPcGVyYXRpb25Tb3VyY2UuZm9yU2VydmVyVGFnZ2VkUXVlcnkocXVlcnlJZCksIHJlbGF0aXZlUGF0aCwgc25hcCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseVRhZ2dlZE9wZXJhdGlvbl8ocXVlcnlQYXRoLCBvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBRdWVyeSBtdXN0IGhhdmUgYmVlbiByZW1vdmVkIGFscmVhZHlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbHkgc2VydmVyIGRhdGEgdG8gYmUgbWVyZ2VkIGluIGZvciB0aGUgc3BlY2lmaWVkIHRhZ2dlZCBxdWVyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywgIU5vZGU+fSBjaGFuZ2VkQ2hpbGRyZW5cbiAgICAgKiBAcGFyYW0geyFudW1iZXJ9IHRhZ1xuICAgICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn0gRXZlbnRzIHRvIHJhaXNlLlxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS5hcHBseVRhZ2dlZFF1ZXJ5TWVyZ2UgPSBmdW5jdGlvbiAocGF0aCwgY2hhbmdlZENoaWxkcmVuLCB0YWcpIHtcbiAgICAgICAgdmFyIHF1ZXJ5S2V5ID0gdGhpcy5xdWVyeUtleUZvclRhZ18odGFnKTtcbiAgICAgICAgaWYgKHF1ZXJ5S2V5KSB7XG4gICAgICAgICAgICB2YXIgciA9IFN5bmNUcmVlLnBhcnNlUXVlcnlLZXlfKHF1ZXJ5S2V5KTtcbiAgICAgICAgICAgIHZhciBxdWVyeVBhdGggPSByLnBhdGgsIHF1ZXJ5SWQgPSByLnF1ZXJ5SWQ7XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVQYXRoID0gUGF0aC5yZWxhdGl2ZVBhdGgocXVlcnlQYXRoLCBwYXRoKTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VUcmVlID0gSW1tdXRhYmxlVHJlZS5mcm9tT2JqZWN0KGNoYW5nZWRDaGlsZHJlbik7XG4gICAgICAgICAgICB2YXIgb3AgPSBuZXcgTWVyZ2UoT3BlcmF0aW9uU291cmNlLmZvclNlcnZlclRhZ2dlZFF1ZXJ5KHF1ZXJ5SWQpLCByZWxhdGl2ZVBhdGgsIGNoYW5nZVRyZWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUYWdnZWRPcGVyYXRpb25fKHF1ZXJ5UGF0aCwgb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UndmUgYWxyZWFkeSByZW1vdmVkIHRoZSBxdWVyeS4gTm8gYmlnIGRlYWwsIGlnbm9yZSB0aGUgdXBkYXRlXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IGEgbGlzdGVuIGNvbXBsZXRlIGZvciBhIHRhZ2dlZCBxdWVyeVxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7IW51bWJlcn0gdGFnXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fSBFdmVudHMgdG8gcmFpc2UuXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLmFwcGx5VGFnZ2VkTGlzdGVuQ29tcGxldGUgPSBmdW5jdGlvbiAocGF0aCwgdGFnKSB7XG4gICAgICAgIHZhciBxdWVyeUtleSA9IHRoaXMucXVlcnlLZXlGb3JUYWdfKHRhZyk7XG4gICAgICAgIGlmIChxdWVyeUtleSkge1xuICAgICAgICAgICAgdmFyIHIgPSBTeW5jVHJlZS5wYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSk7XG4gICAgICAgICAgICB2YXIgcXVlcnlQYXRoID0gci5wYXRoLCBxdWVyeUlkID0gci5xdWVyeUlkO1xuICAgICAgICAgICAgdmFyIHJlbGF0aXZlUGF0aCA9IFBhdGgucmVsYXRpdmVQYXRoKHF1ZXJ5UGF0aCwgcGF0aCk7XG4gICAgICAgICAgICB2YXIgb3AgPSBuZXcgTGlzdGVuQ29tcGxldGUoT3BlcmF0aW9uU291cmNlLmZvclNlcnZlclRhZ2dlZFF1ZXJ5KHF1ZXJ5SWQpLCByZWxhdGl2ZVBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUYWdnZWRPcGVyYXRpb25fKHF1ZXJ5UGF0aCwgb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UndmUgYWxyZWFkeSByZW1vdmVkIHRoZSBxdWVyeS4gTm8gYmlnIGRlYWwsIGlnbm9yZSB0aGUgdXBkYXRlXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhbiBldmVudCBjYWxsYmFjayBmb3IgdGhlIHNwZWNpZmllZCBxdWVyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgICAqIEBwYXJhbSB7IUV2ZW50UmVnaXN0cmF0aW9ufSBldmVudFJlZ2lzdHJhdGlvblxuICAgICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn0gRXZlbnRzIHRvIHJhaXNlLlxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS5hZGRFdmVudFJlZ2lzdHJhdGlvbiA9IGZ1bmN0aW9uIChxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pIHtcbiAgICAgICAgdmFyIHBhdGggPSBxdWVyeS5wYXRoO1xuICAgICAgICB2YXIgc2VydmVyQ2FjaGUgPSBudWxsO1xuICAgICAgICB2YXIgZm91bmRBbmNlc3RvckRlZmF1bHRWaWV3ID0gZmFsc2U7XG4gICAgICAgIC8vIEFueSBjb3ZlcmluZyB3cml0ZXMgd2lsbCBuZWNlc3NhcmlseSBiZSBhdCB0aGUgcm9vdCwgc28gcmVhbGx5IGFsbCB3ZSBuZWVkIHRvIGZpbmQgaXMgdGhlIHNlcnZlciBjYWNoZS5cbiAgICAgICAgLy8gQ29uc2lkZXIgb3B0aW1pemluZyB0aGlzIG9uY2UgdGhlcmUncyBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIHdoYXQgYWN0dWFsIGJlaGF2aW9yIHdpbGwgYmUuXG4gICAgICAgIHRoaXMuc3luY1BvaW50VHJlZV8uZm9yZWFjaE9uUGF0aChwYXRoLCBmdW5jdGlvbiAocGF0aFRvU3luY1BvaW50LCBzcCkge1xuICAgICAgICAgICAgdmFyIHJlbGF0aXZlUGF0aCA9IFBhdGgucmVsYXRpdmVQYXRoKHBhdGhUb1N5bmNQb2ludCwgcGF0aCk7XG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSA9IHNlcnZlckNhY2hlIHx8IHNwLmdldENvbXBsZXRlU2VydmVyQ2FjaGUocmVsYXRpdmVQYXRoKTtcbiAgICAgICAgICAgIGZvdW5kQW5jZXN0b3JEZWZhdWx0VmlldyA9XG4gICAgICAgICAgICAgICAgZm91bmRBbmNlc3RvckRlZmF1bHRWaWV3IHx8IHNwLmhhc0NvbXBsZXRlVmlldygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHN5bmNQb2ludCA9IHRoaXMuc3luY1BvaW50VHJlZV8uZ2V0KHBhdGgpO1xuICAgICAgICBpZiAoIXN5bmNQb2ludCkge1xuICAgICAgICAgICAgc3luY1BvaW50ID0gbmV3IFN5bmNQb2ludCgpO1xuICAgICAgICAgICAgdGhpcy5zeW5jUG9pbnRUcmVlXyA9IHRoaXMuc3luY1BvaW50VHJlZV8uc2V0KHBhdGgsIHN5bmNQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgPVxuICAgICAgICAgICAgICAgIGZvdW5kQW5jZXN0b3JEZWZhdWx0VmlldyB8fCBzeW5jUG9pbnQuaGFzQ29tcGxldGVWaWV3KCk7XG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSA9IHNlcnZlckNhY2hlIHx8IHN5bmNQb2ludC5nZXRDb21wbGV0ZVNlcnZlckNhY2hlKFBhdGguRW1wdHkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZXJ2ZXJDYWNoZUNvbXBsZXRlO1xuICAgICAgICBpZiAoc2VydmVyQ2FjaGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2VydmVyQ2FjaGVDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZUNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgICAgICAgICAgdmFyIHN1YnRyZWUgPSB0aGlzLnN5bmNQb2ludFRyZWVfLnN1YnRyZWUocGF0aCk7XG4gICAgICAgICAgICBzdWJ0cmVlLmZvcmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGROYW1lLCBjaGlsZFN5bmNQb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciBjb21wbGV0ZUNhY2hlID0gY2hpbGRTeW5jUG9pbnQuZ2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShQYXRoLkVtcHR5KTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJDYWNoZSA9IHNlcnZlckNhY2hlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgY29tcGxldGVDYWNoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZpZXdBbHJlYWR5RXhpc3RzID0gc3luY1BvaW50LnZpZXdFeGlzdHNGb3JRdWVyeShxdWVyeSk7XG4gICAgICAgIGlmICghdmlld0FscmVhZHlFeGlzdHMgJiYgIXF1ZXJ5LmdldFF1ZXJ5UGFyYW1zKCkubG9hZHNBbGxEYXRhKCkpIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdHJhY2sgYSB0YWcgZm9yIHRoaXMgcXVlcnlcbiAgICAgICAgICAgIHZhciBxdWVyeUtleSA9IFN5bmNUcmVlLm1ha2VRdWVyeUtleV8ocXVlcnkpO1xuICAgICAgICAgICAgYXNzZXJ0KCEocXVlcnlLZXkgaW4gdGhpcy5xdWVyeVRvVGFnTWFwXyksICdWaWV3IGRvZXMgbm90IGV4aXN0LCBidXQgd2UgaGF2ZSBhIHRhZycpO1xuICAgICAgICAgICAgdmFyIHRhZyA9IFN5bmNUcmVlLmdldE5leHRRdWVyeVRhZ18oKTtcbiAgICAgICAgICAgIHRoaXMucXVlcnlUb1RhZ01hcF9bcXVlcnlLZXldID0gdGFnO1xuICAgICAgICAgICAgLy8gQ29lcmNlIHRvIHN0cmluZyB0byBhdm9pZCBzcGFyc2UgYXJyYXlzLlxuICAgICAgICAgICAgdGhpcy50YWdUb1F1ZXJ5TWFwX1snXycgKyB0YWddID0gcXVlcnlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyaXRlc0NhY2hlID0gdGhpcy5wZW5kaW5nV3JpdGVUcmVlXy5jaGlsZFdyaXRlcyhwYXRoKTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHN5bmNQb2ludC5hZGRFdmVudFJlZ2lzdHJhdGlvbihxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSk7XG4gICAgICAgIGlmICghdmlld0FscmVhZHlFeGlzdHMgJiYgIWZvdW5kQW5jZXN0b3JEZWZhdWx0Vmlldykge1xuICAgICAgICAgICAgdmFyIHZpZXcgLyoqIEB0eXBlICFWaWV3ICovID0gc3luY1BvaW50LnZpZXdGb3JRdWVyeShxdWVyeSk7XG4gICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHRoaXMuc2V0dXBMaXN0ZW5lcl8ocXVlcnksIHZpZXcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV2ZW50IGNhbGxiYWNrKHMpLlxuICAgICAqXG4gICAgICogSWYgcXVlcnkgaXMgdGhlIGRlZmF1bHQgcXVlcnksIHdlJ2xsIGNoZWNrIGFsbCBxdWVyaWVzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50UmVnaXN0cmF0aW9uLlxuICAgICAqIElmIGV2ZW50UmVnaXN0cmF0aW9uIGlzIG51bGwsIHdlJ2xsIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciB0aGUgc3BlY2lmaWVkIHF1ZXJ5L3F1ZXJpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICAgKiBAcGFyYW0gez9FdmVudFJlZ2lzdHJhdGlvbn0gZXZlbnRSZWdpc3RyYXRpb24gSWYgbnVsbCwgYWxsIGNhbGxiYWNrcyBhcmUgcmVtb3ZlZC5cbiAgICAgKiBAcGFyYW0ge0Vycm9yPX0gY2FuY2VsRXJyb3IgSWYgYSBjYW5jZWxFcnJvciBpcyBwcm92aWRlZCwgYXBwcm9wcmlhdGUgY2FuY2VsIGV2ZW50cyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn0gQ2FuY2VsIGV2ZW50cywgaWYgY2FuY2VsRXJyb3Igd2FzIHByb3ZpZGVkLlxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS5yZW1vdmVFdmVudFJlZ2lzdHJhdGlvbiA9IGZ1bmN0aW9uIChxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIGNhbmNlbEVycm9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIEZpbmQgdGhlIHN5bmNQb2ludCBmaXJzdC4gVGhlbiBkZWFsIHdpdGggd2hldGhlciBvciBub3QgaXQgaGFzIG1hdGNoaW5nIGxpc3RlbmVyc1xuICAgICAgICB2YXIgcGF0aCA9IHF1ZXJ5LnBhdGg7XG4gICAgICAgIHZhciBtYXliZVN5bmNQb2ludCA9IHRoaXMuc3luY1BvaW50VHJlZV8uZ2V0KHBhdGgpO1xuICAgICAgICB2YXIgY2FuY2VsRXZlbnRzID0gW107XG4gICAgICAgIC8vIEEgcmVtb3ZhbCBvbiBhIGRlZmF1bHQgcXVlcnkgYWZmZWN0cyBhbGwgcXVlcmllcyBhdCB0aGF0IGxvY2F0aW9uLiBBIHJlbW92YWwgb24gYW4gaW5kZXhlZCBxdWVyeSwgZXZlbiBvbmUgd2l0aG91dFxuICAgICAgICAvLyBvdGhlciBxdWVyeSBjb25zdHJhaW50cywgZG9lcyAqbm90KiBhZmZlY3QgYWxsIHF1ZXJpZXMgYXQgdGhhdCBsb2NhdGlvbi4gU28gdGhpcyBjaGVjayBtdXN0IGJlIGZvciAnZGVmYXVsdCcsIGFuZFxuICAgICAgICAvLyBub3QgbG9hZHNBbGxEYXRhKCkuXG4gICAgICAgIGlmIChtYXliZVN5bmNQb2ludCAmJlxuICAgICAgICAgICAgKHF1ZXJ5LnF1ZXJ5SWRlbnRpZmllcigpID09PSAnZGVmYXVsdCcgfHxcbiAgICAgICAgICAgICAgICBtYXliZVN5bmNQb2ludC52aWV3RXhpc3RzRm9yUXVlcnkocXVlcnkpKSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZSB7e3JlbW92ZWQ6ICFBcnJheS48IVF1ZXJ5PiwgZXZlbnRzOiAhQXJyYXkuPCFFdmVudD59fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgcmVtb3ZlZEFuZEV2ZW50cyA9IG1heWJlU3luY1BvaW50LnJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpO1xuICAgICAgICAgICAgaWYgKG1heWJlU3luY1BvaW50LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3luY1BvaW50VHJlZV8gPSB0aGlzLnN5bmNQb2ludFRyZWVfLnJlbW92ZShwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZW1vdmVkID0gcmVtb3ZlZEFuZEV2ZW50cy5yZW1vdmVkO1xuICAgICAgICAgICAgY2FuY2VsRXZlbnRzID0gcmVtb3ZlZEFuZEV2ZW50cy5ldmVudHM7XG4gICAgICAgICAgICAvLyBXZSBtYXkgaGF2ZSBqdXN0IHJlbW92ZWQgb25lIG9mIG1hbnkgbGlzdGVuZXJzIGFuZCBjYW4gc2hvcnQtY2lyY3VpdCB0aGlzIHdob2xlIHByb2Nlc3NcbiAgICAgICAgICAgIC8vIFdlIG1heSBhbHNvIG5vdCBoYXZlIHJlbW92ZWQgYSBkZWZhdWx0IGxpc3RlbmVyLCBpbiB3aGljaCBjYXNlIGFsbCBvZiB0aGUgZGVzY2VuZGFudCBsaXN0ZW5lcnMgc2hvdWxkIGFscmVhZHkgYmVcbiAgICAgICAgICAgIC8vIHByb3Blcmx5IHNldCB1cC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBTaW5jZSBpbmRleGVkIHF1ZXJpZXMgY2FuIHNoYWRvdyBpZiB0aGV5IGRvbid0IGhhdmUgb3RoZXIgcXVlcnkgY29uc3RyYWludHMsIGNoZWNrIGZvciBsb2Fkc0FsbERhdGEoKSwgaW5zdGVhZCBvZlxuICAgICAgICAgICAgLy8gcXVlcnlJZCA9PT0gJ2RlZmF1bHQnXG4gICAgICAgICAgICB2YXIgcmVtb3ZpbmdEZWZhdWx0ID0gLTEgIT09XG4gICAgICAgICAgICAgICAgcmVtb3ZlZC5maW5kSW5kZXgoZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxdWVyeS5nZXRRdWVyeVBhcmFtcygpLmxvYWRzQWxsRGF0YSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGNvdmVyZWQgPSB0aGlzLnN5bmNQb2ludFRyZWVfLmZpbmRPblBhdGgocGF0aCwgZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgcGFyZW50U3luY1BvaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudFN5bmNQb2ludC5oYXNDb21wbGV0ZVZpZXcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlbW92aW5nRGVmYXVsdCAmJiAhY292ZXJlZCkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJ0cmVlID0gdGhpcy5zeW5jUG9pbnRUcmVlXy5zdWJ0cmVlKHBhdGgpO1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBwb3RlbnRpYWxseSBjaGlsZCBsaXN0ZW5lcnMuIERldGVybWluZSB3aGF0IGlmIGFueSBsaXN0ZW5zIHdlIG5lZWQgdG8gc2VuZCBiZWZvcmUgZXhlY3V0aW5nIHRoZVxuICAgICAgICAgICAgICAgIC8vIHJlbW92YWxcbiAgICAgICAgICAgICAgICBpZiAoIXN1YnRyZWUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZm9sZCBvdmVyIG91ciBzdWJ0cmVlIGFuZCBjb2xsZWN0IHRoZSBsaXN0ZW5lcnMgdG8gc2VuZFxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Vmlld3MgPSB0aGlzLmNvbGxlY3REaXN0aW5jdFZpZXdzRm9yU3ViVHJlZV8oc3VidHJlZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9rLCB3ZSd2ZSBjb2xsZWN0ZWQgYWxsIHRoZSBsaXN0ZW5zIHdlIG5lZWQuIFNldCB0aGVtIHVwLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1ZpZXdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlldyA9IG5ld1ZpZXdzW2ldLCBuZXdRdWVyeSA9IHZpZXcuZ2V0UXVlcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuY3JlYXRlTGlzdGVuZXJGb3JWaWV3Xyh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuUHJvdmlkZXJfLnN0YXJ0TGlzdGVuaW5nKFN5bmNUcmVlLnF1ZXJ5Rm9yTGlzdGVuaW5nXyhuZXdRdWVyeSksIHRoaXMudGFnRm9yUXVlcnlfKG5ld1F1ZXJ5KSwgbGlzdGVuZXIuaGFzaEZuLCBsaXN0ZW5lci5vbkNvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUncyBub3RoaW5nIGJlbG93IHVzLCBzbyBub3RoaW5nIHdlIG5lZWQgdG8gc3RhcnQgbGlzdGVuaW5nIG9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgcmVtb3ZlZCBhbnl0aGluZyBhbmQgd2UncmUgbm90IGNvdmVyZWQgYnkgYSBoaWdoZXIgdXAgbGlzdGVuLCB3ZSBuZWVkIHRvIHN0b3AgbGlzdGVuaW5nIG9uIHRoaXMgcXVlcnlcbiAgICAgICAgICAgIC8vIFRoZSBhYm92ZSBibG9jayBoYXMgdXMgY292ZXJlZCBpbiB0ZXJtcyBvZiBtYWtpbmcgc3VyZSB3ZSdyZSBzZXQgdXAgb24gbGlzdGVucyBsb3dlciBpbiB0aGUgdHJlZS5cbiAgICAgICAgICAgIC8vIEFsc28sIG5vdGUgdGhhdCBpZiB3ZSBoYXZlIGEgY2FuY2VsRXJyb3IsIGl0J3MgYWxyZWFkeSBiZWVuIHJlbW92ZWQgYXQgdGhlIHByb3ZpZGVyIGxldmVsLlxuICAgICAgICAgICAgaWYgKCFjb3ZlcmVkICYmIHJlbW92ZWQubGVuZ3RoID4gMCAmJiAhY2FuY2VsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZW1vdmVkIGEgZGVmYXVsdCwgdGhlbiB3ZSB3ZXJlbid0IGxpc3RlbmluZyBvbiBhbnkgb2YgdGhlIG90aGVyIHF1ZXJpZXMgaGVyZS4gSnVzdCBjYW5jZWwgdGhlIG9uZVxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQuIE90aGVyd2lzZSwgd2UgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggYW5kIGNhbmNlbCBlYWNoIGluZGl2aWR1YWwgcXVlcnlcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZpbmdEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHRhZyBkZWZhdWx0IGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdFRhZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuUHJvdmlkZXJfLnN0b3BMaXN0ZW5pbmcoU3luY1RyZWUucXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5KSwgZGVmYXVsdFRhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5VG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWdUb1JlbW92ZSA9IF90aGlzLnF1ZXJ5VG9UYWdNYXBfW1N5bmNUcmVlLm1ha2VRdWVyeUtleV8ocXVlcnlUb1JlbW92ZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubGlzdGVuUHJvdmlkZXJfLnN0b3BMaXN0ZW5pbmcoU3luY1RyZWUucXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5VG9SZW1vdmUpLCB0YWdUb1JlbW92ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdywgY2xlYXIgYWxsIG9mIHRoZSB0YWdzIHdlJ3JlIHRyYWNraW5nIGZvciB0aGUgcmVtb3ZlZCBsaXN0ZW5zXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVRhZ3NfKHJlbW92ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8tb3AsIHRoaXMgbGlzdGVuZXIgbXVzdCd2ZSBiZWVuIGFscmVhZHkgcmVtb3ZlZFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW5jZWxFdmVudHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29tcGxldGUgY2FjaGUsIGlmIHdlIGhhdmUgb25lLCBvZiB0aGUgZGF0YSBhdCBhIHBhcnRpY3VsYXIgcGF0aC4gVGhlIGxvY2F0aW9uIG11c3QgaGF2ZSBhIGxpc3RlbmVyIGFib3ZlXG4gICAgICogaXQsIGJ1dCBhcyB0aGlzIGlzIG9ubHkgdXNlZCBieSB0cmFuc2FjdGlvbiBjb2RlLCB0aGF0IHNob3VsZCBhbHdheXMgYmUgdGhlIGNhc2UgYW55d2F5cy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIHdpbGwgKmluY2x1ZGUqIGhpZGRlbiB3cml0ZXMgZnJvbSB0cmFuc2FjdGlvbiB3aXRoIGFwcGx5TG9jYWxseSBzZXQgdG8gZmFsc2UuXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aCBUaGUgcGF0aCB0byB0aGUgZGF0YSB3ZSB3YW50XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPj19IHdyaXRlSWRzVG9FeGNsdWRlIEEgc3BlY2lmaWMgc2V0IHRvIGJlIGV4Y2x1ZGVkXG4gICAgICogQHJldHVybiB7P05vZGV9XG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUgPSBmdW5jdGlvbiAocGF0aCwgd3JpdGVJZHNUb0V4Y2x1ZGUpIHtcbiAgICAgICAgdmFyIGluY2x1ZGVIaWRkZW5TZXRzID0gdHJ1ZTtcbiAgICAgICAgdmFyIHdyaXRlVHJlZSA9IHRoaXMucGVuZGluZ1dyaXRlVHJlZV87XG4gICAgICAgIHZhciBzZXJ2ZXJDYWNoZSA9IHRoaXMuc3luY1BvaW50VHJlZV8uZmluZE9uUGF0aChwYXRoLCBmdW5jdGlvbiAocGF0aFNvRmFyLCBzeW5jUG9pbnQpIHtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVBhdGggPSBQYXRoLnJlbGF0aXZlUGF0aChwYXRoU29GYXIsIHBhdGgpO1xuICAgICAgICAgICAgdmFyIHNlcnZlckNhY2hlID0gc3luY1BvaW50LmdldENvbXBsZXRlU2VydmVyQ2FjaGUocmVsYXRpdmVQYXRoKTtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJDYWNoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJDYWNoZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3cml0ZVRyZWUuY2FsY0NvbXBsZXRlRXZlbnRDYWNoZShwYXRoLCBzZXJ2ZXJDYWNoZSwgd3JpdGVJZHNUb0V4Y2x1ZGUsIGluY2x1ZGVIaWRkZW5TZXRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgY29sbGFwc2VzIG11bHRpcGxlIHVuZmlsdGVyZWQgdmlld3MgaW50byBhIHNpbmdsZSB2aWV3LCBzaW5jZSB3ZSBvbmx5IG5lZWQgYSBzaW5nbGVcbiAgICAgKiBsaXN0ZW5lciBmb3IgdGhlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUltbXV0YWJsZVRyZWUuPCFTeW5jUG9pbnQ+fSBzdWJ0cmVlXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhVmlldz59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuY29sbGVjdERpc3RpbmN0Vmlld3NGb3JTdWJUcmVlXyA9IGZ1bmN0aW9uIChzdWJ0cmVlKSB7XG4gICAgICAgIHJldHVybiBzdWJ0cmVlLmZvbGQoZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgbWF5YmVDaGlsZFN5bmNQb2ludCwgY2hpbGRNYXApIHtcbiAgICAgICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50ICYmIG1heWJlQ2hpbGRTeW5jUG9pbnQuaGFzQ29tcGxldGVWaWV3KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcGxldGVWaWV3ID0gbWF5YmVDaGlsZFN5bmNQb2ludC5nZXRDb21wbGV0ZVZpZXcoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2NvbXBsZXRlVmlld107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyBjb21wbGV0ZSB2aWV3IGhlcmUsIGZsYXR0ZW4gYW55IGRlZXBlciBsaXN0ZW5zIGludG8gYW4gYXJyYXlcbiAgICAgICAgICAgICAgICB2YXIgdmlld3NfMSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdzXzEgPSBtYXliZUNoaWxkU3luY1BvaW50LmdldFF1ZXJ5Vmlld3MoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yRWFjaChjaGlsZE1hcCwgZnVuY3Rpb24gKGtleSwgY2hpbGRWaWV3cykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3c18xID0gdmlld3NfMS5jb25jYXQoY2hpbGRWaWV3cyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdzXzE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshQXJyYXkuPCFRdWVyeT59IHF1ZXJpZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS5yZW1vdmVUYWdzXyA9IGZ1bmN0aW9uIChxdWVyaWVzKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcXVlcmllcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdmFyIHJlbW92ZWRRdWVyeSA9IHF1ZXJpZXNbal07XG4gICAgICAgICAgICBpZiAoIXJlbW92ZWRRdWVyeS5nZXRRdWVyeVBhcmFtcygpLmxvYWRzQWxsRGF0YSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGhhdmUgYSB0YWcgZm9yIHRoaXNcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZFF1ZXJ5S2V5ID0gU3luY1RyZWUubWFrZVF1ZXJ5S2V5XyhyZW1vdmVkUXVlcnkpO1xuICAgICAgICAgICAgICAgIHZhciByZW1vdmVkUXVlcnlUYWcgPSB0aGlzLnF1ZXJ5VG9UYWdNYXBfW3JlbW92ZWRRdWVyeUtleV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucXVlcnlUb1RhZ01hcF9bcmVtb3ZlZFF1ZXJ5S2V5XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50YWdUb1F1ZXJ5TWFwX1snXycgKyByZW1vdmVkUXVlcnlUYWddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIGEgcXVlcnkgdG8gYSBxdWVyeSB3ZSBzZW5kIHRoZSBzZXJ2ZXIgZm9yIGxpc3RlbmluZ1xuICAgICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgICAqIEByZXR1cm4geyFRdWVyeX0gVGhlIG5vcm1hbGl6ZWQgcXVlcnlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFN5bmNUcmVlLnF1ZXJ5Rm9yTGlzdGVuaW5nXyA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICBpZiAocXVlcnkuZ2V0UXVlcnlQYXJhbXMoKS5sb2Fkc0FsbERhdGEoKSAmJlxuICAgICAgICAgICAgIXF1ZXJ5LmdldFF1ZXJ5UGFyYW1zKCkuaXNEZWZhdWx0KCkpIHtcbiAgICAgICAgICAgIC8vIFdlIHRyZWF0IHF1ZXJpZXMgdGhhdCBsb2FkIGFsbCBkYXRhIGFzIGRlZmF1bHQgcXVlcmllc1xuICAgICAgICAgICAgLy8gQ2FzdCBpcyBuZWNlc3NhcnkgYmVjYXVzZSByZWYoKSB0ZWNobmljYWxseSByZXR1cm5zIEZpcmViYXNlIHdoaWNoIGlzIGFjdHVhbGx5IGZiLmFwaS5GaXJlYmFzZSB3aGljaCBpbmhlcml0c1xuICAgICAgICAgICAgLy8gZnJvbSBRdWVyeVxuICAgICAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7IVF1ZXJ5fSAqLyBxdWVyeS5nZXRSZWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9yIGEgZ2l2ZW4gbmV3IGxpc3RlbiwgbWFuYWdlIHRoZSBkZS1kdXBsaWNhdGlvbiBvZiBvdXRzdGFuZGluZyBzdWJzY3JpcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAgICogQHBhcmFtIHshVmlld30gdmlld1xuICAgICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn0gVGhpcyBtZXRob2QgY2FuIHJldHVybiBldmVudHMgdG8gc3VwcG9ydCBzeW5jaHJvbm91cyBkYXRhIHNvdXJjZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS5zZXR1cExpc3RlbmVyXyA9IGZ1bmN0aW9uIChxdWVyeSwgdmlldykge1xuICAgICAgICB2YXIgcGF0aCA9IHF1ZXJ5LnBhdGg7XG4gICAgICAgIHZhciB0YWcgPSB0aGlzLnRhZ0ZvclF1ZXJ5XyhxdWVyeSk7XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuY3JlYXRlTGlzdGVuZXJGb3JWaWV3Xyh2aWV3KTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMubGlzdGVuUHJvdmlkZXJfLnN0YXJ0TGlzdGVuaW5nKFN5bmNUcmVlLnF1ZXJ5Rm9yTGlzdGVuaW5nXyhxdWVyeSksIHRhZywgbGlzdGVuZXIuaGFzaEZuLCBsaXN0ZW5lci5vbkNvbXBsZXRlKTtcbiAgICAgICAgdmFyIHN1YnRyZWUgPSB0aGlzLnN5bmNQb2ludFRyZWVfLnN1YnRyZWUocGF0aCk7XG4gICAgICAgIC8vIFRoZSByb290IG9mIHRoaXMgc3VidHJlZSBoYXMgb3VyIHF1ZXJ5LiBXZSdyZSBoZXJlIGJlY2F1c2Ugd2UgZGVmaW5pdGVseSBuZWVkIHRvIHNlbmQgYSBsaXN0ZW4gZm9yIHRoYXQsIGJ1dCB3ZVxuICAgICAgICAvLyBtYXkgbmVlZCB0byBzaGFkb3cgb3RoZXIgbGlzdGVucyBhcyB3ZWxsLlxuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICBhc3NlcnQoIXN1YnRyZWUudmFsdWUuaGFzQ29tcGxldGVWaWV3KCksIFwiSWYgd2UncmUgYWRkaW5nIGEgcXVlcnksIGl0IHNob3VsZG4ndCBiZSBzaGFkb3dlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNoYWRvdyBldmVyeXRoaW5nIGF0IG9yIGJlbG93IHRoaXMgbG9jYXRpb24sIHRoaXMgaXMgYSBkZWZhdWx0IGxpc3RlbmVyLlxuICAgICAgICAgICAgdmFyIHF1ZXJpZXNUb1N0b3AgPSBzdWJ0cmVlLmZvbGQoZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgbWF5YmVDaGlsZFN5bmNQb2ludCwgY2hpbGRNYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGF0aC5pc0VtcHR5KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVDaGlsZFN5bmNQb2ludCAmJlxuICAgICAgICAgICAgICAgICAgICBtYXliZUNoaWxkU3luY1BvaW50Lmhhc0NvbXBsZXRlVmlldygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWF5YmVDaGlsZFN5bmNQb2ludC5nZXRDb21wbGV0ZVZpZXcoKS5nZXRRdWVyeSgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGRlZmF1bHQgbGlzdGVuZXIgaGVyZSwgZmxhdHRlbiBhbnkgZGVlcGVyIHF1ZXJpZXMgaW50byBhbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICB2YXIgcXVlcmllc18xID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVzXzEgPSBxdWVyaWVzXzEuY29uY2F0KG1heWJlQ2hpbGRTeW5jUG9pbnQuZ2V0UXVlcnlWaWV3cygpLm1hcChmdW5jdGlvbiAodmlldykgeyByZXR1cm4gdmlldy5nZXRRdWVyeSgpOyB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yRWFjaChjaGlsZE1hcCwgZnVuY3Rpb24gKGtleSwgY2hpbGRRdWVyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVzXzEgPSBxdWVyaWVzXzEuY29uY2F0KGNoaWxkUXVlcmllcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVlcmllc18xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWVyaWVzVG9TdG9wLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5VG9TdG9wID0gcXVlcmllc1RvU3RvcFtpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlblByb3ZpZGVyXy5zdG9wTGlzdGVuaW5nKFN5bmNUcmVlLnF1ZXJ5Rm9yTGlzdGVuaW5nXyhxdWVyeVRvU3RvcCksIHRoaXMudGFnRm9yUXVlcnlfKHF1ZXJ5VG9TdG9wKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHshVmlld30gdmlld1xuICAgICAqIEByZXR1cm4ge3toYXNoRm46IGZ1bmN0aW9uKCksIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCFzdHJpbmcsICopfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS5jcmVhdGVMaXN0ZW5lckZvclZpZXdfID0gZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHF1ZXJ5ID0gdmlldy5nZXRRdWVyeSgpO1xuICAgICAgICB2YXIgdGFnID0gdGhpcy50YWdGb3JRdWVyeV8ocXVlcnkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGFzaEZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlID0gdmlldy5nZXRTZXJ2ZXJDYWNoZSgpIHx8IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS5oYXNoKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFwcGx5VGFnZ2VkTGlzdGVuQ29tcGxldGUocXVlcnkucGF0aCwgdGFnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5hcHBseUxpc3RlbkNvbXBsZXRlKHF1ZXJ5LnBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIGxpc3RlbiBmYWlsZWQsIGtpbGwgYWxsIG9mIHRoZSBsaXN0ZW5lcnMgaGVyZSwgbm90IGp1c3QgdGhlIG9uZSB0aGF0IHRyaWdnZXJlZCB0aGUgZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBuZWVkIHRvIGJlIHNjb3BlZCB0byBqdXN0IHRoaXMgbGlzdGVuZXIgaWYgd2UgY2hhbmdlIHBlcm1pc3Npb25zIG9uIGZpbHRlcmVkIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IGVycm9yRm9yU2VydmVyQ29kZShzdGF0dXMsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHF1ZXJ5LCBcbiAgICAgICAgICAgICAgICAgICAgLypldmVudFJlZ2lzdHJhdGlvbiovIG51bGwsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHF1ZXJ5LCBjb21wdXRlcyBhIFwicXVlcnlLZXlcIiBzdWl0YWJsZSBmb3IgdXNlIGluIG91ciBxdWVyeVRvVGFnTWFwXy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBTeW5jVHJlZS5tYWtlUXVlcnlLZXlfID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBxdWVyeS5wYXRoLnRvU3RyaW5nKCkgKyAnJCcgKyBxdWVyeS5xdWVyeUlkZW50aWZpZXIoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgcXVlcnlLZXkgKGNyZWF0ZWQgYnkgbWFrZVF1ZXJ5S2V5KSwgcGFyc2UgaXQgYmFjayBpbnRvIGEgcGF0aCBhbmQgcXVlcnlJZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gcXVlcnlLZXlcbiAgICAgKiBAcmV0dXJuIHt7cXVlcnlJZDogIXN0cmluZywgcGF0aDogIVBhdGh9fVxuICAgICAqL1xuICAgIFN5bmNUcmVlLnBhcnNlUXVlcnlLZXlfID0gZnVuY3Rpb24gKHF1ZXJ5S2V5KSB7XG4gICAgICAgIHZhciBzcGxpdEluZGV4ID0gcXVlcnlLZXkuaW5kZXhPZignJCcpO1xuICAgICAgICBhc3NlcnQoc3BsaXRJbmRleCAhPT0gLTEgJiYgc3BsaXRJbmRleCA8IHF1ZXJ5S2V5Lmxlbmd0aCAtIDEsICdCYWQgcXVlcnlLZXkuJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBxdWVyeUlkOiBxdWVyeUtleS5zdWJzdHIoc3BsaXRJbmRleCArIDEpLFxuICAgICAgICAgICAgcGF0aDogbmV3IFBhdGgocXVlcnlLZXkuc3Vic3RyKDAsIHNwbGl0SW5kZXgpKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBxdWVyeSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHRhZywgaWYgd2UgaGF2ZSBvbmVcbiAgICAgKiBAcGFyYW0geyFudW1iZXJ9IHRhZ1xuICAgICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUucXVlcnlLZXlGb3JUYWdfID0gZnVuY3Rpb24gKHRhZykge1xuICAgICAgICByZXR1cm4gdGhpcy50YWdUb1F1ZXJ5TWFwX1snXycgKyB0YWddO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB0YWcgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBxdWVyeS5cbiAgICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICAgKiBAcmV0dXJuIHs/bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLnRhZ0ZvclF1ZXJ5XyA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICB2YXIgcXVlcnlLZXkgPSBTeW5jVHJlZS5tYWtlUXVlcnlLZXlfKHF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuIHNhZmVHZXQodGhpcy5xdWVyeVRvVGFnTWFwXywgcXVlcnlLZXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhdGljIGFjY2Vzc29yIGZvciBxdWVyeSB0YWdzLlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFN5bmNUcmVlLmdldE5leHRRdWVyeVRhZ18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBTeW5jVHJlZS5uZXh0UXVlcnlUYWdfKys7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciBtZXRob2QgdG8gYXBwbHkgdGFnZ2VkIG9wZXJhdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHF1ZXJ5UGF0aFxuICAgICAqIEBwYXJhbSB7IU9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLmFwcGx5VGFnZ2VkT3BlcmF0aW9uXyA9IGZ1bmN0aW9uIChxdWVyeVBhdGgsIG9wZXJhdGlvbikge1xuICAgICAgICB2YXIgc3luY1BvaW50ID0gdGhpcy5zeW5jUG9pbnRUcmVlXy5nZXQocXVlcnlQYXRoKTtcbiAgICAgICAgYXNzZXJ0KHN5bmNQb2ludCwgXCJNaXNzaW5nIHN5bmMgcG9pbnQgZm9yIHF1ZXJ5IHRhZyB0aGF0IHdlJ3JlIHRyYWNraW5nXCIpO1xuICAgICAgICB2YXIgd3JpdGVzQ2FjaGUgPSB0aGlzLnBlbmRpbmdXcml0ZVRyZWVfLmNoaWxkV3JpdGVzKHF1ZXJ5UGF0aCk7XG4gICAgICAgIHJldHVybiBzeW5jUG9pbnQuYXBwbHlPcGVyYXRpb24ob3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgXG4gICAgICAgIC8qc2VydmVyQ2FjaGU9Ki8gbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciBtZXRob2QgdGhhdCB2aXNpdHMgYWxsIGRlc2NlbmRhbnQgYW5kIGFuY2VzdG9yIFN5bmNQb2ludHMsIGFwcGx5aW5nIHRoZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBOT1RFUzpcbiAgICAgKiAtIERlc2NlbmRhbnQgU3luY1BvaW50cyB3aWxsIGJlIHZpc2l0ZWQgZmlyc3QgKHNpbmNlIHdlIHJhaXNlIGV2ZW50cyBkZXB0aC1maXJzdCkuXG4gIFxuICAgICAqIC0gV2UgY2FsbCBhcHBseU9wZXJhdGlvbigpIG9uIGVhY2ggU3luY1BvaW50IHBhc3NpbmcgdGhyZWUgdGhpbmdzOlxuICAgICAqICAgMS4gQSB2ZXJzaW9uIG9mIHRoZSBPcGVyYXRpb24gdGhhdCBoYXMgYmVlbiBtYWRlIHJlbGF0aXZlIHRvIHRoZSBTeW5jUG9pbnQgbG9jYXRpb24uXG4gICAgICogICAyLiBBIFdyaXRlVHJlZVJlZiBvZiBhbnkgd3JpdGVzIHdlIGhhdmUgY2FjaGVkIGF0IHRoZSBTeW5jUG9pbnQgbG9jYXRpb24uXG4gICAgICogICAzLiBBIHNuYXBzaG90IE5vZGUgd2l0aCBjYWNoZWQgc2VydmVyIGRhdGEsIGlmIHdlIGhhdmUgaXQuXG4gIFxuICAgICAqIC0gV2UgY29uY2F0ZW5hdGUgYWxsIG9mIHRoZSBldmVudHMgcmV0dXJuZWQgYnkgZWFjaCBTeW5jUG9pbnQgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHshT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfID0gZnVuY3Rpb24gKG9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseU9wZXJhdGlvbkhlbHBlcl8ob3BlcmF0aW9uLCB0aGlzLnN5bmNQb2ludFRyZWVfLCBcbiAgICAgICAgLypzZXJ2ZXJDYWNoZT0qLyBudWxsLCB0aGlzLnBlbmRpbmdXcml0ZVRyZWVfLmNoaWxkV3JpdGVzKFBhdGguRW1wdHkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZSBoZWxwZXIgZm9yIGFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzX1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyFPcGVyYXRpb259IG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7SW1tdXRhYmxlVHJlZS48IVN5bmNQb2ludD59IHN5bmNQb2ludFRyZWVcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBzZXJ2ZXJDYWNoZVxuICAgICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzQ2FjaGVcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59XG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLmFwcGx5T3BlcmF0aW9uSGVscGVyXyA9IGZ1bmN0aW9uIChvcGVyYXRpb24sIHN5bmNQb2ludFRyZWUsIHNlcnZlckNhY2hlLCB3cml0ZXNDYWNoZSkge1xuICAgICAgICBpZiAob3BlcmF0aW9uLnBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyhvcGVyYXRpb24sIHN5bmNQb2ludFRyZWUsIHNlcnZlckNhY2hlLCB3cml0ZXNDYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgc3luY1BvaW50ID0gc3luY1BvaW50VHJlZS5nZXQoUGF0aC5FbXB0eSk7XG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGNhY2hlZCBzZXJ2ZXIgZGF0YSwgc2VlIGlmIHdlIGNhbiBnZXQgaXQgZnJvbSB0aGlzIFN5bmNQb2ludC5cbiAgICAgICAgICAgIGlmIChzZXJ2ZXJDYWNoZSA9PSBudWxsICYmIHN5bmNQb2ludCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VydmVyQ2FjaGUgPSBzeW5jUG9pbnQuZ2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShQYXRoLkVtcHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBldmVudHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5hbWUgPSBvcGVyYXRpb24ucGF0aC5nZXRGcm9udCgpO1xuICAgICAgICAgICAgdmFyIGNoaWxkT3BlcmF0aW9uID0gb3BlcmF0aW9uLm9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZSk7XG4gICAgICAgICAgICB2YXIgY2hpbGRUcmVlID0gc3luY1BvaW50VHJlZS5jaGlsZHJlbi5nZXQoY2hpbGROYW1lKTtcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUgJiYgY2hpbGRPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRTZXJ2ZXJDYWNoZSA9IHNlcnZlckNhY2hlXG4gICAgICAgICAgICAgICAgICAgID8gc2VydmVyQ2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkV3JpdGVzQ2FjaGUgPSB3cml0ZXNDYWNoZS5jaGlsZChjaGlsZE5hbWUpO1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQodGhpcy5hcHBseU9wZXJhdGlvbkhlbHBlcl8oY2hpbGRPcGVyYXRpb24sIGNoaWxkVHJlZSwgY2hpbGRTZXJ2ZXJDYWNoZSwgY2hpbGRXcml0ZXNDYWNoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN5bmNQb2ludCkge1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1BvaW50LmFwcGx5T3BlcmF0aW9uKG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmUgaGVscGVyIGZvciBhcHBseU9wZXJhdGlvblRvU3luY1BvaW50c19cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHshT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0ge0ltbXV0YWJsZVRyZWUuPCFTeW5jUG9pbnQ+fSBzeW5jUG9pbnRUcmVlXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gc2VydmVyQ2FjaGVcbiAgICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fVxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS5hcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyA9IGZ1bmN0aW9uIChvcGVyYXRpb24sIHN5bmNQb2ludFRyZWUsIHNlcnZlckNhY2hlLCB3cml0ZXNDYWNoZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3luY1BvaW50ID0gc3luY1BvaW50VHJlZS5nZXQoUGF0aC5FbXB0eSk7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgY2FjaGVkIHNlcnZlciBkYXRhLCBzZWUgaWYgd2UgY2FuIGdldCBpdCBmcm9tIHRoaXMgU3luY1BvaW50LlxuICAgICAgICBpZiAoc2VydmVyQ2FjaGUgPT0gbnVsbCAmJiBzeW5jUG9pbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2VydmVyQ2FjaGUgPSBzeW5jUG9pbnQuZ2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShQYXRoLkVtcHR5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRzID0gW107XG4gICAgICAgIHN5bmNQb2ludFRyZWUuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbChmdW5jdGlvbiAoY2hpbGROYW1lLCBjaGlsZFRyZWUpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZFNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGVcbiAgICAgICAgICAgICAgICA/IHNlcnZlckNhY2hlLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSlcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICB2YXIgY2hpbGRXcml0ZXNDYWNoZSA9IHdyaXRlc0NhY2hlLmNoaWxkKGNoaWxkTmFtZSk7XG4gICAgICAgICAgICB2YXIgY2hpbGRPcGVyYXRpb24gPSBvcGVyYXRpb24ub3BlcmF0aW9uRm9yQ2hpbGQoY2hpbGROYW1lKTtcbiAgICAgICAgICAgIGlmIChjaGlsZE9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoX3RoaXMuYXBwbHlPcGVyYXRpb25EZXNjZW5kYW50c0hlbHBlcl8oY2hpbGRPcGVyYXRpb24sIGNoaWxkVHJlZSwgY2hpbGRTZXJ2ZXJDYWNoZSwgY2hpbGRXcml0ZXNDYWNoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN5bmNQb2ludCkge1xuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jUG9pbnQuYXBwbHlPcGVyYXRpb24ob3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhdGljIHRyYWNrZXIgZm9yIG5leHQgcXVlcnkgdGFnLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBTeW5jVHJlZS5uZXh0UXVlcnlUYWdfID0gMTtcbiAgICByZXR1cm4gU3luY1RyZWU7XG59KCkpO1xuZXhwb3J0IHsgU3luY1RyZWUgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9TeW5jVHJlZS5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGZpbmRLZXksIGZvckVhY2gsIHNhZmVHZXQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydGlvbkVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4vdXRpbC9QYXRoJztcbmltcG9ydCB7IENvbXBvdW5kV3JpdGUgfSBmcm9tICcuL0NvbXBvdW5kV3JpdGUnO1xuaW1wb3J0IHsgUFJJT1JJVFlfSU5ERVggfSBmcm9tICcuL3NuYXAvaW5kZXhlcy9Qcmlvcml0eUluZGV4JztcbmltcG9ydCB7IENoaWxkcmVuTm9kZSB9IGZyb20gJy4vc25hcC9DaGlsZHJlbk5vZGUnO1xuLyoqXG4gKiBXcml0ZVRyZWUgdHJhY2tzIGFsbCBwZW5kaW5nIHVzZXItaW5pdGlhdGVkIHdyaXRlcyBhbmQgaGFzIG1ldGhvZHMgdG8gY2FsY3VsYXRlIHRoZSByZXN1bHQgb2YgbWVyZ2luZyB0aGVtXG4gKiB3aXRoIHVuZGVybHlpbmcgc2VydmVyIGRhdGEgKHRvIGNyZWF0ZSBcImV2ZW50IGNhY2hlXCIgZGF0YSkuICBQZW5kaW5nIHdyaXRlcyBhcmUgYWRkZWQgd2l0aCBhZGRPdmVyd3JpdGUoKVxuICogYW5kIGFkZE1lcmdlKCksIGFuZCByZW1vdmVkIHdpdGggcmVtb3ZlV3JpdGUoKS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFdyaXRlVHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXcml0ZVRyZWUoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHRyZWUgdHJhY2tpbmcgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBhbGwgdmlzaWJsZSB3cml0ZXMuICBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdHJhbnNhY3Rpb25zIHdpdGhcbiAgICAgICAgICogYXBwbHlMb2NhbGx5PWZhbHNlIG9yIHdyaXRlcyB0aGF0IGFyZSBjb21wbGV0ZWx5IHNoYWRvd2VkIGJ5IG90aGVyIHdyaXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUgeyFDb21wb3VuZFdyaXRlfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aXNpYmxlV3JpdGVzXyA9IENvbXBvdW5kV3JpdGUuRW1wdHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgYWxsIHBlbmRpbmcgd3JpdGVzLCByZWdhcmRsZXNzIG9mIHZpc2liaWxpdHkgYW5kIHNoYWRvd2VkLW5lc3MuICBVc2VkIHRvIGNhbGN1bGF0ZSBhcmJpdHJhcnlcbiAgICAgICAgICogc2V0cyBvZiB0aGUgY2hhbmdlZCBkYXRhLCBzdWNoIGFzIGhpZGRlbiB3cml0ZXMgKGZyb20gdHJhbnNhY3Rpb25zKSBvciBjaGFuZ2VzIHdpdGggY2VydGFpbiB3cml0ZXMgZXhjbHVkZWQgKGFsc29cbiAgICAgICAgICogdXNlZCBieSB0cmFuc2FjdGlvbnMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5LjwhV3JpdGVSZWNvcmQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbGxXcml0ZXNfID0gW107XG4gICAgICAgIHRoaXMubGFzdFdyaXRlSWRfID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBXcml0ZVRyZWVSZWYgZm9yIHRoZSBnaXZlbiBwYXRoLiBGb3IgdXNlIHdpdGggYSBuZXcgc3luYyBwb2ludCBhdCB0aGUgZ2l2ZW4gcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcmV0dXJuIHshV3JpdGVUcmVlUmVmfVxuICAgICAqL1xuICAgIFdyaXRlVHJlZS5wcm90b3R5cGUuY2hpbGRXcml0ZXMgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRlVHJlZVJlZihwYXRoLCB0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlY29yZCBhIG5ldyBvdmVyd3JpdGUgZnJvbSB1c2VyIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshTm9kZX0gc25hcFxuICAgICAqIEBwYXJhbSB7IW51bWJlcn0gd3JpdGVJZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHZpc2libGUgVGhpcyBpcyBzZXQgdG8gZmFsc2UgYnkgc29tZSB0cmFuc2FjdGlvbnMuIEl0IHNob3VsZCBiZSBleGNsdWRlZCBmcm9tIGV2ZW50IGNhY2hlc1xuICAgICAqL1xuICAgIFdyaXRlVHJlZS5wcm90b3R5cGUuYWRkT3ZlcndyaXRlID0gZnVuY3Rpb24gKHBhdGgsIHNuYXAsIHdyaXRlSWQsIHZpc2libGUpIHtcbiAgICAgICAgYXNzZXJ0KHdyaXRlSWQgPiB0aGlzLmxhc3RXcml0ZUlkXywgJ1N0YWNraW5nIGFuIG9sZGVyIHdyaXRlIG9uIHRvcCBvZiBuZXdlciBvbmVzJyk7XG4gICAgICAgIGlmICh2aXNpYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZpc2libGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsV3JpdGVzXy5wdXNoKHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICBzbmFwOiBzbmFwLFxuICAgICAgICAgICAgd3JpdGVJZDogd3JpdGVJZCxcbiAgICAgICAgICAgIHZpc2libGU6IHZpc2libGVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVXcml0ZXNfID0gdGhpcy52aXNpYmxlV3JpdGVzXy5hZGRXcml0ZShwYXRoLCBzbmFwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RXcml0ZUlkXyA9IHdyaXRlSWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWNvcmQgYSBuZXcgbWVyZ2UgZnJvbSB1c2VyIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsICFOb2RlPn0gY2hhbmdlZENoaWxkcmVuXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB3cml0ZUlkXG4gICAgICovXG4gICAgV3JpdGVUcmVlLnByb3RvdHlwZS5hZGRNZXJnZSA9IGZ1bmN0aW9uIChwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpIHtcbiAgICAgICAgYXNzZXJ0KHdyaXRlSWQgPiB0aGlzLmxhc3RXcml0ZUlkXywgJ1N0YWNraW5nIGFuIG9sZGVyIG1lcmdlIG9uIHRvcCBvZiBuZXdlciBvbmVzJyk7XG4gICAgICAgIHRoaXMuYWxsV3JpdGVzXy5wdXNoKHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hhbmdlZENoaWxkcmVuLFxuICAgICAgICAgICAgd3JpdGVJZDogd3JpdGVJZCxcbiAgICAgICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlzaWJsZVdyaXRlc18gPSB0aGlzLnZpc2libGVXcml0ZXNfLmFkZFdyaXRlcyhwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4pO1xuICAgICAgICB0aGlzLmxhc3RXcml0ZUlkXyA9IHdyaXRlSWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFudW1iZXJ9IHdyaXRlSWRcbiAgICAgKiBAcmV0dXJuIHs/V3JpdGVSZWNvcmR9XG4gICAgICovXG4gICAgV3JpdGVUcmVlLnByb3RvdHlwZS5nZXRXcml0ZSA9IGZ1bmN0aW9uICh3cml0ZUlkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbGxXcml0ZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkID0gdGhpcy5hbGxXcml0ZXNfW2ldO1xuICAgICAgICAgICAgaWYgKHJlY29yZC53cml0ZUlkID09PSB3cml0ZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHdyaXRlIChlaXRoZXIgYW4gb3ZlcndyaXRlIG9yIG1lcmdlKSB0aGF0IGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBhY2tub3dsZWRnZSBieSB0aGUgc2VydmVyLiBSZWNhbGN1bGF0ZXNcbiAgICAgKiB0aGUgdHJlZSBpZiBuZWNlc3NhcnkuICBXZSByZXR1cm4gdHJ1ZSBpZiBpdCBtYXkgaGF2ZSBiZWVuIHZpc2libGUsIG1lYW5pbmcgdmlld3MgbmVlZCB0byByZWV2YWx1YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB3cml0ZUlkXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgd3JpdGUgbWF5IGhhdmUgYmVlbiB2aXNpYmxlIChtZWFuaW5nIHdlJ2xsIG5lZWQgdG8gcmVldmFsdWF0ZSAvIHJhaXNlXG4gICAgICogZXZlbnRzIGFzIGEgcmVzdWx0KS5cbiAgICAgKi9cbiAgICBXcml0ZVRyZWUucHJvdG90eXBlLnJlbW92ZVdyaXRlID0gZnVuY3Rpb24gKHdyaXRlSWQpIHtcbiAgICAgICAgLy8gTm90ZTogZGlzYWJsaW5nIHRoaXMgY2hlY2suIEl0IGNvdWxkIGJlIGEgdHJhbnNhY3Rpb24gdGhhdCBwcmVlbXB0ZWQgYW5vdGhlciB0cmFuc2FjdGlvbiwgYW5kIHRodXMgd2FzIGFwcGxpZWRcbiAgICAgICAgLy8gb3V0IG9mIG9yZGVyLlxuICAgICAgICAvL2NvbnN0IHZhbGlkQ2xlYXIgPSByZXZlcnQgfHwgdGhpcy5hbGxXcml0ZXNfLmxlbmd0aCA9PT0gMCB8fCB3cml0ZUlkIDw9IHRoaXMuYWxsV3JpdGVzX1swXS53cml0ZUlkO1xuICAgICAgICAvL2Fzc2VydCh2YWxpZENsZWFyLCBcIkVpdGhlciB3ZSBkb24ndCBoYXZlIHRoaXMgd3JpdGUsIG9yIGl0J3MgdGhlIGZpcnN0IG9uZSBpbiB0aGUgcXVldWVcIik7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFsbFdyaXRlc18uZmluZEluZGV4KGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gcy53cml0ZUlkID09PSB3cml0ZUlkO1xuICAgICAgICB9KTtcbiAgICAgICAgYXNzZXJ0KGlkeCA+PSAwLCAncmVtb3ZlV3JpdGUgY2FsbGVkIHdpdGggbm9uZXhpc3RlbnQgd3JpdGVJZC4nKTtcbiAgICAgICAgdmFyIHdyaXRlVG9SZW1vdmUgPSB0aGlzLmFsbFdyaXRlc19baWR4XTtcbiAgICAgICAgdGhpcy5hbGxXcml0ZXNfLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB2YXIgcmVtb3ZlZFdyaXRlV2FzVmlzaWJsZSA9IHdyaXRlVG9SZW1vdmUudmlzaWJsZTtcbiAgICAgICAgdmFyIHJlbW92ZWRXcml0ZU92ZXJsYXBzV2l0aE90aGVyV3JpdGVzID0gZmFsc2U7XG4gICAgICAgIHZhciBpID0gdGhpcy5hbGxXcml0ZXNfLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChyZW1vdmVkV3JpdGVXYXNWaXNpYmxlICYmIGkgPj0gMCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRXcml0ZSA9IHRoaXMuYWxsV3JpdGVzX1tpXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50V3JpdGUudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGlmIChpID49IGlkeCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29yZENvbnRhaW5zUGF0aF8oY3VycmVudFdyaXRlLCB3cml0ZVRvUmVtb3ZlLnBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZW1vdmVkIHdyaXRlIHdhcyBjb21wbGV0ZWx5IHNoYWRvd2VkIGJ5IGEgc3Vic2VxdWVudCB3cml0ZS5cbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFdyaXRlV2FzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3cml0ZVRvUmVtb3ZlLnBhdGguY29udGFpbnMoY3VycmVudFdyaXRlLnBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVpdGhlciB3ZSdyZSBjb3ZlcmluZyBzb21lIHdyaXRlcyBvciB0aGV5J3JlIGNvdmVyaW5nIHBhcnQgb2YgdXMgKGRlcGVuZGluZyBvbiB3aGljaCBjYW1lIGZpcnN0KS5cbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFdyaXRlT3ZlcmxhcHNXaXRoT3RoZXJXcml0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlbW92ZWRXcml0ZVdhc1Zpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZW1vdmVkV3JpdGVPdmVybGFwc1dpdGhPdGhlcldyaXRlcykge1xuICAgICAgICAgICAgLy8gVGhlcmUncyBzb21lIHNoYWRvd2luZyBnb2luZyBvbi4gSnVzdCByZWJ1aWxkIHRoZSB2aXNpYmxlIHdyaXRlcyBmcm9tIHNjcmF0Y2guXG4gICAgICAgICAgICB0aGlzLnJlc2V0VHJlZV8oKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlcmUncyBubyBzaGFkb3dpbmcuICBXZSBjYW4gc2FmZWx5IGp1c3QgcmVtb3ZlIHRoZSB3cml0ZShzKSBmcm9tIHZpc2libGVXcml0ZXMuXG4gICAgICAgICAgICBpZiAod3JpdGVUb1JlbW92ZS5zbmFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlV3JpdGVzXyA9IHRoaXMudmlzaWJsZVdyaXRlc18ucmVtb3ZlV3JpdGUod3JpdGVUb1JlbW92ZS5wYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHdyaXRlVG9SZW1vdmUuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52aXNpYmxlV3JpdGVzXyA9IF90aGlzLnZpc2libGVXcml0ZXNfLnJlbW92ZVdyaXRlKHdyaXRlVG9SZW1vdmUucGF0aC5jaGlsZChjaGlsZE5hbWUpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBjb21wbGV0ZSBzbmFwc2hvdCBmb3IgdGhlIGdpdmVuIHBhdGggaWYgdGhlcmUncyB2aXNpYmxlIHdyaXRlIGRhdGEgYXQgdGhhdCBwYXRoLCBlbHNlIG51bGwuXG4gICAgICogTm8gc2VydmVyIGRhdGEgaXMgY29uc2lkZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICAgKi9cbiAgICBXcml0ZVRyZWUucHJvdG90eXBlLmdldENvbXBsZXRlV3JpdGVEYXRhID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZVdyaXRlc18uZ2V0Q29tcGxldGVOb2RlKHBhdGgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gb3B0aW9uYWwsIHVuZGVybHlpbmcgc2VydmVyIGRhdGEsIGFuZCBhbiBvcHRpb25hbCBzZXQgb2YgY29uc3RyYWludHMgKGV4Y2x1ZGUgc29tZSBzZXRzLCBpbmNsdWRlIGhpZGRlblxuICAgICAqIHdyaXRlcyksIGF0dGVtcHQgdG8gY2FsY3VsYXRlIGEgY29tcGxldGUgc25hcHNob3QgZm9yIHRoZSBnaXZlbiBwYXRoXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSB0cmVlUGF0aFxuICAgICAqIEBwYXJhbSB7P05vZGV9IGNvbXBsZXRlU2VydmVyQ2FjaGVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+PX0gd3JpdGVJZHNUb0V4Y2x1ZGUgQW4gb3B0aW9uYWwgc2V0IHRvIGJlIGV4Y2x1ZGVkXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5jbHVkZUhpZGRlbldyaXRlcyBEZWZhdWx0cyB0byBmYWxzZSwgd2hldGhlciBvciBub3QgdG8gbGF5ZXIgb24gd3JpdGVzIHdpdGggdmlzaWJsZSBzZXQgdG8gZmFsc2VcbiAgICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICAgKi9cbiAgICBXcml0ZVRyZWUucHJvdG90eXBlLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUgPSBmdW5jdGlvbiAodHJlZVBhdGgsIGNvbXBsZXRlU2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuV3JpdGVzKSB7XG4gICAgICAgIGlmICghd3JpdGVJZHNUb0V4Y2x1ZGUgJiYgIWluY2x1ZGVIaWRkZW5Xcml0ZXMpIHtcbiAgICAgICAgICAgIHZhciBzaGFkb3dpbmdOb2RlID0gdGhpcy52aXNpYmxlV3JpdGVzXy5nZXRDb21wbGV0ZU5vZGUodHJlZVBhdGgpO1xuICAgICAgICAgICAgaWYgKHNoYWRvd2luZ05vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGFkb3dpbmdOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1Yk1lcmdlID0gdGhpcy52aXNpYmxlV3JpdGVzXy5jaGlsZENvbXBvdW5kV3JpdGUodHJlZVBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChzdWJNZXJnZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlU2VydmVyQ2FjaGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBsZXRlU2VydmVyQ2FjaGUgPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAhc3ViTWVyZ2UuaGFzQ29tcGxldGVXcml0ZShQYXRoLkVtcHR5KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSB3b3VsZG4ndCBoYXZlIGEgY29tcGxldGUgc25hcHNob3QsIHNpbmNlIHRoZXJlJ3Mgbm8gdW5kZXJseWluZyBkYXRhIGFuZCBubyBjb21wbGV0ZSBzaGFkb3dcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGF5ZXJlZENhY2hlID0gY29tcGxldGVTZXJ2ZXJDYWNoZSB8fCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Yk1lcmdlLmFwcGx5KGxheWVyZWRDYWNoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1lcmdlID0gdGhpcy52aXNpYmxlV3JpdGVzXy5jaGlsZENvbXBvdW5kV3JpdGUodHJlZVBhdGgpO1xuICAgICAgICAgICAgaWYgKCFpbmNsdWRlSGlkZGVuV3JpdGVzICYmIG1lcmdlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZVNlcnZlckNhY2hlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNlcnZlciBjYWNoZSBpcyBudWxsLCBhbmQgd2UgZG9uJ3QgaGF2ZSBhIGNvbXBsZXRlIGNhY2hlLCB3ZSBuZWVkIHRvIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgaWYgKCFpbmNsdWRlSGlkZGVuV3JpdGVzICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlU2VydmVyQ2FjaGUgPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAhbWVyZ2UuaGFzQ29tcGxldGVXcml0ZShQYXRoLkVtcHR5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBmdW5jdGlvbiAod3JpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHdyaXRlLnZpc2libGUgfHwgaW5jbHVkZUhpZGRlbldyaXRlcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIXdyaXRlSWRzVG9FeGNsdWRlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICF+d3JpdGVJZHNUb0V4Y2x1ZGUuaW5kZXhPZih3cml0ZS53cml0ZUlkKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAod3JpdGUucGF0aC5jb250YWlucyh0cmVlUGF0aCkgfHwgdHJlZVBhdGguY29udGFpbnMod3JpdGUucGF0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lcmdlQXRQYXRoID0gV3JpdGVUcmVlLmxheWVyVHJlZV8odGhpcy5hbGxXcml0ZXNfLCBmaWx0ZXIsIHRyZWVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxheWVyZWRDYWNoZSA9IGNvbXBsZXRlU2VydmVyQ2FjaGUgfHwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZUF0UGF0aC5hcHBseShsYXllcmVkQ2FjaGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogV2l0aCBvcHRpb25hbCwgdW5kZXJseWluZyBzZXJ2ZXIgZGF0YSwgYXR0ZW1wdCB0byByZXR1cm4gYSBjaGlsZHJlbiBub2RlIG9mIGNoaWxkcmVuIHRoYXQgd2UgaGF2ZSBjb21wbGV0ZSBkYXRhIGZvci5cbiAgICAgKiBVc2VkIHdoZW4gY3JlYXRpbmcgbmV3IHZpZXdzLCB0byBwcmUtZmlsbCB0aGVpciBjb21wbGV0ZSBldmVudCBjaGlsZHJlbiBzbmFwc2hvdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHRyZWVQYXRoXG4gICAgICogQHBhcmFtIHs/Q2hpbGRyZW5Ob2RlfSBjb21wbGV0ZVNlcnZlckNoaWxkcmVuXG4gICAgICogQHJldHVybiB7IUNoaWxkcmVuTm9kZX1cbiAgICAgKi9cbiAgICBXcml0ZVRyZWUucHJvdG90eXBlLmNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4gPSBmdW5jdGlvbiAodHJlZVBhdGgsIGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGNvbXBsZXRlQ2hpbGRyZW4gPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgdmFyIHRvcExldmVsU2V0ID0gdGhpcy52aXNpYmxlV3JpdGVzXy5nZXRDb21wbGV0ZU5vZGUodHJlZVBhdGgpO1xuICAgICAgICBpZiAodG9wTGV2ZWxTZXQpIHtcbiAgICAgICAgICAgIGlmICghdG9wTGV2ZWxTZXQuaXNMZWFmTm9kZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UncmUgc2hhZG93aW5nIGV2ZXJ5dGhpbmcuIFJldHVybiB0aGUgY2hpbGRyZW4uXG4gICAgICAgICAgICAgICAgdG9wTGV2ZWxTZXQuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCBmdW5jdGlvbiAoY2hpbGROYW1lLCBjaGlsZFNuYXApIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVDaGlsZHJlbiA9IGNvbXBsZXRlQ2hpbGRyZW4udXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBjaGlsZFNuYXApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlQ2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcGxldGVTZXJ2ZXJDaGlsZHJlbikge1xuICAgICAgICAgICAgLy8gTGF5ZXIgYW55IGNoaWxkcmVuIHdlIGhhdmUgb24gdG9wIG9mIHRoaXNcbiAgICAgICAgICAgIC8vIFdlIGtub3cgd2UgZG9uJ3QgaGF2ZSBhIHRvcC1sZXZlbCBzZXQsIHNvIGp1c3QgZW51bWVyYXRlIGV4aXN0aW5nIGNoaWxkcmVuXG4gICAgICAgICAgICB2YXIgbWVyZ2VfMSA9IHRoaXMudmlzaWJsZVdyaXRlc18uY2hpbGRDb21wb3VuZFdyaXRlKHRyZWVQYXRoKTtcbiAgICAgICAgICAgIGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4uZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCBmdW5jdGlvbiAoY2hpbGROYW1lLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG1lcmdlXzFcbiAgICAgICAgICAgICAgICAgICAgLmNoaWxkQ29tcG91bmRXcml0ZShuZXcgUGF0aChjaGlsZE5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAuYXBwbHkoY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIG5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBZGQgYW55IGNvbXBsZXRlIGNoaWxkcmVuIHdlIGhhdmUgZnJvbSB0aGUgc2V0XG4gICAgICAgICAgICBtZXJnZV8xLmdldENvbXBsZXRlQ2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChuYW1lZE5vZGUubmFtZSwgbmFtZWROb2RlLm5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGVDaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGhhdmUgYW55dGhpbmcgdG8gbGF5ZXIgb24gdG9wIG9mLiBMYXllciBvbiBhbnkgY2hpbGRyZW4gd2UgaGF2ZVxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGNhbiByZXR1cm4gYW4gZW1wdHkgc25hcCBpZiB3ZSBoYXZlIGEgZGVmaW5lZCBkZWxldGVcbiAgICAgICAgICAgIHZhciBtZXJnZSA9IHRoaXMudmlzaWJsZVdyaXRlc18uY2hpbGRDb21wb3VuZFdyaXRlKHRyZWVQYXRoKTtcbiAgICAgICAgICAgIG1lcmdlLmdldENvbXBsZXRlQ2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChuYW1lZE5vZGUubmFtZSwgbmFtZWROb2RlLm5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGVDaGlsZHJlbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gdGhhdCB0aGUgdW5kZXJseWluZyBzZXJ2ZXIgZGF0YSBoYXMgdXBkYXRlZCwgZGV0ZXJtaW5lIHdoYXQsIGlmIGFueXRoaW5nLCBuZWVkcyB0byBiZVxuICAgICAqIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGNhY2hlLlxuICAgICAqXG4gICAgICogUG9zc2liaWxpdGllczpcbiAgICAgKlxuICAgICAqIDEuIE5vIHdyaXRlcyBhcmUgc2hhZG93aW5nLiBFdmVudHMgc2hvdWxkIGJlIHJhaXNlZCwgdGhlIHNuYXAgdG8gYmUgYXBwbGllZCBjb21lcyBmcm9tIHRoZSBzZXJ2ZXIgZGF0YVxuICAgICAqXG4gICAgICogMi4gU29tZSB3cml0ZSBpcyBjb21wbGV0ZWx5IHNoYWRvd2luZy4gTm8gZXZlbnRzIHRvIGJlIHJhaXNlZFxuICAgICAqXG4gICAgICogMy4gSXMgcGFydGlhbGx5IHNoYWRvd2VkLiBFdmVudHNcbiAgICAgKlxuICAgICAqIEVpdGhlciBleGlzdGluZ0V2ZW50U25hcCBvciBleGlzdGluZ1NlcnZlclNuYXAgbXVzdCBleGlzdFxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gdHJlZVBhdGhcbiAgICAgKiBAcGFyYW0geyFQYXRofSBjaGlsZFBhdGhcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBleGlzdGluZ0V2ZW50U25hcFxuICAgICAqIEBwYXJhbSB7P05vZGV9IGV4aXN0aW5nU2VydmVyU25hcFxuICAgICAqIEByZXR1cm4gez9Ob2RlfVxuICAgICAqL1xuICAgIFdyaXRlVHJlZS5wcm90b3R5cGUuY2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZSA9IGZ1bmN0aW9uICh0cmVlUGF0aCwgY2hpbGRQYXRoLCBleGlzdGluZ0V2ZW50U25hcCwgZXhpc3RpbmdTZXJ2ZXJTbmFwKSB7XG4gICAgICAgIGFzc2VydChleGlzdGluZ0V2ZW50U25hcCB8fCBleGlzdGluZ1NlcnZlclNuYXAsICdFaXRoZXIgZXhpc3RpbmdFdmVudFNuYXAgb3IgZXhpc3RpbmdTZXJ2ZXJTbmFwIG11c3QgZXhpc3QnKTtcbiAgICAgICAgdmFyIHBhdGggPSB0cmVlUGF0aC5jaGlsZChjaGlsZFBhdGgpO1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlV3JpdGVzXy5oYXNDb21wbGV0ZVdyaXRlKHBhdGgpKSB7XG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGNhbiBwcm9iYWJseSBndWFyYW50ZWUgdGhhdCB3ZSdyZSBpbiBjYXNlIDIsIG1lYW5pbmcgbm8gZXZlbnRzXG4gICAgICAgICAgICAvLyBNYXkgbmVlZCB0byBjaGVjayB2aXNpYmlsaXR5IHdoaWxlIGRvaW5nIHRoZSBmaW5kUm9vdE1vc3RWYWx1ZUFuZFBhdGggY2FsbFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBObyBjb21wbGV0ZSBzaGFkb3dpbmcuIFdlJ3JlIGVpdGhlciBwYXJ0aWFsbHkgc2hhZG93aW5nIG9yIG5vdCBzaGFkb3dpbmcgYXQgYWxsLlxuICAgICAgICAgICAgdmFyIGNoaWxkTWVyZ2UgPSB0aGlzLnZpc2libGVXcml0ZXNfLmNoaWxkQ29tcG91bmRXcml0ZShwYXRoKTtcbiAgICAgICAgICAgIGlmIChjaGlsZE1lcmdlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBzaGFkb3dpbmcgYXQgYWxsLiBDYXNlIDFcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdTZXJ2ZXJTbmFwLmdldENoaWxkKGNoaWxkUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIG1vcmUgZWZmaWNpZW50IGlmIHRoZSBzZXJ2ZXJOb2RlICsgdXBkYXRlcyBkb2Vzbid0IGNoYW5nZSB0aGUgZXZlbnRTbmFwXG4gICAgICAgICAgICAgICAgLy8gSG93ZXZlciB0aGlzIGlzIHRyaWNreSB0byBmaW5kIG91dCwgc2luY2UgdXNlciB1cGRhdGVzIGRvbid0IG5lY2Vzc2FyeSBjaGFuZ2UgdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgIC8vIHNuYXAsIGUuZy4gcHJpb3JpdHkgdXBkYXRlcyBvbiBlbXB0eSBub2Rlcywgb3IgZGVlcCBkZWxldGVzLiBBbm90aGVyIHNwZWNpYWwgY2FzZSBpcyBpZiB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgLy8gYWRkcyBub2RlcywgYnV0IGRvZXNuJ3QgY2hhbmdlIGFueSBleGlzdGluZyB3cml0ZXMuIEl0IGlzIHRoZXJlZm9yZSBub3QgZW5vdWdoIHRvXG4gICAgICAgICAgICAgICAgLy8gb25seSBjaGVjayBpZiB0aGUgdXBkYXRlcyBjaGFuZ2UgdGhlIHNlcnZlck5vZGUuXG4gICAgICAgICAgICAgICAgLy8gTWF5YmUgY2hlY2sgaWYgdGhlIG1lcmdlIHRyZWUgY29udGFpbnMgdGhlc2Ugc3BlY2lhbCBjYXNlcyBhbmQgb25seSBkbyBhIGZ1bGwgb3ZlcndyaXRlIGluIHRoYXQgY2FzZT9cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRNZXJnZS5hcHBseShleGlzdGluZ1NlcnZlclNuYXAuZ2V0Q2hpbGQoY2hpbGRQYXRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb21wbGV0ZSBjaGlsZCBmb3IgYSBnaXZlbiBzZXJ2ZXIgc25hcCBhZnRlciBhcHBseWluZyBhbGwgdXNlciB3cml0ZXMgb3IgbnVsbCBpZiB0aGVyZSBpcyBub1xuICAgICAqIGNvbXBsZXRlIGNoaWxkIGZvciB0aGlzIENoaWxkS2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gdHJlZVBhdGhcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGNoaWxkS2V5XG4gICAgICogQHBhcmFtIHshQ2FjaGVOb2RlfSBleGlzdGluZ1NlcnZlclNuYXBcbiAgICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICAgKi9cbiAgICBXcml0ZVRyZWUucHJvdG90eXBlLmNhbGNDb21wbGV0ZUNoaWxkID0gZnVuY3Rpb24gKHRyZWVQYXRoLCBjaGlsZEtleSwgZXhpc3RpbmdTZXJ2ZXJTbmFwKSB7XG4gICAgICAgIHZhciBwYXRoID0gdHJlZVBhdGguY2hpbGQoY2hpbGRLZXkpO1xuICAgICAgICB2YXIgc2hhZG93aW5nTm9kZSA9IHRoaXMudmlzaWJsZVdyaXRlc18uZ2V0Q29tcGxldGVOb2RlKHBhdGgpO1xuICAgICAgICBpZiAoc2hhZG93aW5nTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hhZG93aW5nTm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1NlcnZlclNuYXAuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE1lcmdlID0gdGhpcy52aXNpYmxlV3JpdGVzXy5jaGlsZENvbXBvdW5kV3JpdGUocGF0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTWVyZ2UuYXBwbHkoZXhpc3RpbmdTZXJ2ZXJTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBub2RlIGlmIHRoZXJlIGlzIGEgY29tcGxldGUgb3ZlcndyaXRlIGZvciB0aGlzIHBhdGguIE1vcmUgc3BlY2lmaWNhbGx5LCBpZiB0aGVyZSBpcyBhIHdyaXRlIGF0XG4gICAgICogYSBoaWdoZXIgcGF0aCwgdGhpcyB3aWxsIHJldHVybiB0aGUgY2hpbGQgb2YgdGhhdCB3cml0ZSByZWxhdGl2ZSB0byB0aGUgd3JpdGUgYW5kIHRoaXMgcGF0aC5cbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm8gd3JpdGUgYXQgdGhpcyBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEByZXR1cm4gez9Ob2RlfVxuICAgICAqL1xuICAgIFdyaXRlVHJlZS5wcm90b3R5cGUuc2hhZG93aW5nV3JpdGUgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlV3JpdGVzXy5nZXRDb21wbGV0ZU5vZGUocGF0aCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHdoZW4gcHJvY2Vzc2luZyBjaGlsZCByZW1vdmUgZXZlbnRzIG9uIGEgcXVlcnkuIElmIHdlIGNhbiwgd2UgcHVsbCBpbiBjaGlsZHJlbiB0aGF0IHdlcmUgb3V0c2lkZVxuICAgICAqIHRoZSB3aW5kb3csIGJ1dCBtYXkgbm93IGJlIGluIHRoZSB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSB0cmVlUGF0aFxuICAgICAqIEBwYXJhbSB7P05vZGV9IGNvbXBsZXRlU2VydmVyRGF0YVxuICAgICAqIEBwYXJhbSB7IU5hbWVkTm9kZX0gc3RhcnRQb3N0XG4gICAgICogQHBhcmFtIHshbnVtYmVyfSBjb3VudFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV2ZXJzZVxuICAgICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleFxuICAgICAqIEByZXR1cm4geyFBcnJheS48IU5hbWVkTm9kZT59XG4gICAgICovXG4gICAgV3JpdGVUcmVlLnByb3RvdHlwZS5jYWxjSW5kZXhlZFNsaWNlID0gZnVuY3Rpb24gKHRyZWVQYXRoLCBjb21wbGV0ZVNlcnZlckRhdGEsIHN0YXJ0UG9zdCwgY291bnQsIHJldmVyc2UsIGluZGV4KSB7XG4gICAgICAgIHZhciB0b0l0ZXJhdGU7XG4gICAgICAgIHZhciBtZXJnZSA9IHRoaXMudmlzaWJsZVdyaXRlc18uY2hpbGRDb21wb3VuZFdyaXRlKHRyZWVQYXRoKTtcbiAgICAgICAgdmFyIHNoYWRvd2luZ05vZGUgPSBtZXJnZS5nZXRDb21wbGV0ZU5vZGUoUGF0aC5FbXB0eSk7XG4gICAgICAgIGlmIChzaGFkb3dpbmdOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRvSXRlcmF0ZSA9IHNoYWRvd2luZ05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcGxldGVTZXJ2ZXJEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRvSXRlcmF0ZSA9IG1lcmdlLmFwcGx5KGNvbXBsZXRlU2VydmVyRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBjaGlsZHJlbiB0byBpdGVyYXRlIG9uXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdG9JdGVyYXRlID0gdG9JdGVyYXRlLndpdGhJbmRleChpbmRleCk7XG4gICAgICAgIGlmICghdG9JdGVyYXRlLmlzRW1wdHkoKSAmJiAhdG9JdGVyYXRlLmlzTGVhZk5vZGUoKSkge1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgICAgICB2YXIgY21wID0gaW5kZXguZ2V0Q29tcGFyZSgpO1xuICAgICAgICAgICAgdmFyIGl0ZXIgPSByZXZlcnNlXG4gICAgICAgICAgICAgICAgPyB0b0l0ZXJhdGUuZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShzdGFydFBvc3QsIGluZGV4KVxuICAgICAgICAgICAgICAgIDogdG9JdGVyYXRlLmdldEl0ZXJhdG9yRnJvbShzdGFydFBvc3QsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCAmJiBub2Rlcy5sZW5ndGggPCBjb3VudCkge1xuICAgICAgICAgICAgICAgIGlmIChjbXAobmV4dCwgc3RhcnRQb3N0KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0ID0gaXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVdyaXRlUmVjb3JkfSB3cml0ZVJlY29yZFxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgV3JpdGVUcmVlLnByb3RvdHlwZS5yZWNvcmRDb250YWluc1BhdGhfID0gZnVuY3Rpb24gKHdyaXRlUmVjb3JkLCBwYXRoKSB7XG4gICAgICAgIGlmICh3cml0ZVJlY29yZC5zbmFwKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVSZWNvcmQucGF0aC5jb250YWlucyhwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZpbmRLZXkgY2FuIHJldHVybiB1bmRlZmluZWQsIHNvIHVzZSAhISB0byBjb2VyY2UgdG8gYm9vbGVhblxuICAgICAgICAgICAgcmV0dXJuICEhZmluZEtleSh3cml0ZVJlY29yZC5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkU25hcCwgY2hpbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlUmVjb3JkLnBhdGguY2hpbGQoY2hpbGROYW1lKS5jb250YWlucyhwYXRoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZS1sYXllciB0aGUgd3JpdGVzIGFuZCBtZXJnZXMgaW50byBhIHRyZWUgc28gd2UgY2FuIGVmZmljaWVudGx5IGNhbGN1bGF0ZSBldmVudCBzbmFwc2hvdHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFdyaXRlVHJlZS5wcm90b3R5cGUucmVzZXRUcmVlXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aXNpYmxlV3JpdGVzXyA9IFdyaXRlVHJlZS5sYXllclRyZWVfKHRoaXMuYWxsV3JpdGVzXywgV3JpdGVUcmVlLkRlZmF1bHRGaWx0ZXJfLCBQYXRoLkVtcHR5KTtcbiAgICAgICAgaWYgKHRoaXMuYWxsV3JpdGVzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RXcml0ZUlkXyA9IHRoaXMuYWxsV3JpdGVzX1t0aGlzLmFsbFdyaXRlc18ubGVuZ3RoIC0gMV0ud3JpdGVJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFdyaXRlSWRfID0gLTE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZpbHRlciB1c2VkIHdoZW4gY29uc3RydWN0aW5nIHRoZSB0cmVlLiBLZWVwIGV2ZXJ5dGhpbmcgdGhhdCdzIHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFXcml0ZVJlY29yZH0gd3JpdGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgV3JpdGVUcmVlLkRlZmF1bHRGaWx0ZXJfID0gZnVuY3Rpb24gKHdyaXRlKSB7XG4gICAgICAgIHJldHVybiB3cml0ZS52aXNpYmxlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhdGljIG1ldGhvZC4gR2l2ZW4gYW4gYXJyYXkgb2YgV3JpdGVSZWNvcmRzLCBhIGZpbHRlciBmb3Igd2hpY2ggb25lcyB0byBpbmNsdWRlLCBhbmQgYSBwYXRoLCBjb25zdHJ1Y3QgdGhlIHRyZWUgb2ZcbiAgICAgKiBldmVudCBkYXRhIGF0IHRoYXQgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhV3JpdGVSZWNvcmQ+fSB3cml0ZXNcbiAgICAgKiBAcGFyYW0geyFmdW5jdGlvbighV3JpdGVSZWNvcmQpOmJvb2xlYW59IGZpbHRlclxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHRyZWVSb290XG4gICAgICogQHJldHVybiB7IUNvbXBvdW5kV3JpdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBXcml0ZVRyZWUubGF5ZXJUcmVlXyA9IGZ1bmN0aW9uICh3cml0ZXMsIGZpbHRlciwgdHJlZVJvb3QpIHtcbiAgICAgICAgdmFyIGNvbXBvdW5kV3JpdGUgPSBDb21wb3VuZFdyaXRlLkVtcHR5O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdyaXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHdyaXRlID0gd3JpdGVzW2ldO1xuICAgICAgICAgICAgLy8gVGhlb3J5LCBhIGxhdGVyIHNldCB3aWxsIGVpdGhlcjpcbiAgICAgICAgICAgIC8vIGEpIGFib3J0IGEgcmVsZXZhbnQgdHJhbnNhY3Rpb24sIHNvIG5vIG5lZWQgdG8gd29ycnkgYWJvdXQgZXhjbHVkaW5nIGl0IGZyb20gY2FsY3VsYXRpbmcgdGhhdCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgLy8gYikgbm90IGJlIHJlbGV2YW50IHRvIGEgdHJhbnNhY3Rpb24gKHNlcGFyYXRlIGJyYW5jaCksIHNvIGFnYWluIHdpbGwgbm90IGFmZmVjdCB0aGUgZGF0YSBmb3IgdGhhdCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgaWYgKGZpbHRlcih3cml0ZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgd3JpdGVQYXRoID0gd3JpdGUucGF0aDtcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXRpdmVQYXRoID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmICh3cml0ZS5zbmFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmVlUm9vdC5jb250YWlucyh3cml0ZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBhdGggPSBQYXRoLnJlbGF0aXZlUGF0aCh0cmVlUm9vdCwgd3JpdGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kV3JpdGUgPSBjb21wb3VuZFdyaXRlLmFkZFdyaXRlKHJlbGF0aXZlUGF0aCwgd3JpdGUuc25hcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAod3JpdGVQYXRoLmNvbnRhaW5zKHRyZWVSb290KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gUGF0aC5yZWxhdGl2ZVBhdGgod3JpdGVQYXRoLCB0cmVlUm9vdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZS5hZGRXcml0ZShQYXRoLkVtcHR5LCB3cml0ZS5zbmFwLmdldENoaWxkKHJlbGF0aXZlUGF0aCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gb3ZlcmxhcCBiZXR3ZWVuIHJvb3QgcGF0aCBhbmQgd3JpdGUgcGF0aCwgaWdub3JlIHdyaXRlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod3JpdGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyZWVSb290LmNvbnRhaW5zKHdyaXRlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IFBhdGgucmVsYXRpdmVQYXRoKHRyZWVSb290LCB3cml0ZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG91bmRXcml0ZSA9IGNvbXBvdW5kV3JpdGUuYWRkV3JpdGVzKHJlbGF0aXZlUGF0aCwgd3JpdGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdyaXRlUGF0aC5jb250YWlucyh0cmVlUm9vdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IFBhdGgucmVsYXRpdmVQYXRoKHdyaXRlUGF0aCwgdHJlZVJvb3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlUGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZS5hZGRXcml0ZXMoUGF0aC5FbXB0eSwgd3JpdGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gc2FmZUdldCh3cml0ZS5jaGlsZHJlbiwgcmVsYXRpdmVQYXRoLmdldEZyb250KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBleGlzdHMgYSBjaGlsZCBpbiB0aGlzIG5vZGUgdGhhdCBtYXRjaGVzIHRoZSByb290IHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZXBOb2RlID0gY2hpbGQuZ2V0Q2hpbGQocmVsYXRpdmVQYXRoLnBvcEZyb250KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZS5hZGRXcml0ZShQYXRoLkVtcHR5LCBkZWVwTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gb3ZlcmxhcCBiZXR3ZWVuIHJvb3QgcGF0aCBhbmQgd3JpdGUgcGF0aCwgaWdub3JlIHdyaXRlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKCdXcml0ZVJlY29yZCBzaG91bGQgaGF2ZSAuc25hcCBvciAuY2hpbGRyZW4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvdW5kV3JpdGU7XG4gICAgfTtcbiAgICByZXR1cm4gV3JpdGVUcmVlO1xufSgpKTtcbmV4cG9ydCB7IFdyaXRlVHJlZSB9O1xuLyoqXG4gKiBBIFdyaXRlVHJlZVJlZiB3cmFwcyBhIFdyaXRlVHJlZSBhbmQgYSBwYXRoLCBmb3IgY29udmVuaWVudCBhY2Nlc3MgdG8gYSBwYXJ0aWN1bGFyIHN1YnRyZWUuICBBbGwgb2YgdGhlIG1ldGhvZHNcbiAqIGp1c3QgcHJveHkgdG8gdGhlIHVuZGVybHlpbmcgV3JpdGVUcmVlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgV3JpdGVUcmVlUmVmID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyFXcml0ZVRyZWV9IHdyaXRlVHJlZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFdyaXRlVHJlZVJlZihwYXRoLCB3cml0ZVRyZWUpIHtcbiAgICAgICAgdGhpcy50cmVlUGF0aF8gPSBwYXRoO1xuICAgICAgICB0aGlzLndyaXRlVHJlZV8gPSB3cml0ZVRyZWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHBvc3NpYmxlLCByZXR1cm5zIGEgY29tcGxldGUgZXZlbnQgY2FjaGUsIHVzaW5nIHRoZSB1bmRlcmx5aW5nIHNlcnZlciBkYXRhIGlmIHBvc3NpYmxlLiBJbiBhZGRpdGlvbiwgY2FuIGJlIHVzZWRcbiAgICAgKiB0byBnZXQgYSBjYWNoZSB0aGF0IGluY2x1ZGVzIGhpZGRlbiB3cml0ZXMsIGFuZCBleGNsdWRlcyBhcmJpdHJhcnkgd3JpdGVzLiBOb3RlIHRoYXQgY3VzdG9taXppbmcgdGhlIHJldHVybmVkIG5vZGVcbiAgICAgKiBjYW4gbGVhZCB0byBhIG1vcmUgZXhwZW5zaXZlIGNhbGN1bGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gY29tcGxldGVTZXJ2ZXJDYWNoZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj49fSB3cml0ZUlkc1RvRXhjbHVkZSBPcHRpb25hbCB3cml0ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbmNsdWRlSGlkZGVuV3JpdGVzIERlZmF1bHRzIHRvIGZhbHNlLCB3aGV0aGVyIG9yIG5vdCB0byBsYXllciBvbiB3cml0ZXMgd2l0aCB2aXNpYmxlIHNldCB0byBmYWxzZVxuICAgICAqIEByZXR1cm4gez9Ob2RlfVxuICAgICAqL1xuICAgIFdyaXRlVHJlZVJlZi5wcm90b3R5cGUuY2FsY0NvbXBsZXRlRXZlbnRDYWNoZSA9IGZ1bmN0aW9uIChjb21wbGV0ZVNlcnZlckNhY2hlLCB3cml0ZUlkc1RvRXhjbHVkZSwgaW5jbHVkZUhpZGRlbldyaXRlcykge1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVRyZWVfLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUodGhpcy50cmVlUGF0aF8sIGNvbXBsZXRlU2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuV3JpdGVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIHBvc3NpYmxlLCByZXR1cm5zIGEgY2hpbGRyZW4gbm9kZSBjb250YWluaW5nIGFsbCBvZiB0aGUgY29tcGxldGUgY2hpbGRyZW4gd2UgaGF2ZSBkYXRhIGZvci4gVGhlIHJldHVybmVkIGRhdGEgaXMgYVxuICAgICAqIG1peCBvZiB0aGUgZ2l2ZW4gc2VydmVyIGRhdGEgYW5kIHdyaXRlIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9DaGlsZHJlbk5vZGV9IGNvbXBsZXRlU2VydmVyQ2hpbGRyZW5cbiAgICAgKiBAcmV0dXJuIHshQ2hpbGRyZW5Ob2RlfVxuICAgICAqL1xuICAgIFdyaXRlVHJlZVJlZi5wcm90b3R5cGUuY2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbiA9IGZ1bmN0aW9uIChjb21wbGV0ZVNlcnZlckNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlVHJlZV8uY2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbih0aGlzLnRyZWVQYXRoXywgY29tcGxldGVTZXJ2ZXJDaGlsZHJlbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiB0aGF0IGVpdGhlciB0aGUgdW5kZXJseWluZyBzZXJ2ZXIgZGF0YSBoYXMgdXBkYXRlZCBvciB0aGUgb3V0c3RhbmRpbmcgd3JpdGVzIGhhdmUgdXBkYXRlZCwgZGV0ZXJtaW5lIHdoYXQsXG4gICAgICogaWYgYW55dGhpbmcsIG5lZWRzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGNhY2hlLlxuICAgICAqXG4gICAgICogUG9zc2liaWxpdGllczpcbiAgICAgKlxuICAgICAqIDEuIE5vIHdyaXRlcyBhcmUgc2hhZG93aW5nLiBFdmVudHMgc2hvdWxkIGJlIHJhaXNlZCwgdGhlIHNuYXAgdG8gYmUgYXBwbGllZCBjb21lcyBmcm9tIHRoZSBzZXJ2ZXIgZGF0YVxuICAgICAqXG4gICAgICogMi4gU29tZSB3cml0ZSBpcyBjb21wbGV0ZWx5IHNoYWRvd2luZy4gTm8gZXZlbnRzIHRvIGJlIHJhaXNlZFxuICAgICAqXG4gICAgICogMy4gSXMgcGFydGlhbGx5IHNoYWRvd2VkLiBFdmVudHMgc2hvdWxkIGJlIHJhaXNlZFxuICAgICAqXG4gICAgICogRWl0aGVyIGV4aXN0aW5nRXZlbnRTbmFwIG9yIGV4aXN0aW5nU2VydmVyU25hcCBtdXN0IGV4aXN0LCB0aGlzIGlzIHZhbGlkYXRlZCB2aWEgYW4gYXNzZXJ0XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gZXhpc3RpbmdFdmVudFNuYXBcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBleGlzdGluZ1NlcnZlclNuYXBcbiAgICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICAgKi9cbiAgICBXcml0ZVRyZWVSZWYucHJvdG90eXBlLmNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUgPSBmdW5jdGlvbiAocGF0aCwgZXhpc3RpbmdFdmVudFNuYXAsIGV4aXN0aW5nU2VydmVyU25hcCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVRyZWVfLmNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUodGhpcy50cmVlUGF0aF8sIHBhdGgsIGV4aXN0aW5nRXZlbnRTbmFwLCBleGlzdGluZ1NlcnZlclNuYXApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5vZGUgaWYgdGhlcmUgaXMgYSBjb21wbGV0ZSBvdmVyd3JpdGUgZm9yIHRoaXMgcGF0aC4gTW9yZSBzcGVjaWZpY2FsbHksIGlmIHRoZXJlIGlzIGEgd3JpdGUgYXRcbiAgICAgKiBhIGhpZ2hlciBwYXRoLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBjaGlsZCBvZiB0aGF0IHdyaXRlIHJlbGF0aXZlIHRvIHRoZSB3cml0ZSBhbmQgdGhpcyBwYXRoLlxuICAgICAqIFJldHVybnMgbnVsbCBpZiB0aGVyZSBpcyBubyB3cml0ZSBhdCB0aGlzIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHJldHVybiB7P05vZGV9XG4gICAgICovXG4gICAgV3JpdGVUcmVlUmVmLnByb3RvdHlwZS5zaGFkb3dpbmdXcml0ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlVHJlZV8uc2hhZG93aW5nV3JpdGUodGhpcy50cmVlUGF0aF8uY2hpbGQocGF0aCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB3aGVuIHByb2Nlc3NpbmcgY2hpbGQgcmVtb3ZlIGV2ZW50cyBvbiBhIHF1ZXJ5LiBJZiB3ZSBjYW4sIHdlIHB1bGwgaW4gY2hpbGRyZW4gdGhhdCB3ZXJlIG91dHNpZGVcbiAgICAgKiB0aGUgd2luZG93LCBidXQgbWF5IG5vdyBiZSBpbiB0aGUgd2luZG93XG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBjb21wbGV0ZVNlcnZlckRhdGFcbiAgICAgKiBAcGFyYW0geyFOYW1lZE5vZGV9IHN0YXJ0UG9zdFxuICAgICAqIEBwYXJhbSB7IW51bWJlcn0gY291bnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJldmVyc2VcbiAgICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFOYW1lZE5vZGU+fVxuICAgICAqL1xuICAgIFdyaXRlVHJlZVJlZi5wcm90b3R5cGUuY2FsY0luZGV4ZWRTbGljZSA9IGZ1bmN0aW9uIChjb21wbGV0ZVNlcnZlckRhdGEsIHN0YXJ0UG9zdCwgY291bnQsIHJldmVyc2UsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlVHJlZV8uY2FsY0luZGV4ZWRTbGljZSh0aGlzLnRyZWVQYXRoXywgY29tcGxldGVTZXJ2ZXJEYXRhLCBzdGFydFBvc3QsIGNvdW50LCByZXZlcnNlLCBpbmRleCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29tcGxldGUgY2hpbGQgZm9yIGEgZ2l2ZW4gc2VydmVyIHNuYXAgYWZ0ZXIgYXBwbHlpbmcgYWxsIHVzZXIgd3JpdGVzIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9cbiAgICAgKiBjb21wbGV0ZSBjaGlsZCBmb3IgdGhpcyBDaGlsZEtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gY2hpbGRLZXlcbiAgICAgKiBAcGFyYW0geyFDYWNoZU5vZGV9IGV4aXN0aW5nU2VydmVyQ2FjaGVcbiAgICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICAgKi9cbiAgICBXcml0ZVRyZWVSZWYucHJvdG90eXBlLmNhbGNDb21wbGV0ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkS2V5LCBleGlzdGluZ1NlcnZlckNhY2hlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlVHJlZV8uY2FsY0NvbXBsZXRlQ2hpbGQodGhpcy50cmVlUGF0aF8sIGNoaWxkS2V5LCBleGlzdGluZ1NlcnZlckNhY2hlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhIFdyaXRlVHJlZVJlZiBmb3IgYSBjaGlsZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZE5hbWVcbiAgICAgKiBAcmV0dXJuIHshV3JpdGVUcmVlUmVmfVxuICAgICAqL1xuICAgIFdyaXRlVHJlZVJlZi5wcm90b3R5cGUuY2hpbGQgPSBmdW5jdGlvbiAoY2hpbGROYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JpdGVUcmVlUmVmKHRoaXMudHJlZVBhdGhfLmNoaWxkKGNoaWxkTmFtZSksIHRoaXMud3JpdGVUcmVlXyk7XG4gICAgfTtcbiAgICByZXR1cm4gV3JpdGVUcmVlUmVmO1xufSgpKTtcbmV4cG9ydCB7IFdyaXRlVHJlZVJlZiB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL1dyaXRlVHJlZS5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IFBhdGggfSBmcm9tICcuLi91dGlsL1BhdGgnO1xuaW1wb3J0IHsgT3BlcmF0aW9uU291cmNlLCBPcGVyYXRpb25UeXBlIH0gZnJvbSAnLi9PcGVyYXRpb24nO1xudmFyIEFja1VzZXJXcml0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyFJbW11dGFibGVUcmVlPCFib29sZWFuPn0gYWZmZWN0ZWRUcmVlIEEgdHJlZSBjb250YWluaW5nIHRydWUgZm9yIGVhY2ggYWZmZWN0ZWQgcGF0aC4gQWZmZWN0ZWQgcGF0aHMgY2FuJ3Qgb3ZlcmxhcC5cbiAgICAgKiBAcGFyYW0geyFib29sZWFufSByZXZlcnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBY2tVc2VyV3JpdGUoXG4gICAgICAgIC8qKkBpbmhlcml0RG9jICovIHBhdGgsIFxuICAgICAgICAvKipAaW5oZXJpdERvYyAqLyBhZmZlY3RlZFRyZWUsIFxuICAgICAgICAvKipAaW5oZXJpdERvYyAqLyByZXZlcnQpIHtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5hZmZlY3RlZFRyZWUgPSBhZmZlY3RlZFRyZWU7XG4gICAgICAgIHRoaXMucmV2ZXJ0ID0gcmV2ZXJ0O1xuICAgICAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICAgICAgdGhpcy50eXBlID0gT3BlcmF0aW9uVHlwZS5BQ0tfVVNFUl9XUklURTtcbiAgICAgICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgICAgIHRoaXMuc291cmNlID0gT3BlcmF0aW9uU291cmNlLlVzZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQWNrVXNlcldyaXRlLnByb3RvdHlwZS5vcGVyYXRpb25Gb3JDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5wYXRoLmdldEZyb250KCkgPT09IGNoaWxkTmFtZSwgJ29wZXJhdGlvbkZvckNoaWxkIGNhbGxlZCBmb3IgdW5yZWxhdGVkIGNoaWxkLicpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY2tVc2VyV3JpdGUodGhpcy5wYXRoLnBvcEZyb250KCksIHRoaXMuYWZmZWN0ZWRUcmVlLCB0aGlzLnJldmVydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hZmZlY3RlZFRyZWUudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXMuYWZmZWN0ZWRUcmVlLmNoaWxkcmVuLmlzRW1wdHkoKSwgJ2FmZmVjdGVkVHJlZSBzaG91bGQgbm90IGhhdmUgb3ZlcmxhcHBpbmcgYWZmZWN0ZWQgcGF0aHMuJyk7XG4gICAgICAgICAgICAvLyBBbGwgY2hpbGQgbG9jYXRpb25zIGFyZSBhZmZlY3RlZCBhcyB3ZWxsOyBqdXN0IHJldHVybiBzYW1lIG9wZXJhdGlvbi5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNoaWxkVHJlZSA9IHRoaXMuYWZmZWN0ZWRUcmVlLnN1YnRyZWUobmV3IFBhdGgoY2hpbGROYW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFja1VzZXJXcml0ZShQYXRoLkVtcHR5LCBjaGlsZFRyZWUsIHRoaXMucmV2ZXJ0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFja1VzZXJXcml0ZTtcbn0oKSk7XG5leHBvcnQgeyBBY2tVc2VyV3JpdGUgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9vcGVyYXRpb24vQWNrVXNlcldyaXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IFBhdGggfSBmcm9tICcuLi91dGlsL1BhdGgnO1xuaW1wb3J0IHsgT3BlcmF0aW9uVHlwZSB9IGZyb20gJy4vT3BlcmF0aW9uJztcbi8qKlxuICogQHBhcmFtIHshT3BlcmF0aW9uU291cmNlfSBzb3VyY2VcbiAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge09wZXJhdGlvbn1cbiAqL1xudmFyIExpc3RlbkNvbXBsZXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpc3RlbkNvbXBsZXRlKHNvdXJjZSwgcGF0aCkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgICAgIHRoaXMudHlwZSA9IE9wZXJhdGlvblR5cGUuTElTVEVOX0NPTVBMRVRFO1xuICAgIH1cbiAgICBMaXN0ZW5Db21wbGV0ZS5wcm90b3R5cGUub3BlcmF0aW9uRm9yQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGROYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLnBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpc3RlbkNvbXBsZXRlKHRoaXMuc291cmNlLCBQYXRoLkVtcHR5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlzdGVuQ29tcGxldGUodGhpcy5zb3VyY2UsIHRoaXMucGF0aC5wb3BGcm9udCgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIExpc3RlbkNvbXBsZXRlO1xufSgpKTtcbmV4cG9ydCB7IExpc3RlbkNvbXBsZXRlIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvb3BlcmF0aW9uL0xpc3RlbkNvbXBsZXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IE9wZXJhdGlvblR5cGUgfSBmcm9tICcuL09wZXJhdGlvbic7XG5pbXBvcnQgeyBPdmVyd3JpdGUgfSBmcm9tICcuL092ZXJ3cml0ZSc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi4vdXRpbC9QYXRoJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbi8qKlxuICogQHBhcmFtIHshT3BlcmF0aW9uU291cmNlfSBzb3VyY2VcbiAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAqIEBwYXJhbSB7IUltbXV0YWJsZVRyZWUuPCFOb2RlPn0gY2hpbGRyZW5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge09wZXJhdGlvbn1cbiAqL1xudmFyIE1lcmdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lcmdlKFxuICAgICAgICAvKipAaW5oZXJpdERvYyAqLyBzb3VyY2UsIFxuICAgICAgICAvKipAaW5oZXJpdERvYyAqLyBwYXRoLCBcbiAgICAgICAgLyoqQGluaGVyaXREb2MgKi8gY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgICAgIHRoaXMudHlwZSA9IE9wZXJhdGlvblR5cGUuTUVSR0U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTWVyZ2UucHJvdG90eXBlLm9wZXJhdGlvbkZvckNoaWxkID0gZnVuY3Rpb24gKGNoaWxkTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5wYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkVHJlZSA9IHRoaXMuY2hpbGRyZW4uc3VidHJlZShuZXcgUGF0aChjaGlsZE5hbWUpKTtcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjaGlsZCBpcyB1bmFmZmVjdGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZFRyZWUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgc25hcHNob3QgZm9yIHRoZSBjaGlsZCBpbiBxdWVzdGlvbi4gIFRoaXMgYmVjb21lcyBhbiBvdmVyd3JpdGUgb2YgdGhlIGNoaWxkLlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgT3ZlcndyaXRlKHRoaXMuc291cmNlLCBQYXRoLkVtcHR5LCBjaGlsZFRyZWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG1lcmdlIGF0IGEgZGVlcGVyIGxldmVsXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNZXJnZSh0aGlzLnNvdXJjZSwgUGF0aC5FbXB0eSwgY2hpbGRUcmVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLnBhdGguZ2V0RnJvbnQoKSA9PT0gY2hpbGROYW1lLCBcIkNhbid0IGdldCBhIG1lcmdlIGZvciBhIGNoaWxkIG5vdCBvbiB0aGUgcGF0aCBvZiB0aGUgb3BlcmF0aW9uXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNZXJnZSh0aGlzLnNvdXJjZSwgdGhpcy5wYXRoLnBvcEZyb250KCksIHRoaXMuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIE1lcmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICgnT3BlcmF0aW9uKCcgK1xuICAgICAgICAgICAgdGhpcy5wYXRoICtcbiAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAnIG1lcmdlOiAnICtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4udG9TdHJpbmcoKSArXG4gICAgICAgICAgICAnKScpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlO1xufSgpKTtcbmV4cG9ydCB7IE1lcmdlIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvb3BlcmF0aW9uL01lcmdlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGRlZXBDb3B5IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgY29udGFpbnMgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG4vKipcbiAqIFRyYWNrcyBhIGNvbGxlY3Rpb24gb2Ygc3RhdHMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTdGF0c0NvbGxlY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdHNDb2xsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvdW50ZXJzXyA9IHt9O1xuICAgIH1cbiAgICBTdGF0c0NvbGxlY3Rpb24ucHJvdG90eXBlLmluY3JlbWVudENvdW50ZXIgPSBmdW5jdGlvbiAobmFtZSwgYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQgPT09IHZvaWQgMCkgeyBhbW91bnQgPSAxOyB9XG4gICAgICAgIGlmICghY29udGFpbnModGhpcy5jb3VudGVyc18sIG5hbWUpKVxuICAgICAgICAgICAgdGhpcy5jb3VudGVyc19bbmFtZV0gPSAwO1xuICAgICAgICB0aGlzLmNvdW50ZXJzX1tuYW1lXSArPSBhbW91bnQ7XG4gICAgfTtcbiAgICBTdGF0c0NvbGxlY3Rpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRlZXBDb3B5KHRoaXMuY291bnRlcnNfKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0c0NvbGxlY3Rpb247XG59KCkpO1xuZXhwb3J0IHsgU3RhdHNDb2xsZWN0aW9uIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvc3RhdHMvU3RhdHNDb2xsZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGNvbnRhaW5zLCBmb3JFYWNoIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgc2V0VGltZW91dE5vbkJsb2NraW5nIH0gZnJvbSAnLi4vdXRpbC91dGlsJztcbmltcG9ydCB7IFN0YXRzTGlzdGVuZXIgfSBmcm9tICcuL1N0YXRzTGlzdGVuZXInO1xuLy8gQXNzdW1pbmcgc29tZSBhcHBzIG1heSBoYXZlIGEgc2hvcnQgYW1vdW50IG9mIHRpbWUgb24gcGFnZSwgYW5kIGEgYnVsayBvZiBmaXJlYmFzZSBvcGVyYXRpb25zIHByb2JhYmx5XG4vLyBoYXBwZW4gb24gcGFnZSBsb2FkLCB3ZSB0cnkgdG8gcmVwb3J0IG91ciBmaXJzdCBzZXQgb2Ygc3RhdHMgcHJldHR5IHF1aWNrbHksIGJ1dCB3ZSB3YWl0IGF0IGxlYXN0IDEwXG4vLyBzZWNvbmRzIHRvIHRyeSB0byBlbnN1cmUgdGhlIEZpcmViYXNlIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQgLyBzZXR0bGVkLlxudmFyIEZJUlNUX1NUQVRTX01JTl9USU1FID0gMTAgKiAxMDAwO1xudmFyIEZJUlNUX1NUQVRTX01BWF9USU1FID0gMzAgKiAxMDAwO1xuLy8gV2UnbGwgY29udGludWUgdG8gcmVwb3J0IHN0YXRzIG9uIGF2ZXJhZ2UgZXZlcnkgNSBtaW51dGVzLlxudmFyIFJFUE9SVF9TVEFUU19JTlRFUlZBTCA9IDUgKiA2MCAqIDEwMDA7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU3RhdHNSZXBvcnRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBzZXJ2ZXJfXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhdHNSZXBvcnRlcihjb2xsZWN0aW9uLCBzZXJ2ZXJfKSB7XG4gICAgICAgIHRoaXMuc2VydmVyXyA9IHNlcnZlcl87XG4gICAgICAgIHRoaXMuc3RhdHNUb1JlcG9ydF8gPSB7fTtcbiAgICAgICAgdGhpcy5zdGF0c0xpc3RlbmVyXyA9IG5ldyBTdGF0c0xpc3RlbmVyKGNvbGxlY3Rpb24pO1xuICAgICAgICB2YXIgdGltZW91dCA9IEZJUlNUX1NUQVRTX01JTl9USU1FICtcbiAgICAgICAgICAgIChGSVJTVF9TVEFUU19NQVhfVElNRSAtIEZJUlNUX1NUQVRTX01JTl9USU1FKSAqIE1hdGgucmFuZG9tKCk7XG4gICAgICAgIHNldFRpbWVvdXROb25CbG9ja2luZyh0aGlzLnJlcG9ydFN0YXRzXy5iaW5kKHRoaXMpLCBNYXRoLmZsb29yKHRpbWVvdXQpKTtcbiAgICB9XG4gICAgU3RhdHNSZXBvcnRlci5wcm90b3R5cGUuaW5jbHVkZVN0YXQgPSBmdW5jdGlvbiAoc3RhdCkge1xuICAgICAgICB0aGlzLnN0YXRzVG9SZXBvcnRfW3N0YXRdID0gdHJ1ZTtcbiAgICB9O1xuICAgIFN0YXRzUmVwb3J0ZXIucHJvdG90eXBlLnJlcG9ydFN0YXRzXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRzID0gdGhpcy5zdGF0c0xpc3RlbmVyXy5nZXQoKTtcbiAgICAgICAgdmFyIHJlcG9ydGVkU3RhdHMgPSB7fTtcbiAgICAgICAgdmFyIGhhdmVTdGF0c1RvUmVwb3J0ID0gZmFsc2U7XG4gICAgICAgIGZvckVhY2goc3RhdHMsIGZ1bmN0aW9uIChzdGF0LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gMCAmJiBjb250YWlucyhfdGhpcy5zdGF0c1RvUmVwb3J0Xywgc3RhdCkpIHtcbiAgICAgICAgICAgICAgICByZXBvcnRlZFN0YXRzW3N0YXRdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaGF2ZVN0YXRzVG9SZXBvcnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhdmVTdGF0c1RvUmVwb3J0KSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZlcl8ucmVwb3J0U3RhdHMocmVwb3J0ZWRTdGF0cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcXVldWUgb3VyIG5leHQgcnVuLlxuICAgICAgICBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcodGhpcy5yZXBvcnRTdGF0c18uYmluZCh0aGlzKSwgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMiAqIFJFUE9SVF9TVEFUU19JTlRFUlZBTCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRzUmVwb3J0ZXI7XG59KCkpO1xuZXhwb3J0IHsgU3RhdHNSZXBvcnRlciB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3N0YXRzL1N0YXRzUmVwb3J0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsganNvbkV2YWwsIHN0cmluZ2lmeSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbi8qKlxuICogV3JhcHMgYSBET00gU3RvcmFnZSBvYmplY3QgYW5kOlxuICogLSBhdXRvbWF0aWNhbGx5IGVuY29kZSBvYmplY3RzIGFzIEpTT04gc3RyaW5ncyBiZWZvcmUgc3RvcmluZyB0aGVtIHRvIGFsbG93IHVzIHRvIHN0b3JlIGFyYml0cmFyeSB0eXBlcy5cbiAqIC0gcHJlZml4ZXMgbmFtZXMgd2l0aCBcImZpcmViYXNlOlwiIHRvIGF2b2lkIGNvbGxpc2lvbnMgd2l0aCBhcHAgZGF0YS5cbiAqXG4gKiBXZSBhdXRvbWF0aWNhbGx5IChzZWUgc3RvcmFnZS5qcykgY3JlYXRlIHR3byBzdWNoIHdyYXBwZXJzLCBvbmUgZm9yIHNlc3Npb25TdG9yYWdlLFxuICogYW5kIG9uZSBmb3IgbG9jYWxTdG9yYWdlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRE9NU3RvcmFnZVdyYXBwZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdG9yYWdlfSBkb21TdG9yYWdlXyBUaGUgdW5kZXJseWluZyBzdG9yYWdlIG9iamVjdCAoZS5nLiBsb2NhbFN0b3JhZ2Ugb3Igc2Vzc2lvblN0b3JhZ2UpXG4gICAgICovXG4gICAgZnVuY3Rpb24gRE9NU3RvcmFnZVdyYXBwZXIoZG9tU3RvcmFnZV8pIHtcbiAgICAgICAgdGhpcy5kb21TdG9yYWdlXyA9IGRvbVN0b3JhZ2VfO1xuICAgICAgICAvLyBVc2UgYSBwcmVmaXggdG8gYXZvaWQgY29sbGlzaW9ucyB3aXRoIG90aGVyIHN0dWZmIHNhdmVkIGJ5IHRoZSBhcHAuXG4gICAgICAgIHRoaXMucHJlZml4XyA9ICdmaXJlYmFzZTonO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gc2F2ZSB0aGUgdmFsdWUgdW5kZXJcbiAgICAgKiBAcGFyYW0gez9PYmplY3R9IHZhbHVlIFRoZSB2YWx1ZSBiZWluZyBzdG9yZWQsIG9yIG51bGwgdG8gcmVtb3ZlIHRoZSBrZXkuXG4gICAgICovXG4gICAgRE9NU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRvbVN0b3JhZ2VfLnJlbW92ZUl0ZW0odGhpcy5wcmVmaXhlZE5hbWVfKGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kb21TdG9yYWdlXy5zZXRJdGVtKHRoaXMucHJlZml4ZWROYW1lXyhrZXkpLCBzdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZSB0aGF0IHdhcyBzdG9yZWQgdW5kZXIgdGhpcyBrZXksIG9yIG51bGxcbiAgICAgKi9cbiAgICBET01TdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgc3RvcmVkVmFsID0gdGhpcy5kb21TdG9yYWdlXy5nZXRJdGVtKHRoaXMucHJlZml4ZWROYW1lXyhrZXkpKTtcbiAgICAgICAgaWYgKHN0b3JlZFZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBqc29uRXZhbChzdG9yZWRWYWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICovXG4gICAgRE9NU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdGhpcy5kb21TdG9yYWdlXy5yZW1vdmVJdGVtKHRoaXMucHJlZml4ZWROYW1lXyhrZXkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIERPTVN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5wcmVmaXhlZE5hbWVfID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlZml4XyArIG5hbWU7XG4gICAgfTtcbiAgICBET01TdG9yYWdlV3JhcHBlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbVN0b3JhZ2VfLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRE9NU3RvcmFnZVdyYXBwZXI7XG59KCkpO1xuZXhwb3J0IHsgRE9NU3RvcmFnZVdyYXBwZXIgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9zdG9yYWdlL0RPTVN0b3JhZ2VXcmFwcGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGNvbnRhaW5zIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuLyoqXG4gKiBBbiBpbi1tZW1vcnkgc3RvcmFnZSBpbXBsZW1lbnRhdGlvbiB0aGF0IG1hdGNoZXMgdGhlIEFQSSBvZiBET01TdG9yYWdlV3JhcHBlclxuICogKFRPRE86IGNyZWF0ZSBpbnRlcmZhY2UgZm9yIGJvdGggdG8gaW1wbGVtZW50KS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE1lbW9yeVN0b3JhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVtb3J5U3RvcmFnZSgpIHtcbiAgICAgICAgdGhpcy5jYWNoZV8gPSB7fTtcbiAgICAgICAgdGhpcy5pc0luTWVtb3J5U3RvcmFnZSA9IHRydWU7XG4gICAgfVxuICAgIE1lbW9yeVN0b3JhZ2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jYWNoZV9ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVfW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVtb3J5U3RvcmFnZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoY29udGFpbnModGhpcy5jYWNoZV8sIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlX1trZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgTWVtb3J5U3RvcmFnZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBkZWxldGUgdGhpcy5jYWNoZV9ba2V5XTtcbiAgICB9O1xuICAgIHJldHVybiBNZW1vcnlTdG9yYWdlO1xufSgpKTtcbmV4cG9ydCB7IE1lbW9yeVN0b3JhZ2UgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS9zdG9yYWdlL01lbW9yeVN0b3JhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuLyoqXG4gKiBGYW5jeSBJRCBnZW5lcmF0b3IgdGhhdCBjcmVhdGVzIDIwLWNoYXJhY3RlciBzdHJpbmcgaWRlbnRpZmllcnMgd2l0aCB0aGVcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqIDEuIFRoZXkncmUgYmFzZWQgb24gdGltZXN0YW1wIHNvIHRoYXQgdGhleSBzb3J0ICphZnRlciogYW55IGV4aXN0aW5nIGlkcy5cbiAqIDIuIFRoZXkgY29udGFpbiA3Mi1iaXRzIG9mIHJhbmRvbSBkYXRhIGFmdGVyIHRoZSB0aW1lc3RhbXAgc28gdGhhdCBJRHMgd29uJ3RcbiAqICAgIGNvbGxpZGUgd2l0aCBvdGhlciBjbGllbnRzJyBJRHMuXG4gKiAzLiBUaGV5IHNvcnQgKmxleGljb2dyYXBoaWNhbGx5KiAoc28gdGhlIHRpbWVzdGFtcCBpcyBjb252ZXJ0ZWQgdG8gY2hhcmFjdGVyc1xuICogICAgdGhhdCB3aWxsIHNvcnQgcHJvcGVybHkpLlxuICogNC4gVGhleSdyZSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcuIEV2ZW4gaWYgeW91IGdlbmVyYXRlIG1vcmUgdGhhbiBvbmUgaW5cbiAqICAgIHRoZSBzYW1lIHRpbWVzdGFtcCwgdGhlIGxhdHRlciBvbmVzIHdpbGwgc29ydCBhZnRlciB0aGUgZm9ybWVyIG9uZXMuIFdlIGRvXG4gKiAgICB0aGlzIGJ5IHVzaW5nIHRoZSBwcmV2aW91cyByYW5kb20gYml0cyBidXQgXCJpbmNyZW1lbnRpbmdcIiB0aGVtIGJ5IDEgKG9ubHlcbiAqICAgIGluIHRoZSBjYXNlIG9mIGEgdGltZXN0YW1wIGNvbGxpc2lvbikuXG4gKi9cbmV4cG9ydCB2YXIgbmV4dFB1c2hJZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLy8gTW9kZWxlZCBhZnRlciBiYXNlNjQgd2ViLXNhZmUgY2hhcnMsIGJ1dCBvcmRlcmVkIGJ5IEFTQ0lJLlxuICAgIHZhciBQVVNIX0NIQVJTID0gJy0wMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xuICAgIC8vIFRpbWVzdGFtcCBvZiBsYXN0IHB1c2gsIHVzZWQgdG8gcHJldmVudCBsb2NhbCBjb2xsaXNpb25zIGlmIHlvdSBwdXNoIHR3aWNlXG4gICAgLy8gaW4gb25lIG1zLlxuICAgIHZhciBsYXN0UHVzaFRpbWUgPSAwO1xuICAgIC8vIFdlIGdlbmVyYXRlIDcyLWJpdHMgb2YgcmFuZG9tbmVzcyB3aGljaCBnZXQgdHVybmVkIGludG8gMTIgY2hhcmFjdGVycyBhbmRcbiAgICAvLyBhcHBlbmRlZCB0byB0aGUgdGltZXN0YW1wIHRvIHByZXZlbnQgY29sbGlzaW9ucyB3aXRoIG90aGVyIGNsaWVudHMuIFdlXG4gICAgLy8gc3RvcmUgdGhlIGxhc3QgY2hhcmFjdGVycyB3ZSBnZW5lcmF0ZWQgYmVjYXVzZSBpbiB0aGUgZXZlbnQgb2YgYSBjb2xsaXNpb24sXG4gICAgLy8gd2UnbGwgdXNlIHRob3NlIHNhbWUgY2hhcmFjdGVycyBleGNlcHQgXCJpbmNyZW1lbnRlZFwiIGJ5IG9uZS5cbiAgICB2YXIgbGFzdFJhbmRDaGFycyA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAobm93KSB7XG4gICAgICAgIHZhciBkdXBsaWNhdGVUaW1lID0gbm93ID09PSBsYXN0UHVzaFRpbWU7XG4gICAgICAgIGxhc3RQdXNoVGltZSA9IG5vdztcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciB0aW1lU3RhbXBDaGFycyA9IG5ldyBBcnJheSg4KTtcbiAgICAgICAgZm9yIChpID0gNzsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHRpbWVTdGFtcENoYXJzW2ldID0gUFVTSF9DSEFSUy5jaGFyQXQobm93ICUgNjQpO1xuICAgICAgICAgICAgLy8gTk9URTogQ2FuJ3QgdXNlIDw8IGhlcmUgYmVjYXVzZSBqYXZhc2NyaXB0IHdpbGwgY29udmVydCB0byBpbnQgYW5kIGxvc2VcbiAgICAgICAgICAgIC8vIHRoZSB1cHBlciBiaXRzLlxuICAgICAgICAgICAgbm93ID0gTWF0aC5mbG9vcihub3cgLyA2NCk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KG5vdyA9PT0gMCwgJ0Nhbm5vdCBwdXNoIGF0IHRpbWUgPT0gMCcpO1xuICAgICAgICB2YXIgaWQgPSB0aW1lU3RhbXBDaGFycy5qb2luKCcnKTtcbiAgICAgICAgaWYgKCFkdXBsaWNhdGVUaW1lKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICAgIGxhc3RSYW5kQ2hhcnNbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA2NCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdGltZXN0YW1wIGhhc24ndCBjaGFuZ2VkIHNpbmNlIGxhc3QgcHVzaCwgdXNlIHRoZSBzYW1lIHJhbmRvbVxuICAgICAgICAgICAgLy8gbnVtYmVyLCBleGNlcHQgaW5jcmVtZW50ZWQgYnkgMS5cbiAgICAgICAgICAgIGZvciAoaSA9IDExOyBpID49IDAgJiYgbGFzdFJhbmRDaGFyc1tpXSA9PT0gNjM7IGktLSkge1xuICAgICAgICAgICAgICAgIGxhc3RSYW5kQ2hhcnNbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdFJhbmRDaGFyc1tpXSsrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBpZCArPSBQVVNIX0NIQVJTLmNoYXJBdChsYXN0UmFuZENoYXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoaWQubGVuZ3RoID09PSAyMCwgJ25leHRQdXNoSWQ6IExlbmd0aCBzaG91bGQgYmUgMjAuJyk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xufSkoKTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS91dGlsL05leHRQdXNoSWQuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuL0V2ZW50RW1pdHRlcic7XG5pbXBvcnQgeyBpc01vYmlsZUNvcmRvdmEgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG4vKipcbiAqIE1vbml0b3JzIG9ubGluZSBzdGF0ZSAoYXMgcmVwb3J0ZWQgYnkgd2luZG93Lm9ubGluZS9vZmZsaW5lIGV2ZW50cykuXG4gKlxuICogVGhlIGV4cGVjdGF0aW9uIGlzIHRoYXQgdGhpcyBjb3VsZCBoYXZlIG1hbnkgZmFsc2UgcG9zaXRpdmVzICh0aGlua3Mgd2UgYXJlIG9ubGluZVxuICogd2hlbiB3ZSdyZSBub3QpLCBidXQgbm8gZmFsc2UgbmVnYXRpdmVzLiAgU28gd2UgY2FuIHNhZmVseSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoZW5cbiAqIHdlIGRlZmluaXRlbHkgY2Fubm90IHJlYWNoIHRoZSBpbnRlcm5ldC5cbiAqXG4gKiBAZXh0ZW5kcyB7RXZlbnRFbWl0dGVyfVxuICovXG52YXIgT25saW5lTW9uaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT25saW5lTW9uaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPbmxpbmVNb25pdG9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBbJ29ubGluZSddKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vbmxpbmVfID0gdHJ1ZTtcbiAgICAgICAgLy8gV2UndmUgaGFkIHJlcGVhdGVkIGNvbXBsYWludHMgdGhhdCBDb3Jkb3ZhIGFwcHMgY2FuIGdldCBzdHVjayBcIm9mZmxpbmVcIiwgZS5nLlxuICAgICAgICAvLyBodHRwczovL2ZvcnVtLmlvbmljZnJhbWV3b3JrLmNvbS90L2ZpcmViYXNlLWNvbm5lY3Rpb24taXMtbG9zdC1hbmQtbmV2ZXItY29tZS1iYWNrLzQzODEwXG4gICAgICAgIC8vIEl0IHdvdWxkIHNlZW0gdGhhdCB0aGUgJ29ubGluZScgZXZlbnQgZG9lcyBub3QgYWx3YXlzIGZpcmUgY29uc2lzdGVudGx5LiBTbyB3ZSBkaXNhYmxlIGl0XG4gICAgICAgIC8vIGZvciBDb3Jkb3ZhLlxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICFpc01vYmlsZUNvcmRvdmEoKSkge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLm9ubGluZV8pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25saW5lXyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXIoJ29ubGluZScsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vbmxpbmVfKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9ubGluZV8gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJpZ2dlcignb25saW5lJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9ubGluZU1vbml0b3IuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT25saW5lTW9uaXRvcigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBldmVudFR5cGVcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48Ym9vbGVhbj59XG4gICAgICovXG4gICAgT25saW5lTW9uaXRvci5wcm90b3R5cGUuZ2V0SW5pdGlhbEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgICBhc3NlcnQoZXZlbnRUeXBlID09PSAnb25saW5lJywgJ1Vua25vd24gZXZlbnQgdHlwZTogJyArIGV2ZW50VHlwZSk7XG4gICAgICAgIHJldHVybiBbdGhpcy5vbmxpbmVfXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgT25saW5lTW9uaXRvci5wcm90b3R5cGUuY3VycmVudGx5T25saW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbmxpbmVfO1xuICAgIH07XG4gICAgcmV0dXJuIE9ubGluZU1vbml0b3I7XG59KEV2ZW50RW1pdHRlcikpO1xuZXhwb3J0IHsgT25saW5lTW9uaXRvciB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3V0aWwvT25saW5lTW9uaXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi9QYXRoJztcbmltcG9ydCB7IGZvckVhY2gsIGNvbnRhaW5zLCBzYWZlR2V0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuLyoqXG4gKiBOb2RlIGluIGEgVHJlZS5cbiAqL1xudmFyIFRyZWVOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyZWVOb2RlKCkge1xuICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBtYWtpbmcgYWNjZXNzb3JzIHRoYXQgY3JlYXRlIGNoaWxkcmVuIGFuZCB2YWx1ZSBsYXppbHkgb3JcbiAgICAgICAgLy8gc2VwYXJhdGUgSW50ZXJuYWwgLyBMZWFmICd0eXBlcycuXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSB7fTtcbiAgICAgICAgdGhpcy5jaGlsZENvdW50ID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBUcmVlTm9kZTtcbn0oKSk7XG5leHBvcnQgeyBUcmVlTm9kZSB9O1xuLyoqXG4gKiBBIGxpZ2h0LXdlaWdodCB0cmVlLCB0cmF2ZXJzYWJsZSBieSBwYXRoLiAgTm9kZXMgY2FuIGhhdmUgYm90aCB2YWx1ZXMgYW5kIGNoaWxkcmVuLlxuICogTm9kZXMgYXJlIG5vdCBlbnVtZXJhdGVkIChieSBmb3JFYWNoQ2hpbGQpIHVubGVzcyB0aGV5IGhhdmUgYSB2YWx1ZSBvciBub24tZW1wdHlcbiAqIGNoaWxkcmVuLlxuICovXG52YXIgVHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gbmFtZV8gT3B0aW9uYWwgbmFtZSBvZiB0aGUgbm9kZS5cbiAgICAgKiBAcGFyYW0ge1RyZWU9fSBwYXJlbnRfIE9wdGlvbmFsIHBhcmVudCBub2RlLlxuICAgICAqIEBwYXJhbSB7VHJlZU5vZGU9fSBub2RlXyBPcHRpb25hbCBub2RlIHRvIHdyYXAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJlZShuYW1lXywgcGFyZW50Xywgbm9kZV8pIHtcbiAgICAgICAgaWYgKG5hbWVfID09PSB2b2lkIDApIHsgbmFtZV8gPSAnJzsgfVxuICAgICAgICBpZiAocGFyZW50XyA9PT0gdm9pZCAwKSB7IHBhcmVudF8gPSBudWxsOyB9XG4gICAgICAgIGlmIChub2RlXyA9PT0gdm9pZCAwKSB7IG5vZGVfID0gbmV3IFRyZWVOb2RlKCk7IH1cbiAgICAgICAgdGhpcy5uYW1lXyA9IG5hbWVfO1xuICAgICAgICB0aGlzLnBhcmVudF8gPSBwYXJlbnRfO1xuICAgICAgICB0aGlzLm5vZGVfID0gbm9kZV87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdWItVHJlZSBmb3IgdGhlIGdpdmVuIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyEoc3RyaW5nfFBhdGgpfSBwYXRoT2JqIFBhdGggdG8gbG9vayB1cC5cbiAgICAgKiBAcmV0dXJuIHshVHJlZS48VD59IFRyZWUgZm9yIHBhdGguXG4gICAgICovXG4gICAgVHJlZS5wcm90b3R5cGUuc3ViVHJlZSA9IGZ1bmN0aW9uIChwYXRoT2JqKSB7XG4gICAgICAgIC8vIFRPRE86IFJlcXVpcmUgcGF0aE9iaiB0byBiZSBQYXRoP1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhPYmogaW5zdGFuY2VvZiBQYXRoID8gcGF0aE9iaiA6IG5ldyBQYXRoKHBhdGhPYmopO1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLCBuZXh0O1xuICAgICAgICB3aGlsZSAoKG5leHQgPSBwYXRoLmdldEZyb250KCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gc2FmZUdldChjaGlsZC5ub2RlXy5jaGlsZHJlbiwgbmV4dCkgfHwgbmV3IFRyZWVOb2RlKCk7XG4gICAgICAgICAgICBjaGlsZCA9IG5ldyBUcmVlKG5leHQsIGNoaWxkLCBjaGlsZE5vZGUpO1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgucG9wRnJvbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRyZWUgbm9kZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez9UfSBUaGUgZGF0YSBvciBudWxsIGlmIG5vIGRhdGEgZXhpc3RzLlxuICAgICAqL1xuICAgIFRyZWUucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlXy52YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgZGF0YSB0byB0aGlzIHRyZWUgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVR9IHZhbHVlIFZhbHVlIHRvIHNldC5cbiAgICAgKi9cbiAgICBUcmVlLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJywgJ0Nhbm5vdCBzZXQgdmFsdWUgdG8gdW5kZWZpbmVkJyk7XG4gICAgICAgIHRoaXMubm9kZV8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVQYXJlbnRzXygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBjb250ZW50cyBvZiB0aGUgdHJlZSBub2RlIChpdHMgdmFsdWUgYW5kIGFsbCBjaGlsZHJlbikuXG4gICAgICovXG4gICAgVHJlZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm9kZV8udmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLm5vZGVfLmNoaWxkcmVuID0ge307XG4gICAgICAgIHRoaXMubm9kZV8uY2hpbGRDb3VudCA9IDA7XG4gICAgICAgIHRoaXMudXBkYXRlUGFyZW50c18oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHRyZWUgaGFzIGFueSBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBUcmVlLnByb3RvdHlwZS5oYXNDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZV8uY2hpbGRDb3VudCA+IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB0cmVlIGlzIGVtcHR5IChubyB2YWx1ZSBvciBjaGlsZHJlbikuXG4gICAgICovXG4gICAgVHJlZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKSA9PT0gbnVsbCAmJiAhdGhpcy5oYXNDaGlsZHJlbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbHMgYWN0aW9uIGZvciBlYWNoIGNoaWxkIG9mIHRoaXMgdHJlZSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbighVHJlZS48VD4pfSBhY3Rpb24gQWN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBjaGlsZC5cbiAgICAgKi9cbiAgICBUcmVlLnByb3RvdHlwZS5mb3JFYWNoQ2hpbGQgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGZvckVhY2godGhpcy5ub2RlXy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBjaGlsZFRyZWUpIHtcbiAgICAgICAgICAgIGFjdGlvbihuZXcgVHJlZShjaGlsZCwgX3RoaXMsIGNoaWxkVHJlZSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERvZXMgYSBkZXB0aC1maXJzdCB0cmF2ZXJzYWwgb2YgdGhpcyBub2RlJ3MgZGVzY2VuZGFudHMsIGNhbGxpbmcgYWN0aW9uIGZvciBlYWNoIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIVRyZWUuPFQ+KX0gYWN0aW9uIEFjdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2ggY2hpbGQuXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5jbHVkZVNlbGYgV2hldGhlciB0byBjYWxsIGFjdGlvbiBvbiB0aGlzIG5vZGUgYXMgd2VsbC4gRGVmYXVsdHMgdG9cbiAgICAgKiAgIGZhbHNlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGNoaWxkcmVuRmlyc3QgV2hldGhlciB0byBjYWxsIGFjdGlvbiBvbiBjaGlsZHJlbiBiZWZvcmUgY2FsbGluZyBpdCBvblxuICAgICAqICAgcGFyZW50LlxuICAgICAqL1xuICAgIFRyZWUucHJvdG90eXBlLmZvckVhY2hEZXNjZW5kYW50ID0gZnVuY3Rpb24gKGFjdGlvbiwgaW5jbHVkZVNlbGYsIGNoaWxkcmVuRmlyc3QpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVTZWxmICYmICFjaGlsZHJlbkZpcnN0KVxuICAgICAgICAgICAgYWN0aW9uKHRoaXMpO1xuICAgICAgICB0aGlzLmZvckVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLmZvckVhY2hEZXNjZW5kYW50KGFjdGlvbiwgLyppbmNsdWRlU2VsZj0qLyB0cnVlLCBjaGlsZHJlbkZpcnN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbmNsdWRlU2VsZiAmJiBjaGlsZHJlbkZpcnN0KVxuICAgICAgICAgICAgYWN0aW9uKHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbHMgYWN0aW9uIG9uIGVhY2ggYW5jZXN0b3Igbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIVRyZWUuPFQ+KX0gYWN0aW9uIEFjdGlvbiB0byBiZSBjYWxsZWQgb24gZWFjaCBwYXJlbnQ7IHJldHVyblxuICAgICAqICAgdHJ1ZSB0byBhYm9ydC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbmNsdWRlU2VsZiBXaGV0aGVyIHRvIGNhbGwgYWN0aW9uIG9uIHRoaXMgbm9kZSBhcyB3ZWxsLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGFjdGlvbiBjYWxsYmFjayByZXR1cm5lZCB0cnVlLlxuICAgICAqL1xuICAgIFRyZWUucHJvdG90eXBlLmZvckVhY2hBbmNlc3RvciA9IGZ1bmN0aW9uIChhY3Rpb24sIGluY2x1ZGVTZWxmKSB7XG4gICAgICAgIHZhciBub2RlID0gaW5jbHVkZVNlbGYgPyB0aGlzIDogdGhpcy5wYXJlbnQoKTtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChhY3Rpb24obm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERvZXMgYSBkZXB0aC1maXJzdCB0cmF2ZXJzYWwgb2YgdGhpcyBub2RlJ3MgZGVzY2VuZGFudHMuICBXaGVuIGEgZGVzY2VuZGFudCB3aXRoIGEgdmFsdWVcbiAgICAgKiBpcyBmb3VuZCwgYWN0aW9uIGlzIGNhbGxlZCBvbiBpdCBhbmQgdHJhdmVyc2FsIGRvZXMgbm90IGNvbnRpbnVlIGluc2lkZSB0aGUgbm9kZS5cbiAgICAgKiBBY3Rpb24gaXMgKm5vdCogY2FsbGVkIG9uIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIVRyZWUuPFQ+KX0gYWN0aW9uIEFjdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2ggY2hpbGQuXG4gICAgICovXG4gICAgVHJlZS5wcm90b3R5cGUuZm9yRWFjaEltbWVkaWF0ZURlc2NlbmRhbnRXaXRoVmFsdWUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLmdldFZhbHVlKCkgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgYWN0aW9uKGNoaWxkKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjaGlsZC5mb3JFYWNoSW1tZWRpYXRlRGVzY2VuZGFudFdpdGhWYWx1ZShhY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFQYXRofSBUaGUgcGF0aCBvZiB0aGlzIHRyZWUgbm9kZSwgYXMgYSBQYXRoLlxuICAgICAqL1xuICAgIFRyZWUucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aCh0aGlzLnBhcmVudF8gPT09IG51bGxcbiAgICAgICAgICAgID8gdGhpcy5uYW1lX1xuICAgICAgICAgICAgOiB0aGlzLnBhcmVudF8ucGF0aCgpICsgJy8nICsgdGhpcy5uYW1lXyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSB0cmVlIG5vZGUuXG4gICAgICovXG4gICAgVHJlZS5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZV87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/VHJlZX0gVGhlIHBhcmVudCB0cmVlIG5vZGUsIG9yIG51bGwgaWYgdGhpcyBpcyB0aGUgcm9vdCBvZiB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBUcmVlLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudF87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIG9yIHJlbW92ZXMgdGhpcyBjaGlsZCBmcm9tIGl0cyBwYXJlbnQgYmFzZWQgb24gd2hldGhlciBpdCdzIGVtcHR5IG9yIG5vdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVHJlZS5wcm90b3R5cGUudXBkYXRlUGFyZW50c18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudF8gIT09IG51bGwpXG4gICAgICAgICAgICB0aGlzLnBhcmVudF8udXBkYXRlQ2hpbGRfKHRoaXMubmFtZV8sIHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBvciByZW1vdmVzIHRoZSBwYXNzZWQgY2hpbGQgdG8gdGhpcyB0cmVlIG5vZGUsIGRlcGVuZGluZyBvbiB3aGV0aGVyIGl0J3MgZW1wdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hpbGROYW1lIFRoZSBuYW1lIG9mIHRoZSBjaGlsZCB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIHshVHJlZS48VD59IGNoaWxkIFRoZSBjaGlsZCB0byB1cGRhdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBUcmVlLnByb3RvdHlwZS51cGRhdGVDaGlsZF8gPSBmdW5jdGlvbiAoY2hpbGROYW1lLCBjaGlsZCkge1xuICAgICAgICB2YXIgY2hpbGRFbXB0eSA9IGNoaWxkLmlzRW1wdHkoKTtcbiAgICAgICAgdmFyIGNoaWxkRXhpc3RzID0gY29udGFpbnModGhpcy5ub2RlXy5jaGlsZHJlbiwgY2hpbGROYW1lKTtcbiAgICAgICAgaWYgKGNoaWxkRW1wdHkgJiYgY2hpbGRFeGlzdHMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5vZGVfLmNoaWxkcmVuW2NoaWxkTmFtZV07XG4gICAgICAgICAgICB0aGlzLm5vZGVfLmNoaWxkQ291bnQtLTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGFyZW50c18oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghY2hpbGRFbXB0eSAmJiAhY2hpbGRFeGlzdHMpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZV8uY2hpbGRyZW5bY2hpbGROYW1lXSA9IGNoaWxkLm5vZGVfO1xuICAgICAgICAgICAgdGhpcy5ub2RlXy5jaGlsZENvdW50Kys7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhcmVudHNfKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUcmVlO1xufSgpKTtcbmV4cG9ydCB7IFRyZWUgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS91dGlsL1RyZWUuanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuL0V2ZW50RW1pdHRlcic7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG4vKipcbiAqIEBleHRlbmRzIHtFdmVudEVtaXR0ZXJ9XG4gKi9cbnZhciBWaXNpYmlsaXR5TW9uaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmlzaWJpbGl0eU1vbml0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmlzaWJpbGl0eU1vbml0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFsndmlzaWJsZSddKSB8fCB0aGlzO1xuICAgICAgICB2YXIgaGlkZGVuO1xuICAgICAgICB2YXIgdmlzaWJpbGl0eUNoYW5nZTtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudFsnaGlkZGVuJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gT3BlcmEgMTIuMTAgYW5kIEZpcmVmb3ggMTggYW5kIGxhdGVyIHN1cHBvcnRcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ3Zpc2liaWxpdHljaGFuZ2UnO1xuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Wydtb3pIaWRkZW4nXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ21venZpc2liaWxpdHljaGFuZ2UnO1xuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICdtb3pIaWRkZW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Wydtc0hpZGRlbiddICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAnbXN2aXNpYmlsaXR5Y2hhbmdlJztcbiAgICAgICAgICAgICAgICBoaWRkZW4gPSAnbXNIaWRkZW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Wyd3ZWJraXRIaWRkZW4nXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ3dlYmtpdHZpc2liaWxpdHljaGFuZ2UnO1xuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICd3ZWJraXRIaWRkZW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEluaXRpYWxseSwgd2UgYWx3YXlzIGFzc3VtZSB3ZSBhcmUgdmlzaWJsZS4gVGhpcyBlbnN1cmVzIHRoYXQgaW4gYnJvd3NlcnNcbiAgICAgICAgLy8gd2l0aG91dCBwYWdlIHZpc2liaWxpdHkgc3VwcG9ydCBvciBpbiBjYXNlcyB3aGVyZSB3ZSBhcmUgbmV2ZXIgdmlzaWJsZVxuICAgICAgICAvLyAoZS5nLiBjaHJvbWUgZXh0ZW5zaW9uKSwgd2UgYWN0IGFzIGlmIHdlIGFyZSB2aXNpYmxlLCBpLmUuIGRvbid0IGRlbGF5XG4gICAgICAgIC8vIHJlY29ubmVjdHNcbiAgICAgICAgX3RoaXMudmlzaWJsZV8gPSB0cnVlO1xuICAgICAgICBpZiAodmlzaWJpbGl0eUNoYW5nZSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih2aXNpYmlsaXR5Q2hhbmdlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpc2libGUgPSAhZG9jdW1lbnRbaGlkZGVuXTtcbiAgICAgICAgICAgICAgICBpZiAodmlzaWJsZSAhPT0gX3RoaXMudmlzaWJsZV8pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlzaWJsZV8gPSB2aXNpYmxlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmlnZ2VyKCd2aXNpYmxlJywgdmlzaWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVmlzaWJpbGl0eU1vbml0b3IuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmlzaWJpbGl0eU1vbml0b3IoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gZXZlbnRUeXBlXG4gICAgICogQHJldHVybiB7QXJyYXkuPGJvb2xlYW4+fVxuICAgICAqL1xuICAgIFZpc2liaWxpdHlNb25pdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG4gICAgICAgIGFzc2VydChldmVudFR5cGUgPT09ICd2aXNpYmxlJywgJ1Vua25vd24gZXZlbnQgdHlwZTogJyArIGV2ZW50VHlwZSk7XG4gICAgICAgIHJldHVybiBbdGhpcy52aXNpYmxlX107XG4gICAgfTtcbiAgICByZXR1cm4gVmlzaWJpbGl0eU1vbml0b3I7XG59KEV2ZW50RW1pdHRlcikpO1xuZXhwb3J0IHsgVmlzaWJpbGl0eU1vbml0b3IgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS91dGlsL1Zpc2liaWxpdHlNb25pdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGdldFZhbHVlcywgc2FmZUdldCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IENoYW5nZSB9IGZyb20gJy4vQ2hhbmdlJztcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0aW9uRXJyb3IgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDaGlsZENoYW5nZUFjY3VtdWxhdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZU1hcF8gPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshQ2hhbmdlfSBjaGFuZ2VcbiAgICAgKi9cbiAgICBDaGlsZENoYW5nZUFjY3VtdWxhdG9yLnByb3RvdHlwZS50cmFja0NoaWxkQ2hhbmdlID0gZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGNoYW5nZS50eXBlO1xuICAgICAgICB2YXIgY2hpbGRLZXkgLyoqIEB0eXBlIHshc3RyaW5nfSAqLyA9IGNoYW5nZS5jaGlsZE5hbWU7XG4gICAgICAgIGFzc2VydCh0eXBlID09IENoYW5nZS5DSElMRF9BRERFRCB8fFxuICAgICAgICAgICAgdHlwZSA9PSBDaGFuZ2UuQ0hJTERfQ0hBTkdFRCB8fFxuICAgICAgICAgICAgdHlwZSA9PSBDaGFuZ2UuQ0hJTERfUkVNT1ZFRCwgJ09ubHkgY2hpbGQgY2hhbmdlcyBzdXBwb3J0ZWQgZm9yIHRyYWNraW5nJyk7XG4gICAgICAgIGFzc2VydChjaGlsZEtleSAhPT0gJy5wcmlvcml0eScsICdPbmx5IG5vbi1wcmlvcml0eSBjaGlsZCBjaGFuZ2VzIGNhbiBiZSB0cmFja2VkLicpO1xuICAgICAgICB2YXIgb2xkQ2hhbmdlID0gc2FmZUdldCh0aGlzLmNoYW5nZU1hcF8sIGNoaWxkS2V5KTtcbiAgICAgICAgaWYgKG9sZENoYW5nZSkge1xuICAgICAgICAgICAgdmFyIG9sZFR5cGUgPSBvbGRDaGFuZ2UudHlwZTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IENoYW5nZS5DSElMRF9BRERFRCAmJiBvbGRUeXBlID09IENoYW5nZS5DSElMRF9SRU1PVkVEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXBfW2NoaWxkS2V5XSA9IENoYW5nZS5jaGlsZENoYW5nZWRDaGFuZ2UoY2hpbGRLZXksIGNoYW5nZS5zbmFwc2hvdE5vZGUsIG9sZENoYW5nZS5zbmFwc2hvdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBDaGFuZ2UuQ0hJTERfUkVNT1ZFRCAmJlxuICAgICAgICAgICAgICAgIG9sZFR5cGUgPT0gQ2hhbmdlLkNISUxEX0FEREVEKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2hhbmdlTWFwX1tjaGlsZEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IENoYW5nZS5DSElMRF9SRU1PVkVEICYmXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PSBDaGFuZ2UuQ0hJTERfQ0hBTkdFRCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwX1tjaGlsZEtleV0gPSBDaGFuZ2UuY2hpbGRSZW1vdmVkQ2hhbmdlKGNoaWxkS2V5LCBvbGRDaGFuZ2Uub2xkU25hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IENoYW5nZS5DSElMRF9DSEFOR0VEICYmXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PSBDaGFuZ2UuQ0hJTERfQURERUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZU1hcF9bY2hpbGRLZXldID0gQ2hhbmdlLmNoaWxkQWRkZWRDaGFuZ2UoY2hpbGRLZXksIGNoYW5nZS5zbmFwc2hvdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBDaGFuZ2UuQ0hJTERfQ0hBTkdFRCAmJlxuICAgICAgICAgICAgICAgIG9sZFR5cGUgPT0gQ2hhbmdlLkNISUxEX0NIQU5HRUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZU1hcF9bY2hpbGRLZXldID0gQ2hhbmdlLmNoaWxkQ2hhbmdlZENoYW5nZShjaGlsZEtleSwgY2hhbmdlLnNuYXBzaG90Tm9kZSwgb2xkQ2hhbmdlLm9sZFNuYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IoJ0lsbGVnYWwgY29tYmluYXRpb24gb2YgY2hhbmdlczogJyArXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSArXG4gICAgICAgICAgICAgICAgICAgICcgb2NjdXJyZWQgYWZ0ZXIgJyArXG4gICAgICAgICAgICAgICAgICAgIG9sZENoYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcF9bY2hpbGRLZXldID0gY2hhbmdlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFDaGFuZ2U+fVxuICAgICAqL1xuICAgIENoaWxkQ2hhbmdlQWNjdW11bGF0b3IucHJvdG90eXBlLmdldENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXRWYWx1ZXModGhpcy5jaGFuZ2VNYXBfKTtcbiAgICB9O1xuICAgIHJldHVybiBDaGlsZENoYW5nZUFjY3VtdWxhdG9yO1xufSgpKTtcbmV4cG9ydCB7IENoaWxkQ2hhbmdlQWNjdW11bGF0b3IgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS92aWV3L0NoaWxkQ2hhbmdlQWNjdW11bGF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDExMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi9DYWNoZU5vZGUnO1xuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBDb21wbGV0ZUNoaWxkU291cmNlIHRoYXQgbmV2ZXIgcmV0dXJucyBhbnkgYWRkaXRpb25hbCBjaGlsZHJlblxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIENvbXBsZXRlQ2hpbGRTb3VyY2VcbiAqL1xudmFyIE5vQ29tcGxldGVDaGlsZFNvdXJjZV8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9Db21wbGV0ZUNoaWxkU291cmNlXygpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBOb0NvbXBsZXRlQ2hpbGRTb3VyY2VfLnByb3RvdHlwZS5nZXRDb21wbGV0ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkS2V5KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBOb0NvbXBsZXRlQ2hpbGRTb3VyY2VfLnByb3RvdHlwZS5nZXRDaGlsZEFmdGVyQ2hpbGQgPSBmdW5jdGlvbiAoaW5kZXgsIGNoaWxkLCByZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIE5vQ29tcGxldGVDaGlsZFNvdXJjZV87XG59KCkpO1xuZXhwb3J0IHsgTm9Db21wbGV0ZUNoaWxkU291cmNlXyB9O1xuLyoqXG4gKiBTaW5nbGV0b24gaW5zdGFuY2UuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHshQ29tcGxldGVDaGlsZFNvdXJjZX1cbiAqL1xuZXhwb3J0IHZhciBOT19DT01QTEVURV9DSElMRF9TT1VSQ0UgPSBuZXcgTm9Db21wbGV0ZUNoaWxkU291cmNlXygpO1xuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBDb21wbGV0ZUNoaWxkU291cmNlIHRoYXQgdXNlcyBhIFdyaXRlVHJlZSBpbiBhZGRpdGlvbiB0byBhbnkgb3RoZXIgc2VydmVyIGRhdGEgb3JcbiAqIG9sZCBldmVudCBjYWNoZXMgYXZhaWxhYmxlIHRvIGNhbGN1bGF0ZSBjb21wbGV0ZSBjaGlsZHJlbi5cbiAqXG4gKlxuICogQGltcGxlbWVudHMgQ29tcGxldGVDaGlsZFNvdXJjZVxuICovXG52YXIgV3JpdGVUcmVlQ29tcGxldGVDaGlsZFNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc19cbiAgICAgKiBAcGFyYW0geyFWaWV3Q2FjaGV9IHZpZXdDYWNoZV9cbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBvcHRDb21wbGV0ZVNlcnZlckNhY2hlX1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2Uod3JpdGVzXywgdmlld0NhY2hlXywgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8pIHtcbiAgICAgICAgaWYgKG9wdENvbXBsZXRlU2VydmVyQ2FjaGVfID09PSB2b2lkIDApIHsgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gPSBudWxsOyB9XG4gICAgICAgIHRoaXMud3JpdGVzXyA9IHdyaXRlc187XG4gICAgICAgIHRoaXMudmlld0NhY2hlXyA9IHZpZXdDYWNoZV87XG4gICAgICAgIHRoaXMub3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gPSBvcHRDb21wbGV0ZVNlcnZlckNhY2hlXztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlLnByb3RvdHlwZS5nZXRDb21wbGV0ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkS2V5KSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy52aWV3Q2FjaGVfLmdldEV2ZW50Q2FjaGUoKTtcbiAgICAgICAgaWYgKG5vZGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0Tm9kZSgpLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzZXJ2ZXJOb2RlID0gdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlXyAhPSBudWxsXG4gICAgICAgICAgICAgICAgPyBuZXcgQ2FjaGVOb2RlKHRoaXMub3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8sIHRydWUsIGZhbHNlKVxuICAgICAgICAgICAgICAgIDogdGhpcy52aWV3Q2FjaGVfLmdldFNlcnZlckNhY2hlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cml0ZXNfLmNhbGNDb21wbGV0ZUNoaWxkKGNoaWxkS2V5LCBzZXJ2ZXJOb2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlLnByb3RvdHlwZS5nZXRDaGlsZEFmdGVyQ2hpbGQgPSBmdW5jdGlvbiAoaW5kZXgsIGNoaWxkLCByZXZlcnNlKSB7XG4gICAgICAgIHZhciBjb21wbGV0ZVNlcnZlckRhdGEgPSB0aGlzLm9wdENvbXBsZXRlU2VydmVyQ2FjaGVfICE9IG51bGxcbiAgICAgICAgICAgID8gdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlX1xuICAgICAgICAgICAgOiB0aGlzLnZpZXdDYWNoZV8uZ2V0Q29tcGxldGVTZXJ2ZXJTbmFwKCk7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMud3JpdGVzXy5jYWxjSW5kZXhlZFNsaWNlKGNvbXBsZXRlU2VydmVyRGF0YSwgY2hpbGQsIDEsIHJldmVyc2UsIGluZGV4KTtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZXNbMF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlO1xufSgpKTtcbmV4cG9ydCB7IFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2UgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS92aWV3L0NvbXBsZXRlQ2hpbGRTb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuLyoqXG4gKiBFbmNhcHN1bGF0ZXMgdGhlIGRhdGEgbmVlZGVkIHRvIHJhaXNlIGFuIGV2ZW50XG4gKiBAaW1wbGVtZW50cyB7RXZlbnR9XG4gKi9cbnZhciBEYXRhRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBldmVudFR5cGUgT25lIG9mOiB2YWx1ZSwgY2hpbGRfYWRkZWQsIGNoaWxkX2NoYW5nZWQsIGNoaWxkX21vdmVkLCBjaGlsZF9yZW1vdmVkXG4gICAgICogQHBhcmFtIHshRXZlbnRSZWdpc3RyYXRpb259IGV2ZW50UmVnaXN0cmF0aW9uIFRoZSBmdW5jdGlvbiB0byBjYWxsIHRvIHdpdGggdGhlIGV2ZW50IGRhdGEuIFVzZXIgcHJvdmlkZWRcbiAgICAgKiBAcGFyYW0geyFEYXRhU25hcHNob3R9IHNuYXBzaG90IFRoZSBkYXRhIGJhY2tpbmcgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHs/c3RyaW5nPX0gcHJldk5hbWUgT3B0aW9uYWwsIHRoZSBuYW1lIG9mIHRoZSBwcmV2aW91cyBjaGlsZCBmb3IgY2hpbGRfKiBldmVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGF0YUV2ZW50KGV2ZW50VHlwZSwgZXZlbnRSZWdpc3RyYXRpb24sIHNuYXBzaG90LCBwcmV2TmFtZSkge1xuICAgICAgICB0aGlzLmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcbiAgICAgICAgdGhpcy5ldmVudFJlZ2lzdHJhdGlvbiA9IGV2ZW50UmVnaXN0cmF0aW9uO1xuICAgICAgICB0aGlzLnNuYXBzaG90ID0gc25hcHNob3Q7XG4gICAgICAgIHRoaXMucHJldk5hbWUgPSBwcmV2TmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBEYXRhRXZlbnQucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzLnNuYXBzaG90LmdldFJlZigpO1xuICAgICAgICBpZiAodGhpcy5ldmVudFR5cGUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIHJldHVybiByZWYucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWYuZ2V0UGFyZW50KCkucGF0aDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBEYXRhRXZlbnQucHJvdG90eXBlLmdldEV2ZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRUeXBlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBEYXRhRXZlbnQucHJvdG90eXBlLmdldEV2ZW50UnVubmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFJlZ2lzdHJhdGlvbi5nZXRFdmVudFJ1bm5lcih0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgRGF0YUV2ZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmdldFBhdGgoKS50b1N0cmluZygpICtcbiAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICB0aGlzLmV2ZW50VHlwZSArXG4gICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgc3RyaW5naWZ5KHRoaXMuc25hcHNob3QuZXhwb3J0VmFsKCkpKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRhRXZlbnQ7XG59KCkpO1xuZXhwb3J0IHsgRGF0YUV2ZW50IH07XG52YXIgQ2FuY2VsRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFdmVudFJlZ2lzdHJhdGlvbn0gZXZlbnRSZWdpc3RyYXRpb25cbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDYW5jZWxFdmVudChldmVudFJlZ2lzdHJhdGlvbiwgZXJyb3IsIHBhdGgpIHtcbiAgICAgICAgdGhpcy5ldmVudFJlZ2lzdHJhdGlvbiA9IGV2ZW50UmVnaXN0cmF0aW9uO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQ2FuY2VsRXZlbnQucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIENhbmNlbEV2ZW50LnByb3RvdHlwZS5nZXRFdmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnY2FuY2VsJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQ2FuY2VsRXZlbnQucHJvdG90eXBlLmdldEV2ZW50UnVubmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFJlZ2lzdHJhdGlvbi5nZXRFdmVudFJ1bm5lcih0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQ2FuY2VsRXZlbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLnRvU3RyaW5nKCkgKyAnOmNhbmNlbCc7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FuY2VsRXZlbnQ7XG59KCkpO1xuZXhwb3J0IHsgQ2FuY2VsRXZlbnQgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS92aWV3L0V2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IE5hbWVkTm9kZSB9IGZyb20gJy4uL3NuYXAvTm9kZSc7XG5pbXBvcnQgeyBDaGFuZ2UgfSBmcm9tICcuL0NoYW5nZSc7XG5pbXBvcnQgeyBhc3NlcnRpb25FcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbi8qKlxuICogQW4gRXZlbnRHZW5lcmF0b3IgaXMgdXNlZCB0byBjb252ZXJ0IFwicmF3XCIgY2hhbmdlcyAoQ2hhbmdlKSBhcyBjb21wdXRlZCBieSB0aGVcbiAqIENhY2hlRGlmZmVyIGludG8gYWN0dWFsIGV2ZW50cyAoRXZlbnQpIHRoYXQgY2FuIGJlIHJhaXNlZC4gIFNlZSBnZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXMoKVxuICogZm9yIGRldGFpbHMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBFdmVudEdlbmVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeV9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFdmVudEdlbmVyYXRvcihxdWVyeV8pIHtcbiAgICAgICAgdGhpcy5xdWVyeV8gPSBxdWVyeV87XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7IUluZGV4fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleF8gPSB0aGlzLnF1ZXJ5Xy5nZXRRdWVyeVBhcmFtcygpLmdldEluZGV4KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgc2V0IG9mIHJhdyBjaGFuZ2VzIChubyBtb3ZlZCBldmVudHMgYW5kIHByZXZOYW1lIG5vdCBzcGVjaWZpZWQgeWV0KSwgYW5kIGEgc2V0IG9mXG4gICAgICogRXZlbnRSZWdpc3RyYXRpb25zIHRoYXQgc2hvdWxkIGJlIG5vdGlmaWVkIG9mIHRoZXNlIGNoYW5nZXMsIGdlbmVyYXRlIHRoZSBhY3R1YWwgZXZlbnRzIHRvIGJlIHJhaXNlZC5cbiAgICAgKlxuICAgICAqIE5vdGVzOlxuICAgICAqICAtIGNoaWxkX21vdmVkIGV2ZW50cyB3aWxsIGJlIHN5bnRoZXNpemVkIGF0IHRoaXMgdGltZSBmb3IgYW55IGNoaWxkX2NoYW5nZWQgZXZlbnRzIHRoYXQgYWZmZWN0XG4gICAgICogICAgb3VyIGluZGV4LlxuICAgICAqICAtIHByZXZOYW1lIHdpbGwgYmUgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgaW5kZXggb3JkZXJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFBcnJheS48IUNoYW5nZT59IGNoYW5nZXNcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBldmVudENhY2hlXG4gICAgICogQHBhcmFtIHshQXJyYXkuPCFFdmVudFJlZ2lzdHJhdGlvbj59IGV2ZW50UmVnaXN0cmF0aW9uc1xuICAgICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn1cbiAgICAgKi9cbiAgICBFdmVudEdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMsIGV2ZW50Q2FjaGUsIGV2ZW50UmVnaXN0cmF0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZXZlbnRzID0gW107XG4gICAgICAgIHZhciBtb3ZlcyA9IFtdO1xuICAgICAgICBjaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZS50eXBlID09PSBDaGFuZ2UuQ0hJTERfQ0hBTkdFRCAmJlxuICAgICAgICAgICAgICAgIF90aGlzLmluZGV4Xy5pbmRleGVkVmFsdWVDaGFuZ2VkKGNoYW5nZS5vbGRTbmFwLCBjaGFuZ2Uuc25hcHNob3ROb2RlKSkge1xuICAgICAgICAgICAgICAgIG1vdmVzLnB1c2goQ2hhbmdlLmNoaWxkTW92ZWRDaGFuZ2UoY2hhbmdlLmNoaWxkTmFtZSwgY2hhbmdlLnNuYXBzaG90Tm9kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUV2ZW50c0ZvclR5cGVfKGV2ZW50cywgQ2hhbmdlLkNISUxEX1JFTU9WRUQsIGNoYW5nZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVFdmVudHNGb3JUeXBlXyhldmVudHMsIENoYW5nZS5DSElMRF9BRERFRCwgY2hhbmdlcywgZXZlbnRSZWdpc3RyYXRpb25zLCBldmVudENhY2hlKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUV2ZW50c0ZvclR5cGVfKGV2ZW50cywgQ2hhbmdlLkNISUxEX01PVkVELCBtb3ZlcywgZXZlbnRSZWdpc3RyYXRpb25zLCBldmVudENhY2hlKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUV2ZW50c0ZvclR5cGVfKGV2ZW50cywgQ2hhbmdlLkNISUxEX0NIQU5HRUQsIGNoYW5nZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVFdmVudHNGb3JUeXBlXyhldmVudHMsIENoYW5nZS5WQUxVRSwgY2hhbmdlcywgZXZlbnRSZWdpc3RyYXRpb25zLCBldmVudENhY2hlKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGNoYW5nZXMgb2YgYSBzaW5nbGUgY2hhbmdlIHR5cGUsIGdlbmVyYXRlIHRoZSBjb3JyZXNwb25kaW5nIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhRXZlbnQ+fSBldmVudHNcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGV2ZW50VHlwZVxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhQ2hhbmdlPn0gY2hhbmdlc1xuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhRXZlbnRSZWdpc3RyYXRpb24+fSByZWdpc3RyYXRpb25zXG4gICAgICogQHBhcmFtIHshTm9kZX0gZXZlbnRDYWNoZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRXZlbnRHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlRXZlbnRzRm9yVHlwZV8gPSBmdW5jdGlvbiAoZXZlbnRzLCBldmVudFR5cGUsIGNoYW5nZXMsIHJlZ2lzdHJhdGlvbnMsIGV2ZW50Q2FjaGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZpbHRlcmVkQ2hhbmdlcyA9IGNoYW5nZXMuZmlsdGVyKGZ1bmN0aW9uIChjaGFuZ2UpIHsgcmV0dXJuIGNoYW5nZS50eXBlID09PSBldmVudFR5cGU7IH0pO1xuICAgICAgICBmaWx0ZXJlZENoYW5nZXMuc29ydCh0aGlzLmNvbXBhcmVDaGFuZ2VzXy5iaW5kKHRoaXMpKTtcbiAgICAgICAgZmlsdGVyZWRDaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsaXplZENoYW5nZSA9IF90aGlzLm1hdGVyaWFsaXplU2luZ2xlQ2hhbmdlXyhjaGFuZ2UsIGV2ZW50Q2FjaGUpO1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAocmVnaXN0cmF0aW9uLnJlc3BvbmRzVG8oY2hhbmdlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHJlZ2lzdHJhdGlvbi5jcmVhdGVFdmVudChtYXRlcmlhbGl6ZWRDaGFuZ2UsIF90aGlzLnF1ZXJ5XykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUNoYW5nZX0gY2hhbmdlXG4gICAgICogQHBhcmFtIHshTm9kZX0gZXZlbnRDYWNoZVxuICAgICAqIEByZXR1cm4geyFDaGFuZ2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBFdmVudEdlbmVyYXRvci5wcm90b3R5cGUubWF0ZXJpYWxpemVTaW5nbGVDaGFuZ2VfID0gZnVuY3Rpb24gKGNoYW5nZSwgZXZlbnRDYWNoZSkge1xuICAgICAgICBpZiAoY2hhbmdlLnR5cGUgPT09ICd2YWx1ZScgfHwgY2hhbmdlLnR5cGUgPT09ICdjaGlsZF9yZW1vdmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZS5wcmV2TmFtZSA9IGV2ZW50Q2FjaGUuZ2V0UHJlZGVjZXNzb3JDaGlsZE5hbWUoXG4gICAgICAgICAgICAvKiogQHR5cGUgeyFzdHJpbmd9ICovXG4gICAgICAgICAgICBjaGFuZ2UuY2hpbGROYW1lLCBjaGFuZ2Uuc25hcHNob3ROb2RlLCB0aGlzLmluZGV4Xyk7XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFDaGFuZ2V9IGFcbiAgICAgKiBAcGFyYW0geyFDaGFuZ2V9IGJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBFdmVudEdlbmVyYXRvci5wcm90b3R5cGUuY29tcGFyZUNoYW5nZXNfID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuY2hpbGROYW1lID09IG51bGwgfHwgYi5jaGlsZE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IoJ1Nob3VsZCBvbmx5IGNvbXBhcmUgY2hpbGRfIGV2ZW50cy4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYVdyYXBwZWQgPSBuZXcgTmFtZWROb2RlKGEuY2hpbGROYW1lLCBhLnNuYXBzaG90Tm9kZSk7XG4gICAgICAgIHZhciBiV3JhcHBlZCA9IG5ldyBOYW1lZE5vZGUoYi5jaGlsZE5hbWUsIGIuc25hcHNob3ROb2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfLmNvbXBhcmUoYVdyYXBwZWQsIGJXcmFwcGVkKTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudEdlbmVyYXRvcjtcbn0oKSk7XG5leHBvcnQgeyBFdmVudEdlbmVyYXRvciB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3ZpZXcvRXZlbnRHZW5lcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgbG9nLCBsb2dnZXIsIGV4Y2VwdGlvbkd1YXJkIH0gZnJvbSAnLi4vdXRpbC91dGlsJztcbi8qKlxuICogVGhlIGV2ZW50IHF1ZXVlIHNlcnZlcyBhIGZldyBwdXJwb3NlczpcbiAqIDEuIEl0IGVuc3VyZXMgd2UgbWFpbnRhaW4gZXZlbnQgb3JkZXIgaW4gdGhlIGZhY2Ugb2YgZXZlbnQgY2FsbGJhY2tzIGRvaW5nIG9wZXJhdGlvbnMgdGhhdCByZXN1bHQgaW4gbW9yZVxuICogICAgZXZlbnRzIGJlaW5nIHF1ZXVlZC5cbiAqIDIuIHJhaXNlUXVldWVkRXZlbnRzKCkgaGFuZGxlcyBiZWluZyBjYWxsZWQgcmVlbnRyYW50bHkgbmljZWx5LiAgVGhhdCBpcywgaWYgaW4gdGhlIGNvdXJzZSBvZiByYWlzaW5nIGV2ZW50cyxcbiAqICAgIHJhaXNlUXVldWVkRXZlbnRzKCkgaXMgY2FsbGVkIGFnYWluLCB0aGUgXCJpbm5lclwiIGNhbGwgd2lsbCBwaWNrIHVwIHJhaXNpbmcgZXZlbnRzIHdoZXJlIHRoZSBcIm91dGVyXCIgY2FsbFxuICogICAgbGVmdCBvZmYsIGVuc3VyaW5nIHRoYXQgdGhlIGV2ZW50cyBhcmUgc3RpbGwgcmFpc2VkIHN5bmNocm9ub3VzbHkgYW5kIGluIG9yZGVyLlxuICogMy4gWW91IGNhbiB1c2UgcmFpc2VFdmVudHNBdFBhdGggYW5kIHJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGggdG8gZW5zdXJlIG9ubHkgcmVsZXZhbnQgcHJldmlvdXNseS1xdWV1ZWRcbiAqICAgIGV2ZW50cyBhcmUgcmFpc2VkIHN5bmNocm9ub3VzbHkuXG4gKlxuICogTk9URTogVGhpcyBjYW4gYWxsIGdvIGF3YXkgaWYvd2hlbiB3ZSBtb3ZlIHRvIGFzeW5jIGV2ZW50cy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEV2ZW50UXVldWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnRRdWV1ZSgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHshQXJyYXkuPEV2ZW50TGlzdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2ZW50TGlzdHNfID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFja3MgcmVjdXJzaW9uIGRlcHRoIG9mIHJhaXNlUXVldWVkRXZlbnRzXywgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUgeyFudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlY3Vyc2lvbkRlcHRoXyA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUFycmF5LjxFdmVudD59IGV2ZW50RGF0YUxpc3QgVGhlIG5ldyBldmVudHMgdG8gcXVldWUuXG4gICAgICovXG4gICAgRXZlbnRRdWV1ZS5wcm90b3R5cGUucXVldWVFdmVudHMgPSBmdW5jdGlvbiAoZXZlbnREYXRhTGlzdCkge1xuICAgICAgICAvLyBXZSBncm91cCBldmVudHMgYnkgcGF0aCwgc3RvcmluZyB0aGVtIGluIGEgc2luZ2xlIEV2ZW50TGlzdCwgdG8gbWFrZSBpdCBlYXNpZXIgdG8gc2tpcCBvdmVyIHRoZW0gcXVpY2tseS5cbiAgICAgICAgdmFyIGN1cnJMaXN0ID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudERhdGFMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnREYXRhID0gZXZlbnREYXRhTGlzdFtpXTtcbiAgICAgICAgICAgIHZhciBldmVudFBhdGggPSBldmVudERhdGEuZ2V0UGF0aCgpO1xuICAgICAgICAgICAgaWYgKGN1cnJMaXN0ICE9PSBudWxsICYmICFldmVudFBhdGguZXF1YWxzKGN1cnJMaXN0LmdldFBhdGgoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TGlzdHNfLnB1c2goY3Vyckxpc3QpO1xuICAgICAgICAgICAgICAgIGN1cnJMaXN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyTGlzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1cnJMaXN0ID0gbmV3IEV2ZW50TGlzdChldmVudFBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3Vyckxpc3QuYWRkKGV2ZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJMaXN0KSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TGlzdHNfLnB1c2goY3Vyckxpc3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBRdWV1ZXMgdGhlIHNwZWNpZmllZCBldmVudHMgYW5kIHN5bmNocm9ub3VzbHkgcmFpc2VzIGFsbCBldmVudHMgKGluY2x1ZGluZyBwcmV2aW91c2x5IHF1ZXVlZCBvbmVzKVxuICAgICAqIGZvciB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICpcbiAgICAgKiBJdCBpcyBhc3N1bWVkIHRoYXQgdGhlIG5ldyBldmVudHMgYXJlIGFsbCBmb3IgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aCBUaGUgcGF0aCB0byByYWlzZSBldmVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7IUFycmF5LjxFdmVudD59IGV2ZW50RGF0YUxpc3QgVGhlIG5ldyBldmVudHMgdG8gcmFpc2UuXG4gICAgICovXG4gICAgRXZlbnRRdWV1ZS5wcm90b3R5cGUucmFpc2VFdmVudHNBdFBhdGggPSBmdW5jdGlvbiAocGF0aCwgZXZlbnREYXRhTGlzdCkge1xuICAgICAgICB0aGlzLnF1ZXVlRXZlbnRzKGV2ZW50RGF0YUxpc3QpO1xuICAgICAgICB0aGlzLnJhaXNlUXVldWVkRXZlbnRzTWF0Y2hpbmdQcmVkaWNhdGVfKGZ1bmN0aW9uIChldmVudFBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudFBhdGguZXF1YWxzKHBhdGgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFF1ZXVlcyB0aGUgc3BlY2lmaWVkIGV2ZW50cyBhbmQgc3luY2hyb25vdXNseSByYWlzZXMgYWxsIGV2ZW50cyAoaW5jbHVkaW5nIHByZXZpb3VzbHkgcXVldWVkIG9uZXMpIGZvclxuICAgICAqIGxvY2F0aW9ucyByZWxhdGVkIHRvIHRoZSBzcGVjaWZpZWQgY2hhbmdlIHBhdGggKGkuZS4gYWxsIGFuY2VzdG9ycyBhbmQgZGVzY2VuZGFudHMpLlxuICAgICAqXG4gICAgICogSXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBuZXcgZXZlbnRzIGFyZSBhbGwgcmVsYXRlZCAoYW5jZXN0b3Igb3IgZGVzY2VuZGFudCkgdG8gdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gY2hhbmdlZFBhdGggVGhlIHBhdGggdG8gcmFpc2UgZXZlbnRzIGZvci5cbiAgICAgKiBAcGFyYW0geyFBcnJheS48IUV2ZW50Pn0gZXZlbnREYXRhTGlzdCBUaGUgZXZlbnRzIHRvIHJhaXNlXG4gICAgICovXG4gICAgRXZlbnRRdWV1ZS5wcm90b3R5cGUucmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aCA9IGZ1bmN0aW9uIChjaGFuZ2VkUGF0aCwgZXZlbnREYXRhTGlzdCkge1xuICAgICAgICB0aGlzLnF1ZXVlRXZlbnRzKGV2ZW50RGF0YUxpc3QpO1xuICAgICAgICB0aGlzLnJhaXNlUXVldWVkRXZlbnRzTWF0Y2hpbmdQcmVkaWNhdGVfKGZ1bmN0aW9uIChldmVudFBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudFBhdGguY29udGFpbnMoY2hhbmdlZFBhdGgpIHx8IGNoYW5nZWRQYXRoLmNvbnRhaW5zKGV2ZW50UGF0aCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshZnVuY3Rpb24oIVBhdGgpOmJvb2xlYW59IHByZWRpY2F0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRXZlbnRRdWV1ZS5wcm90b3R5cGUucmFpc2VRdWV1ZWRFdmVudHNNYXRjaGluZ1ByZWRpY2F0ZV8gPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgIHRoaXMucmVjdXJzaW9uRGVwdGhfKys7XG4gICAgICAgIHZhciBzZW50QWxsID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50TGlzdHNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRMaXN0ID0gdGhpcy5ldmVudExpc3RzX1tpXTtcbiAgICAgICAgICAgIGlmIChldmVudExpc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRQYXRoID0gZXZlbnRMaXN0LmdldFBhdGgoKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKGV2ZW50UGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudExpc3RzX1tpXS5yYWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TGlzdHNfW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbnRBbGwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbnRBbGwpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0c18gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlY3Vyc2lvbkRlcHRoXy0tO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50UXVldWU7XG59KCkpO1xuZXhwb3J0IHsgRXZlbnRRdWV1ZSB9O1xuLyoqXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEV2ZW50TGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudExpc3QocGF0aF8pIHtcbiAgICAgICAgdGhpcy5wYXRoXyA9IHBhdGhfO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFBcnJheS48RXZlbnQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ldmVudHNfID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUV2ZW50fSBldmVudERhdGFcbiAgICAgKi9cbiAgICBFdmVudExpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChldmVudERhdGEpIHtcbiAgICAgICAgdGhpcy5ldmVudHNfLnB1c2goZXZlbnREYXRhKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIGxpc3QgYW5kIHJhaXNlcyBlYWNoIGV2ZW50XG4gICAgICovXG4gICAgRXZlbnRMaXN0LnByb3RvdHlwZS5yYWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50c18ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB0aGlzLmV2ZW50c19baV07XG4gICAgICAgICAgICBpZiAoZXZlbnREYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHNfW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRGbiA9IGV2ZW50RGF0YS5nZXRFdmVudFJ1bm5lcigpO1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKCdldmVudDogJyArIGV2ZW50RGF0YS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhjZXB0aW9uR3VhcmQoZXZlbnRGbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFQYXRofVxuICAgICAqL1xuICAgIEV2ZW50TGlzdC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aF87XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRMaXN0O1xufSgpKTtcbmV4cG9ydCB7IEV2ZW50TGlzdCB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3ZpZXcvRXZlbnRRdWV1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBEYXRhU25hcHNob3QgfSBmcm9tICcuLi8uLi9hcGkvRGF0YVNuYXBzaG90JztcbmltcG9ydCB7IERhdGFFdmVudCwgQ2FuY2VsRXZlbnQgfSBmcm9tICcuL0V2ZW50JztcbmltcG9ydCB7IGNvbnRhaW5zLCBnZXRDb3VudCwgZ2V0QW55S2V5LCBldmVyeSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbi8qKlxuICogUmVwcmVzZW50cyByZWdpc3RyYXRpb24gZm9yICd2YWx1ZScgZXZlbnRzLlxuICovXG52YXIgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbighRGF0YVNuYXBzaG90KX0gY2FsbGJhY2tfXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb24oRXJyb3IpfSBjYW5jZWxDYWxsYmFja19cbiAgICAgKiBAcGFyYW0gez9PYmplY3R9IGNvbnRleHRfXG4gICAgICovXG4gICAgZnVuY3Rpb24gVmFsdWVFdmVudFJlZ2lzdHJhdGlvbihjYWxsYmFja18sIGNhbmNlbENhbGxiYWNrXywgY29udGV4dF8pIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFja187XG4gICAgICAgIHRoaXMuY2FuY2VsQ2FsbGJhY2tfID0gY2FuY2VsQ2FsbGJhY2tfO1xuICAgICAgICB0aGlzLmNvbnRleHRfID0gY29udGV4dF87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbi5wcm90b3R5cGUucmVzcG9uZHNUbyA9IGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50VHlwZSA9PT0gJ3ZhbHVlJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbi5wcm90b3R5cGUuY3JlYXRlRXZlbnQgPSBmdW5jdGlvbiAoY2hhbmdlLCBxdWVyeSkge1xuICAgICAgICB2YXIgaW5kZXggPSBxdWVyeS5nZXRRdWVyeVBhcmFtcygpLmdldEluZGV4KCk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YUV2ZW50KCd2YWx1ZScsIHRoaXMsIG5ldyBEYXRhU25hcHNob3QoY2hhbmdlLnNuYXBzaG90Tm9kZSwgcXVlcnkuZ2V0UmVmKCksIGluZGV4KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFZhbHVlRXZlbnRSZWdpc3RyYXRpb24ucHJvdG90eXBlLmdldEV2ZW50UnVubmVyID0gZnVuY3Rpb24gKGV2ZW50RGF0YSkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0XztcbiAgICAgICAgaWYgKGV2ZW50RGF0YS5nZXRFdmVudFR5cGUoKSA9PT0gJ2NhbmNlbCcpIHtcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLmNhbmNlbENhbGxiYWNrXywgJ1JhaXNpbmcgYSBjYW5jZWwgZXZlbnQgb24gYSBsaXN0ZW5lciB3aXRoIG5vIGNhbmNlbCBjYWxsYmFjaycpO1xuICAgICAgICAgICAgdmFyIGNhbmNlbENCXzEgPSB0aGlzLmNhbmNlbENhbGxiYWNrXztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Uga25vdyB0aGF0IGVycm9yIGV4aXN0cywgd2UgY2hlY2tlZCBhYm92ZSB0aGF0IHRoaXMgaXMgYSBjYW5jZWwgZXZlbnRcbiAgICAgICAgICAgICAgICBjYW5jZWxDQl8xLmNhbGwoY3R4LCBldmVudERhdGEuZXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjYl8xID0gdGhpcy5jYWxsYmFja187XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNiXzEuY2FsbChjdHgsIGV2ZW50RGF0YS5zbmFwc2hvdCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFZhbHVlRXZlbnRSZWdpc3RyYXRpb24ucHJvdG90eXBlLmNyZWF0ZUNhbmNlbEV2ZW50ID0gZnVuY3Rpb24gKGVycm9yLCBwYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbENhbGxiYWNrXykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYW5jZWxFdmVudCh0aGlzLCBlcnJvciwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghb3RoZXIuY2FsbGJhY2tfIHx8ICF0aGlzLmNhbGxiYWNrXykge1xuICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgc3BlY2lmaWVkLCB3ZSBjb25zaWRlciBpdCB0byBtYXRjaCBhbnkgY2FsbGJhY2suXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAob3RoZXIuY2FsbGJhY2tfID09PSB0aGlzLmNhbGxiYWNrXyAmJiBvdGhlci5jb250ZXh0XyA9PT0gdGhpcy5jb250ZXh0Xyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbi5wcm90b3R5cGUuaGFzQW55Q2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxiYWNrXyAhPT0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uO1xufSgpKTtcbmV4cG9ydCB7IFZhbHVlRXZlbnRSZWdpc3RyYXRpb24gfTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgcmVnaXN0cmF0aW9uIG9mIDEgb3IgbW9yZSBjaGlsZF94eHggZXZlbnRzLlxuICpcbiAqIEN1cnJlbnRseSwgaXQgaXMgYWx3YXlzIGV4YWN0bHkgMSBjaGlsZF94eHggZXZlbnQsIGJ1dCB0aGUgaWRlYSBpcyB3ZSBtaWdodCBsZXQgeW91XG4gKiByZWdpc3RlciBhIGdyb3VwIG9mIGNhbGxiYWNrcyB0b2dldGhlciBpbiB0aGUgZnV0dXJlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge0V2ZW50UmVnaXN0cmF0aW9ufVxuICovXG52YXIgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez9PYmplY3QuPHN0cmluZywgZnVuY3Rpb24oIURhdGFTbmFwc2hvdCwgP3N0cmluZz0pPn0gY2FsbGJhY2tzX1xuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9uKEVycm9yKX0gY2FuY2VsQ2FsbGJhY2tfXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBjb250ZXh0X1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENoaWxkRXZlbnRSZWdpc3RyYXRpb24oY2FsbGJhY2tzXywgY2FuY2VsQ2FsbGJhY2tfLCBjb250ZXh0Xykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrc18gPSBjYWxsYmFja3NfO1xuICAgICAgICB0aGlzLmNhbmNlbENhbGxiYWNrXyA9IGNhbmNlbENhbGxiYWNrXztcbiAgICAgICAgdGhpcy5jb250ZXh0XyA9IGNvbnRleHRfO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIENoaWxkRXZlbnRSZWdpc3RyYXRpb24ucHJvdG90eXBlLnJlc3BvbmRzVG8gPSBmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG4gICAgICAgIHZhciBldmVudFRvQ2hlY2sgPSBldmVudFR5cGUgPT09ICdjaGlsZHJlbl9hZGRlZCcgPyAnY2hpbGRfYWRkZWQnIDogZXZlbnRUeXBlO1xuICAgICAgICBldmVudFRvQ2hlY2sgPVxuICAgICAgICAgICAgZXZlbnRUb0NoZWNrID09PSAnY2hpbGRyZW5fcmVtb3ZlZCcgPyAnY2hpbGRfcmVtb3ZlZCcgOiBldmVudFRvQ2hlY2s7XG4gICAgICAgIHJldHVybiBjb250YWlucyh0aGlzLmNhbGxiYWNrc18sIGV2ZW50VG9DaGVjayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIENoaWxkRXZlbnRSZWdpc3RyYXRpb24ucHJvdG90eXBlLmNyZWF0ZUNhbmNlbEV2ZW50ID0gZnVuY3Rpb24gKGVycm9yLCBwYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbENhbGxiYWNrXykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYW5jZWxFdmVudCh0aGlzLCBlcnJvciwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uLnByb3RvdHlwZS5jcmVhdGVFdmVudCA9IGZ1bmN0aW9uIChjaGFuZ2UsIHF1ZXJ5KSB7XG4gICAgICAgIGFzc2VydChjaGFuZ2UuY2hpbGROYW1lICE9IG51bGwsICdDaGlsZCBldmVudHMgc2hvdWxkIGhhdmUgYSBjaGlsZE5hbWUuJyk7XG4gICAgICAgIHZhciByZWYgPSBxdWVyeS5nZXRSZWYoKS5jaGlsZCgvKiogQHR5cGUgeyFzdHJpbmd9ICovIChjaGFuZ2UuY2hpbGROYW1lKSk7XG4gICAgICAgIHZhciBpbmRleCA9IHF1ZXJ5LmdldFF1ZXJ5UGFyYW1zKCkuZ2V0SW5kZXgoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhRXZlbnQoY2hhbmdlLnR5cGUsIHRoaXMsIG5ldyBEYXRhU25hcHNob3QoY2hhbmdlLnNuYXBzaG90Tm9kZSwgcmVmLCBpbmRleCksIGNoYW5nZS5wcmV2TmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIENoaWxkRXZlbnRSZWdpc3RyYXRpb24ucHJvdG90eXBlLmdldEV2ZW50UnVubmVyID0gZnVuY3Rpb24gKGV2ZW50RGF0YSkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0XztcbiAgICAgICAgaWYgKGV2ZW50RGF0YS5nZXRFdmVudFR5cGUoKSA9PT0gJ2NhbmNlbCcpIHtcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLmNhbmNlbENhbGxiYWNrXywgJ1JhaXNpbmcgYSBjYW5jZWwgZXZlbnQgb24gYSBsaXN0ZW5lciB3aXRoIG5vIGNhbmNlbCBjYWxsYmFjaycpO1xuICAgICAgICAgICAgdmFyIGNhbmNlbENCXzIgPSB0aGlzLmNhbmNlbENhbGxiYWNrXztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Uga25vdyB0aGF0IGVycm9yIGV4aXN0cywgd2UgY2hlY2tlZCBhYm92ZSB0aGF0IHRoaXMgaXMgYSBjYW5jZWwgZXZlbnRcbiAgICAgICAgICAgICAgICBjYW5jZWxDQl8yLmNhbGwoY3R4LCBldmVudERhdGEuZXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjYl8yID0gdGhpcy5jYWxsYmFja3NfW2V2ZW50RGF0YS5ldmVudFR5cGVdO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYl8yLmNhbGwoY3R4LCBldmVudERhdGEuc25hcHNob3QsIGV2ZW50RGF0YS5wcmV2TmFtZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIENoaWxkRXZlbnRSZWdpc3RyYXRpb24ucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrc18gfHwgIW90aGVyLmNhbGxiYWNrc18pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGV4dF8gPT09IG90aGVyLmNvbnRleHRfKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyQ291bnQgPSBnZXRDb3VudChvdGhlci5jYWxsYmFja3NfKTtcbiAgICAgICAgICAgICAgICB2YXIgdGhpc0NvdW50ID0gZ2V0Q291bnQodGhpcy5jYWxsYmFja3NfKTtcbiAgICAgICAgICAgICAgICBpZiAob3RoZXJDb3VudCA9PT0gdGhpc0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGNvdW50IGlzIDEsIGRvIGFuIGV4YWN0IG1hdGNoIG9uIGV2ZW50VHlwZSwgaWYgZWl0aGVyIGlzIGRlZmluZWQgYnV0IG51bGwsIGl0J3MgYSBtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgLy8gIElmIGV2ZW50IHR5cGVzIGRvbid0IG1hdGNoLCBub3QgYSBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBjb3VudCBpcyBub3QgMSwgZXhhY3QgbWF0Y2ggYWNyb3NzIGFsbFxuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyS2V5IC8qKiBAdHlwZSB7IXN0cmluZ30gKi8gPSBnZXRBbnlLZXkob3RoZXIuY2FsbGJhY2tzXyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhpc0tleSAvKiogQHR5cGUgeyFzdHJpbmd9ICovID0gZ2V0QW55S2V5KHRoaXMuY2FsbGJhY2tzXyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXNLZXkgPT09IG90aGVyS2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFvdGhlci5jYWxsYmFja3NfW290aGVyS2V5XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5jYWxsYmFja3NfW3RoaXNLZXldIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLmNhbGxiYWNrc19bb3RoZXJLZXldID09PSB0aGlzLmNhbGxiYWNrc19bdGhpc0tleV0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4YWN0IG1hdGNoIG9uIGVhY2gga2V5LlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZXJ5KHRoaXMuY2FsbGJhY2tzXywgZnVuY3Rpb24gKGV2ZW50VHlwZSwgY2IpIHsgcmV0dXJuIG90aGVyLmNhbGxiYWNrc19bZXZlbnRUeXBlXSA9PT0gY2I7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbi5wcm90b3R5cGUuaGFzQW55Q2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxiYWNrc18gIT09IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbjtcbn0oKSk7XG5leHBvcnQgeyBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvdmlldy9FdmVudFJlZ2lzdHJhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBNSU5fTkFNRSwgTUFYX05BTUUgfSBmcm9tICcuLi91dGlsL3V0aWwnO1xuaW1wb3J0IHsgS0VZX0lOREVYIH0gZnJvbSAnLi4vc25hcC9pbmRleGVzL0tleUluZGV4JztcbmltcG9ydCB7IFBSSU9SSVRZX0lOREVYIH0gZnJvbSAnLi4vc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXgnO1xuaW1wb3J0IHsgVkFMVUVfSU5ERVggfSBmcm9tICcuLi9zbmFwL2luZGV4ZXMvVmFsdWVJbmRleCc7XG5pbXBvcnQgeyBQYXRoSW5kZXggfSBmcm9tICcuLi9zbmFwL2luZGV4ZXMvUGF0aEluZGV4JztcbmltcG9ydCB7IEluZGV4ZWRGaWx0ZXIgfSBmcm9tICcuL2ZpbHRlci9JbmRleGVkRmlsdGVyJztcbmltcG9ydCB7IExpbWl0ZWRGaWx0ZXIgfSBmcm9tICcuL2ZpbHRlci9MaW1pdGVkRmlsdGVyJztcbmltcG9ydCB7IFJhbmdlZEZpbHRlciB9IGZyb20gJy4vZmlsdGVyL1JhbmdlZEZpbHRlcic7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgYW4gaW1tdXRhYmxlLWZyb20tdGhlLXB1YmxpYy1hcGkgc3RydWN0IGNvbnRhaW5pbmcgYSBzZXQgb2YgcXVlcnkgcGFyYW1ldGVycyBkZWZpbmluZyBhXG4gKiByYW5nZSB0byBiZSByZXR1cm5lZCBmb3IgYSBwYXJ0aWN1bGFyIGxvY2F0aW9uLiBJdCBpcyBhc3N1bWVkIHRoYXQgdmFsaWRhdGlvbiBvZiBwYXJhbWV0ZXJzIGlzIGRvbmUgYXQgdGhlXG4gKiB1c2VyLWZhY2luZyBBUEkgbGV2ZWwsIHNvIGl0IGlzIG5vdCBkb25lIGhlcmUuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFF1ZXJ5UGFyYW1zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFF1ZXJ5UGFyYW1zKCkge1xuICAgICAgICB0aGlzLmxpbWl0U2V0XyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXJ0U2V0XyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXJ0TmFtZVNldF8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbmRTZXRfID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5kTmFtZVNldF8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saW1pdF8gPSAwO1xuICAgICAgICB0aGlzLnZpZXdGcm9tXyA9ICcnO1xuICAgICAgICB0aGlzLmluZGV4U3RhcnRWYWx1ZV8gPSBudWxsO1xuICAgICAgICB0aGlzLmluZGV4U3RhcnROYW1lXyA9ICcnO1xuICAgICAgICB0aGlzLmluZGV4RW5kVmFsdWVfID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmRleEVuZE5hbWVfID0gJyc7XG4gICAgICAgIHRoaXMuaW5kZXhfID0gUFJJT1JJVFlfSU5ERVg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmhhc1N0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydFNldF87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGl0IHdvdWxkIHJldHVybiBmcm9tIGxlZnQuXG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmlzVmlld0Zyb21MZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy52aWV3RnJvbV8gPT09ICcnKSB7XG4gICAgICAgICAgICAvLyBsaW1pdCgpLCByYXRoZXIgdGhhbiBsaW1pdFRvRmlyc3Qgb3IgbGltaXRUb0xhc3Qgd2FzIGNhbGxlZC5cbiAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCBvbmx5IG9uZSBvZiBzdGFydFNldF8gYW5kIGVuZFNldF8gaXMgdHJ1ZS4gVXNlIHRoZW1cbiAgICAgICAgICAgIC8vIHRvIGNhbGN1bGF0ZSB3aGljaCBzaWRlIG9mIHRoZSB2aWV3IHRvIGFuY2hvciB0by4gSWYgbmVpdGhlciBpcyBzZXQsXG4gICAgICAgICAgICAvLyBhbmNob3IgdG8gdGhlIGVuZC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0U2V0XztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy52aWV3RnJvbV8gPT09IFF1ZXJ5UGFyYW1zLldJUkVfUFJPVE9DT0xfQ09OU1RBTlRTXy5WSUVXX0ZST01fTEVGVCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNTdGFydCgpIHJldHVybnMgdHJ1ZVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmdldEluZGV4U3RhcnRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuc3RhcnRTZXRfLCAnT25seSB2YWxpZCBpZiBzdGFydCBoYXMgYmVlbiBzZXQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhTdGFydFZhbHVlXztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNTdGFydCgpIHJldHVybnMgdHJ1ZS5cbiAgICAgKiBSZXR1cm5zIHRoZSBzdGFydGluZyBrZXkgbmFtZSBmb3IgdGhlIHJhbmdlIGRlZmluZWQgYnkgdGhlc2UgcXVlcnkgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm4geyFzdHJpbmd9XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmdldEluZGV4U3RhcnROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBhc3NlcnQodGhpcy5zdGFydFNldF8sICdPbmx5IHZhbGlkIGlmIHN0YXJ0IGhhcyBiZWVuIHNldCcpO1xuICAgICAgICBpZiAodGhpcy5zdGFydE5hbWVTZXRfKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleFN0YXJ0TmFtZV87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTUlOX05BTUU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmhhc0VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kU2V0XztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNFbmQoKSByZXR1cm5zIHRydWUuXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUuZ2V0SW5kZXhFbmRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuZW5kU2V0XywgJ09ubHkgdmFsaWQgaWYgZW5kIGhhcyBiZWVuIHNldCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleEVuZFZhbHVlXztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNFbmQoKSByZXR1cm5zIHRydWUuXG4gICAgICogUmV0dXJucyB0aGUgZW5kIGtleSBuYW1lIGZvciB0aGUgcmFuZ2UgZGVmaW5lZCBieSB0aGVzZSBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybiB7IXN0cmluZ31cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUuZ2V0SW5kZXhFbmROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBhc3NlcnQodGhpcy5lbmRTZXRfLCAnT25seSB2YWxpZCBpZiBlbmQgaGFzIGJlZW4gc2V0Jyk7XG4gICAgICAgIGlmICh0aGlzLmVuZE5hbWVTZXRfKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleEVuZE5hbWVfO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1BWF9OQU1FO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5oYXNMaW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGltaXRTZXRfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIGxpbWl0IGhhcyBiZWVuIHNldCBhbmQgaXQgaGFzIGJlZW4gZXhwbGljaXRseSBhbmNob3JlZFxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5oYXNBbmNob3JlZExpbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW1pdFNldF8gJiYgdGhpcy52aWV3RnJvbV8gIT09ICcnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT25seSB2YWxpZCB0byBjYWxsIGlmIGhhc0xpbWl0KCkgcmV0dXJucyB0cnVlXG4gICAgICogQHJldHVybiB7IW51bWJlcn1cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUuZ2V0TGltaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLmxpbWl0U2V0XywgJ09ubHkgdmFsaWQgaWYgbGltaXQgaGFzIGJlZW4gc2V0Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbWl0XztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFJbmRleH1cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUuZ2V0SW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFRdWVyeVBhcmFtc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5jb3B5XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvcHkgPSBuZXcgUXVlcnlQYXJhbXMoKTtcbiAgICAgICAgY29weS5saW1pdFNldF8gPSB0aGlzLmxpbWl0U2V0XztcbiAgICAgICAgY29weS5saW1pdF8gPSB0aGlzLmxpbWl0XztcbiAgICAgICAgY29weS5zdGFydFNldF8gPSB0aGlzLnN0YXJ0U2V0XztcbiAgICAgICAgY29weS5pbmRleFN0YXJ0VmFsdWVfID0gdGhpcy5pbmRleFN0YXJ0VmFsdWVfO1xuICAgICAgICBjb3B5LnN0YXJ0TmFtZVNldF8gPSB0aGlzLnN0YXJ0TmFtZVNldF87XG4gICAgICAgIGNvcHkuaW5kZXhTdGFydE5hbWVfID0gdGhpcy5pbmRleFN0YXJ0TmFtZV87XG4gICAgICAgIGNvcHkuZW5kU2V0XyA9IHRoaXMuZW5kU2V0XztcbiAgICAgICAgY29weS5pbmRleEVuZFZhbHVlXyA9IHRoaXMuaW5kZXhFbmRWYWx1ZV87XG4gICAgICAgIGNvcHkuZW5kTmFtZVNldF8gPSB0aGlzLmVuZE5hbWVTZXRfO1xuICAgICAgICBjb3B5LmluZGV4RW5kTmFtZV8gPSB0aGlzLmluZGV4RW5kTmFtZV87XG4gICAgICAgIGNvcHkuaW5kZXhfID0gdGhpcy5pbmRleF87XG4gICAgICAgIGNvcHkudmlld0Zyb21fID0gdGhpcy52aWV3RnJvbV87XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSBuZXdMaW1pdFxuICAgICAqIEByZXR1cm4geyFRdWVyeVBhcmFtc31cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUubGltaXQgPSBmdW5jdGlvbiAobmV3TGltaXQpIHtcbiAgICAgICAgdmFyIG5ld1BhcmFtcyA9IHRoaXMuY29weV8oKTtcbiAgICAgICAgbmV3UGFyYW1zLmxpbWl0U2V0XyA9IHRydWU7XG4gICAgICAgIG5ld1BhcmFtcy5saW1pdF8gPSBuZXdMaW1pdDtcbiAgICAgICAgbmV3UGFyYW1zLnZpZXdGcm9tXyA9ICcnO1xuICAgICAgICByZXR1cm4gbmV3UGFyYW1zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSBuZXdMaW1pdFxuICAgICAqIEByZXR1cm4geyFRdWVyeVBhcmFtc31cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUubGltaXRUb0ZpcnN0ID0gZnVuY3Rpb24gKG5ld0xpbWl0KSB7XG4gICAgICAgIHZhciBuZXdQYXJhbXMgPSB0aGlzLmNvcHlfKCk7XG4gICAgICAgIG5ld1BhcmFtcy5saW1pdFNldF8gPSB0cnVlO1xuICAgICAgICBuZXdQYXJhbXMubGltaXRfID0gbmV3TGltaXQ7XG4gICAgICAgIG5ld1BhcmFtcy52aWV3RnJvbV8gPSBRdWVyeVBhcmFtcy5XSVJFX1BST1RPQ09MX0NPTlNUQU5UU18uVklFV19GUk9NX0xFRlQ7XG4gICAgICAgIHJldHVybiBuZXdQYXJhbXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFudW1iZXJ9IG5ld0xpbWl0XG4gICAgICogQHJldHVybiB7IVF1ZXJ5UGFyYW1zfVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5saW1pdFRvTGFzdCA9IGZ1bmN0aW9uIChuZXdMaW1pdCkge1xuICAgICAgICB2YXIgbmV3UGFyYW1zID0gdGhpcy5jb3B5XygpO1xuICAgICAgICBuZXdQYXJhbXMubGltaXRTZXRfID0gdHJ1ZTtcbiAgICAgICAgbmV3UGFyYW1zLmxpbWl0XyA9IG5ld0xpbWl0O1xuICAgICAgICBuZXdQYXJhbXMudmlld0Zyb21fID0gUXVlcnlQYXJhbXMuV0lSRV9QUk9UT0NPTF9DT05TVEFOVFNfLlZJRVdfRlJPTV9SSUdIVDtcbiAgICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gaW5kZXhWYWx1ZVxuICAgICAqIEBwYXJhbSB7P3N0cmluZz19IGtleVxuICAgICAqIEByZXR1cm4geyFRdWVyeVBhcmFtc31cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUuc3RhcnRBdCA9IGZ1bmN0aW9uIChpbmRleFZhbHVlLCBrZXkpIHtcbiAgICAgICAgdmFyIG5ld1BhcmFtcyA9IHRoaXMuY29weV8oKTtcbiAgICAgICAgbmV3UGFyYW1zLnN0YXJ0U2V0XyA9IHRydWU7XG4gICAgICAgIGlmICghKGluZGV4VmFsdWUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGluZGV4VmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG5ld1BhcmFtcy5pbmRleFN0YXJ0VmFsdWVfID0gaW5kZXhWYWx1ZTtcbiAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZXdQYXJhbXMuc3RhcnROYW1lU2V0XyA9IHRydWU7XG4gICAgICAgICAgICBuZXdQYXJhbXMuaW5kZXhTdGFydE5hbWVfID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3UGFyYW1zLnN0YXJ0TmFtZVNldF8gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1BhcmFtcy5pbmRleFN0YXJ0TmFtZV8gPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UGFyYW1zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBpbmRleFZhbHVlXG4gICAgICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5XG4gICAgICogQHJldHVybiB7IVF1ZXJ5UGFyYW1zfVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5lbmRBdCA9IGZ1bmN0aW9uIChpbmRleFZhbHVlLCBrZXkpIHtcbiAgICAgICAgdmFyIG5ld1BhcmFtcyA9IHRoaXMuY29weV8oKTtcbiAgICAgICAgbmV3UGFyYW1zLmVuZFNldF8gPSB0cnVlO1xuICAgICAgICBpZiAoIShpbmRleFZhbHVlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBpbmRleFZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBuZXdQYXJhbXMuaW5kZXhFbmRWYWx1ZV8gPSBpbmRleFZhbHVlO1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld1BhcmFtcy5lbmROYW1lU2V0XyA9IHRydWU7XG4gICAgICAgICAgICBuZXdQYXJhbXMuaW5kZXhFbmROYW1lXyA9IGtleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1BhcmFtcy5lbmROYW1lU2V0XyA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3UGFyYW1zLmluZGV4RW5kTmFtZV8gPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UGFyYW1zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4XG4gICAgICogQHJldHVybiB7IVF1ZXJ5UGFyYW1zfVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5vcmRlckJ5ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBuZXdQYXJhbXMgPSB0aGlzLmNvcHlfKCk7XG4gICAgICAgIG5ld1BhcmFtcy5pbmRleF8gPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFPYmplY3R9XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmdldFF1ZXJ5T2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMgPSBRdWVyeVBhcmFtcy5XSVJFX1BST1RPQ09MX0NPTlNUQU5UU187XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRTZXRfKSB7XG4gICAgICAgICAgICBvYmpbV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVhfU1RBUlRfVkFMVUVdID0gdGhpcy5pbmRleFN0YXJ0VmFsdWVfO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnROYW1lU2V0Xykge1xuICAgICAgICAgICAgICAgIG9ialtXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5JTkRFWF9TVEFSVF9OQU1FXSA9IHRoaXMuaW5kZXhTdGFydE5hbWVfO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVuZFNldF8pIHtcbiAgICAgICAgICAgIG9ialtXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5JTkRFWF9FTkRfVkFMVUVdID0gdGhpcy5pbmRleEVuZFZhbHVlXztcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZE5hbWVTZXRfKSB7XG4gICAgICAgICAgICAgICAgb2JqW1dJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX0VORF9OQU1FXSA9IHRoaXMuaW5kZXhFbmROYW1lXztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saW1pdFNldF8pIHtcbiAgICAgICAgICAgIG9ialtXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5MSU1JVF0gPSB0aGlzLmxpbWl0XztcbiAgICAgICAgICAgIHZhciB2aWV3RnJvbSA9IHRoaXMudmlld0Zyb21fO1xuICAgICAgICAgICAgaWYgKHZpZXdGcm9tID09PSAnJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmlld0Zyb21MZWZ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld0Zyb20gPSBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5WSUVXX0ZST01fTEVGVDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuVklFV19GUk9NX1JJR0hUO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9ialtXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5WSUVXX0ZST01dID0gdmlld0Zyb207XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIG5vdywgcHJpb3JpdHkgaW5kZXggaXMgdGhlIGRlZmF1bHQsIHNvIHdlIG9ubHkgc3BlY2lmeSBpZiBpdCdzIHNvbWUgb3RoZXIgaW5kZXhcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhfICE9PSBQUklPUklUWV9JTkRFWCkge1xuICAgICAgICAgICAgb2JqW1dJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYXSA9IHRoaXMuaW5kZXhfLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmxvYWRzQWxsRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEodGhpcy5zdGFydFNldF8gfHwgdGhpcy5lbmRTZXRfIHx8IHRoaXMubGltaXRTZXRfKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmlzRGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZHNBbGxEYXRhKCkgJiYgdGhpcy5pbmRleF8gPT0gUFJJT1JJVFlfSU5ERVg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshTm9kZUZpbHRlcn1cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUuZ2V0Tm9kZUZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubG9hZHNBbGxEYXRhKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5kZXhlZEZpbHRlcih0aGlzLmdldEluZGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaGFzTGltaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW1pdGVkRmlsdGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZWRGaWx0ZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzZXQgb2YgUkVTVCBxdWVyeSBzdHJpbmcgcGFyYW1ldGVycyByZXByZXNlbnRpbmcgdGhpcyBxdWVyeS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyFPYmplY3QuPHN0cmluZywqPn0gcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUudG9SZXN0UXVlcnlTdHJpbmdQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgUkVTVF9DT05TVEFOVFMgPSBRdWVyeVBhcmFtcy5SRVNUX1FVRVJZX0NPTlNUQU5UU187XG4gICAgICAgIHZhciBxcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5pc0RlZmF1bHQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHFzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmRlckJ5O1xuICAgICAgICBpZiAodGhpcy5pbmRleF8gPT09IFBSSU9SSVRZX0lOREVYKSB7XG4gICAgICAgICAgICBvcmRlckJ5ID0gUkVTVF9DT05TVEFOVFMuUFJJT1JJVFlfSU5ERVg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pbmRleF8gPT09IFZBTFVFX0lOREVYKSB7XG4gICAgICAgICAgICBvcmRlckJ5ID0gUkVTVF9DT05TVEFOVFMuVkFMVUVfSU5ERVg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pbmRleF8gPT09IEtFWV9JTkRFWCkge1xuICAgICAgICAgICAgb3JkZXJCeSA9IFJFU1RfQ09OU1RBTlRTLktFWV9JTkRFWDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLmluZGV4XyBpbnN0YW5jZW9mIFBhdGhJbmRleCwgJ1VucmVjb2duaXplZCBpbmRleCB0eXBlIScpO1xuICAgICAgICAgICAgb3JkZXJCeSA9IHRoaXMuaW5kZXhfLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcXNbUkVTVF9DT05TVEFOVFMuT1JERVJfQlldID0gc3RyaW5naWZ5KG9yZGVyQnkpO1xuICAgICAgICBpZiAodGhpcy5zdGFydFNldF8pIHtcbiAgICAgICAgICAgIHFzW1JFU1RfQ09OU1RBTlRTLlNUQVJUX0FUXSA9IHN0cmluZ2lmeSh0aGlzLmluZGV4U3RhcnRWYWx1ZV8pO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnROYW1lU2V0Xykge1xuICAgICAgICAgICAgICAgIHFzW1JFU1RfQ09OU1RBTlRTLlNUQVJUX0FUXSArPSAnLCcgKyBzdHJpbmdpZnkodGhpcy5pbmRleFN0YXJ0TmFtZV8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVuZFNldF8pIHtcbiAgICAgICAgICAgIHFzW1JFU1RfQ09OU1RBTlRTLkVORF9BVF0gPSBzdHJpbmdpZnkodGhpcy5pbmRleEVuZFZhbHVlXyk7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmROYW1lU2V0Xykge1xuICAgICAgICAgICAgICAgIHFzW1JFU1RfQ09OU1RBTlRTLkVORF9BVF0gKz0gJywnICsgc3RyaW5naWZ5KHRoaXMuaW5kZXhFbmROYW1lXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGltaXRTZXRfKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZpZXdGcm9tTGVmdCgpKSB7XG4gICAgICAgICAgICAgICAgcXNbUkVTVF9DT05TVEFOVFMuTElNSVRfVE9fRklSU1RdID0gdGhpcy5saW1pdF87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxc1tSRVNUX0NPTlNUQU5UUy5MSU1JVF9UT19MQVNUXSA9IHRoaXMubGltaXRfO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdpcmUgUHJvdG9jb2wgQ29uc3RhbnRzXG4gICAgICogQGNvbnN0XG4gICAgICogQGVudW0ge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLldJUkVfUFJPVE9DT0xfQ09OU1RBTlRTXyA9IHtcbiAgICAgICAgSU5ERVhfU1RBUlRfVkFMVUU6ICdzcCcsXG4gICAgICAgIElOREVYX1NUQVJUX05BTUU6ICdzbicsXG4gICAgICAgIElOREVYX0VORF9WQUxVRTogJ2VwJyxcbiAgICAgICAgSU5ERVhfRU5EX05BTUU6ICdlbicsXG4gICAgICAgIExJTUlUOiAnbCcsXG4gICAgICAgIFZJRVdfRlJPTTogJ3ZmJyxcbiAgICAgICAgVklFV19GUk9NX0xFRlQ6ICdsJyxcbiAgICAgICAgVklFV19GUk9NX1JJR0hUOiAncicsXG4gICAgICAgIElOREVYOiAnaSdcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJFU1QgUXVlcnkgQ29uc3RhbnRzXG4gICAgICogQGNvbnN0XG4gICAgICogQGVudW0ge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLlJFU1RfUVVFUllfQ09OU1RBTlRTXyA9IHtcbiAgICAgICAgT1JERVJfQlk6ICdvcmRlckJ5JyxcbiAgICAgICAgUFJJT1JJVFlfSU5ERVg6ICckcHJpb3JpdHknLFxuICAgICAgICBWQUxVRV9JTkRFWDogJyR2YWx1ZScsXG4gICAgICAgIEtFWV9JTkRFWDogJyRrZXknLFxuICAgICAgICBTVEFSVF9BVDogJ3N0YXJ0QXQnLFxuICAgICAgICBFTkRfQVQ6ICdlbmRBdCcsXG4gICAgICAgIExJTUlUX1RPX0ZJUlNUOiAnbGltaXRUb0ZpcnN0JyxcbiAgICAgICAgTElNSVRfVE9fTEFTVDogJ2xpbWl0VG9MYXN0J1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCwgZW1wdHkgcXVlcnkgcGFyYW1ldGVyc1xuICAgICAqIEB0eXBlIHshUXVlcnlQYXJhbXN9XG4gICAgICogQGNvbnN0XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMuREVGQVVMVCA9IG5ldyBRdWVyeVBhcmFtcygpO1xuICAgIHJldHVybiBRdWVyeVBhcmFtcztcbn0oKSk7XG5leHBvcnQgeyBRdWVyeVBhcmFtcyB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3ZpZXcvUXVlcnlQYXJhbXMuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgSW5kZXhlZEZpbHRlciB9IGZyb20gJy4vZmlsdGVyL0luZGV4ZWRGaWx0ZXInO1xuaW1wb3J0IHsgVmlld1Byb2Nlc3NvciB9IGZyb20gJy4vVmlld1Byb2Nlc3Nvcic7XG5pbXBvcnQgeyBDaGlsZHJlbk5vZGUgfSBmcm9tICcuLi9zbmFwL0NoaWxkcmVuTm9kZSc7XG5pbXBvcnQgeyBDYWNoZU5vZGUgfSBmcm9tICcuL0NhY2hlTm9kZSc7XG5pbXBvcnQgeyBWaWV3Q2FjaGUgfSBmcm9tICcuL1ZpZXdDYWNoZSc7XG5pbXBvcnQgeyBFdmVudEdlbmVyYXRvciB9IGZyb20gJy4vRXZlbnRHZW5lcmF0b3InO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgT3BlcmF0aW9uVHlwZSB9IGZyb20gJy4uL29wZXJhdGlvbi9PcGVyYXRpb24nO1xuaW1wb3J0IHsgQ2hhbmdlIH0gZnJvbSAnLi9DaGFuZ2UnO1xuaW1wb3J0IHsgUFJJT1JJVFlfSU5ERVggfSBmcm9tICcuLi9zbmFwL2luZGV4ZXMvUHJpb3JpdHlJbmRleCc7XG4vKipcbiAqIEEgdmlldyByZXByZXNlbnRzIGEgc3BlY2lmaWMgbG9jYXRpb24gYW5kIHF1ZXJ5IHRoYXQgaGFzIDEgb3IgbW9yZSBldmVudCByZWdpc3RyYXRpb25zLlxuICpcbiAqIEl0IGRvZXMgc2V2ZXJhbCB0aGluZ3M6XG4gKiAgLSBNYWludGFpbnMgdGhlIGxpc3Qgb2YgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBsb2NhdGlvbi9xdWVyeS5cbiAqICAtIE1haW50YWlucyBhIGNhY2hlIG9mIHRoZSBkYXRhIHZpc2libGUgZm9yIHRoaXMgbG9jYXRpb24vcXVlcnkuXG4gKiAgLSBBcHBsaWVzIG5ldyBvcGVyYXRpb25zICh2aWEgYXBwbHlPcGVyYXRpb24pLCB1cGRhdGVzIHRoZSBjYWNoZSwgYW5kIGJhc2VkIG9uIHRoZSBldmVudFxuICogICAgcmVnaXN0cmF0aW9ucyByZXR1cm5zIHRoZSBzZXQgb2YgZXZlbnRzIHRvIGJlIHJhaXNlZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeV9cbiAgICAgKiBAcGFyYW0geyFWaWV3Q2FjaGV9IGluaXRpYWxWaWV3Q2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWaWV3KHF1ZXJ5XywgaW5pdGlhbFZpZXdDYWNoZSkge1xuICAgICAgICB0aGlzLnF1ZXJ5XyA9IHF1ZXJ5XztcbiAgICAgICAgdGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfID0gW107XG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnF1ZXJ5Xy5nZXRRdWVyeVBhcmFtcygpO1xuICAgICAgICB2YXIgaW5kZXhGaWx0ZXIgPSBuZXcgSW5kZXhlZEZpbHRlcihwYXJhbXMuZ2V0SW5kZXgoKSk7XG4gICAgICAgIHZhciBmaWx0ZXIgPSBwYXJhbXMuZ2V0Tm9kZUZpbHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge1ZpZXdQcm9jZXNzb3J9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb2Nlc3Nvcl8gPSBuZXcgVmlld1Byb2Nlc3NvcihmaWx0ZXIpO1xuICAgICAgICB2YXIgaW5pdGlhbFNlcnZlckNhY2hlID0gaW5pdGlhbFZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpO1xuICAgICAgICB2YXIgaW5pdGlhbEV2ZW50Q2FjaGUgPSBpbml0aWFsVmlld0NhY2hlLmdldEV2ZW50Q2FjaGUoKTtcbiAgICAgICAgLy8gRG9uJ3QgZmlsdGVyIHNlcnZlciBub2RlIHdpdGggb3RoZXIgZmlsdGVyIHRoYW4gaW5kZXgsIHdhaXQgZm9yIHRhZ2dlZCBsaXN0ZW5cbiAgICAgICAgdmFyIHNlcnZlclNuYXAgPSBpbmRleEZpbHRlci51cGRhdGVGdWxsTm9kZShDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgaW5pdGlhbFNlcnZlckNhY2hlLmdldE5vZGUoKSwgbnVsbCk7XG4gICAgICAgIHZhciBldmVudFNuYXAgPSBmaWx0ZXIudXBkYXRlRnVsbE5vZGUoQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUsIGluaXRpYWxFdmVudENhY2hlLmdldE5vZGUoKSwgbnVsbCk7XG4gICAgICAgIHZhciBuZXdTZXJ2ZXJDYWNoZSA9IG5ldyBDYWNoZU5vZGUoc2VydmVyU25hcCwgaW5pdGlhbFNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpLCBpbmRleEZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XG4gICAgICAgIHZhciBuZXdFdmVudENhY2hlID0gbmV3IENhY2hlTm9kZShldmVudFNuYXAsIGluaXRpYWxFdmVudENhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpLCBmaWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFWaWV3Q2FjaGV9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpZXdDYWNoZV8gPSBuZXcgVmlld0NhY2hlKG5ld0V2ZW50Q2FjaGUsIG5ld1NlcnZlckNhY2hlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHshRXZlbnRHZW5lcmF0b3J9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2ZW50R2VuZXJhdG9yXyA9IG5ldyBFdmVudEdlbmVyYXRvcih0aGlzLnF1ZXJ5Xyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFRdWVyeX1cbiAgICAgKi9cbiAgICBWaWV3LnByb3RvdHlwZS5nZXRRdWVyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P05vZGV9XG4gICAgICovXG4gICAgVmlldy5wcm90b3R5cGUuZ2V0U2VydmVyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdDYWNoZV8uZ2V0U2VydmVyQ2FjaGUoKS5nZXROb2RlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHJldHVybiB7P05vZGV9XG4gICAgICovXG4gICAgVmlldy5wcm90b3R5cGUuZ2V0Q29tcGxldGVTZXJ2ZXJDYWNoZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IHRoaXMudmlld0NhY2hlXy5nZXRDb21wbGV0ZVNlcnZlclNuYXAoKTtcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzbid0IGEgXCJsb2Fkc0FsbERhdGFcIiB2aWV3LCB0aGVuIGNhY2hlIGlzbid0IGFjdHVhbGx5IGEgY29tcGxldGUgY2FjaGUgYW5kXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHNlZSBpZiBpdCBjb250YWlucyB0aGUgY2hpbGQgd2UncmUgaW50ZXJlc3RlZCBpbi5cbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5Xy5nZXRRdWVyeVBhcmFtcygpLmxvYWRzQWxsRGF0YSgpIHx8XG4gICAgICAgICAgICAgICAgKCFwYXRoLmlzRW1wdHkoKSAmJiAhY2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQocGF0aC5nZXRGcm9udCgpKS5pc0VtcHR5KCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmdldENoaWxkKHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBWaWV3LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUV2ZW50UmVnaXN0cmF0aW9ufSBldmVudFJlZ2lzdHJhdGlvblxuICAgICAqL1xuICAgIFZpZXcucHJvdG90eXBlLmFkZEV2ZW50UmVnaXN0cmF0aW9uID0gZnVuY3Rpb24gKGV2ZW50UmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuZXZlbnRSZWdpc3RyYXRpb25zXy5wdXNoKGV2ZW50UmVnaXN0cmF0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P0V2ZW50UmVnaXN0cmF0aW9ufSBldmVudFJlZ2lzdHJhdGlvbiBJZiBudWxsLCByZW1vdmUgYWxsIGNhbGxiYWNrcy5cbiAgICAgKiBAcGFyYW0ge0Vycm9yPX0gY2FuY2VsRXJyb3IgSWYgYSBjYW5jZWxFcnJvciBpcyBwcm92aWRlZCwgYXBwcm9wcmlhdGUgY2FuY2VsIGV2ZW50cyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn0gQ2FuY2VsIGV2ZW50cywgaWYgY2FuY2VsRXJyb3Igd2FzIHByb3ZpZGVkLlxuICAgICAqL1xuICAgIFZpZXcucHJvdG90eXBlLnJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uID0gZnVuY3Rpb24gKGV2ZW50UmVnaXN0cmF0aW9uLCBjYW5jZWxFcnJvcikge1xuICAgICAgICB2YXIgY2FuY2VsRXZlbnRzID0gW107XG4gICAgICAgIGlmIChjYW5jZWxFcnJvcikge1xuICAgICAgICAgICAgYXNzZXJ0KGV2ZW50UmVnaXN0cmF0aW9uID09IG51bGwsICdBIGNhbmNlbCBzaG91bGQgY2FuY2VsIGFsbCBldmVudCByZWdpc3RyYXRpb25zLicpO1xuICAgICAgICAgICAgdmFyIHBhdGhfMSA9IHRoaXMucXVlcnlfLnBhdGg7XG4gICAgICAgICAgICB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uc18uZm9yRWFjaChmdW5jdGlvbiAocmVnaXN0cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsRXJyb3IgLyoqIEB0eXBlIHshRXJyb3J9ICovID0gY2FuY2VsRXJyb3I7XG4gICAgICAgICAgICAgICAgdmFyIG1heWJlRXZlbnQgPSByZWdpc3RyYXRpb24uY3JlYXRlQ2FuY2VsRXZlbnQoY2FuY2VsRXJyb3IsIHBhdGhfMSk7XG4gICAgICAgICAgICAgICAgaWYgKG1heWJlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsRXZlbnRzLnB1c2gobWF5YmVFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50UmVnaXN0cmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRSZWdpc3RyYXRpb25zXy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMuZXZlbnRSZWdpc3RyYXRpb25zX1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nLm1hdGNoZXMoZXZlbnRSZWdpc3RyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZy5wdXNoKGV4aXN0aW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRSZWdpc3RyYXRpb24uaGFzQW55Q2FsbGJhY2soKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSdyZSByZW1vdmluZyBqdXN0IHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5jb25jYXQodGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXZlbnRSZWdpc3RyYXRpb25zXyA9IHJlbWFpbmluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRSZWdpc3RyYXRpb25zXyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW5jZWxFdmVudHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBnaXZlbiBPcGVyYXRpb24sIHVwZGF0ZXMgb3VyIGNhY2hlLCBhbmQgcmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gY29tcGxldGVTZXJ2ZXJDYWNoZVxuICAgICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn1cbiAgICAgKi9cbiAgICBWaWV3LnByb3RvdHlwZS5hcHBseU9wZXJhdGlvbiA9IGZ1bmN0aW9uIChvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZVNlcnZlckNhY2hlKSB7XG4gICAgICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gT3BlcmF0aW9uVHlwZS5NRVJHRSAmJlxuICAgICAgICAgICAgb3BlcmF0aW9uLnNvdXJjZS5xdWVyeUlkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy52aWV3Q2FjaGVfLmdldENvbXBsZXRlU2VydmVyU25hcCgpLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgZnVsbCBjYWNoZSBiZWZvcmUgaGFuZGxpbmcgbWVyZ2VzJyk7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy52aWV3Q2FjaGVfLmdldENvbXBsZXRlRXZlbnRTbmFwKCksICdNaXNzaW5nIGV2ZW50IGNhY2hlLCBldmVuIHRob3VnaCB3ZSBoYXZlIGEgc2VydmVyIGNhY2hlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9sZFZpZXdDYWNoZSA9IHRoaXMudmlld0NhY2hlXztcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucHJvY2Vzc29yXy5hcHBseU9wZXJhdGlvbihvbGRWaWV3Q2FjaGUsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlU2VydmVyQ2FjaGUpO1xuICAgICAgICB0aGlzLnByb2Nlc3Nvcl8uYXNzZXJ0SW5kZXhlZChyZXN1bHQudmlld0NhY2hlKTtcbiAgICAgICAgYXNzZXJ0KHJlc3VsdC52aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fFxuICAgICAgICAgICAgIW9sZFZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzRnVsbHlJbml0aWFsaXplZCgpLCAnT25jZSBhIHNlcnZlciBzbmFwIGlzIGNvbXBsZXRlLCBpdCBzaG91bGQgbmV2ZXIgZ28gYmFjaycpO1xuICAgICAgICB0aGlzLnZpZXdDYWNoZV8gPSByZXN1bHQudmlld0NhY2hlO1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXNfKHJlc3VsdC5jaGFuZ2VzLCByZXN1bHQudmlld0NhY2hlLmdldEV2ZW50Q2FjaGUoKS5nZXROb2RlKCksIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshRXZlbnRSZWdpc3RyYXRpb259IHJlZ2lzdHJhdGlvblxuICAgICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn1cbiAgICAgKi9cbiAgICBWaWV3LnByb3RvdHlwZS5nZXRJbml0aWFsRXZlbnRzID0gZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbikge1xuICAgICAgICB2YXIgZXZlbnRTbmFwID0gdGhpcy52aWV3Q2FjaGVfLmdldEV2ZW50Q2FjaGUoKTtcbiAgICAgICAgdmFyIGluaXRpYWxDaGFuZ2VzID0gW107XG4gICAgICAgIGlmICghZXZlbnRTbmFwLmdldE5vZGUoKS5pc0xlYWZOb2RlKCkpIHtcbiAgICAgICAgICAgIHZhciBldmVudE5vZGUgPSBldmVudFNuYXAuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgZXZlbnROb2RlLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgZnVuY3Rpb24gKGtleSwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbENoYW5nZXMucHVzaChDaGFuZ2UuY2hpbGRBZGRlZENoYW5nZShrZXksIGNoaWxkTm9kZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICAgICAgaW5pdGlhbENoYW5nZXMucHVzaChDaGFuZ2UudmFsdWVDaGFuZ2UoZXZlbnRTbmFwLmdldE5vZGUoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlc18oaW5pdGlhbENoYW5nZXMsIGV2ZW50U25hcC5nZXROb2RlKCksIHJlZ2lzdHJhdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhQ2hhbmdlPn0gY2hhbmdlc1xuICAgICAqIEBwYXJhbSB7IU5vZGV9IGV2ZW50Q2FjaGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50UmVnaXN0cmF0aW9uPX0gZXZlbnRSZWdpc3RyYXRpb25cbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59XG4gICAgICovXG4gICAgVmlldy5wcm90b3R5cGUuZ2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzXyA9IGZ1bmN0aW9uIChjaGFuZ2VzLCBldmVudENhY2hlLCBldmVudFJlZ2lzdHJhdGlvbikge1xuICAgICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IGV2ZW50UmVnaXN0cmF0aW9uXG4gICAgICAgICAgICA/IFtldmVudFJlZ2lzdHJhdGlvbl1cbiAgICAgICAgICAgIDogdGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfO1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudEdlbmVyYXRvcl8uZ2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzKGNoYW5nZXMsIGV2ZW50Q2FjaGUsIHJlZ2lzdHJhdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIFZpZXc7XG59KCkpO1xuZXhwb3J0IHsgVmlldyB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9jb3JlL3ZpZXcvVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBPcGVyYXRpb25UeXBlIH0gZnJvbSAnLi4vb3BlcmF0aW9uL09wZXJhdGlvbic7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydGlvbkVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvciB9IGZyb20gJy4vQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcic7XG5pbXBvcnQgeyBDaGFuZ2UgfSBmcm9tICcuL0NoYW5nZSc7XG5pbXBvcnQgeyBDaGlsZHJlbk5vZGUgfSBmcm9tICcuLi9zbmFwL0NoaWxkcmVuTm9kZSc7XG5pbXBvcnQgeyBLRVlfSU5ERVggfSBmcm9tICcuLi9zbmFwL2luZGV4ZXMvS2V5SW5kZXgnO1xuaW1wb3J0IHsgSW1tdXRhYmxlVHJlZSB9IGZyb20gJy4uL3V0aWwvSW1tdXRhYmxlVHJlZSc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi4vdXRpbC9QYXRoJztcbmltcG9ydCB7IFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2UsIE5PX0NPTVBMRVRFX0NISUxEX1NPVVJDRSB9IGZyb20gJy4vQ29tcGxldGVDaGlsZFNvdXJjZSc7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHN0cnVjdFxuICovXG52YXIgUHJvY2Vzc29yUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gdmlld0NhY2hlXG4gICAgICogQHBhcmFtIHshQXJyYXkuPCFDaGFuZ2U+fSBjaGFuZ2VzXG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJvY2Vzc29yUmVzdWx0KHZpZXdDYWNoZSwgY2hhbmdlcykge1xuICAgICAgICB0aGlzLnZpZXdDYWNoZSA9IHZpZXdDYWNoZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcbiAgICB9XG4gICAgcmV0dXJuIFByb2Nlc3NvclJlc3VsdDtcbn0oKSk7XG5leHBvcnQgeyBQcm9jZXNzb3JSZXN1bHQgfTtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBWaWV3UHJvY2Vzc29yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IU5vZGVGaWx0ZXJ9IGZpbHRlcl9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWaWV3UHJvY2Vzc29yKGZpbHRlcl8pIHtcbiAgICAgICAgdGhpcy5maWx0ZXJfID0gZmlsdGVyXztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshVmlld0NhY2hlfSB2aWV3Q2FjaGVcbiAgICAgKi9cbiAgICBWaWV3UHJvY2Vzc29yLnByb3RvdHlwZS5hc3NlcnRJbmRleGVkID0gZnVuY3Rpb24gKHZpZXdDYWNoZSkge1xuICAgICAgICBhc3NlcnQodmlld0NhY2hlXG4gICAgICAgICAgICAuZ2V0RXZlbnRDYWNoZSgpXG4gICAgICAgICAgICAuZ2V0Tm9kZSgpXG4gICAgICAgICAgICAuaXNJbmRleGVkKHRoaXMuZmlsdGVyXy5nZXRJbmRleCgpKSwgJ0V2ZW50IHNuYXAgbm90IGluZGV4ZWQnKTtcbiAgICAgICAgYXNzZXJ0KHZpZXdDYWNoZVxuICAgICAgICAgICAgLmdldFNlcnZlckNhY2hlKClcbiAgICAgICAgICAgIC5nZXROb2RlKClcbiAgICAgICAgICAgIC5pc0luZGV4ZWQodGhpcy5maWx0ZXJfLmdldEluZGV4KCkpLCAnU2VydmVyIHNuYXAgbm90IGluZGV4ZWQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gb2xkVmlld0NhY2hlXG4gICAgICogQHBhcmFtIHshT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gY29tcGxldGVDYWNoZVxuICAgICAqIEByZXR1cm4geyFQcm9jZXNzb3JSZXN1bHR9XG4gICAgICovXG4gICAgVmlld1Byb2Nlc3Nvci5wcm90b3R5cGUuYXBwbHlPcGVyYXRpb24gPSBmdW5jdGlvbiAob2xkVmlld0NhY2hlLCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlKSB7XG4gICAgICAgIHZhciBhY2N1bXVsYXRvciA9IG5ldyBDaGlsZENoYW5nZUFjY3VtdWxhdG9yKCk7XG4gICAgICAgIHZhciBuZXdWaWV3Q2FjaGUsIGZpbHRlclNlcnZlck5vZGU7XG4gICAgICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gT3BlcmF0aW9uVHlwZS5PVkVSV1JJVEUpIHtcbiAgICAgICAgICAgIHZhciBvdmVyd3JpdGUgPSBvcGVyYXRpb247XG4gICAgICAgICAgICBpZiAob3ZlcndyaXRlLnNvdXJjZS5mcm9tVXNlcikge1xuICAgICAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHRoaXMuYXBwbHlVc2VyT3ZlcndyaXRlXyhvbGRWaWV3Q2FjaGUsIG92ZXJ3cml0ZS5wYXRoLCBvdmVyd3JpdGUuc25hcCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2VydChvdmVyd3JpdGUuc291cmNlLmZyb21TZXJ2ZXIsICdVbmtub3duIHNvdXJjZS4nKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBmaWx0ZXIgdGhlIG5vZGUgaWYgaXQncyBhIHRhZ2dlZCB1cGRhdGUgb3IgdGhlIG5vZGUgaGFzIGJlZW4gcHJldmlvdXNseSBmaWx0ZXJlZCAgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBpcyBub3QgYXQgdGhlIHJvb3QgaW4gd2hpY2ggY2FzZSBpdCBpcyBvayAoYW5kIG5lY2Vzc2FyeSkgdG8gbWFyayB0aGUgbm9kZSB1bmZpbHRlcmVkXG4gICAgICAgICAgICAgICAgLy8gYWdhaW5cbiAgICAgICAgICAgICAgICBmaWx0ZXJTZXJ2ZXJOb2RlID1cbiAgICAgICAgICAgICAgICAgICAgb3ZlcndyaXRlLnNvdXJjZS50YWdnZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChvbGRWaWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5pc0ZpbHRlcmVkKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhb3ZlcndyaXRlLnBhdGguaXNFbXB0eSgpKTtcbiAgICAgICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB0aGlzLmFwcGx5U2VydmVyT3ZlcndyaXRlXyhvbGRWaWV3Q2FjaGUsIG92ZXJ3cml0ZS5wYXRoLCBvdmVyd3JpdGUuc25hcCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24udHlwZSA9PT0gT3BlcmF0aW9uVHlwZS5NRVJHRSkge1xuICAgICAgICAgICAgdmFyIG1lcmdlID0gb3BlcmF0aW9uO1xuICAgICAgICAgICAgaWYgKG1lcmdlLnNvdXJjZS5mcm9tVXNlcikge1xuICAgICAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHRoaXMuYXBwbHlVc2VyTWVyZ2VfKG9sZFZpZXdDYWNoZSwgbWVyZ2UucGF0aCwgbWVyZ2UuY2hpbGRyZW4sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQobWVyZ2Uuc291cmNlLmZyb21TZXJ2ZXIsICdVbmtub3duIHNvdXJjZS4nKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBmaWx0ZXIgdGhlIG5vZGUgaWYgaXQncyBhIHRhZ2dlZCB1cGRhdGUgb3IgdGhlIG5vZGUgaGFzIGJlZW4gcHJldmlvdXNseSBmaWx0ZXJlZFxuICAgICAgICAgICAgICAgIGZpbHRlclNlcnZlck5vZGUgPVxuICAgICAgICAgICAgICAgICAgICBtZXJnZS5zb3VyY2UudGFnZ2VkIHx8IG9sZFZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzRmlsdGVyZWQoKTtcbiAgICAgICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB0aGlzLmFwcGx5U2VydmVyTWVyZ2VfKG9sZFZpZXdDYWNoZSwgbWVyZ2UucGF0aCwgbWVyZ2UuY2hpbGRyZW4sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvblR5cGUuQUNLX1VTRVJfV1JJVEUpIHtcbiAgICAgICAgICAgIHZhciBhY2tVc2VyV3JpdGUgPSBvcGVyYXRpb247XG4gICAgICAgICAgICBpZiAoIWFja1VzZXJXcml0ZS5yZXZlcnQpIHtcbiAgICAgICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB0aGlzLmFja1VzZXJXcml0ZV8ob2xkVmlld0NhY2hlLCBhY2tVc2VyV3JpdGUucGF0aCwgYWNrVXNlcldyaXRlLmFmZmVjdGVkVHJlZSwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHRoaXMucmV2ZXJ0VXNlcldyaXRlXyhvbGRWaWV3Q2FjaGUsIGFja1VzZXJXcml0ZS5wYXRoLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25UeXBlLkxJU1RFTl9DT01QTEVURSkge1xuICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gdGhpcy5saXN0ZW5Db21wbGV0ZV8ob2xkVmlld0NhY2hlLCBvcGVyYXRpb24ucGF0aCwgd3JpdGVzQ2FjaGUsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKCdVbmtub3duIG9wZXJhdGlvbiB0eXBlOiAnICsgb3BlcmF0aW9uLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFuZ2VzID0gYWNjdW11bGF0b3IuZ2V0Q2hhbmdlcygpO1xuICAgICAgICBWaWV3UHJvY2Vzc29yLm1heWJlQWRkVmFsdWVFdmVudF8ob2xkVmlld0NhY2hlLCBuZXdWaWV3Q2FjaGUsIGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4gbmV3IFByb2Nlc3NvclJlc3VsdChuZXdWaWV3Q2FjaGUsIGNoYW5nZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshVmlld0NhY2hlfSBvbGRWaWV3Q2FjaGVcbiAgICAgKiBAcGFyYW0geyFWaWV3Q2FjaGV9IG5ld1ZpZXdDYWNoZVxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhQ2hhbmdlPn0gYWNjdW11bGF0b3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZXdQcm9jZXNzb3IubWF5YmVBZGRWYWx1ZUV2ZW50XyA9IGZ1bmN0aW9uIChvbGRWaWV3Q2FjaGUsIG5ld1ZpZXdDYWNoZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgICAgdmFyIGV2ZW50U25hcCA9IG5ld1ZpZXdDYWNoZS5nZXRFdmVudENhY2hlKCk7XG4gICAgICAgIGlmIChldmVudFNuYXAuaXNGdWxseUluaXRpYWxpemVkKCkpIHtcbiAgICAgICAgICAgIHZhciBpc0xlYWZPckVtcHR5ID0gZXZlbnRTbmFwLmdldE5vZGUoKS5pc0xlYWZOb2RlKCkgfHwgZXZlbnRTbmFwLmdldE5vZGUoKS5pc0VtcHR5KCk7XG4gICAgICAgICAgICB2YXIgb2xkQ29tcGxldGVTbmFwID0gb2xkVmlld0NhY2hlLmdldENvbXBsZXRlRXZlbnRTbmFwKCk7XG4gICAgICAgICAgICBpZiAoYWNjdW11bGF0b3IubGVuZ3RoID4gMCB8fFxuICAgICAgICAgICAgICAgICFvbGRWaWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8XG4gICAgICAgICAgICAgICAgKGlzTGVhZk9yRW1wdHkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWV2ZW50U25hcFxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldE5vZGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVxdWFscygvKiogQHR5cGUgeyFOb2RlfSAqLyAob2xkQ29tcGxldGVTbmFwKSkpIHx8XG4gICAgICAgICAgICAgICAgIWV2ZW50U25hcFxuICAgICAgICAgICAgICAgICAgICAuZ2V0Tm9kZSgpXG4gICAgICAgICAgICAgICAgICAgIC5nZXRQcmlvcml0eSgpXG4gICAgICAgICAgICAgICAgICAgIC5lcXVhbHMob2xkQ29tcGxldGVTbmFwLmdldFByaW9yaXR5KCkpKSB7XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0b3IucHVzaChDaGFuZ2UudmFsdWVDaGFuZ2UoXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHshTm9kZX0gKi8gbmV3Vmlld0NhY2hlLmdldENvbXBsZXRlRXZlbnRTbmFwKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshVmlld0NhY2hlfSB2aWV3Q2FjaGVcbiAgICAgKiBAcGFyYW0geyFQYXRofSBjaGFuZ2VQYXRoXG4gICAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgICAqIEBwYXJhbSB7IUNvbXBsZXRlQ2hpbGRTb3VyY2V9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7IUNoaWxkQ2hhbmdlQWNjdW11bGF0b3J9IGFjY3VtdWxhdG9yXG4gICAgICogQHJldHVybiB7IVZpZXdDYWNoZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZXdQcm9jZXNzb3IucHJvdG90eXBlLmdlbmVyYXRlRXZlbnRDYWNoZUFmdGVyU2VydmVyRXZlbnRfID0gZnVuY3Rpb24gKHZpZXdDYWNoZSwgY2hhbmdlUGF0aCwgd3JpdGVzQ2FjaGUsIHNvdXJjZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgICAgdmFyIG9sZEV2ZW50U25hcCA9IHZpZXdDYWNoZS5nZXRFdmVudENhY2hlKCk7XG4gICAgICAgIGlmICh3cml0ZXNDYWNoZS5zaGFkb3dpbmdXcml0ZShjaGFuZ2VQYXRoKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIGEgc2hhZG93aW5nIHdyaXRlLCBpZ25vcmUgY2hhbmdlc1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXdFdmVudENhY2hlID0gdm9pZCAwLCBzZXJ2ZXJOb2RlID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGNoYW5nZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZmlndXJlIG91dCBob3cgdGhpcyBwbGF5cyB3aXRoIFwic2xpZGluZyBhY2sgd2luZG93c1wiXG4gICAgICAgICAgICAgICAgYXNzZXJ0KHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzRnVsbHlJbml0aWFsaXplZCgpLCAnSWYgY2hhbmdlIHBhdGggaXMgZW1wdHksIHdlIG11c3QgaGF2ZSBjb21wbGV0ZSBzZXJ2ZXIgZGF0YScpO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5pc0ZpbHRlcmVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBzcGVjaWFsIGNhc2UgdGhpcywgYmVjYXVzZSB3ZSBuZWVkIHRvIG9ubHkgYXBwbHkgd3JpdGVzIHRvIGNvbXBsZXRlIGNoaWxkcmVuLCBvclxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBtaWdodCBlbmQgdXAgcmFpc2luZyBldmVudHMgZm9yIGluY29tcGxldGUgY2hpbGRyZW4uIElmIHRoZSBzZXJ2ZXIgZGF0YSBpcyBmaWx0ZXJlZCBkZWVwXG4gICAgICAgICAgICAgICAgICAgIC8vIHdyaXRlcyBjYW5ub3QgYmUgZ3VhcmFudGVlZCB0byBiZSBjb21wbGV0ZVxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VydmVyQ2FjaGUgPSB2aWV3Q2FjaGUuZ2V0Q29tcGxldGVTZXJ2ZXJTbmFwKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wbGV0ZUNoaWxkcmVuID0gc2VydmVyQ2FjaGUgaW5zdGFuY2VvZiBDaGlsZHJlbk5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VydmVyQ2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wbGV0ZUV2ZW50Q2hpbGRyZW4gPSB3cml0ZXNDYWNoZS5jYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKGNvbXBsZXRlQ2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdGhpcy5maWx0ZXJfLnVwZGF0ZUZ1bGxOb2RlKHZpZXdDYWNoZS5nZXRFdmVudENhY2hlKCkuZ2V0Tm9kZSgpLCBjb21wbGV0ZUV2ZW50Q2hpbGRyZW4sIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wbGV0ZU5vZGUgPSB3cml0ZXNDYWNoZS5jYWxjQ29tcGxldGVFdmVudENhY2hlKHZpZXdDYWNoZS5nZXRDb21wbGV0ZVNlcnZlclNuYXAoKSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB0aGlzLmZpbHRlcl8udXBkYXRlRnVsbE5vZGUodmlld0NhY2hlLmdldEV2ZW50Q2FjaGUoKS5nZXROb2RlKCksIGNvbXBsZXRlTm9kZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZEtleSA9IGNoYW5nZVBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRLZXkgPT0gJy5wcmlvcml0eScpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGNoYW5nZVBhdGguZ2V0TGVuZ3RoKCkgPT0gMSwgXCJDYW4ndCBoYXZlIGEgcHJpb3JpdHkgd2l0aCBhZGRpdGlvbmFsIHBhdGggY29tcG9uZW50c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZEV2ZW50Tm9kZSA9IG9sZEV2ZW50U25hcC5nZXROb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5nZXROb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG1pZ2h0IGhhdmUgb3ZlcndyaXRlcyBmb3IgdGhpcyBwcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZFByaW9yaXR5ID0gd3JpdGVzQ2FjaGUuY2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZShjaGFuZ2VQYXRoLCBvbGRFdmVudE5vZGUsIHNlcnZlck5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZFByaW9yaXR5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB0aGlzLmZpbHRlcl8udXBkYXRlUHJpb3JpdHkob2xkRXZlbnROb2RlLCB1cGRhdGVkUHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJpb3JpdHkgZGlkbid0IGNoYW5nZSwga2VlcCBvbGQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50U25hcC5nZXROb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZENoYW5nZVBhdGggPSBjaGFuZ2VQYXRoLnBvcEZyb250KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBjaGlsZFxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RXZlbnRDaGlsZCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZEV2ZW50U25hcC5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJOb2RlID0gdmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50Q2hpbGRVcGRhdGUgPSB3cml0ZXNDYWNoZS5jYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlKGNoYW5nZVBhdGgsIG9sZEV2ZW50U25hcC5nZXROb2RlKCksIHNlcnZlck5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50Q2hpbGRVcGRhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2hpbGQgPSBvbGRFdmVudFNuYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldE5vZGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51cGRhdGVDaGlsZChjaGlsZENoYW5nZVBhdGgsIGV2ZW50Q2hpbGRVcGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBjaGFuZ2VkLCBqdXN0IGtlZXAgdGhlIG9sZCBjaGlsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2hpbGQgPSBvbGRFdmVudFNuYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldE5vZGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDaGlsZCA9IHdyaXRlc0NhY2hlLmNhbGNDb21wbGV0ZUNoaWxkKGNoaWxkS2V5LCB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0V2ZW50Q2hpbGQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHRoaXMuZmlsdGVyXy51cGRhdGVDaGlsZChvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLCBjaGlsZEtleSwgbmV3RXZlbnRDaGlsZCwgY2hpbGRDaGFuZ2VQYXRoLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIGNvbXBsZXRlIGNoaWxkIGF2YWlsYWJsZSBvciBubyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZpZXdDYWNoZS51cGRhdGVFdmVudFNuYXAobmV3RXZlbnRDYWNoZSwgb2xkRXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8IGNoYW5nZVBhdGguaXNFbXB0eSgpLCB0aGlzLmZpbHRlcl8uZmlsdGVyc05vZGVzKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFWaWV3Q2FjaGV9IG9sZFZpZXdDYWNoZVxuICAgICAqIEBwYXJhbSB7IVBhdGh9IGNoYW5nZVBhdGhcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBjaGFuZ2VkU25hcFxuICAgICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzQ2FjaGVcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBjb21wbGV0ZUNhY2hlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmaWx0ZXJTZXJ2ZXJOb2RlXG4gICAgICogQHBhcmFtIHshQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcn0gYWNjdW11bGF0b3JcbiAgICAgKiBAcmV0dXJuIHshVmlld0NhY2hlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVmlld1Byb2Nlc3Nvci5wcm90b3R5cGUuYXBwbHlTZXJ2ZXJPdmVyd3JpdGVfID0gZnVuY3Rpb24gKG9sZFZpZXdDYWNoZSwgY2hhbmdlUGF0aCwgY2hhbmdlZFNuYXAsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcikge1xuICAgICAgICB2YXIgb2xkU2VydmVyU25hcCA9IG9sZFZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpO1xuICAgICAgICB2YXIgbmV3U2VydmVyQ2FjaGU7XG4gICAgICAgIHZhciBzZXJ2ZXJGaWx0ZXIgPSBmaWx0ZXJTZXJ2ZXJOb2RlXG4gICAgICAgICAgICA/IHRoaXMuZmlsdGVyX1xuICAgICAgICAgICAgOiB0aGlzLmZpbHRlcl8uZ2V0SW5kZXhlZEZpbHRlcigpO1xuICAgICAgICBpZiAoY2hhbmdlUGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIG5ld1NlcnZlckNhY2hlID0gc2VydmVyRmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKG9sZFNlcnZlclNuYXAuZ2V0Tm9kZSgpLCBjaGFuZ2VkU25hcCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VydmVyRmlsdGVyLmZpbHRlcnNOb2RlcygpICYmICFvbGRTZXJ2ZXJTbmFwLmlzRmlsdGVyZWQoKSkge1xuICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBmaWx0ZXIgdGhlIHNlcnZlciBub2RlLCBidXQgd2UgZGlkbid0IGZpbHRlciB0aGUgc2VydmVyIG5vZGUgeWV0LCBzbyBzaW11bGF0ZSBhIGZ1bGwgdXBkYXRlXG4gICAgICAgICAgICB2YXIgbmV3U2VydmVyTm9kZSA9IG9sZFNlcnZlclNuYXBcbiAgICAgICAgICAgICAgICAuZ2V0Tm9kZSgpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZUNoaWxkKGNoYW5nZVBhdGgsIGNoYW5nZWRTbmFwKTtcbiAgICAgICAgICAgIG5ld1NlcnZlckNhY2hlID0gc2VydmVyRmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKG9sZFNlcnZlclNuYXAuZ2V0Tm9kZSgpLCBuZXdTZXJ2ZXJOb2RlLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEtleSA9IGNoYW5nZVBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgIGlmICghb2xkU2VydmVyU25hcC5pc0NvbXBsZXRlRm9yUGF0aChjaGFuZ2VQYXRoKSAmJlxuICAgICAgICAgICAgICAgIGNoYW5nZVBhdGguZ2V0TGVuZ3RoKCkgPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXBkYXRlIGluY29tcGxldGUgbm9kZXMgd2l0aCB1cGRhdGVzIGludGVuZGVkIGZvciBvdGhlciBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVmlld0NhY2hlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkQ2hhbmdlUGF0aCA9IGNoYW5nZVBhdGgucG9wRnJvbnQoKTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XG4gICAgICAgICAgICB2YXIgbmV3Q2hpbGROb2RlID0gY2hpbGROb2RlLnVwZGF0ZUNoaWxkKGNoaWxkQ2hhbmdlUGF0aCwgY2hhbmdlZFNuYXApO1xuICAgICAgICAgICAgaWYgKGNoaWxkS2V5ID09ICcucHJpb3JpdHknKSB7XG4gICAgICAgICAgICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlUHJpb3JpdHkob2xkU2VydmVyU25hcC5nZXROb2RlKCksIG5ld0NoaWxkTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTZXJ2ZXJDYWNoZSA9IHNlcnZlckZpbHRlci51cGRhdGVDaGlsZChvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKSwgY2hpbGRLZXksIG5ld0NoaWxkTm9kZSwgY2hpbGRDaGFuZ2VQYXRoLCBOT19DT01QTEVURV9DSElMRF9TT1VSQ0UsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdWaWV3Q2FjaGUgPSBvbGRWaWV3Q2FjaGUudXBkYXRlU2VydmVyU25hcChuZXdTZXJ2ZXJDYWNoZSwgb2xkU2VydmVyU25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fCBjaGFuZ2VQYXRoLmlzRW1wdHkoKSwgc2VydmVyRmlsdGVyLmZpbHRlcnNOb2RlcygpKTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IG5ldyBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlKHdyaXRlc0NhY2hlLCBuZXdWaWV3Q2FjaGUsIGNvbXBsZXRlQ2FjaGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUV2ZW50Q2FjaGVBZnRlclNlcnZlckV2ZW50XyhuZXdWaWV3Q2FjaGUsIGNoYW5nZVBhdGgsIHdyaXRlc0NhY2hlLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gb2xkVmlld0NhY2hlXG4gICAgICogQHBhcmFtIHshUGF0aH0gY2hhbmdlUGF0aFxuICAgICAqIEBwYXJhbSB7IU5vZGV9IGNoYW5nZWRTbmFwXG4gICAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgICAqIEBwYXJhbSB7P05vZGV9IGNvbXBsZXRlQ2FjaGVcbiAgICAgKiBAcGFyYW0geyFDaGlsZENoYW5nZUFjY3VtdWxhdG9yfSBhY2N1bXVsYXRvclxuICAgICAqIEByZXR1cm4geyFWaWV3Q2FjaGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWaWV3UHJvY2Vzc29yLnByb3RvdHlwZS5hcHBseVVzZXJPdmVyd3JpdGVfID0gZnVuY3Rpb24gKG9sZFZpZXdDYWNoZSwgY2hhbmdlUGF0aCwgY2hhbmdlZFNuYXAsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcikge1xuICAgICAgICB2YXIgb2xkRXZlbnRTbmFwID0gb2xkVmlld0NhY2hlLmdldEV2ZW50Q2FjaGUoKTtcbiAgICAgICAgdmFyIG5ld1ZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IG5ldyBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlKHdyaXRlc0NhY2hlLCBvbGRWaWV3Q2FjaGUsIGNvbXBsZXRlQ2FjaGUpO1xuICAgICAgICBpZiAoY2hhbmdlUGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB0aGlzLmZpbHRlcl8udXBkYXRlRnVsbE5vZGUob2xkVmlld0NhY2hlLmdldEV2ZW50Q2FjaGUoKS5nZXROb2RlKCksIGNoYW5nZWRTbmFwLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSBvbGRWaWV3Q2FjaGUudXBkYXRlRXZlbnRTbmFwKG5ld0V2ZW50Q2FjaGUsIHRydWUsIHRoaXMuZmlsdGVyXy5maWx0ZXJzTm9kZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRLZXkgPSBjaGFuZ2VQYXRoLmdldEZyb250KCk7XG4gICAgICAgICAgICBpZiAoY2hpbGRLZXkgPT09ICcucHJpb3JpdHknKSB7XG4gICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHRoaXMuZmlsdGVyXy51cGRhdGVQcmlvcml0eShvbGRWaWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpLmdldE5vZGUoKSwgY2hhbmdlZFNuYXApO1xuICAgICAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IG9sZFZpZXdDYWNoZS51cGRhdGVFdmVudFNuYXAobmV3RXZlbnRDYWNoZSwgb2xkRXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpLCBvbGRFdmVudFNuYXAuaXNGaWx0ZXJlZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZENoYW5nZVBhdGggPSBjaGFuZ2VQYXRoLnBvcEZyb250KCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZENoaWxkID0gb2xkRXZlbnRTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZENoYW5nZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoaWxkIG92ZXJ3cml0ZSwgd2UgY2FuIHJlcGxhY2UgdGhlIGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gY2hhbmdlZFNuYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gc291cmNlLmdldENvbXBsZXRlQ2hpbGQoY2hpbGRLZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZENoYW5nZVBhdGguZ2V0QmFjaygpID09PSAnLnByaW9yaXR5JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5nZXRDaGlsZChjaGlsZENoYW5nZVBhdGgucGFyZW50KCkpLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBwcmlvcml0eSB1cGRhdGUgb24gYW4gZW1wdHkgbm9kZS4gSWYgdGhpcyBub2RlIGV4aXN0cyBvbiB0aGUgc2VydmVyLCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXJ2ZXIgd2lsbCBzZW5kIGRvd24gdGhlIHByaW9yaXR5IGluIHRoZSB1cGRhdGUsIHNvIGlnbm9yZSBmb3Igbm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBjaGlsZE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNoaWxkTm9kZS51cGRhdGVDaGlsZChjaGlsZENoYW5nZVBhdGgsIGNoYW5nZWRTbmFwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGNvbXBsZXRlIGNoaWxkIG5vZGUgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghb2xkQ2hpbGQuZXF1YWxzKG5ld0NoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RXZlbnRTbmFwID0gdGhpcy5maWx0ZXJfLnVwZGF0ZUNoaWxkKG9sZEV2ZW50U25hcC5nZXROb2RlKCksIGNoaWxkS2V5LCBuZXdDaGlsZCwgY2hpbGRDaGFuZ2VQYXRoLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gb2xkVmlld0NhY2hlLnVwZGF0ZUV2ZW50U25hcChuZXdFdmVudFNuYXAsIG9sZEV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgdGhpcy5maWx0ZXJfLmZpbHRlcnNOb2RlcygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IG9sZFZpZXdDYWNoZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1ZpZXdDYWNoZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gdmlld0NhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkS2V5XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZXdQcm9jZXNzb3IuY2FjaGVIYXNDaGlsZF8gPSBmdW5jdGlvbiAodmlld0NhY2hlLCBjaGlsZEtleSkge1xuICAgICAgICByZXR1cm4gdmlld0NhY2hlLmdldEV2ZW50Q2FjaGUoKS5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshVmlld0NhY2hlfSB2aWV3Q2FjaGVcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHtJbW11dGFibGVUcmVlLjwhTm9kZT59IGNoYW5nZWRDaGlsZHJlblxuICAgICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzQ2FjaGVcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBzZXJ2ZXJDYWNoZVxuICAgICAqIEBwYXJhbSB7IUNoaWxkQ2hhbmdlQWNjdW11bGF0b3J9IGFjY3VtdWxhdG9yXG4gICAgICogQHJldHVybiB7IVZpZXdDYWNoZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZXdQcm9jZXNzb3IucHJvdG90eXBlLmFwcGx5VXNlck1lcmdlXyA9IGZ1bmN0aW9uICh2aWV3Q2FjaGUsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBhY2N1bXVsYXRvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBIQUNLOiBJbiB0aGUgY2FzZSBvZiBhIGxpbWl0IHF1ZXJ5LCB0aGVyZSBtYXkgYmUgc29tZSBjaGFuZ2VzIHRoYXQgYnVtcCB0aGluZ3Mgb3V0IG9mIHRoZVxuICAgICAgICAvLyB3aW5kb3cgbGVhdmluZyByb29tIGZvciBuZXcgaXRlbXMuICBJdCdzIGltcG9ydGFudCB3ZSBwcm9jZXNzIHRoZXNlIGNoYW5nZXMgZmlyc3QsIHNvIHdlXG4gICAgICAgIC8vIGl0ZXJhdGUgdGhlIGNoYW5nZXMgdHdpY2UsIGZpcnN0IHByb2Nlc3NpbmcgYW55IHRoYXQgYWZmZWN0IGl0ZW1zIGN1cnJlbnRseSBpbiB2aWV3LlxuICAgICAgICAvLyBUT0RPOiBJIGNvbnNpZGVyIGFuIGl0ZW0gXCJpbiB2aWV3XCIgaWYgY2FjaGVIYXNDaGlsZCBpcyB0cnVlLCB3aGljaCBjaGVja3MgYm90aCB0aGUgc2VydmVyXG4gICAgICAgIC8vIGFuZCBldmVudCBzbmFwLiAgSSdtIG5vdCBzdXJlIGlmIHRoaXMgd2lsbCByZXN1bHQgaW4gZWRnZSBjYXNlcyB3aGVuIGEgY2hpbGQgaXMgaW4gb25lIGJ1dFxuICAgICAgICAvLyBub3QgdGhlIG90aGVyLlxuICAgICAgICB2YXIgY3VyVmlld0NhY2hlID0gdmlld0NhY2hlO1xuICAgICAgICBjaGFuZ2VkQ2hpbGRyZW4uZm9yZWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIHZhciB3cml0ZVBhdGggPSBwYXRoLmNoaWxkKHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICBpZiAoVmlld1Byb2Nlc3Nvci5jYWNoZUhhc0NoaWxkXyh2aWV3Q2FjaGUsIHdyaXRlUGF0aC5nZXRGcm9udCgpKSkge1xuICAgICAgICAgICAgICAgIGN1clZpZXdDYWNoZSA9IF90aGlzLmFwcGx5VXNlck92ZXJ3cml0ZV8oY3VyVmlld0NhY2hlLCB3cml0ZVBhdGgsIGNoaWxkTm9kZSwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGFuZ2VkQ2hpbGRyZW4uZm9yZWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIHZhciB3cml0ZVBhdGggPSBwYXRoLmNoaWxkKHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICBpZiAoIVZpZXdQcm9jZXNzb3IuY2FjaGVIYXNDaGlsZF8odmlld0NhY2hlLCB3cml0ZVBhdGguZ2V0RnJvbnQoKSkpIHtcbiAgICAgICAgICAgICAgICBjdXJWaWV3Q2FjaGUgPSBfdGhpcy5hcHBseVVzZXJPdmVyd3JpdGVfKGN1clZpZXdDYWNoZSwgd3JpdGVQYXRoLCBjaGlsZE5vZGUsIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGN1clZpZXdDYWNoZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge0ltbXV0YWJsZVRyZWUuPCFOb2RlPn0gbWVyZ2VcbiAgICAgKiBAcmV0dXJuIHshTm9kZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZXdQcm9jZXNzb3IucHJvdG90eXBlLmFwcGx5TWVyZ2VfID0gZnVuY3Rpb24gKG5vZGUsIG1lcmdlKSB7XG4gICAgICAgIG1lcmdlLmZvcmVhY2goZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGgsIGNoaWxkTm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gdmlld0NhY2hlXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7IUltbXV0YWJsZVRyZWUuPCFOb2RlPn0gY2hhbmdlZENoaWxkcmVuXG4gICAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgICAqIEBwYXJhbSB7P05vZGV9IHNlcnZlckNhY2hlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmaWx0ZXJTZXJ2ZXJOb2RlXG4gICAgICogQHBhcmFtIHshQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcn0gYWNjdW11bGF0b3JcbiAgICAgKiBAcmV0dXJuIHshVmlld0NhY2hlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVmlld1Byb2Nlc3Nvci5wcm90b3R5cGUuYXBwbHlTZXJ2ZXJNZXJnZV8gPSBmdW5jdGlvbiAodmlld0NhY2hlLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNhY2hlIHlldCwgdGhpcyBtZXJnZSB3YXMgaW50ZW5kZWQgZm9yIGEgcHJldmlvdXNseSBsaXN0ZW4gaW4gdGhlIHNhbWUgbG9jYXRpb24uIElnbm9yZSBpdCBhbmRcbiAgICAgICAgLy8gd2FpdCBmb3IgdGhlIGNvbXBsZXRlIGRhdGEgdXBkYXRlIGNvbWluZyBzb29uLlxuICAgICAgICBpZiAodmlld0NhY2hlXG4gICAgICAgICAgICAuZ2V0U2VydmVyQ2FjaGUoKVxuICAgICAgICAgICAgLmdldE5vZGUoKVxuICAgICAgICAgICAgLmlzRW1wdHkoKSAmJlxuICAgICAgICAgICAgIXZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzRnVsbHlJbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhBQ0s6IEluIHRoZSBjYXNlIG9mIGEgbGltaXQgcXVlcnksIHRoZXJlIG1heSBiZSBzb21lIGNoYW5nZXMgdGhhdCBidW1wIHRoaW5ncyBvdXQgb2YgdGhlXG4gICAgICAgIC8vIHdpbmRvdyBsZWF2aW5nIHJvb20gZm9yIG5ldyBpdGVtcy4gIEl0J3MgaW1wb3J0YW50IHdlIHByb2Nlc3MgdGhlc2UgY2hhbmdlcyBmaXJzdCwgc28gd2VcbiAgICAgICAgLy8gaXRlcmF0ZSB0aGUgY2hhbmdlcyB0d2ljZSwgZmlyc3QgcHJvY2Vzc2luZyBhbnkgdGhhdCBhZmZlY3QgaXRlbXMgY3VycmVudGx5IGluIHZpZXcuXG4gICAgICAgIC8vIFRPRE86IEkgY29uc2lkZXIgYW4gaXRlbSBcImluIHZpZXdcIiBpZiBjYWNoZUhhc0NoaWxkIGlzIHRydWUsIHdoaWNoIGNoZWNrcyBib3RoIHRoZSBzZXJ2ZXJcbiAgICAgICAgLy8gYW5kIGV2ZW50IHNuYXAuICBJJ20gbm90IHN1cmUgaWYgdGhpcyB3aWxsIHJlc3VsdCBpbiBlZGdlIGNhc2VzIHdoZW4gYSBjaGlsZCBpcyBpbiBvbmUgYnV0XG4gICAgICAgIC8vIG5vdCB0aGUgb3RoZXIuXG4gICAgICAgIHZhciBjdXJWaWV3Q2FjaGUgPSB2aWV3Q2FjaGU7XG4gICAgICAgIHZhciB2aWV3TWVyZ2VUcmVlO1xuICAgICAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHZpZXdNZXJnZVRyZWUgPSBjaGFuZ2VkQ2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2aWV3TWVyZ2VUcmVlID0gSW1tdXRhYmxlVHJlZS5FbXB0eS5zZXRUcmVlKHBhdGgsIGNoYW5nZWRDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5nZXROb2RlKCk7XG4gICAgICAgIHZpZXdNZXJnZVRyZWUuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbChmdW5jdGlvbiAoY2hpbGRLZXksIGNoaWxkVHJlZSkge1xuICAgICAgICAgICAgaWYgKHNlcnZlck5vZGUuaGFzQ2hpbGQoY2hpbGRLZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcnZlckNoaWxkID0gdmlld0NhY2hlXG4gICAgICAgICAgICAgICAgICAgIC5nZXRTZXJ2ZXJDYWNoZSgpXG4gICAgICAgICAgICAgICAgICAgIC5nZXROb2RlKClcbiAgICAgICAgICAgICAgICAgICAgLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q2hpbGQgPSBfdGhpcy5hcHBseU1lcmdlXyhzZXJ2ZXJDaGlsZCwgY2hpbGRUcmVlKTtcbiAgICAgICAgICAgICAgICBjdXJWaWV3Q2FjaGUgPSBfdGhpcy5hcHBseVNlcnZlck92ZXJ3cml0ZV8oY3VyVmlld0NhY2hlLCBuZXcgUGF0aChjaGlsZEtleSksIG5ld0NoaWxkLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZpZXdNZXJnZVRyZWUuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbChmdW5jdGlvbiAoY2hpbGRLZXksIGNoaWxkTWVyZ2VUcmVlKSB7XG4gICAgICAgICAgICB2YXIgaXNVbmtub3duRGVlcE1lcmdlID0gIXZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzQ29tcGxldGVGb3JDaGlsZChjaGlsZEtleSkgJiZcbiAgICAgICAgICAgICAgICBjaGlsZE1lcmdlVHJlZS52YWx1ZSA9PSBudWxsO1xuICAgICAgICAgICAgaWYgKCFzZXJ2ZXJOb2RlLmhhc0NoaWxkKGNoaWxkS2V5KSAmJiAhaXNVbmtub3duRGVlcE1lcmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcnZlckNoaWxkID0gdmlld0NhY2hlXG4gICAgICAgICAgICAgICAgICAgIC5nZXRTZXJ2ZXJDYWNoZSgpXG4gICAgICAgICAgICAgICAgICAgIC5nZXROb2RlKClcbiAgICAgICAgICAgICAgICAgICAgLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q2hpbGQgPSBfdGhpcy5hcHBseU1lcmdlXyhzZXJ2ZXJDaGlsZCwgY2hpbGRNZXJnZVRyZWUpO1xuICAgICAgICAgICAgICAgIGN1clZpZXdDYWNoZSA9IF90aGlzLmFwcGx5U2VydmVyT3ZlcndyaXRlXyhjdXJWaWV3Q2FjaGUsIG5ldyBQYXRoKGNoaWxkS2V5KSwgbmV3Q2hpbGQsIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGN1clZpZXdDYWNoZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gdmlld0NhY2hlXG4gICAgICogQHBhcmFtIHshUGF0aH0gYWNrUGF0aFxuICAgICAqIEBwYXJhbSB7IUltbXV0YWJsZVRyZWU8IWJvb2xlYW4+fSBhZmZlY3RlZFRyZWVcbiAgICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gY29tcGxldGVDYWNoZVxuICAgICAqIEBwYXJhbSB7IUNoaWxkQ2hhbmdlQWNjdW11bGF0b3J9IGFjY3VtdWxhdG9yXG4gICAgICogQHJldHVybiB7IVZpZXdDYWNoZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZXdQcm9jZXNzb3IucHJvdG90eXBlLmFja1VzZXJXcml0ZV8gPSBmdW5jdGlvbiAodmlld0NhY2hlLCBhY2tQYXRoLCBhZmZlY3RlZFRyZWUsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcikge1xuICAgICAgICBpZiAod3JpdGVzQ2FjaGUuc2hhZG93aW5nV3JpdGUoYWNrUGF0aCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGZpbHRlciBzZXJ2ZXIgbm9kZSBpZiBpdCBpcyBjdXJyZW50bHkgZmlsdGVyZWRcbiAgICAgICAgdmFyIGZpbHRlclNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5pc0ZpbHRlcmVkKCk7XG4gICAgICAgIC8vIEVzc2VudGlhbGx5IHdlJ2xsIGp1c3QgZ2V0IG91ciBleGlzdGluZyBzZXJ2ZXIgY2FjaGUgZm9yIHRoZSBhZmZlY3RlZCBwYXRocyBhbmQgcmUtYXBwbHkgaXQgYXMgYSBzZXJ2ZXIgdXBkYXRlXG4gICAgICAgIC8vIG5vdyB0aGF0IGl0IHdvbid0IGJlIHNoYWRvd2VkLlxuICAgICAgICB2YXIgc2VydmVyQ2FjaGUgPSB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKTtcbiAgICAgICAgaWYgKGFmZmVjdGVkVHJlZS52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFuIG92ZXJ3cml0ZS5cbiAgICAgICAgICAgIGlmICgoYWNrUGF0aC5pc0VtcHR5KCkgJiYgc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkpIHx8XG4gICAgICAgICAgICAgICAgc2VydmVyQ2FjaGUuaXNDb21wbGV0ZUZvclBhdGgoYWNrUGF0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseVNlcnZlck92ZXJ3cml0ZV8odmlld0NhY2hlLCBhY2tQYXRoLCBzZXJ2ZXJDYWNoZS5nZXROb2RlKCkuZ2V0Q2hpbGQoYWNrUGF0aCksIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2tQYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBnb29meSBlZGdlIGNhc2Ugd2hlcmUgd2UgYXJlIGFja2luZyBkYXRhIGF0IHRoaXMgbG9jYXRpb24gYnV0IGRvbid0IGhhdmUgZnVsbCBkYXRhLiAgV2VcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQganVzdCByZS1hcHBseSB3aGF0ZXZlciB3ZSBoYXZlIGluIG91ciBjYWNoZSBhcyBhIG1lcmdlLlxuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkQ2hpbGRyZW5fMSA9IEltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICAgICAgICAgICAgc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLmZvckVhY2hDaGlsZChLRVlfSU5ERVgsIGZ1bmN0aW9uIChuYW1lLCBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRDaGlsZHJlbl8xID0gY2hhbmdlZENoaWxkcmVuXzEuc2V0KG5ldyBQYXRoKG5hbWUpLCBub2RlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseVNlcnZlck1lcmdlXyh2aWV3Q2FjaGUsIGFja1BhdGgsIGNoYW5nZWRDaGlsZHJlbl8xLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBtZXJnZS5cbiAgICAgICAgICAgIHZhciBjaGFuZ2VkQ2hpbGRyZW5fMiA9IEltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICAgICAgICBhZmZlY3RlZFRyZWUuZm9yZWFjaChmdW5jdGlvbiAobWVyZ2VQYXRoLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJ2ZXJDYWNoZVBhdGggPSBhY2tQYXRoLmNoaWxkKG1lcmdlUGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZlckNhY2hlLmlzQ29tcGxldGVGb3JQYXRoKHNlcnZlckNhY2hlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZENoaWxkcmVuXzIgPSBjaGFuZ2VkQ2hpbGRyZW5fMi5zZXQobWVyZ2VQYXRoLCBzZXJ2ZXJDYWNoZS5nZXROb2RlKCkuZ2V0Q2hpbGQoc2VydmVyQ2FjaGVQYXRoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseVNlcnZlck1lcmdlXyh2aWV3Q2FjaGUsIGFja1BhdGgsIGNoYW5nZWRDaGlsZHJlbl8yLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFWaWV3Q2FjaGV9IHZpZXdDYWNoZVxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAgICogQHBhcmFtIHshQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcn0gYWNjdW11bGF0b3JcbiAgICAgKiBAcmV0dXJuIHshVmlld0NhY2hlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVmlld1Byb2Nlc3Nvci5wcm90b3R5cGUubGlzdGVuQ29tcGxldGVfID0gZnVuY3Rpb24gKHZpZXdDYWNoZSwgcGF0aCwgd3JpdGVzQ2FjaGUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICAgIHZhciBvbGRTZXJ2ZXJOb2RlID0gdmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCk7XG4gICAgICAgIHZhciBuZXdWaWV3Q2FjaGUgPSB2aWV3Q2FjaGUudXBkYXRlU2VydmVyU25hcChvbGRTZXJ2ZXJOb2RlLmdldE5vZGUoKSwgb2xkU2VydmVyTm9kZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fCBwYXRoLmlzRW1wdHkoKSwgb2xkU2VydmVyTm9kZS5pc0ZpbHRlcmVkKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUV2ZW50Q2FjaGVBZnRlclNlcnZlckV2ZW50XyhuZXdWaWV3Q2FjaGUsIHBhdGgsIHdyaXRlc0NhY2hlLCBOT19DT01QTEVURV9DSElMRF9TT1VSQ0UsIGFjY3VtdWxhdG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gdmlld0NhY2hlXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzQ2FjaGVcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBjb21wbGV0ZVNlcnZlckNhY2hlXG4gICAgICogQHBhcmFtIHshQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcn0gYWNjdW11bGF0b3JcbiAgICAgKiBAcmV0dXJuIHshVmlld0NhY2hlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVmlld1Byb2Nlc3Nvci5wcm90b3R5cGUucmV2ZXJ0VXNlcldyaXRlXyA9IGZ1bmN0aW9uICh2aWV3Q2FjaGUsIHBhdGgsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZVNlcnZlckNhY2hlLCBhY2N1bXVsYXRvcikge1xuICAgICAgICB2YXIgY29tcGxldGU7XG4gICAgICAgIGlmICh3cml0ZXNDYWNoZS5zaGFkb3dpbmdXcml0ZShwYXRoKSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IG5ldyBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlKHdyaXRlc0NhY2hlLCB2aWV3Q2FjaGUsIGNvbXBsZXRlU2VydmVyQ2FjaGUpO1xuICAgICAgICAgICAgdmFyIG9sZEV2ZW50Q2FjaGUgPSB2aWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpLmdldE5vZGUoKTtcbiAgICAgICAgICAgIHZhciBuZXdFdmVudENhY2hlID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHBhdGguaXNFbXB0eSgpIHx8IHBhdGguZ2V0RnJvbnQoKSA9PT0gJy5wcmlvcml0eScpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAodmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuaXNGdWxseUluaXRpYWxpemVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZSA9IHdyaXRlc0NhY2hlLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUodmlld0NhY2hlLmdldENvbXBsZXRlU2VydmVyU25hcCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXJ2ZXJDaGlsZHJlbiA9IHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmdldE5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHNlcnZlckNoaWxkcmVuIGluc3RhbmNlb2YgQ2hpbGRyZW5Ob2RlLCAnc2VydmVyQ2hpbGRyZW4gd291bGQgYmUgY29tcGxldGUgaWYgbGVhZiBub2RlJyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld05vZGUgPSB3cml0ZXNDYWNoZS5jYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKHNlcnZlckNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IG5ld05vZGU7XG4gICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHRoaXMuZmlsdGVyXy51cGRhdGVGdWxsTm9kZShvbGRFdmVudENhY2hlLCBuZXdOb2RlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRLZXkgPSBwYXRoLmdldEZyb250KCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkID0gd3JpdGVzQ2FjaGUuY2FsY0NvbXBsZXRlQ2hpbGQoY2hpbGRLZXksIHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQgPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gb2xkRXZlbnRDYWNoZS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdDaGlsZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB0aGlzLmZpbHRlcl8udXBkYXRlQ2hpbGQob2xkRXZlbnRDYWNoZSwgY2hpbGRLZXksIG5ld0NoaWxkLCBwYXRoLnBvcEZyb250KCksIHNvdXJjZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2aWV3Q2FjaGVcbiAgICAgICAgICAgICAgICAgICAgLmdldEV2ZW50Q2FjaGUoKVxuICAgICAgICAgICAgICAgICAgICAuZ2V0Tm9kZSgpXG4gICAgICAgICAgICAgICAgICAgIC5oYXNDaGlsZChjaGlsZEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gY29tcGxldGUgY2hpbGQgYXZhaWxhYmxlLCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZSwgaWYgYW55XG4gICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB0aGlzLmZpbHRlcl8udXBkYXRlQ2hpbGQob2xkRXZlbnRDYWNoZSwgY2hpbGRLZXksIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLCBwYXRoLnBvcEZyb250KCksIHNvdXJjZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50Q2FjaGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdFdmVudENhY2hlLmlzRW1wdHkoKSAmJlxuICAgICAgICAgICAgICAgICAgICB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBtaWdodCBoYXZlIHJldmVydGVkIGFsbCBjaGlsZCB3cml0ZXMuIE1heWJlIHRoZSBvbGQgZXZlbnQgd2FzIGEgbGVhZiBub2RlXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlID0gd3JpdGVzQ2FjaGUuY2FsY0NvbXBsZXRlRXZlbnRDYWNoZSh2aWV3Q2FjaGUuZ2V0Q29tcGxldGVTZXJ2ZXJTbmFwKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGUuaXNMZWFmTm9kZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdGhpcy5maWx0ZXJfLnVwZGF0ZUZ1bGxOb2RlKG5ld0V2ZW50Q2FjaGUsIGNvbXBsZXRlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wbGV0ZSA9XG4gICAgICAgICAgICAgICAgdmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuaXNGdWxseUluaXRpYWxpemVkKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVzQ2FjaGUuc2hhZG93aW5nV3JpdGUoUGF0aC5FbXB0eSkgIT0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB2aWV3Q2FjaGUudXBkYXRlRXZlbnRTbmFwKG5ld0V2ZW50Q2FjaGUsIGNvbXBsZXRlLCB0aGlzLmZpbHRlcl8uZmlsdGVyc05vZGVzKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVmlld1Byb2Nlc3Nvcjtcbn0oKSk7XG5leHBvcnQgeyBWaWV3UHJvY2Vzc29yIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL2NvcmUvdmlldy9WaWV3UHJvY2Vzc29yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IFJhbmdlZEZpbHRlciB9IGZyb20gJy4vUmFuZ2VkRmlsdGVyJztcbmltcG9ydCB7IENoaWxkcmVuTm9kZSB9IGZyb20gJy4uLy4uL3NuYXAvQ2hpbGRyZW5Ob2RlJztcbmltcG9ydCB7IE5hbWVkTm9kZSB9IGZyb20gJy4uLy4uL3NuYXAvTm9kZSc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBDaGFuZ2UgfSBmcm9tICcuLi9DaGFuZ2UnO1xuLyoqXG4gKiBBcHBsaWVzIGEgbGltaXQgYW5kIGEgcmFuZ2UgdG8gYSBub2RlIGFuZCB1c2VzIFJhbmdlZEZpbHRlciB0byBkbyB0aGUgaGVhdnkgbGlmdGluZyB3aGVyZSBwb3NzaWJsZVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge05vZGVGaWx0ZXJ9XG4gKi9cbnZhciBMaW1pdGVkRmlsdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5UGFyYW1zfSBwYXJhbXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaW1pdGVkRmlsdGVyKHBhcmFtcykge1xuICAgICAgICB0aGlzLnJhbmdlZEZpbHRlcl8gPSBuZXcgUmFuZ2VkRmlsdGVyKHBhcmFtcyk7XG4gICAgICAgIHRoaXMuaW5kZXhfID0gcGFyYW1zLmdldEluZGV4KCk7XG4gICAgICAgIHRoaXMubGltaXRfID0gcGFyYW1zLmdldExpbWl0KCk7XG4gICAgICAgIHRoaXMucmV2ZXJzZV8gPSAhcGFyYW1zLmlzVmlld0Zyb21MZWZ0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTGltaXRlZEZpbHRlci5wcm90b3R5cGUudXBkYXRlQ2hpbGQgPSBmdW5jdGlvbiAoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XG4gICAgICAgIGlmICghdGhpcy5yYW5nZWRGaWx0ZXJfLm1hdGNoZXMobmV3IE5hbWVkTm9kZShrZXksIG5ld0NoaWxkKSkpIHtcbiAgICAgICAgICAgIG5ld0NoaWxkID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNuYXAuZ2V0SW1tZWRpYXRlQ2hpbGQoa2V5KS5lcXVhbHMobmV3Q2hpbGQpKSB7XG4gICAgICAgICAgICAvLyBObyBjaGFuZ2VcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNuYXAubnVtQ2hpbGRyZW4oKSA8IHRoaXMubGltaXRfKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYW5nZWRGaWx0ZXJfXG4gICAgICAgICAgICAgICAgLmdldEluZGV4ZWRGaWx0ZXIoKVxuICAgICAgICAgICAgICAgIC51cGRhdGVDaGlsZChzbmFwLCBrZXksIG5ld0NoaWxkLCBhZmZlY3RlZFBhdGgsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVsbExpbWl0VXBkYXRlQ2hpbGRfKHNuYXAsIGtleSwgbmV3Q2hpbGQsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIExpbWl0ZWRGaWx0ZXIucHJvdG90eXBlLnVwZGF0ZUZ1bGxOb2RlID0gZnVuY3Rpb24gKG9sZFNuYXAsIG5ld1NuYXAsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XG4gICAgICAgIHZhciBmaWx0ZXJlZDtcbiAgICAgICAgaWYgKG5ld1NuYXAuaXNMZWFmTm9kZSgpIHx8IG5ld1NuYXAuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIGNoaWxkcmVuIG5vZGUgd2l0aCB0aGUgY29ycmVjdCBpbmRleCwgbm90IGEgbGVhZiBub2RlO1xuICAgICAgICAgICAgZmlsdGVyZWQgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERS53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMubGltaXRfICogMiA8IG5ld1NuYXAubnVtQ2hpbGRyZW4oKSAmJlxuICAgICAgICAgICAgICAgIG5ld1NuYXAuaXNJbmRleGVkKHRoaXMuaW5kZXhfKSkge1xuICAgICAgICAgICAgICAgIC8vIEVhc2llciB0byBidWlsZCB1cCBhIHNuYXBzaG90LCBzaW5jZSB3aGF0IHdlJ3JlIGdpdmVuIGhhcyBtb3JlIHRoYW4gdHdpY2UgdGhlIGVsZW1lbnRzIHdlIHdhbnRcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yIHRvIHRoZSBzdGFydFBvc3QsIGVuZFBvc3QsIG9yIGxhc3QgZWxlbWVudCBhcyBhcHByb3ByaWF0ZVxuICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXZlcnNlXykge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9IG5ld1NuYXAuZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbSh0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0RW5kUG9zdCgpLCB0aGlzLmluZGV4Xyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9IG5ld1NuYXAuZ2V0SXRlcmF0b3JGcm9tKHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRTdGFydFBvc3QoKSwgdGhpcy5pbmRleF8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpdGVyYXRvci5oYXNOZXh0KCkgJiYgY291bnQgPCB0aGlzLmxpbWl0Xykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGl0ZXJhdG9yLmdldE5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluUmFuZ2UgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJldmVyc2VfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpblJhbmdlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4Xy5jb21wYXJlKHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRTdGFydFBvc3QoKSwgbmV4dCkgPD0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUmFuZ2UgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhfLmNvbXBhcmUobmV4dCwgdGhpcy5yYW5nZWRGaWx0ZXJfLmdldEVuZFBvc3QoKSkgPD0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5SYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVJbW1lZGlhdGVDaGlsZChuZXh0Lm5hbWUsIG5leHQubm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSByZWFjaGVkIHRoZSBlbmQgcG9zdCwgd2UgY2Fubm90IGtlZXAgYWRkaW5nIGVsZW1tZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc25hcCBjb250YWlucyBsZXNzIHRoYW4gdHdpY2UgdGhlIGxpbWl0LiBGYXN0ZXIgdG8gZGVsZXRlIGZyb20gdGhlIHNuYXAgdGhhbiBidWlsZCB1cCBhIG5ldyBvbmVcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IG5ld1NuYXAud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQudXBkYXRlUHJpb3JpdHkoQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydFBvc3QgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGVuZFBvc3QgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGNtcCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmV2ZXJzZV8pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBmaWx0ZXJlZC5nZXRSZXZlcnNlSXRlcmF0b3IodGhpcy5pbmRleF8pO1xuICAgICAgICAgICAgICAgICAgICBzdGFydFBvc3QgPSB0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0RW5kUG9zdCgpO1xuICAgICAgICAgICAgICAgICAgICBlbmRQb3N0ID0gdGhpcy5yYW5nZWRGaWx0ZXJfLmdldFN0YXJ0UG9zdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhDb21wYXJlXzEgPSB0aGlzLmluZGV4Xy5nZXRDb21wYXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNtcCA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBpbmRleENvbXBhcmVfMShiLCBhKTsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gZmlsdGVyZWQuZ2V0SXRlcmF0b3IodGhpcy5pbmRleF8pO1xuICAgICAgICAgICAgICAgICAgICBzdGFydFBvc3QgPSB0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0U3RhcnRQb3N0KCk7XG4gICAgICAgICAgICAgICAgICAgIGVuZFBvc3QgPSB0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0RW5kUG9zdCgpO1xuICAgICAgICAgICAgICAgICAgICBjbXAgPSB0aGlzLmluZGV4Xy5nZXRDb21wYXJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGZvdW5kU3RhcnRQb3N0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGl0ZXJhdG9yLmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGl0ZXJhdG9yLmdldE5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZFN0YXJ0UG9zdCAmJiBjbXAoc3RhcnRQb3N0LCBuZXh0KSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBhZGRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kU3RhcnRQb3N0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5SYW5nZSA9IGZvdW5kU3RhcnRQb3N0ICYmIGNvdW50IDwgdGhpcy5saW1pdF8gJiYgY21wKG5leHQsIGVuZFBvc3QpIDw9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVJbW1lZGlhdGVDaGlsZChuZXh0Lm5hbWUsIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZWRGaWx0ZXJfXG4gICAgICAgICAgICAuZ2V0SW5kZXhlZEZpbHRlcigpXG4gICAgICAgICAgICAudXBkYXRlRnVsbE5vZGUob2xkU25hcCwgZmlsdGVyZWQsIG9wdENoYW5nZUFjY3VtdWxhdG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTGltaXRlZEZpbHRlci5wcm90b3R5cGUudXBkYXRlUHJpb3JpdHkgPSBmdW5jdGlvbiAob2xkU25hcCwgbmV3UHJpb3JpdHkpIHtcbiAgICAgICAgLy8gRG9uJ3Qgc3VwcG9ydCBwcmlvcml0aWVzIG9uIHF1ZXJpZXNcbiAgICAgICAgcmV0dXJuIG9sZFNuYXA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIExpbWl0ZWRGaWx0ZXIucHJvdG90eXBlLmZpbHRlcnNOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIExpbWl0ZWRGaWx0ZXIucHJvdG90eXBlLmdldEluZGV4ZWRGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0SW5kZXhlZEZpbHRlcigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBMaW1pdGVkRmlsdGVyLnByb3RvdHlwZS5nZXRJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshTm9kZX0gc25hcFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZEtleVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IGNoaWxkU25hcFxuICAgICAqIEBwYXJhbSB7IUNvbXBsZXRlQ2hpbGRTb3VyY2V9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7P0NoaWxkQ2hhbmdlQWNjdW11bGF0b3J9IGNoYW5nZUFjY3VtdWxhdG9yXG4gICAgICogQHJldHVybiB7IU5vZGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBMaW1pdGVkRmlsdGVyLnByb3RvdHlwZS5mdWxsTGltaXRVcGRhdGVDaGlsZF8gPSBmdW5jdGlvbiAoc25hcCwgY2hpbGRLZXksIGNoaWxkU25hcCwgc291cmNlLCBjaGFuZ2VBY2N1bXVsYXRvcikge1xuICAgICAgICAvLyBUT0RPOiByZW5hbWUgYWxsIGNhY2hlIHN0dWZmIGV0YyB0byBnZW5lcmFsIHNuYXAgdGVybWlub2xvZ3lcbiAgICAgICAgdmFyIGNtcDtcbiAgICAgICAgaWYgKHRoaXMucmV2ZXJzZV8pIHtcbiAgICAgICAgICAgIHZhciBpbmRleENtcF8xID0gdGhpcy5pbmRleF8uZ2V0Q29tcGFyZSgpO1xuICAgICAgICAgICAgY21wID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGluZGV4Q21wXzEoYiwgYSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbXAgPSB0aGlzLmluZGV4Xy5nZXRDb21wYXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9sZEV2ZW50Q2FjaGUgPSBzbmFwO1xuICAgICAgICBhc3NlcnQob2xkRXZlbnRDYWNoZS5udW1DaGlsZHJlbigpID09IHRoaXMubGltaXRfLCAnJyk7XG4gICAgICAgIHZhciBuZXdDaGlsZE5hbWVkTm9kZSA9IG5ldyBOYW1lZE5vZGUoY2hpbGRLZXksIGNoaWxkU25hcCk7XG4gICAgICAgIHZhciB3aW5kb3dCb3VuZGFyeSA9IHRoaXMucmV2ZXJzZV9cbiAgICAgICAgICAgID8gb2xkRXZlbnRDYWNoZS5nZXRGaXJzdENoaWxkKHRoaXMuaW5kZXhfKVxuICAgICAgICAgICAgOiBvbGRFdmVudENhY2hlLmdldExhc3RDaGlsZCh0aGlzLmluZGV4Xyk7XG4gICAgICAgIHZhciBpblJhbmdlID0gdGhpcy5yYW5nZWRGaWx0ZXJfLm1hdGNoZXMobmV3Q2hpbGROYW1lZE5vZGUpO1xuICAgICAgICBpZiAob2xkRXZlbnRDYWNoZS5oYXNDaGlsZChjaGlsZEtleSkpIHtcbiAgICAgICAgICAgIHZhciBvbGRDaGlsZFNuYXAgPSBvbGRFdmVudENhY2hlLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcbiAgICAgICAgICAgIHZhciBuZXh0Q2hpbGQgPSBzb3VyY2UuZ2V0Q2hpbGRBZnRlckNoaWxkKHRoaXMuaW5kZXhfLCB3aW5kb3dCb3VuZGFyeSwgdGhpcy5yZXZlcnNlXyk7XG4gICAgICAgICAgICB3aGlsZSAobmV4dENoaWxkICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAobmV4dENoaWxkLm5hbWUgPT0gY2hpbGRLZXkgfHwgb2xkRXZlbnRDYWNoZS5oYXNDaGlsZChuZXh0Q2hpbGQubmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSB3ZWlyZCBlZGdlIGNhc2Ugd2hlcmUgYSBub2RlIGlzIHVwZGF0ZWQgYXMgcGFydCBvZiBhIG1lcmdlIGluIHRoZSB3cml0ZSB0cmVlLCBidXQgaGFzbid0XG4gICAgICAgICAgICAgICAgLy8gYmVlbiBhcHBsaWVkIHRvIHRoZSBsaW1pdGVkIGZpbHRlciB5ZXQuIElnbm9yZSB0aGlzIG5leHQgY2hpbGQgd2hpY2ggd2lsbCBiZSB1cGRhdGVkIGxhdGVyIGluXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxpbWl0ZWQgZmlsdGVyLi4uXG4gICAgICAgICAgICAgICAgbmV4dENoaWxkID0gc291cmNlLmdldENoaWxkQWZ0ZXJDaGlsZCh0aGlzLmluZGV4XywgbmV4dENoaWxkLCB0aGlzLnJldmVyc2VfKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb21wYXJlTmV4dCA9IG5leHRDaGlsZCA9PSBudWxsID8gMSA6IGNtcChuZXh0Q2hpbGQsIG5ld0NoaWxkTmFtZWROb2RlKTtcbiAgICAgICAgICAgIHZhciByZW1haW5zSW5XaW5kb3cgPSBpblJhbmdlICYmICFjaGlsZFNuYXAuaXNFbXB0eSgpICYmIGNvbXBhcmVOZXh0ID49IDA7XG4gICAgICAgICAgICBpZiAocmVtYWluc0luV2luZG93KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZUFjY3VtdWxhdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShDaGFuZ2UuY2hpbGRDaGFuZ2VkQ2hhbmdlKGNoaWxkS2V5LCBjaGlsZFNuYXAsIG9sZENoaWxkU25hcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkRXZlbnRDYWNoZS51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZEtleSwgY2hpbGRTbmFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoQ2hhbmdlLmNoaWxkUmVtb3ZlZENoYW5nZShjaGlsZEtleSwgb2xkQ2hpbGRTbmFwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuZXdFdmVudENhY2hlID0gb2xkRXZlbnRDYWNoZS51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZEtleSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0Q2hpbGRJblJhbmdlID0gbmV4dENoaWxkICE9IG51bGwgJiYgdGhpcy5yYW5nZWRGaWx0ZXJfLm1hdGNoZXMobmV4dENoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dENoaWxkSW5SYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShDaGFuZ2UuY2hpbGRBZGRlZENoYW5nZShuZXh0Q2hpbGQubmFtZSwgbmV4dENoaWxkLm5vZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3RXZlbnRDYWNoZS51cGRhdGVJbW1lZGlhdGVDaGlsZChuZXh0Q2hpbGQubmFtZSwgbmV4dENoaWxkLm5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0V2ZW50Q2FjaGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkU25hcC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIC8vIHdlJ3JlIGRlbGV0aW5nIGEgbm9kZSwgYnV0IGl0IHdhcyBub3QgaW4gdGhlIHdpbmRvdywgc28gaWdub3JlIGl0XG4gICAgICAgICAgICByZXR1cm4gc25hcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpblJhbmdlKSB7XG4gICAgICAgICAgICBpZiAoY21wKHdpbmRvd0JvdW5kYXJ5LCBuZXdDaGlsZE5hbWVkTm9kZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoQ2hhbmdlLmNoaWxkUmVtb3ZlZENoYW5nZSh3aW5kb3dCb3VuZGFyeS5uYW1lLCB3aW5kb3dCb3VuZGFyeS5ub2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoQ2hhbmdlLmNoaWxkQWRkZWRDaGFuZ2UoY2hpbGRLZXksIGNoaWxkU25hcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkRXZlbnRDYWNoZVxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXksIGNoaWxkU25hcClcbiAgICAgICAgICAgICAgICAgICAgLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKHdpbmRvd0JvdW5kYXJ5Lm5hbWUsIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzbmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNuYXA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBMaW1pdGVkRmlsdGVyO1xufSgpKTtcbmV4cG9ydCB7IExpbWl0ZWRGaWx0ZXIgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9zcmMvY29yZS92aWV3L2ZpbHRlci9MaW1pdGVkRmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IEJyb3dzZXJQb2xsQ29ubmVjdGlvbiB9IGZyb20gJy4vQnJvd3NlclBvbGxDb25uZWN0aW9uJztcbmltcG9ydCB7IFdlYlNvY2tldENvbm5lY3Rpb24gfSBmcm9tICcuL1dlYlNvY2tldENvbm5lY3Rpb24nO1xuaW1wb3J0IHsgd2FybiwgZWFjaCB9IGZyb20gJy4uL2NvcmUvdXRpbC91dGlsJztcbi8qKlxuICogQ3VycmVudGx5IHNpbXBsaXN0aWMsIHRoaXMgY2xhc3MgbWFuYWdlcyB3aGF0IHRyYW5zcG9ydCBhIENvbm5lY3Rpb24gc2hvdWxkIHVzZSBhdCB2YXJpb3VzIHN0YWdlcyBvZiBpdHNcbiAqIGxpZmVjeWNsZS5cbiAqXG4gKiBJdCBzdGFydHMgd2l0aCBsb25ncG9sbGluZyBpbiBhIGJyb3dzZXIsIGFuZCBodHRwcG9sbGluZyBvbiBub2RlLiBJdCB0aGVuIHVwZ3JhZGVzIHRvIHdlYnNvY2tldHMgaWZcbiAqIHRoZXkgYXJlIGF2YWlsYWJsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgVHJhbnNwb3J0TWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFSZXBvSW5mb30gcmVwb0luZm8gTWV0YWRhdGEgYXJvdW5kIHRoZSBuYW1lc3BhY2Ugd2UncmUgY29ubmVjdGluZyB0b1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyYW5zcG9ydE1hbmFnZXIocmVwb0luZm8pIHtcbiAgICAgICAgdGhpcy5pbml0VHJhbnNwb3J0c18ocmVwb0luZm8pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNwb3J0TWFuYWdlciwgXCJBTExfVFJBTlNQT1JUU1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY29uc3RcbiAgICAgICAgICogQHR5cGUgeyFBcnJheS48ZnVuY3Rpb24obmV3OlRyYW5zcG9ydCwgc3RyaW5nLCBSZXBvSW5mbywgc3RyaW5nPSk+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gW0Jyb3dzZXJQb2xsQ29ubmVjdGlvbiwgV2ViU29ja2V0Q29ubmVjdGlvbl07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVJlcG9JbmZvfSByZXBvSW5mb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVHJhbnNwb3J0TWFuYWdlci5wcm90b3R5cGUuaW5pdFRyYW5zcG9ydHNfID0gZnVuY3Rpb24gKHJlcG9JbmZvKSB7XG4gICAgICAgIHZhciBpc1dlYlNvY2tldHNBdmFpbGFibGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uICYmIFdlYlNvY2tldENvbm5lY3Rpb25bJ2lzQXZhaWxhYmxlJ10oKTtcbiAgICAgICAgdmFyIGlzU2tpcFBvbGxDb25uZWN0aW9uID0gaXNXZWJTb2NrZXRzQXZhaWxhYmxlICYmICFXZWJTb2NrZXRDb25uZWN0aW9uLnByZXZpb3VzbHlGYWlsZWQoKTtcbiAgICAgICAgaWYgKHJlcG9JbmZvLndlYlNvY2tldE9ubHkpIHtcbiAgICAgICAgICAgIGlmICghaXNXZWJTb2NrZXRzQXZhaWxhYmxlKVxuICAgICAgICAgICAgICAgIHdhcm4oXCJ3c3M6Ly8gVVJMIHVzZWQsIGJ1dCBicm93c2VyIGlzbid0IGtub3duIHRvIHN1cHBvcnQgd2Vic29ja2V0cy4gIFRyeWluZyBhbnl3YXkuXCIpO1xuICAgICAgICAgICAgaXNTa2lwUG9sbENvbm5lY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NraXBQb2xsQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnRzXyA9IFtXZWJTb2NrZXRDb25uZWN0aW9uXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0cmFuc3BvcnRzXzEgPSAodGhpcy50cmFuc3BvcnRzXyA9IFtdKTtcbiAgICAgICAgICAgIGVhY2goVHJhbnNwb3J0TWFuYWdlci5BTExfVFJBTlNQT1JUUywgZnVuY3Rpb24gKGksIHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc3BvcnQgJiYgdHJhbnNwb3J0Wydpc0F2YWlsYWJsZSddKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0c18xLnB1c2godHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb24obmV3OlRyYW5zcG9ydCwgIXN0cmluZywgIVJlcG9JbmZvLCBzdHJpbmc9LCBzdHJpbmc9KX0gVGhlIGNvbnN0cnVjdG9yIGZvciB0aGVcbiAgICAgKiBpbml0aWFsIHRyYW5zcG9ydCB0byB1c2VcbiAgICAgKi9cbiAgICBUcmFuc3BvcnRNYW5hZ2VyLnByb3RvdHlwZS5pbml0aWFsVHJhbnNwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnRzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRzX1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P2Z1bmN0aW9uKG5ldzpUcmFuc3BvcnQsIGZ1bmN0aW9uKCksZnVuY3Rpb24oKSwgc3RyaW5nPSl9IFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIG5leHRcbiAgICAgKiB0cmFuc3BvcnQsIG9yIG51bGxcbiAgICAgKi9cbiAgICBUcmFuc3BvcnRNYW5hZ2VyLnByb3RvdHlwZS51cGdyYWRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnRzXy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRzX1sxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVHJhbnNwb3J0TWFuYWdlcjtcbn0oKSk7XG5leHBvcnQgeyBUcmFuc3BvcnRNYW5hZ2VyIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9lc20vc3JjL3JlYWx0aW1lL1RyYW5zcG9ydE1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgZXhjZXB0aW9uR3VhcmQgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWwvdXRpbCc7XG4vKipcbiAqIFRoaXMgY2xhc3MgZW5zdXJlcyB0aGUgcGFja2V0cyBmcm9tIHRoZSBzZXJ2ZXIgYXJyaXZlIGluIG9yZGVyXG4gKiBUaGlzIGNsYXNzIHRha2VzIGRhdGEgZnJvbSB0aGUgc2VydmVyIGFuZCBlbnN1cmVzIGl0IGdldHMgcGFzc2VkIGludG8gdGhlIGNhbGxiYWNrcyBpbiBvcmRlci5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUGFja2V0UmVjZWl2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9uTWVzc2FnZV9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYWNrZXRSZWNlaXZlcihvbk1lc3NhZ2VfKSB7XG4gICAgICAgIHRoaXMub25NZXNzYWdlXyA9IG9uTWVzc2FnZV87XG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRSZXNwb25zZU51bSA9IDA7XG4gICAgICAgIHRoaXMuY2xvc2VBZnRlclJlc3BvbnNlID0gLTE7XG4gICAgICAgIHRoaXMub25DbG9zZSA9IG51bGw7XG4gICAgfVxuICAgIFBhY2tldFJlY2VpdmVyLnByb3RvdHlwZS5jbG9zZUFmdGVyID0gZnVuY3Rpb24gKHJlc3BvbnNlTnVtLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSA9IHJlc3BvbnNlTnVtO1xuICAgICAgICB0aGlzLm9uQ2xvc2UgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VBZnRlclJlc3BvbnNlIDwgdGhpcy5jdXJyZW50UmVzcG9uc2VOdW0pIHtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRWFjaCBtZXNzYWdlIGZyb20gdGhlIHNlcnZlciBjb21lcyB3aXRoIGEgcmVzcG9uc2UgbnVtYmVyLCBhbmQgYW4gYXJyYXkgb2YgZGF0YS4gVGhlIHJlc3BvbnNlTnVtYmVyXG4gICAgICogYWxsb3dzIHVzIHRvIGVuc3VyZSB0aGF0IHdlIHByb2Nlc3MgdGhlbSBpbiB0aGUgcmlnaHQgb3JkZXIsIHNpbmNlIHdlIGNhbid0IGJlIGd1YXJhbnRlZWQgdGhhdCBhbGxcbiAgICAgKiBicm93c2VycyB3aWxsIHJlc3BvbmQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHJlcXVlc3RzIHdlIHNlbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVxdWVzdE51bVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGFcbiAgICAgKi9cbiAgICBQYWNrZXRSZWNlaXZlci5wcm90b3R5cGUuaGFuZGxlUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVxdWVzdE51bSwgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXNbcmVxdWVzdE51bV0gPSBkYXRhO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b1Byb2Nlc3MgPSB0aGlzXzEucGVuZGluZ1Jlc3BvbnNlc1t0aGlzXzEuY3VycmVudFJlc3BvbnNlTnVtXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzXzEucGVuZGluZ1Jlc3BvbnNlc1t0aGlzXzEuY3VycmVudFJlc3BvbnNlTnVtXTtcbiAgICAgICAgICAgIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9Qcm9jZXNzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbkd1YXJkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uTWVzc2FnZV8odG9Qcm9jZXNzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9Qcm9jZXNzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgX2xvb3BfMihpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzXzEuY3VycmVudFJlc3BvbnNlTnVtID09PSB0aGlzXzEuY2xvc2VBZnRlclJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNfMS5vbkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNfMS5vbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNfMS5vbkNsb3NlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNfMS5jdXJyZW50UmVzcG9uc2VOdW0rKztcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh0aGlzLnBlbmRpbmdSZXNwb25zZXNbdGhpcy5jdXJyZW50UmVzcG9uc2VOdW1dKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzEoKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZV8xID09PSBcImJyZWFrXCIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQYWNrZXRSZWNlaXZlcjtcbn0oKSk7XG5leHBvcnQgeyBQYWNrZXRSZWNlaXZlciB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL3NyYy9yZWFsdGltZS9wb2xsaW5nL1BhY2tldFJlY2VpdmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCAnLi9zcmMvcG9seWZpbGxzL3Byb21pc2UnO1xuaW1wb3J0ICcuL3NyYy9zaGltcy9maW5kJztcbmltcG9ydCAnLi9zcmMvc2hpbXMvZmluZEluZGV4JztcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9wb2x5ZmlsbC9kaXN0L2VzbS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19nbG9iYWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QnKTtcbn0pKCk7XG4vLyBQb2x5ZmlsbCBQcm9taXNlXG5pZiAodHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gSEFDSzogVFMgdGhyb3dzIGFuIGVycm9yIGlmIEkgYXR0ZW1wdCB0byB1c2UgJ2RvdC1ub3RhdGlvbidcbiAgICBfX2dsb2JhbFsnUHJvbWlzZSddID0gUHJvbWlzZSA9IHJlcXVpcmUoJ3Byb21pc2UtcG9seWZpbGwnKTtcbn1cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS9wb2x5ZmlsbC9kaXN0L2VzbS9zcmMvcG9seWZpbGxzL3Byb21pc2UuanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGlzIGlzIHRoZSBBcnJheS5wcm90b3R5cGUuZmluZCBwb2x5ZmlsbCBmcm9tIE1ETlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmluZFxuICogaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRcbiAqL1xuaWYgKCFBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsICdmaW5kJywge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgLy8gMS4gTGV0IE8gYmUgPyBUb09iamVjdCh0aGlzIHZhbHVlKS5cbiAgICAgICAgICAgIGlmICh0aGlzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInRoaXNcIiBpcyBudWxsIG9yIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbyA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIC8vIDIuIExldCBsZW4gYmUgPyBUb0xlbmd0aCg/IEdldChPLCBcImxlbmd0aFwiKSkuXG4gICAgICAgICAgICB2YXIgbGVuID0gby5sZW5ndGggPj4+IDA7XG4gICAgICAgICAgICAvLyAzLiBJZiBJc0NhbGxhYmxlKHByZWRpY2F0ZSkgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gNC4gSWYgdGhpc0FyZyB3YXMgc3VwcGxpZWQsIGxldCBUIGJlIHRoaXNBcmc7IGVsc2UgbGV0IFQgYmUgdW5kZWZpbmVkLlxuICAgICAgICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAvLyA1LiBMZXQgayBiZSAwLlxuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgLy8gNi4gUmVwZWF0LCB3aGlsZSBrIDwgbGVuXG4gICAgICAgICAgICB3aGlsZSAoayA8IGxlbikge1xuICAgICAgICAgICAgICAgIC8vIGEuIExldCBQayBiZSAhIFRvU3RyaW5nKGspLlxuICAgICAgICAgICAgICAgIC8vIGIuIExldCBrVmFsdWUgYmUgPyBHZXQoTywgUGspLlxuICAgICAgICAgICAgICAgIC8vIGMuIExldCB0ZXN0UmVzdWx0IGJlIFRvQm9vbGVhbig/IENhbGwocHJlZGljYXRlLCBULCDCqyBrVmFsdWUsIGssIE8gwrspKS5cbiAgICAgICAgICAgICAgICAvLyBkLiBJZiB0ZXN0UmVzdWx0IGlzIHRydWUsIHJldHVybiBrVmFsdWUuXG4gICAgICAgICAgICAgICAgdmFyIGtWYWx1ZSA9IG9ba107XG4gICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIGtWYWx1ZSwgaywgbykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZS4gSW5jcmVhc2UgayBieSAxLlxuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDcuIFJldHVybiB1bmRlZmluZWQuXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvcG9seWZpbGwvZGlzdC9lc20vc3JjL3NoaW1zL2ZpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGlzIGlzIHRoZSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4IHBvbHlmaWxsIGZyb20gTUROXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maW5kSW5kZXhcbiAqIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhcbiAqL1xuaWYgKCFBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgJ2ZpbmRJbmRleCcsIHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIC8vIDEuIExldCBPIGJlID8gVG9PYmplY3QodGhpcyB2YWx1ZSkuXG4gICAgICAgICAgICBpZiAodGhpcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ0aGlzXCIgaXMgbnVsbCBvciBub3QgZGVmaW5lZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG8gPSBPYmplY3QodGhpcyk7XG4gICAgICAgICAgICAvLyAyLiBMZXQgbGVuIGJlID8gVG9MZW5ndGgoPyBHZXQoTywgXCJsZW5ndGhcIikpLlxuICAgICAgICAgICAgdmFyIGxlbiA9IG8ubGVuZ3RoID4+PiAwO1xuICAgICAgICAgICAgLy8gMy4gSWYgSXNDYWxsYWJsZShwcmVkaWNhdGUpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ByZWRpY2F0ZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDQuIElmIHRoaXNBcmcgd2FzIHN1cHBsaWVkLCBsZXQgVCBiZSB0aGlzQXJnOyBlbHNlIGxldCBUIGJlIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgLy8gNS4gTGV0IGsgYmUgMC5cbiAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgIC8vIDYuIFJlcGVhdCwgd2hpbGUgayA8IGxlblxuICAgICAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBhLiBMZXQgUGsgYmUgISBUb1N0cmluZyhrKS5cbiAgICAgICAgICAgICAgICAvLyBiLiBMZXQga1ZhbHVlIGJlID8gR2V0KE8sIFBrKS5cbiAgICAgICAgICAgICAgICAvLyBjLiBMZXQgdGVzdFJlc3VsdCBiZSBUb0Jvb2xlYW4oPyBDYWxsKHByZWRpY2F0ZSwgVCwgwqsga1ZhbHVlLCBrLCBPIMK7KSkuXG4gICAgICAgICAgICAgICAgLy8gZC4gSWYgdGVzdFJlc3VsdCBpcyB0cnVlLCByZXR1cm4gay5cbiAgICAgICAgICAgICAgICB2YXIga1ZhbHVlID0gb1trXTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywga1ZhbHVlLCBrLCBvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZS4gSW5jcmVhc2UgayBieSAxLlxuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDcuIFJldHVybiAtMS5cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL3BvbHlmaWxsL2Rpc3QvZXNtL3NyYy9zaGltcy9maW5kSW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEbyBhIGRlZXAtY29weSBvZiBiYXNpYyBKYXZhU2NyaXB0IE9iamVjdHMgb3IgQXJyYXlzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcENvcHkodmFsdWUpIHtcbiAgICByZXR1cm4gZGVlcEV4dGVuZCh1bmRlZmluZWQsIHZhbHVlKTtcbn1cbi8qKlxuICogQ29weSBwcm9wZXJ0aWVzIGZyb20gc291cmNlIHRvIHRhcmdldCAocmVjdXJzaXZlbHkgYWxsb3dzIGV4dGVuc2lvblxuICogb2YgT2JqZWN0cyBhbmQgQXJyYXlzKS4gIFNjYWxhciB2YWx1ZXMgaW4gdGhlIHRhcmdldCBhcmUgb3Zlci13cml0dGVuLlxuICogSWYgdGFyZ2V0IGlzIHVuZGVmaW5lZCwgYW4gb2JqZWN0IG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlIHdpbGwgYmUgY3JlYXRlZFxuICogKGFuZCByZXR1cm5lZCkuXG4gKlxuICogV2UgcmVjdXJzaXZlbHkgY29weSBhbGwgY2hpbGQgcHJvcGVydGllcyBvZiBwbGFpbiBPYmplY3RzIGluIHRoZSBzb3VyY2UtIHNvXG4gKiB0aGF0IG5hbWVzcGFjZS0gbGlrZSBkaWN0aW9uYXJpZXMgYXJlIG1lcmdlZC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIHRhcmdldCBjYW4gYmUgYSBmdW5jdGlvbiwgaW4gd2hpY2ggY2FzZSB0aGUgcHJvcGVydGllcyBpblxuICogdGhlIHNvdXJjZSBPYmplY3QgYXJlIGNvcGllZCBvbnRvIGl0IGFzIHN0YXRpYyBwcm9wZXJ0aWVzIG9mIHRoZSBGdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBFeHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuICAgIHN3aXRjaCAoc291cmNlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgRGF0ZTpcbiAgICAgICAgICAgIC8vIFRyZWF0IERhdGVzIGxpa2Ugc2NhbGFyczsgaWYgdGhlIHRhcmdldCBkYXRlIG9iamVjdCBoYWQgYW55IGNoaWxkXG4gICAgICAgICAgICAvLyBwcm9wZXJ0aWVzIC0gdGhleSB3aWxsIGJlIGxvc3QhXG4gICAgICAgICAgICB2YXIgZGF0ZVZhbHVlID0gc291cmNlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGVWYWx1ZS5nZXRUaW1lKCkpO1xuICAgICAgICBjYXNlIE9iamVjdDpcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQXJyYXk6XG4gICAgICAgICAgICAvLyBBbHdheXMgY29weSB0aGUgYXJyYXkgc291cmNlIGFuZCBvdmVyd3JpdGUgdGhlIHRhcmdldC5cbiAgICAgICAgICAgIHRhcmdldCA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBOb3QgYSBwbGFpbiBPYmplY3QgLSB0cmVhdCBpdCBhcyBhIHNjYWxhci5cbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGlmICghc291cmNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBkZWVwRXh0ZW5kKHRhcmdldFtwcm9wXSwgc291cmNlW3Byb3BdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbi8vIFRPRE86IFJlYWxseSBuZWVkZWQgKGZvciBKU0NvbXBpbGVyIHR5cGUgY2hlY2tpbmcpP1xuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoUHJvcGVydHkob2JqLCBwcm9wLCB2YWx1ZSkge1xuICAgIG9ialtwcm9wXSA9IHZhbHVlO1xufVxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL3V0aWwvZGlzdC9lc20vc3JjL2RlZXBDb3B5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBEZWZlcnJlZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZlcnJlZCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgX3RoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBfdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAqIE91ciBBUEkgaW50ZXJuYWxzIGFyZSBub3QgcHJvbWlzZWlmaWVkIGFuZCBjYW5ub3QgYmVjYXVzZSBvdXIgY2FsbGJhY2sgQVBJcyBoYXZlIHN1YnRsZSBleHBlY3RhdGlvbnMgYXJvdW5kXG4gICAgKiBpbnZva2luZyBwcm9taXNlcyBpbmxpbmUsIHdoaWNoIFByb21pc2VzIGFyZSBmb3JiaWRkZW4gdG8gZG8uIFRoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9uYWwgbm9kZS1zdHlsZSBjYWxsYmFja1xuICAgICogYW5kIHJldHVybnMgYSBub2RlLXN0eWxlIGNhbGxiYWNrIHdoaWNoIHdpbGwgcmVzb2x2ZSBvciByZWplY3QgdGhlIERlZmVycmVkJ3MgcHJvbWlzZS5cbiAgICAqIEBwYXJhbSB7KCg/ZnVuY3Rpb24oPyhFcnJvcikpOiAoP3x1bmRlZmluZWQpKXwgKD9mdW5jdGlvbig/KEVycm9yKSw/PSk6ICg/fHVuZGVmaW5lZCkpKT19IGNhbGxiYWNrXG4gICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oPyhFcnJvciksID89KX1cbiAgICAqL1xuICAgIERlZmVycmVkLnByb3RvdHlwZS53cmFwQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvciwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBBdHRhY2hpbmcgbm9vcCBoYW5kbGVyIGp1c3QgaW4gY2FzZSBkZXZlbG9wZXIgd2Fzbid0IGV4cGVjdGluZ1xuICAgICAgICAgICAgICAgIC8vIHByb21pc2VzXG4gICAgICAgICAgICAgICAgX3RoaXMucHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgICAgIC8vIFNvbWUgb2Ygb3VyIGNhbGxiYWNrcyBkb24ndCBleHBlY3QgYSB2YWx1ZSBhbmQgb3VyIG93biB0ZXN0c1xuICAgICAgICAgICAgICAgIC8vIGFzc2VydCB0aGF0IHRoZSBwYXJhbWV0ZXIgbGVuZ3RoIGlzIDFcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIERlZmVycmVkO1xufSgpKTtcbmV4cG9ydCB7IERlZmVycmVkIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvdXRpbC9kaXN0L2VzbS9zcmMvZGVmZXJyZWQuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgQ09OU1RBTlRTIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuLyoqXG4gKiBSZXR1cm5zIG5hdmlnYXRvci51c2VyQWdlbnQgc3RyaW5nIG9yICcnIGlmIGl0J3Mgbm90IGRlZmluZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHVzZXIgYWdlbnQgc3RyaW5nXG4gKi9cbmV4cG9ydCB2YXIgZ2V0VUEgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3JbJ3VzZXJBZ2VudCddID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yWyd1c2VyQWdlbnQnXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59O1xuLyoqXG4gKiBEZXRlY3QgQ29yZG92YSAvIFBob25lR2FwIC8gSW9uaWMgZnJhbWV3b3JrcyBvbiBhIG1vYmlsZSBkZXZpY2UuXG4gKlxuICogRGVsaWJlcmF0ZWx5IGRvZXMgbm90IHJlbHkgb24gY2hlY2tpbmcgYGZpbGU6Ly9gIFVSTHMgKGFzIHRoaXMgZmFpbHMgUGhvbmVHYXAgaW4gdGhlIFJpcHBsZSBlbXVsYXRvcikgbm9yXG4gKiBDb3Jkb3ZhIGBvbkRldmljZVJlYWR5YCwgd2hpY2ggd291bGQgbm9ybWFsbHkgd2FpdCBmb3IgYSBjYWxsYmFjay5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBpc01vYmlsZUNvcmRvdmFcbiAqL1xuZXhwb3J0IHZhciBpc01vYmlsZUNvcmRvdmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAhISh3aW5kb3dbJ2NvcmRvdmEnXSB8fCB3aW5kb3dbJ3Bob25lZ2FwJ10gfHwgd2luZG93WydQaG9uZUdhcCddKSAmJlxuICAgICAgICAvaW9zfGlwaG9uZXxpcG9kfGlwYWR8YW5kcm9pZHxibGFja2JlcnJ5fGllbW9iaWxlL2kudGVzdChnZXRVQSgpKSk7XG59O1xuLyoqXG4gKiBEZXRlY3QgUmVhY3QgTmF0aXZlLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgUmVhY3ROYXRpdmUgZW52aXJvbm1lbnQgaXMgZGV0ZWN0ZWQuXG4gKi9cbmV4cG9ydCB2YXIgaXNSZWFjdE5hdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIG5hdmlnYXRvclsncHJvZHVjdCddID09PSAnUmVhY3ROYXRpdmUnKTtcbn07XG4vKipcbiAqIERldGVjdCBOb2RlLmpzLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgTm9kZS5qcyBlbnZpcm9ubWVudCBpcyBkZXRlY3RlZC5cbiAqL1xuZXhwb3J0IHZhciBpc05vZGVTZGsgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIENPTlNUQU5UUy5OT0RFX0NMSUVOVCA9PT0gdHJ1ZSB8fCBDT05TVEFOVFMuTk9ERV9BRE1JTiA9PT0gdHJ1ZTtcbn07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvdXRpbC9kaXN0L2VzbS9zcmMvZW52aXJvbm1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRVJST1JfTkFNRSA9ICdGaXJlYmFzZUVycm9yJztcbnZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IEVycm9yXG4gICAgLmNhcHR1cmVTdGFja1RyYWNlO1xuLy8gRXhwb3J0IGZvciBmYWtpbmcgaW4gdGVzdHNcbmV4cG9ydCBmdW5jdGlvbiBwYXRjaENhcHR1cmUoY2FwdHVyZUZha2UpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2FwdHVyZVN0YWNrVHJhY2U7XG4gICAgY2FwdHVyZVN0YWNrVHJhY2UgPSBjYXB0dXJlRmFrZTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxudmFyIEZpcmViYXNlRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmlyZWJhc2VFcnJvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHZhciBzdGFjaztcbiAgICAgICAgLy8gV2Ugd2FudCB0aGUgc3RhY2sgdmFsdWUsIGlmIGltcGxlbWVudGVkIGJ5IEVycm9yXG4gICAgICAgIGlmIChjYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgLy8gUGF0Y2hlcyB0aGlzLnN0YWNrLCBvbWl0dGVkIGNhbGxzIGFib3ZlIEVycm9yRmFjdG9yeSNjcmVhdGVcbiAgICAgICAgICAgIGNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEVycm9yRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlcnJfMSA9IEVycm9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBFUlJPUl9OQU1FO1xuICAgICAgICAgICAgLy8gTWFrZSBub24tZW51bWVyYWJsZSBnZXR0ZXIgZm9yIHRoZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RhY2snLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJfMS5zdGFjaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRmlyZWJhc2VFcnJvcjtcbn0oKSk7XG5leHBvcnQgeyBGaXJlYmFzZUVycm9yIH07XG4vLyBCYWNrLWRvb3IgaW5oZXJpdGFuY2VcbkZpcmViYXNlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuRmlyZWJhc2VFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGaXJlYmFzZUVycm9yO1xuRmlyZWJhc2VFcnJvci5wcm90b3R5cGUubmFtZSA9IEVSUk9SX05BTUU7XG52YXIgRXJyb3JGYWN0b3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVycm9yRmFjdG9yeShzZXJ2aWNlLCBzZXJ2aWNlTmFtZSwgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIHRoaXMuc2VydmljZU5hbWUgPSBzZXJ2aWNlTmFtZTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIC8vIE1hdGNoZXMgeyRuYW1lfSwgYnkgZGVmYXVsdC5cbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gL1xce1xcJChbXn1dKyl9L2c7XG4gICAgICAgIC8vIGVtcHR5XG4gICAgfVxuICAgIEVycm9yRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGNvZGUsIGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMuZXJyb3JzW2NvZGVdO1xuICAgICAgICB2YXIgZnVsbENvZGUgPSB0aGlzLnNlcnZpY2UgKyAnLycgKyBjb2RlO1xuICAgICAgICB2YXIgbWVzc2FnZTtcbiAgICAgICAgaWYgKHRlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnRXJyb3InO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRlbXBsYXRlLnJlcGxhY2UodGhpcy5wYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2gsIGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlLnRvU3RyaW5nKCkgOiAnPCcgKyBrZXkgKyAnPz4nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VydmljZTogRXJyb3IgbWVzc2FnZSAoc2VydmljZS9jb2RlKS5cbiAgICAgICAgbWVzc2FnZSA9IHRoaXMuc2VydmljZU5hbWUgKyAnOiAnICsgbWVzc2FnZSArICcgKCcgKyBmdWxsQ29kZSArICcpLic7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRmlyZWJhc2VFcnJvcihmdWxsQ29kZSwgbWVzc2FnZSk7XG4gICAgICAgIC8vIFBvcHVsYXRlIHRoZSBFcnJvciBvYmplY3Qgd2l0aCBtZXNzYWdlIHBhcnRzIGZvciBwcm9ncmFtbWF0aWNcbiAgICAgICAgLy8gYWNjZXNzZXMgKGUuZy4sIGUuZmlsZSkuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFkYXRhLmhhc093blByb3BlcnR5KHByb3ApIHx8IHByb3Auc2xpY2UoLTEpID09PSAnXycpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycltwcm9wXSA9IGRhdGFbcHJvcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9O1xuICAgIHJldHVybiBFcnJvckZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0IHsgRXJyb3JGYWN0b3J5IH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvdXRpbC9kaXN0L2VzbS9zcmMvZXJyb3JzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEFic3RyYWN0IGNyeXB0b2dyYXBoaWMgaGFzaCBpbnRlcmZhY2UuXG4gKlxuICogU2VlIFNoYTEgYW5kIE1kNSBmb3Igc2FtcGxlIGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKi9cbi8qKlxuICogQ3JlYXRlIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGluc3RhbmNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHN0cnVjdFxuICovXG52YXIgSGFzaCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIYXNoKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJsb2NrIHNpemUgZm9yIHRoZSBoYXNoZXIuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJsb2NrU2l6ZSA9IC0xO1xuICAgIH1cbiAgICByZXR1cm4gSGFzaDtcbn0oKSk7XG5leHBvcnQgeyBIYXNoIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvdXRpbC9kaXN0L2VzbS9zcmMvaGFzaC5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBiYXNlNjREZWNvZGUgfSBmcm9tICcuL2NyeXB0JztcbmltcG9ydCB7IGpzb25FdmFsIH0gZnJvbSAnLi9qc29uJztcbi8qKlxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGludG8gY29uc3RpdHVlbnQgcGFydHMuXG4gKlxuICogTm90ZXM6XG4gKiAtIE1heSByZXR1cm4gd2l0aCBpbnZhbGlkIC8gaW5jb21wbGV0ZSBjbGFpbXMgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7P3N0cmluZ30gdG9rZW5cbiAqIEByZXR1cm4ge3toZWFkZXI6ICosIGNsYWltczogKiwgZGF0YTogKiwgc2lnbmF0dXJlOiBzdHJpbmd9fVxuICovXG5leHBvcnQgdmFyIGRlY29kZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIHZhciBoZWFkZXIgPSB7fSwgY2xhaW1zID0ge30sIGRhdGEgPSB7fSwgc2lnbmF0dXJlID0gJyc7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICAgICAgaGVhZGVyID0ganNvbkV2YWwoYmFzZTY0RGVjb2RlKHBhcnRzWzBdKSB8fCAnJyk7XG4gICAgICAgIGNsYWltcyA9IGpzb25FdmFsKGJhc2U2NERlY29kZShwYXJ0c1sxXSkgfHwgJycpO1xuICAgICAgICBzaWduYXR1cmUgPSBwYXJ0c1syXTtcbiAgICAgICAgZGF0YSA9IGNsYWltc1snZCddIHx8IHt9O1xuICAgICAgICBkZWxldGUgY2xhaW1zWydkJ107XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICByZXR1cm4ge1xuICAgICAgICBoZWFkZXI6IGhlYWRlcixcbiAgICAgICAgY2xhaW1zOiBjbGFpbXMsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlXG4gICAgfTtcbn07XG4vKipcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgY2hlY2tzIHRoZSB2YWxpZGl0eSBvZiBpdHMgdGltZS1iYXNlZCBjbGFpbXMuIFdpbGwgcmV0dXJuIHRydWUgaWYgdGhlXG4gKiB0b2tlbiBpcyB3aXRoaW4gdGhlIHRpbWUgd2luZG93IGF1dGhvcml6ZWQgYnkgdGhlICduYmYnIChub3QtYmVmb3JlKSBhbmQgJ2lhdCcgKGlzc3VlZC1hdCkgY2xhaW1zLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7P3N0cmluZ30gdG9rZW5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCB2YXIgaXNWYWxpZFRpbWVzdGFtcCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIHZhciBjbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcywgbm93ID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApLCB2YWxpZFNpbmNlLCB2YWxpZFVudGlsO1xuICAgIGlmICh0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCduYmYnKSkge1xuICAgICAgICAgICAgdmFsaWRTaW5jZSA9IGNsYWltc1snbmJmJ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKSkge1xuICAgICAgICAgICAgdmFsaWRTaW5jZSA9IGNsYWltc1snaWF0J107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnZXhwJykpIHtcbiAgICAgICAgICAgIHZhbGlkVW50aWwgPSBjbGFpbXNbJ2V4cCddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdG9rZW4gd2lsbCBleHBpcmUgYWZ0ZXIgMjRoIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIHZhbGlkVW50aWwgPSB2YWxpZFNpbmNlICsgODY0MDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChub3cgJiYgdmFsaWRTaW5jZSAmJiB2YWxpZFVudGlsICYmIG5vdyA+PSB2YWxpZFNpbmNlICYmIG5vdyA8PSB2YWxpZFVudGlsKTtcbn07XG4vKipcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgcmV0dXJucyBpdHMgaXNzdWVkIGF0IHRpbWUgaWYgdmFsaWQsIG51bGwgb3RoZXJ3aXNlLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIG51bGwgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7P3N0cmluZ30gdG9rZW5cbiAqIEByZXR1cm4gez9udW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgaXNzdWVkQXRUaW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgdmFyIGNsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xuICAgIGlmICh0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpKSB7XG4gICAgICAgIHJldHVybiBjbGFpbXNbJ2lhdCddO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG4vKipcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgY2hlY2tzIHRoZSB2YWxpZGl0eSBvZiBpdHMgZm9ybWF0LiBFeHBlY3RzIGEgdmFsaWQgaXNzdWVkLWF0IHRpbWUgYW5kIG5vbi1lbXB0eVxuICogc2lnbmF0dXJlLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7P3N0cmluZ30gdG9rZW5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCB2YXIgaXNWYWxpZEZvcm1hdCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIHZhciBkZWNvZGVkID0gZGVjb2RlKHRva2VuKSwgY2xhaW1zID0gZGVjb2RlZC5jbGFpbXM7XG4gICAgcmV0dXJuICghIWRlY29kZWQuc2lnbmF0dXJlICYmXG4gICAgICAgICEhY2xhaW1zICYmXG4gICAgICAgIHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpO1xufTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gcGVlciBpbnRvIGFuIGF1dGggdG9rZW4gYW5kIGRldGVybWluZSBpZiBpdCdzIGFuIGFkbWluIGF1dGggdG9rZW4gYnkgbG9va2luZyBhdCB0aGUgY2xhaW1zIHBvcnRpb24uXG4gKlxuICogTm90ZXM6XG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKlxuICogQHBhcmFtIHs/c3RyaW5nfSB0b2tlblxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IHZhciBpc0FkbWluID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgdmFyIGNsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xuICAgIHJldHVybiB0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXNbJ2FkbWluJ10gPT09IHRydWU7XG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL3V0aWwvZGlzdC9lc20vc3JjL2p3dC5qc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBmb3JFYWNoIH0gZnJvbSAnLi9vYmonO1xuLyoqXG4gKiBSZXR1cm5zIGEgcXVlcnlzdHJpbmctZm9ybWF0dGVkIHN0cmluZyAoZS5nLiAmYXJnPXZhbCZhcmcyPXZhbDIpIGZyb20gYSBwYXJhbXNcbiAqIG9iamVjdCAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcbiAqIE5vdGU6IFlvdSBtdXN0IHByZXBlbmQgaXQgd2l0aCA/IHdoZW4gYWRkaW5nIGl0IHRvIGEgVVJMLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gcXVlcnlzdHJpbmdQYXJhbXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBxdWVyeXN0cmluZyA9IGZ1bmN0aW9uIChxdWVyeXN0cmluZ1BhcmFtcykge1xuICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICBmb3JFYWNoKHF1ZXJ5c3RyaW5nUGFyYW1zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGFycmF5VmFsKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJyYXlWYWwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwYXJhbXMubGVuZ3RoID8gJyYnICsgcGFyYW1zLmpvaW4oJyYnKSA6ICcnO1xufTtcbi8qKlxuICogRGVjb2RlcyBhIHF1ZXJ5c3RyaW5nIChlLmcuID9hcmc9dmFsJmFyZzI9dmFsMikgaW50byBhIHBhcmFtcyBvYmplY3QgKGUuZy4ge2FyZzogJ3ZhbCcsIGFyZzI6ICd2YWwyJ30pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5c3RyaW5nXG4gKiBAcmV0dXJuIHshT2JqZWN0fVxuICovXG5leHBvcnQgdmFyIHF1ZXJ5c3RyaW5nRGVjb2RlID0gZnVuY3Rpb24gKHF1ZXJ5c3RyaW5nKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIHZhciB0b2tlbnMgPSBxdWVyeXN0cmluZy5yZXBsYWNlKC9eXFw/LywgJycpLnNwbGl0KCcmJyk7XG4gICAgdG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgdmFyIGtleSA9IHRva2VuLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICBvYmpba2V5WzBdXSA9IGtleVsxXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGZpcmViYXNlL3V0aWwvZGlzdC9lc20vc3JjL3F1ZXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IHsgSGFzaCB9IGZyb20gJy4vaGFzaCc7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0hBLTEgY3J5cHRvZ3JhcGhpYyBoYXNoLlxuICogVmFyaWFibGUgbmFtZXMgZm9sbG93IHRoZSBub3RhdGlvbiBpbiBGSVBTIFBVQiAxODAtMzpcbiAqIGh0dHA6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9maXBzL2ZpcHMxODAtMy9maXBzMTgwLTNfZmluYWwucGRmLlxuICpcbiAqIFVzYWdlOlxuICogICB2YXIgc2hhMSA9IG5ldyBzaGExKCk7XG4gKiAgIHNoYTEudXBkYXRlKGJ5dGVzKTtcbiAqICAgdmFyIGhhc2ggPSBzaGExLmRpZ2VzdCgpO1xuICpcbiAqIFBlcmZvcm1hbmNlOlxuICogICBDaHJvbWUgMjM6ICAgfjQwMCBNYml0L3NcbiAqICAgRmlyZWZveCAxNjogIH4yNTAgTWJpdC9zXG4gKlxuICovXG4vKipcbiAqIFNIQS0xIGNyeXB0b2dyYXBoaWMgaGFzaCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBUaGUgcHJvcGVydGllcyBkZWNsYXJlZCBoZXJlIGFyZSBkaXNjdXNzZWQgaW4gdGhlIGFib3ZlIGFsZ29yaXRobSBkb2N1bWVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0hhc2h9XG4gKiBAZmluYWxcbiAqIEBzdHJ1Y3RcbiAqL1xudmFyIFNoYTEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNoYTEsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2hhMSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvbGRzIHRoZSBwcmV2aW91cyB2YWx1ZXMgb2YgYWNjdW11bGF0ZWQgdmFyaWFibGVzIGEtZSBpbiB0aGUgY29tcHJlc3NfXG4gICAgICAgICAqIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5PG51bWJlcj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5jaGFpbl8gPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYnVmZmVyIGhvbGRpbmcgdGhlIHBhcnRpYWxseSBjb21wdXRlZCBoYXNoIHJlc3VsdC5cbiAgICAgICAgICogQHR5cGUgeyFBcnJheTxudW1iZXI+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYnVmXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgODAgYnl0ZXMsIGVhY2ggYSBwYXJ0IG9mIHRoZSBtZXNzYWdlIHRvIGJlIGhhc2hlZC4gIFJlZmVycmVkIHRvXG4gICAgICAgICAqIGFzIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGluIHRoZSBkb2NzLlxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5PG51bWJlcj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5XXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGFpbnMgZGF0YSBuZWVkZWQgdG8gcGFkIG1lc3NhZ2VzIGxlc3MgdGhhbiA2NCBieXRlcy5cbiAgICAgICAgICogQHR5cGUgeyFBcnJheTxudW1iZXI+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMucGFkXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmluYnVmXyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudG90YWxfID0gMDtcbiAgICAgICAgX3RoaXMuYmxvY2tTaXplID0gNTEyIC8gODtcbiAgICAgICAgX3RoaXMucGFkX1swXSA9IDEyODtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBfdGhpcy5ibG9ja1NpemU7ICsraSkge1xuICAgICAgICAgICAgX3RoaXMucGFkX1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMucmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTaGExLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAweDY3NDUyMzAxO1xuICAgICAgICB0aGlzLmNoYWluX1sxXSA9IDB4ZWZjZGFiODk7XG4gICAgICAgIHRoaXMuY2hhaW5fWzJdID0gMHg5OGJhZGNmZTtcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAweDEwMzI1NDc2O1xuICAgICAgICB0aGlzLmNoYWluX1s0XSA9IDB4YzNkMmUxZjA7XG4gICAgICAgIHRoaXMuaW5idWZfID0gMDtcbiAgICAgICAgdGhpcy50b3RhbF8gPSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgY29tcHJlc3MgaGVscGVyIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7IUFycmF5PG51bWJlcj58IVVpbnQ4QXJyYXl8c3RyaW5nfSBidWYgQmxvY2sgdG8gY29tcHJlc3MuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfb2Zmc2V0IE9mZnNldCBvZiB0aGUgYmxvY2sgaW4gdGhlIGJ1ZmZlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFNoYTEucHJvdG90eXBlLmNvbXByZXNzXyA9IGZ1bmN0aW9uIChidWYsIG9wdF9vZmZzZXQpIHtcbiAgICAgICAgaWYgKCFvcHRfb2Zmc2V0KSB7XG4gICAgICAgICAgICBvcHRfb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgVyA9IHRoaXMuV187XG4gICAgICAgIC8vIGdldCAxNiBiaWcgZW5kaWFuIHdvcmRzXG4gICAgICAgIGlmICh0eXBlb2YgYnVmID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyh1c2VyKTogW2J1ZyA4MTQwMTIyXSBSZWNlbnQgdmVyc2lvbnMgb2YgU2FmYXJpIGZvciBNYWMgT1MgYW5kIGlPU1xuICAgICAgICAgICAgICAgIC8vIGhhdmUgYSBidWcgdGhhdCB0dXJucyB0aGUgcG9zdC1pbmNyZW1lbnQgKysgb3BlcmF0b3IgaW50byBwcmUtaW5jcmVtZW50XG4gICAgICAgICAgICAgICAgLy8gZHVyaW5nIEpJVCBjb21waWxhdGlvbi4gIFdlIGhhdmUgY29kZSB0aGF0IGRlcGVuZHMgaGVhdmlseSBvbiBTSEEtMSBmb3JcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0bmVzcyBhbmQgd2hpY2ggaXMgYWZmZWN0ZWQgYnkgdGhpcyBidWcsIHNvIEkndmUgcmVtb3ZlZCBhbGwgdXNlc1xuICAgICAgICAgICAgICAgIC8vIG9mIHBvc3QtaW5jcmVtZW50ICsrIGluIHdoaWNoIHRoZSByZXN1bHQgdmFsdWUgaXMgdXNlZC4gIFdlIGNhbiByZXZlcnRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNoYW5nZSBvbmNlIHRoZSBTYWZhcmkgYnVnXG4gICAgICAgICAgICAgICAgLy8gKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDkwMzYpIGhhcyBiZWVuIGZpeGVkIGFuZFxuICAgICAgICAgICAgICAgIC8vIG1vc3QgY2xpZW50cyBoYXZlIGJlZW4gdXBkYXRlZC5cbiAgICAgICAgICAgICAgICBXW2ldID1cbiAgICAgICAgICAgICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9wdF9vZmZzZXQpIDw8IDI0KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob3B0X29mZnNldCArIDEpIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob3B0X29mZnNldCArIDIpIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Zi5jaGFyQ29kZUF0KG9wdF9vZmZzZXQgKyAzKTtcbiAgICAgICAgICAgICAgICBvcHRfb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBXW2ldID1cbiAgICAgICAgICAgICAgICAgICAgKGJ1ZltvcHRfb2Zmc2V0XSA8PCAyNCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZltvcHRfb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWZbb3B0X29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZltvcHRfb2Zmc2V0ICsgM107XG4gICAgICAgICAgICAgICAgb3B0X29mZnNldCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGV4cGFuZCB0byA4MCB3b3Jkc1xuICAgICAgICBmb3IgKHZhciBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdCA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl07XG4gICAgICAgICAgICBXW2ldID0gKCh0IDw8IDEpIHwgKHQgPj4+IDMxKSkgJiAweGZmZmZmZmZmO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFpbl9bMF07XG4gICAgICAgIHZhciBiID0gdGhpcy5jaGFpbl9bMV07XG4gICAgICAgIHZhciBjID0gdGhpcy5jaGFpbl9bMl07XG4gICAgICAgIHZhciBkID0gdGhpcy5jaGFpbl9bM107XG4gICAgICAgIHZhciBlID0gdGhpcy5jaGFpbl9bNF07XG4gICAgICAgIHZhciBmLCBrO1xuICAgICAgICAvLyBUT0RPKHVzZXIpOiBUcnkgdG8gdW5yb2xsIHRoaXMgbG9vcCB0byBzcGVlZCB1cCB0aGUgY29tcHV0YXRpb24uXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCA0MCkge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMjApIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgICAgICAgICAgICAgICBrID0gMHg1YTgyNzk5OTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDZlZDllYmExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgNjApIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IChiICYgYykgfCAoZCAmIChiIHwgYykpO1xuICAgICAgICAgICAgICAgICAgICBrID0gMHg4ZjFiYmNkYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgICAgICAgICAgICAgIGsgPSAweGNhNjJjMWQ2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ID0gKCgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyBrICsgV1tpXSkgJiAweGZmZmZmZmZmO1xuICAgICAgICAgICAgZSA9IGQ7XG4gICAgICAgICAgICBkID0gYztcbiAgICAgICAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICBiID0gYTtcbiAgICAgICAgICAgIGEgPSB0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhaW5fWzBdID0gKHRoaXMuY2hhaW5fWzBdICsgYSkgJiAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLmNoYWluX1sxXSA9ICh0aGlzLmNoYWluX1sxXSArIGIpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5jaGFpbl9bMl0gPSAodGhpcy5jaGFpbl9bMl0gKyBjKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuY2hhaW5fWzNdID0gKHRoaXMuY2hhaW5fWzNdICsgZCkgJiAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLmNoYWluX1s0XSA9ICh0aGlzLmNoYWluX1s0XSArIGUpICYgMHhmZmZmZmZmZjtcbiAgICB9O1xuICAgIFNoYTEucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChieXRlcywgb3B0X2xlbmd0aCkge1xuICAgICAgICAvLyBUT0RPKGpvaG5sZW56KTogdGlnaHRlbiB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlIGFuZCByZW1vdmUgdGhpcyBjaGVja1xuICAgICAgICBpZiAoYnl0ZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRfbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdF9sZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aE1pbnVzQmxvY2sgPSBvcHRfbGVuZ3RoIC0gdGhpcy5ibG9ja1NpemU7XG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgLy8gVXNpbmcgbG9jYWwgaW5zdGVhZCBvZiBtZW1iZXIgdmFyaWFibGVzIGdpdmVzIH41JSBzcGVlZHVwIG9uIEZpcmVmb3ggMTYuXG4gICAgICAgIHZhciBidWYgPSB0aGlzLmJ1Zl87XG4gICAgICAgIHZhciBpbmJ1ZiA9IHRoaXMuaW5idWZfO1xuICAgICAgICAvLyBUaGUgb3V0ZXIgd2hpbGUgbG9vcCBzaG91bGQgZXhlY3V0ZSBhdCBtb3N0IHR3aWNlLlxuICAgICAgICB3aGlsZSAobiA8IG9wdF9sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgaGF2ZSBubyBkYXRhIGluIHRoZSBibG9jayB0byB0b3AgdXAsIHdlIGNhbiBkaXJlY3RseSBwcm9jZXNzIHRoZVxuICAgICAgICAgICAgLy8gaW5wdXQgYnVmZmVyIChhc3N1bWluZyBpdCBjb250YWlucyBzdWZmaWNpZW50IGRhdGEpLiBUaGlzIGdpdmVzIH4yNSVcbiAgICAgICAgICAgIC8vIHNwZWVkdXAgb24gQ2hyb21lIDIzIGFuZCB+MTUlIHNwZWVkdXAgb24gRmlyZWZveCAxNiwgYnV0IHJlcXVpcmVzIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZSBkYXRhIGlzIHByb3ZpZGVkIGluIGxhcmdlIGNodW5rcyAob3IgaW4gbXVsdGlwbGVzIG9mIDY0IGJ5dGVzKS5cbiAgICAgICAgICAgIGlmIChpbmJ1ZiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPD0gbGVuZ3RoTWludXNCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhieXRlcywgbik7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gdGhpcy5ibG9ja1NpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8IG9wdF9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzLmNoYXJDb2RlQXQobik7XG4gICAgICAgICAgICAgICAgICAgICsraW5idWY7XG4gICAgICAgICAgICAgICAgICAgICsrbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluYnVmID09IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhidWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5idWYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8IG9wdF9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzW25dO1xuICAgICAgICAgICAgICAgICAgICArK2luYnVmO1xuICAgICAgICAgICAgICAgICAgICArK247XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmJ1ZiA9PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluYnVmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIG91dGVyIGxvb3Agc28gd2UgdXNlIHRoZSBmdWxsLWJsb2NrIG9wdGltaXphdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5idWZfID0gaW5idWY7XG4gICAgICAgIHRoaXMudG90YWxfICs9IG9wdF9sZW5ndGg7XG4gICAgfTtcbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgU2hhMS5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGlnZXN0ID0gW107XG4gICAgICAgIHZhciB0b3RhbEJpdHMgPSB0aGlzLnRvdGFsXyAqIDg7XG4gICAgICAgIC8vIEFkZCBwYWQgMHg4MCAweDAwKi5cbiAgICAgICAgaWYgKHRoaXMuaW5idWZfIDwgNTYpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRoaXMucGFkXywgNTYgLSB0aGlzLmluYnVmXyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLnBhZF8sIHRoaXMuYmxvY2tTaXplIC0gKHRoaXMuaW5idWZfIC0gNTYpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgIyBiaXRzLlxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5ibG9ja1NpemUgLSAxOyBpID49IDU2OyBpLS0pIHtcbiAgICAgICAgICAgIHRoaXMuYnVmX1tpXSA9IHRvdGFsQml0cyAmIDI1NTtcbiAgICAgICAgICAgIHRvdGFsQml0cyAvPSAyNTY7IC8vIERvbid0IHVzZSBiaXQtc2hpZnRpbmcgaGVyZSFcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXByZXNzXyh0aGlzLmJ1Zl8pO1xuICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMjQ7IGogPj0gMDsgaiAtPSA4KSB7XG4gICAgICAgICAgICAgICAgZGlnZXN0W25dID0gKHRoaXMuY2hhaW5fW2ldID4+IGopICYgMjU1O1xuICAgICAgICAgICAgICAgICsrbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlnZXN0O1xuICAgIH07XG4gICAgcmV0dXJuIFNoYTE7XG59KEhhc2gpKTtcbmV4cG9ydCB7IFNoYTEgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS91dGlsL2Rpc3QvZXNtL3NyYy9zaGExLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBIZWxwZXIgdG8gbWFrZSBhIFN1YnNjcmliZSBmdW5jdGlvbiAoanVzdCBsaWtlIFByb21pc2UgaGVscHMgbWFrZSBhXG4gKiBUaGVuYWJsZSkuXG4gKlxuICogQHBhcmFtIGV4ZWN1dG9yIEZ1bmN0aW9uIHdoaWNoIGNhbiBtYWtlIGNhbGxzIHRvIGEgc2luZ2xlIE9ic2VydmVyXG4gKiAgICAgYXMgYSBwcm94eS5cbiAqIEBwYXJhbSBvbk5vT2JzZXJ2ZXJzIENhbGxiYWNrIHdoZW4gY291bnQgb2YgT2JzZXJ2ZXJzIGdvZXMgdG8gemVyby5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmliZShleGVjdXRvciwgb25Ob09ic2VydmVycykge1xuICAgIHZhciBwcm94eSA9IG5ldyBPYnNlcnZlclByb3h5KGV4ZWN1dG9yLCBvbk5vT2JzZXJ2ZXJzKTtcbiAgICByZXR1cm4gcHJveHkuc3Vic2NyaWJlLmJpbmQocHJveHkpO1xufVxuLyoqXG4gKiBJbXBsZW1lbnQgZmFuLW91dCBmb3IgYW55IG51bWJlciBvZiBPYnNlcnZlcnMgYXR0YWNoZWQgdmlhIGEgc3Vic2NyaWJlXG4gKiBmdW5jdGlvbi5cbiAqL1xudmFyIE9ic2VydmVyUHJveHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGV4ZWN1dG9yIEZ1bmN0aW9uIHdoaWNoIGNhbiBtYWtlIGNhbGxzIHRvIGEgc2luZ2xlIE9ic2VydmVyXG4gICAgICogICAgIGFzIGEgcHJveHkuXG4gICAgICogQHBhcmFtIG9uTm9PYnNlcnZlcnMgQ2FsbGJhY2sgd2hlbiBjb3VudCBvZiBPYnNlcnZlcnMgZ29lcyB0byB6ZXJvLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE9ic2VydmVyUHJveHkoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZXMgPSBbXTtcbiAgICAgICAgdGhpcy5vYnNlcnZlckNvdW50ID0gMDtcbiAgICAgICAgLy8gTWljcm8tdGFzayBzY2hlZHVsaW5nIGJ5IGNhbGxpbmcgdGFzay50aGVuKCkuXG4gICAgICAgIHRoaXMudGFzayA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnMgPSBvbk5vT2JzZXJ2ZXJzO1xuICAgICAgICAvLyBDYWxsIHRoZSBleGVjdXRvciBhc3luY2hyb25vdXNseSBzbyBzdWJzY3JpYmVycyB0aGF0IGFyZSBjYWxsZWRcbiAgICAgICAgLy8gc3luY2hyb25vdXNseSBhZnRlciB0aGUgY3JlYXRpb24gb2YgdGhlIHN1YnNjcmliZSBmdW5jdGlvblxuICAgICAgICAvLyBjYW4gc3RpbGwgcmVjZWl2ZSB0aGUgdmVyeSBmaXJzdCB2YWx1ZSBnZW5lcmF0ZWQgaW4gdGhlIGV4ZWN1dG9yLlxuICAgICAgICB0aGlzLnRhc2tcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGV4ZWN1dG9yKF90aGlzKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMuZXJyb3IoZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBPYnNlcnZlclByb3h5LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JzZXJ2ZXJQcm94eS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNsb3NlKGVycm9yKTtcbiAgICB9O1xuICAgIE9ic2VydmVyUHJveHkucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcihmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgYW4gT2JzZXJ2ZXIgdG8gdGhlIGZhbi1vdXQgbGlzdC5cbiAgICAgKlxuICAgICAqIC0gV2UgcmVxdWlyZSB0aGF0IG5vIGV2ZW50IGlzIHNlbnQgdG8gYSBzdWJzY3JpYmVyIHN5Y2hyb25vdXNseSB0byB0aGVpclxuICAgICAqICAgY2FsbCB0byBzdWJzY3JpYmUoKS5cbiAgICAgKi9cbiAgICBPYnNlcnZlclByb3h5LnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb2JzZXJ2ZXI7XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBlcnJvciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBjb21wbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgT2JzZXJ2ZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXNzZW1ibGUgYW4gT2JzZXJ2ZXIgb2JqZWN0IHdoZW4gcGFzc2VkIGFzIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgICAgICAgaWYgKGltcGxlbWVudHNBbnlNZXRob2RzKG5leHRPck9ic2VydmVyLCBbJ25leHQnLCAnZXJyb3InLCAnY29tcGxldGUnXSkpIHtcbiAgICAgICAgICAgIG9ic2VydmVyID0gbmV4dE9yT2JzZXJ2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgICAgICBuZXh0OiBuZXh0T3JPYnNlcnZlcixcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYnNlcnZlci5uZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYnNlcnZlci5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvciA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9ic2VydmVyLmNvbXBsZXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdW5zdWIgPSB0aGlzLnVuc3Vic2NyaWJlT25lLmJpbmQodGhpcywgdGhpcy5vYnNlcnZlcnMubGVuZ3RoKTtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBzdWJzY3JpYmUgdG8gYSB0ZXJtaW5hdGVkIE9ic2VydmFibGUgLSB3ZVxuICAgICAgICAvLyBqdXN0IHJlc3BvbmQgdG8gdGhlIE9ic2VydmVyIHdpdGggdGhlIGZpbmFsIGVycm9yIG9yIGNvbXBsZXRlXG4gICAgICAgIC8vIGV2ZW50LlxuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudGFzay50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZmluYWxFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoX3RoaXMuZmluYWxFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICAgIHJldHVybiB1bnN1YjtcbiAgICB9O1xuICAgIC8vIFVuc3Vic2NyaWJlIGlzIHN5bmNocm9ub3VzIC0gd2UgZ3VhcmFudGVlIHRoYXQgbm8gZXZlbnRzIGFyZSBzZW50IHRvXG4gICAgLy8gYW55IHVuc3Vic2NyaWJlZCBPYnNlcnZlci5cbiAgICBPYnNlcnZlclByb3h5LnByb3RvdHlwZS51bnN1YnNjcmliZU9uZSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVycyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub2JzZXJ2ZXJzW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5vYnNlcnZlcnNbaV07XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJDb3VudCAtPSAxO1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlckNvdW50ID09PSAwICYmIHRoaXMub25Ob09ic2VydmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnModGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9ic2VydmVyUHJveHkucHJvdG90eXBlLmZvckVhY2hPYnNlcnZlciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgICAgIC8vIEFscmVhZHkgY2xvc2VkIGJ5IHByZXZpb3VzIGV2ZW50Li4uLmp1c3QgZWF0IHRoZSBhZGRpdGlvbmFsIHZhbHVlcy5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5jZSBzZW5kT25lIGNhbGxzIGFzeW5jaHJvbm91c2x5IC0gdGhlcmUgaXMgbm8gY2hhbmNlIHRoYXRcbiAgICAgICAgLy8gdGhpcy5vYnNlcnZlcnMgd2lsbCBiZWNvbWUgdW5kZWZpbmVkLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub2JzZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRPbmUoaSwgZm4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBDYWxsIHRoZSBPYnNlcnZlciB2aWEgb25lIG9mIGl0J3MgY2FsbGJhY2sgZnVuY3Rpb24uIFdlIGFyZSBjYXJlZnVsIHRvXG4gICAgLy8gY29uZmlybSB0aGF0IHRoZSBvYnNlcnZlIGhhcyBub3QgYmVlbiB1bnN1YnNjcmliZWQgc2luY2UgdGhpcyBhc3luY2hyb25vdXNcbiAgICAvLyBmdW5jdGlvbiBoYWQgYmVlbiBxdWV1ZWQuXG4gICAgT2JzZXJ2ZXJQcm94eS5wcm90b3R5cGUuc2VuZE9uZSA9IGZ1bmN0aW9uIChpLCBmbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBFeGVjdXRlIHRoZSBjYWxsYmFjayBhc3luY2hyb25vdXNseVxuICAgICAgICB0aGlzLnRhc2sudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQgJiYgX3RoaXMub2JzZXJ2ZXJzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmbihfdGhpcy5vYnNlcnZlcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXhjZXB0aW9ucyByYWlzZWQgaW4gT2JzZXJ2ZXJzIG9yIG1pc3NpbmcgbWV0aG9kcyBvZiBhblxuICAgICAgICAgICAgICAgICAgICAvLyBPYnNlcnZlci5cbiAgICAgICAgICAgICAgICAgICAgLy8gTG9nIGVycm9yIHRvIGNvbnNvbGUuIGIvMzE0MDQ4MDZcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9ic2VydmVyUHJveHkucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IHRydWU7XG4gICAgICAgIGlmIChlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5maW5hbEVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb3h5IGlzIG5vIGxvbmdlciBuZWVkZWQgLSBnYXJiYWdlIGNvbGxlY3QgcmVmZXJlbmNlc1xuICAgICAgICB0aGlzLnRhc2sudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5vYnNlcnZlcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBfdGhpcy5vbk5vT2JzZXJ2ZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZlclByb3h5O1xufSgpKTtcbi8qKiBUdXJuIHN5bmNocm9ub3VzIGZ1bmN0aW9uIGludG8gb25lIGNhbGxlZCBhc3luY2hyb25vdXNseS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3luYyhmbiwgb25FcnJvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHRydWUpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmbi5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIG9iamVjdCBwYXNzZWQgaW4gaW1wbGVtZW50cyBhbnkgb2YgdGhlIG5hbWVkIG1ldGhvZHMuXG4gKi9cbmZ1bmN0aW9uIGltcGxlbWVudHNBbnlNZXRob2RzKG9iaiwgbWV0aG9kcykge1xuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIG1ldGhvZHNfMSA9IG1ldGhvZHM7IF9pIDwgbWV0aG9kc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgbWV0aG9kID0gbWV0aG9kc18xW19pXTtcbiAgICAgICAgaWYgKG1ldGhvZCBpbiBvYmogJiYgdHlwZW9mIG9ialttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBub29wKCkge1xuICAgIC8vIGRvIG5vdGhpbmdcbn1cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0BmaXJlYmFzZS91dGlsL2Rpc3QvZXNtL3NyYy9zdWJzY3JpYmUuanNcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi9hc3NlcnQnO1xuLy8gQ29kZSBvcmlnaW5hbGx5IGNhbWUgZnJvbSBnb29nLmNyeXB0LnN0cmluZ1RvVXRmOEJ5dGVBcnJheSwgYnV0IGZvciBzb21lIHJlYXNvbiB0aGV5XG4vLyBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkICdcXHJcXG4nIHdpdGggJ1xcbicsIGFuZCB0aGV5IGRpZG4ndCBoYW5kbGUgc3Vycm9nYXRlIHBhaXJzLFxuLy8gc28gaXQncyBiZWVuIG1vZGlmaWVkLlxuLy8gTm90ZSB0aGF0IG5vdCBhbGwgVW5pY29kZSBjaGFyYWN0ZXJzIGFwcGVhciBhcyBzaW5nbGUgY2hhcmFjdGVycyBpbiBKYXZhU2NyaXB0IHN0cmluZ3MuXG4vLyBmcm9tQ2hhckNvZGUgcmV0dXJucyB0aGUgVVRGLTE2IGVuY29kaW5nIG9mIGEgY2hhcmFjdGVyIC0gc28gc29tZSBVbmljb2RlIGNoYXJhY3RlcnNcbi8vIHVzZSAyIGNoYXJhY3RlcnMgaW4gSmF2YXNjcmlwdC4gIEFsbCA0LWJ5dGUgVVRGLTggY2hhcmFjdGVycyBiZWdpbiB3aXRoIGEgZmlyc3Rcbi8vIGNoYXJhY3RlciBpbiB0aGUgcmFuZ2UgMHhEODAwIC0gMHhEQkZGICh0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc28tY2FsbGVkIHN1cnJvZ2F0ZVxuLy8gcGFpcikuXG4vLyBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTE1LjEuM1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZXhwb3J0IHZhciBzdHJpbmdUb0J5dGVBcnJheSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgb3V0ID0gW10sIHAgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIC8vIElzIHRoaXMgdGhlIGxlYWQgc3Vycm9nYXRlIGluIGEgc3Vycm9nYXRlIHBhaXI/XG4gICAgICAgIGlmIChjID49IDB4ZDgwMCAmJiBjIDw9IDB4ZGJmZikge1xuICAgICAgICAgICAgdmFyIGhpZ2ggPSBjIC0gMHhkODAwOyAvLyB0aGUgaGlnaCAxMCBiaXRzLlxuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgYXNzZXJ0KGkgPCBzdHIubGVuZ3RoLCAnU3Vycm9nYXRlIHBhaXIgbWlzc2luZyB0cmFpbCBzdXJyb2dhdGUuJyk7XG4gICAgICAgICAgICB2YXIgbG93ID0gc3RyLmNoYXJDb2RlQXQoaSkgLSAweGRjMDA7IC8vIHRoZSBsb3cgMTAgYml0cy5cbiAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKGhpZ2ggPDwgMTApICsgbG93O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpIHtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCA2NTUzNikge1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDEyKSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcbi8qKlxuICogQ2FsY3VsYXRlIGxlbmd0aCB3aXRob3V0IGFjdHVhbGx5IGNvbnZlcnRpbmc7IHVzZWZ1bCBmb3IgZG9pbmcgY2hlYXBlciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIHN0cmluZ0xlbmd0aCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgcCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICAgIHArKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xuICAgICAgICAgICAgcCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XG4gICAgICAgICAgICAvLyBMZWFkIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLiAgVGhlIHBhaXIgdG9nZXRoZXIgd2lsbCB0YWtlIDQgYnl0ZXMgdG8gcmVwcmVzZW50LlxuICAgICAgICAgICAgcCArPSA0O1xuICAgICAgICAgICAgaSsrOyAvLyBza2lwIHRyYWlsIHN1cnJvZ2F0ZS5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHAgKz0gMztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDtcbn07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvdXRpbC9kaXN0L2VzbS9zcmMvdXRmOC5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgZm9yIGEgcHVibGljIGZ1bmN0aW9uLlxuICogVGhyb3dzIGFuIGVycm9yIGlmIGl0IGZhaWxzLlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gZm5OYW1lIFRoZSBmdW5jdGlvbiBuYW1lXG4gKiBAcGFyYW0geyFudW1iZXJ9IG1pbkNvdW50IFRoZSBtaW5pbXVtIG51bWJlciBvZiBhcmd1bWVudHMgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXG4gKiBAcGFyYW0geyFudW1iZXJ9IG1heENvdW50IFRoZSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudCB0byBhbGxvdyBmb3IgdGhlIGZ1bmN0aW9uIGNhbGxcbiAqIEBwYXJhbSB7IW51bWJlcn0gYXJnQ291bnQgVGhlIGFjdHVhbCBudW1iZXIgb2YgYXJndW1lbnRzIHByb3ZpZGVkLlxuICovXG5leHBvcnQgdmFyIHZhbGlkYXRlQXJnQ291bnQgPSBmdW5jdGlvbiAoZm5OYW1lLCBtaW5Db3VudCwgbWF4Q291bnQsIGFyZ0NvdW50KSB7XG4gICAgdmFyIGFyZ0Vycm9yO1xuICAgIGlmIChhcmdDb3VudCA8IG1pbkNvdW50KSB7XG4gICAgICAgIGFyZ0Vycm9yID0gJ2F0IGxlYXN0ICcgKyBtaW5Db3VudDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJnQ291bnQgPiBtYXhDb3VudCkge1xuICAgICAgICBhcmdFcnJvciA9IG1heENvdW50ID09PSAwID8gJ25vbmUnIDogJ25vIG1vcmUgdGhhbiAnICsgbWF4Q291bnQ7XG4gICAgfVxuICAgIGlmIChhcmdFcnJvcikge1xuICAgICAgICB2YXIgZXJyb3IgPSBmbk5hbWUgK1xuICAgICAgICAgICAgJyBmYWlsZWQ6IFdhcyBjYWxsZWQgd2l0aCAnICtcbiAgICAgICAgICAgIGFyZ0NvdW50ICtcbiAgICAgICAgICAgIChhcmdDb3VudCA9PT0gMSA/ICcgYXJndW1lbnQuJyA6ICcgYXJndW1lbnRzLicpICtcbiAgICAgICAgICAgICcgRXhwZWN0cyAnICtcbiAgICAgICAgICAgIGFyZ0Vycm9yICtcbiAgICAgICAgICAgICcuJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICB9XG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBzdHJpbmcgdG8gcHJlZml4IGFuIGVycm9yIG1lc3NhZ2UgYWJvdXQgZmFpbGVkIGFyZ3VtZW50IHZhbGlkYXRpb25cbiAqXG4gKiBAcGFyYW0geyFzdHJpbmd9IGZuTmFtZSBUaGUgZnVuY3Rpb24gbmFtZVxuICogQHBhcmFtIHshbnVtYmVyfSBhcmd1bWVudE51bWJlciBUaGUgaW5kZXggb2YgdGhlIGFyZ3VtZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbmFsIFdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudCBpcyBvcHRpb25hbFxuICogQHJldHVybiB7IXN0cmluZ30gVGhlIHByZWZpeCB0byBhZGQgdG8gdGhlIGVycm9yIHRocm93biBmb3IgdmFsaWRhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSB7XG4gICAgdmFyIGFyZ05hbWUgPSAnJztcbiAgICBzd2l0Y2ggKGFyZ3VtZW50TnVtYmVyKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGFyZ05hbWUgPSBvcHRpb25hbCA/ICdmaXJzdCcgOiAnRmlyc3QnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGFyZ05hbWUgPSBvcHRpb25hbCA/ICdzZWNvbmQnIDogJ1NlY29uZCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgYXJnTmFtZSA9IG9wdGlvbmFsID8gJ3RoaXJkJyA6ICdUaGlyZCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgYXJnTmFtZSA9IG9wdGlvbmFsID8gJ2ZvdXJ0aCcgOiAnRm91cnRoJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcnJvclByZWZpeCBjYWxsZWQgd2l0aCBhcmd1bWVudE51bWJlciA+IDQuICBOZWVkIHRvIHVwZGF0ZSBpdD8nKTtcbiAgICB9XG4gICAgdmFyIGVycm9yID0gZm5OYW1lICsgJyBmYWlsZWQ6ICc7XG4gICAgZXJyb3IgKz0gYXJnTmFtZSArICcgYXJndW1lbnQgJztcbiAgICByZXR1cm4gZXJyb3I7XG59XG4vKipcbiAqIEBwYXJhbSB7IXN0cmluZ30gZm5OYW1lXG4gKiBAcGFyYW0geyFudW1iZXJ9IGFyZ3VtZW50TnVtYmVyXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVzcGFjZVxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVOYW1lc3BhY2UoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgbmFtZXNwYWNlLCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiAhbmFtZXNwYWNlKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vVE9ETzogSSBzaG91bGQgZG8gbW9yZSB2YWxpZGF0aW9uIGhlcmUuIFdlIG9ubHkgYWxsb3cgY2VydGFpbiBjaGFycyBpbiBuYW1lc3BhY2VzLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICdtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgbmFtZXNwYWNlLicpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUNhbGxiYWNrKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIGNhbGxiYWNrLCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiAhY2FsbGJhY2spXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICdtdXN0IGJlIGEgdmFsaWQgZnVuY3Rpb24uJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVDb250ZXh0T2JqZWN0KGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIGNvbnRleHQsIG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsICYmICFjb250ZXh0KVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JyB8fCBjb250ZXh0ID09PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICdtdXN0IGJlIGEgdmFsaWQgY29udGV4dCBvYmplY3QuJyk7XG59XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZmlyZWJhc2UvdXRpbC9kaXN0L2VzbS9zcmMvdmFsaWRhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gMTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIExvZGFzaCA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanMuZm91bmRhdGlvbi8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cbjsoZnVuY3Rpb24oKSB7XG5cbiAgLyoqIFVzZWQgYXMgYSBzYWZlIHJlZmVyZW5jZSBmb3IgYHVuZGVmaW5lZGAgaW4gcHJlLUVTNSBlbnZpcm9ubWVudHMuICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLiAqL1xuICB2YXIgVkVSU0lPTiA9ICc0LjE3LjQnO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xuICB2YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuICAvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG4gIHZhciBDT1JFX0VSUk9SX1RFWFQgPSAnVW5zdXBwb3J0ZWQgY29yZS1qcyB1c2UuIFRyeSBodHRwczovL25wbXMuaW8vc2VhcmNoP3E9cG9ueWZpbGwuJyxcbiAgICAgIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuICAvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG4gIHZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuICAvKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG4gIHZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi9cbiAgdmFyIFBMQUNFSE9MREVSID0gJ19fbG9kYXNoX3BsYWNlaG9sZGVyX18nO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG4gIHZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG4gIHZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbiAgdmFyIFdSQVBfQklORF9GTEFHID0gMSxcbiAgICAgIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsXG4gICAgICBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgICAgV1JBUF9DVVJSWV9GTEFHID0gOCxcbiAgICAgIFdSQVBfQ1VSUllfUklHSFRfRkxBRyA9IDE2LFxuICAgICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMixcbiAgICAgIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHID0gNjQsXG4gICAgICBXUkFQX0FSWV9GTEFHID0gMTI4LFxuICAgICAgV1JBUF9SRUFSR19GTEFHID0gMjU2LFxuICAgICAgV1JBUF9GTElQX0ZMQUcgPSA1MTI7XG5cbiAgLyoqIFVzZWQgYXMgZGVmYXVsdCBvcHRpb25zIGZvciBgXy50cnVuY2F0ZWAuICovXG4gIHZhciBERUZBVUxUX1RSVU5DX0xFTkdUSCA9IDMwLFxuICAgICAgREVGQVVMVF9UUlVOQ19PTUlTU0lPTiA9ICcuLi4nO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbiAgdmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICAgIEhPVF9TUEFOID0gMTY7XG5cbiAgLyoqIFVzZWQgdG8gaW5kaWNhdGUgdGhlIHR5cGUgb2YgbGF6eSBpdGVyYXRlZXMuICovXG4gIHZhciBMQVpZX0ZJTFRFUl9GTEFHID0gMSxcbiAgICAgIExBWllfTUFQX0ZMQUcgPSAyLFxuICAgICAgTEFaWV9XSElMRV9GTEFHID0gMztcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbiAgdmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MSxcbiAgICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgsXG4gICAgICBOQU4gPSAwIC8gMDtcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB0aGUgbWF4aW11bSBsZW5ndGggYW5kIGluZGV4IG9mIGFuIGFycmF5LiAqL1xuICB2YXIgTUFYX0FSUkFZX0xFTkdUSCA9IDQyOTQ5NjcyOTUsXG4gICAgICBNQVhfQVJSQVlfSU5ERVggPSBNQVhfQVJSQVlfTEVOR1RIIC0gMSxcbiAgICAgIEhBTEZfTUFYX0FSUkFZX0xFTkdUSCA9IE1BWF9BUlJBWV9MRU5HVEggPj4+IDE7XG5cbiAgLyoqIFVzZWQgdG8gYXNzb2NpYXRlIHdyYXAgbWV0aG9kcyB3aXRoIHRoZWlyIGJpdCBmbGFncy4gKi9cbiAgdmFyIHdyYXBGbGFncyA9IFtcbiAgICBbJ2FyeScsIFdSQVBfQVJZX0ZMQUddLFxuICAgIFsnYmluZCcsIFdSQVBfQklORF9GTEFHXSxcbiAgICBbJ2JpbmRLZXknLCBXUkFQX0JJTkRfS0VZX0ZMQUddLFxuICAgIFsnY3VycnknLCBXUkFQX0NVUlJZX0ZMQUddLFxuICAgIFsnY3VycnlSaWdodCcsIFdSQVBfQ1VSUllfUklHSFRfRkxBR10sXG4gICAgWydmbGlwJywgV1JBUF9GTElQX0ZMQUddLFxuICAgIFsncGFydGlhbCcsIFdSQVBfUEFSVElBTF9GTEFHXSxcbiAgICBbJ3BhcnRpYWxSaWdodCcsIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHXSxcbiAgICBbJ3JlYXJnJywgV1JBUF9SRUFSR19GTEFHXVxuICBdO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBkb21FeGNUYWcgPSAnW29iamVjdCBET01FeGNlcHRpb25dJyxcbiAgICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXScsXG4gICAgICB3ZWFrU2V0VGFnID0gJ1tvYmplY3QgV2Vha1NldF0nO1xuXG4gIHZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbiAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUVzY2FwZWRIdG1sID0gLyYoPzphbXB8bHR8Z3R8cXVvdHwjMzkpOy9nLFxuICAgICAgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csXG4gICAgICByZUhhc0VzY2FwZWRIdG1sID0gUmVnRXhwKHJlRXNjYXBlZEh0bWwuc291cmNlKSxcbiAgICAgIHJlSGFzVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cChyZVVuZXNjYXBlZEh0bWwuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlRXZhbHVhdGUgPSAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcc1xcU10rPyklPi9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXG4gICAgICByZUxlYWRpbmdEb3QgPSAvXlxcLi8sXG4gICAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gICAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICAgKi9cbiAgdmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZyxcbiAgICAgIHJlSGFzUmVnRXhwQ2hhciA9IFJlZ0V4cChyZVJlZ0V4cENoYXIuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xuICB2YXIgcmVUcmltID0gL15cXHMrfFxccyskL2csXG4gICAgICByZVRyaW1TdGFydCA9IC9eXFxzKy8sXG4gICAgICByZVRyaW1FbmQgPSAvXFxzKyQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdyYXAgZGV0YWlsIGNvbW1lbnRzLiAqL1xuICB2YXIgcmVXcmFwQ29tbWVudCA9IC9cXHsoPzpcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoIC4rXFxdIFxcKlxcLyk/XFxuPy8sXG4gICAgICByZVdyYXBEZXRhaWxzID0gL1xce1xcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggKC4rKVxcXSBcXCovLFxuICAgICAgcmVTcGxpdERldGFpbHMgPSAvLD8gJiAvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIGNvbXBvc2VkIG9mIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaFxuICAgKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxuICAgKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG4gIHZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG4gIHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG4gIHZhciByZUxhdGluID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2c7XG5cbiAgLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbiAgdmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgICByc0RpbmdiYXRSYW5nZSA9ICdcXFxcdTI3MDAtXFxcXHUyN2JmJyxcbiAgICAgIHJzTG93ZXJSYW5nZSA9ICdhLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmYnLFxuICAgICAgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JyxcbiAgICAgIHJzTm9uQ2hhclJhbmdlID0gJ1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZicsXG4gICAgICByc1B1bmN0dWF0aW9uUmFuZ2UgPSAnXFxcXHUyMDAwLVxcXFx1MjA2ZicsXG4gICAgICByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnLFxuICAgICAgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZScsXG4gICAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZicsXG4gICAgICByc0JyZWFrUmFuZ2UgPSByc01hdGhPcFJhbmdlICsgcnNOb25DaGFyUmFuZ2UgKyByc1B1bmN0dWF0aW9uUmFuZ2UgKyByc1NwYWNlUmFuZ2U7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xuICB2YXIgcnNBcG9zID0gXCJbJ1xcdTIwMTldXCIsXG4gICAgICByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgICByc0JyZWFrID0gJ1snICsgcnNCcmVha1JhbmdlICsgJ10nLFxuICAgICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICAgIHJzRGlnaXRzID0gJ1xcXFxkKycsXG4gICAgICByc0RpbmdiYXQgPSAnWycgKyByc0RpbmdiYXRSYW5nZSArICddJyxcbiAgICAgIHJzTG93ZXIgPSAnWycgKyByc0xvd2VyUmFuZ2UgKyAnXScsXG4gICAgICByc01pc2MgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICAgIHJzVXBwZXIgPSAnWycgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xuICB2YXIgcnNNaXNjTG93ZXIgPSAnKD86JyArIHJzTG93ZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgICByc01pc2NVcHBlciA9ICcoPzonICsgcnNVcHBlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICAgIHJzT3B0Q29udHJMb3dlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OmR8bGx8bXxyZXxzfHR8dmUpKT8nLFxuICAgICAgcnNPcHRDb250clVwcGVyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86RHxMTHxNfFJFfFN8VHxWRSkpPycsXG4gICAgICByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICAgIHJzT3JkTG93ZXIgPSAnXFxcXGQqKD86KD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aClcXFxcYiknLFxuICAgICAgcnNPcmRVcHBlciA9ICdcXFxcZCooPzooPzoxU1R8Mk5EfDNSRHwoPyFbMTIzXSlcXFxcZFRIKVxcXFxiKScsXG4gICAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgICByc0Vtb2ppID0gJyg/OicgKyBbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc1NlcSxcbiAgICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGFwb3N0cm9waGVzLiAqL1xuICB2YXIgcmVBcG9zID0gUmVnRXhwKHJzQXBvcywgJ2cnKTtcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxuICAgKi9cbiAgdmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbiAgdmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGNvbXBsZXggb3IgY29tcG91bmQgd29yZHMuICovXG4gIHZhciByZVVuaWNvZGVXb3JkID0gUmVnRXhwKFtcbiAgICByc1VwcGVyICsgJz8nICsgcnNMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICAgIHJzTWlzY1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciArIHJzTWlzY0xvd2VyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgICByc1VwcGVyICsgJz8nICsgcnNNaXNjTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIsXG4gICAgcnNVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlcixcbiAgICByc09yZFVwcGVyLFxuICAgIHJzT3JkTG93ZXIsXG4gICAgcnNEaWdpdHMsXG4gICAgcnNFbW9qaVxuICBdLmpvaW4oJ3wnKSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbiAgdmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3MgdGhhdCBuZWVkIGEgbW9yZSByb2J1c3QgcmVnZXhwIHRvIG1hdGNoIHdvcmRzLiAqL1xuICB2YXIgcmVIYXNVbmljb2RlV29yZCA9IC9bYS16XVtBLVpdfFtBLVpdezIsfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMuICovXG4gIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgJ0FycmF5JywgJ0J1ZmZlcicsICdEYXRhVmlldycsICdEYXRlJywgJ0Vycm9yJywgJ0Zsb2F0MzJBcnJheScsICdGbG9hdDY0QXJyYXknLFxuICAgICdGdW5jdGlvbicsICdJbnQ4QXJyYXknLCAnSW50MTZBcnJheScsICdJbnQzMkFycmF5JywgJ01hcCcsICdNYXRoJywgJ09iamVjdCcsXG4gICAgJ1Byb21pc2UnLCAnUmVnRXhwJywgJ1NldCcsICdTdHJpbmcnLCAnU3ltYm9sJywgJ1R5cGVFcnJvcicsICdVaW50OEFycmF5JyxcbiAgICAnVWludDhDbGFtcGVkQXJyYXknLCAnVWludDE2QXJyYXknLCAnVWludDMyQXJyYXknLCAnV2Vha01hcCcsXG4gICAgJ18nLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJywgJ3BhcnNlSW50JywgJ3NldFRpbWVvdXQnXG4gIF07XG5cbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeS4gKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IC0xO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbiAgdmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG4gIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIHR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xuICB2YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuICBjbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICBjbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gbWFwIExhdGluIFVuaWNvZGUgbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLiAqL1xuICB2YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAgIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgICAnXFx4YzAnOiAnQScsICAnXFx4YzEnOiAnQScsICdcXHhjMic6ICdBJywgJ1xceGMzJzogJ0EnLCAnXFx4YzQnOiAnQScsICdcXHhjNSc6ICdBJyxcbiAgICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICAgJ1xceGQwJzogJ0QnLCAgJ1xceGYwJzogJ2QnLFxuICAgICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgICAnXFx4Y2MnOiAnSScsICAnXFx4Y2QnOiAnSScsICdcXHhjZSc6ICdJJywgJ1xceGNmJzogJ0knLFxuICAgICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAgICdcXHhkMic6ICdPJywgICdcXHhkMyc6ICdPJywgJ1xceGQ0JzogJ08nLCAnXFx4ZDUnOiAnTycsICdcXHhkNic6ICdPJywgJ1xceGQ4JzogJ08nLFxuICAgICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAgICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICAgJ1xceGY5JzogJ3UnLCAgJ1xceGZhJzogJ3UnLCAnXFx4ZmInOiAndScsICdcXHhmYyc6ICd1JyxcbiAgICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAgICdcXHhkZSc6ICdUaCcsICdcXHhmZSc6ICd0aCcsXG4gICAgJ1xceGRmJzogJ3NzJyxcbiAgICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAgICdcXHUwMTAwJzogJ0EnLCAgJ1xcdTAxMDInOiAnQScsICdcXHUwMTA0JzogJ0EnLFxuICAgICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAgICdcXHUwMTA2JzogJ0MnLCAgJ1xcdTAxMDgnOiAnQycsICdcXHUwMTBhJzogJ0MnLCAnXFx1MDEwYyc6ICdDJyxcbiAgICAnXFx1MDEwNyc6ICdjJywgICdcXHUwMTA5JzogJ2MnLCAnXFx1MDEwYic6ICdjJywgJ1xcdTAxMGQnOiAnYycsXG4gICAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAgICdcXHUwMTEyJzogJ0UnLCAgJ1xcdTAxMTQnOiAnRScsICdcXHUwMTE2JzogJ0UnLCAnXFx1MDExOCc6ICdFJywgJ1xcdTAxMWEnOiAnRScsXG4gICAgJ1xcdTAxMTMnOiAnZScsICAnXFx1MDExNSc6ICdlJywgJ1xcdTAxMTcnOiAnZScsICdcXHUwMTE5JzogJ2UnLCAnXFx1MDExYic6ICdlJyxcbiAgICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICAgJ1xcdTAxMWQnOiAnZycsICAnXFx1MDExZic6ICdnJywgJ1xcdTAxMjEnOiAnZycsICdcXHUwMTIzJzogJ2cnLFxuICAgICdcXHUwMTI0JzogJ0gnLCAgJ1xcdTAxMjYnOiAnSCcsICdcXHUwMTI1JzogJ2gnLCAnXFx1MDEyNyc6ICdoJyxcbiAgICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAgICdcXHUwMTI5JzogJ2knLCAgJ1xcdTAxMmInOiAnaScsICdcXHUwMTJkJzogJ2knLCAnXFx1MDEyZic6ICdpJywgJ1xcdTAxMzEnOiAnaScsXG4gICAgJ1xcdTAxMzQnOiAnSicsICAnXFx1MDEzNSc6ICdqJyxcbiAgICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgICAnXFx1MDEzOSc6ICdMJywgICdcXHUwMTNiJzogJ0wnLCAnXFx1MDEzZCc6ICdMJywgJ1xcdTAxM2YnOiAnTCcsICdcXHUwMTQxJzogJ0wnLFxuICAgICdcXHUwMTNhJzogJ2wnLCAgJ1xcdTAxM2MnOiAnbCcsICdcXHUwMTNlJzogJ2wnLCAnXFx1MDE0MCc6ICdsJywgJ1xcdTAxNDInOiAnbCcsXG4gICAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAgICdcXHUwMTQ0JzogJ24nLCAgJ1xcdTAxNDYnOiAnbicsICdcXHUwMTQ4JzogJ24nLCAnXFx1MDE0Yic6ICduJyxcbiAgICAnXFx1MDE0Yyc6ICdPJywgICdcXHUwMTRlJzogJ08nLCAnXFx1MDE1MCc6ICdPJyxcbiAgICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgICAnXFx1MDE1NCc6ICdSJywgICdcXHUwMTU2JzogJ1InLCAnXFx1MDE1OCc6ICdSJyxcbiAgICAnXFx1MDE1NSc6ICdyJywgICdcXHUwMTU3JzogJ3InLCAnXFx1MDE1OSc6ICdyJyxcbiAgICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICAgJ1xcdTAxNWInOiAncycsICAnXFx1MDE1ZCc6ICdzJywgJ1xcdTAxNWYnOiAncycsICdcXHUwMTYxJzogJ3MnLFxuICAgICdcXHUwMTYyJzogJ1QnLCAgJ1xcdTAxNjQnOiAnVCcsICdcXHUwMTY2JzogJ1QnLFxuICAgICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAgICdcXHUwMTY4JzogJ1UnLCAgJ1xcdTAxNmEnOiAnVScsICdcXHUwMTZjJzogJ1UnLCAnXFx1MDE2ZSc6ICdVJywgJ1xcdTAxNzAnOiAnVScsICdcXHUwMTcyJzogJ1UnLFxuICAgICdcXHUwMTY5JzogJ3UnLCAgJ1xcdTAxNmInOiAndScsICdcXHUwMTZkJzogJ3UnLCAnXFx1MDE2Zic6ICd1JywgJ1xcdTAxNzEnOiAndScsICdcXHUwMTczJzogJ3UnLFxuICAgICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICAgJ1xcdTAxNzYnOiAnWScsICAnXFx1MDE3Nyc6ICd5JywgJ1xcdTAxNzgnOiAnWScsXG4gICAgJ1xcdTAxNzknOiAnWicsICAnXFx1MDE3Yic6ICdaJywgJ1xcdTAxN2QnOiAnWicsXG4gICAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICAgJ1xcdTAxMzInOiAnSUonLCAnXFx1MDEzMyc6ICdpaicsXG4gICAgJ1xcdTAxNTInOiAnT2UnLCAnXFx1MDE1Myc6ICdvZScsXG4gICAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3MnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbiAgdmFyIGh0bWxFc2NhcGVzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7J1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuICovXG4gIHZhciBodG1sVW5lc2NhcGVzID0ge1xuICAgICcmYW1wOyc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJiMzOTsnOiBcIidcIlxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICAvKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xuICB2YXIgZnJlZVBhcnNlRmxvYXQgPSBwYXJzZUZsb2F0LFxuICAgICAgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG4gIHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xuICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG4gIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuICAvKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbiAgdmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfSgpKTtcblxuICAvKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xuICB2YXIgbm9kZUlzQXJyYXlCdWZmZXIgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc0FycmF5QnVmZmVyLFxuICAgICAgbm9kZUlzRGF0ZSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzRGF0ZSxcbiAgICAgIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwLFxuICAgICAgbm9kZUlzUmVnRXhwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNSZWdFeHAsXG4gICAgICBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldCxcbiAgICAgIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGtleS12YWx1ZSBgcGFpcmAgdG8gYG1hcGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhaXIgVGhlIGtleS12YWx1ZSBwYWlyIHRvIGFkZC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgbWFwYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFkZE1hcEVudHJ5KG1hcCwgcGFpcikge1xuICAgIC8vIERvbid0IHJldHVybiBgbWFwLnNldGAgYmVjYXVzZSBpdCdzIG5vdCBjaGFpbmFibGUgaW4gSUUgMTEuXG4gICAgbWFwLnNldChwYWlyWzBdLCBwYWlyWzFdKTtcbiAgICByZXR1cm4gbWFwO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYHZhbHVlYCB0byBgc2V0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBzZXRgLlxuICAgKi9cbiAgZnVuY3Rpb24gYWRkU2V0RW50cnkoc2V0LCB2YWx1ZSkge1xuICAgIC8vIERvbid0IHJldHVybiBgc2V0LmFkZGAgYmVjYXVzZSBpdCdzIG5vdCBjaGFpbmFibGUgaW4gSUUgMTEuXG4gICAgc2V0LmFkZCh2YWx1ZSk7XG4gICAgcmV0dXJuIHNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQWdncmVnYXRvcmAgZm9yIGFycmF5cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlBZ2dyZWdhdG9yKGFycmF5LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RWFjaFJpZ2h0KGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5ldmVyeWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFdmVyeShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmICghcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICAgIH1cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZVJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAgICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVJlZHVjZVJpZ2h0KGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVstLWxlbmd0aF07XG4gICAgfVxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgdmFyIGFzY2lpU2l6ZSA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZmluZEtleWAgYW5kIGBfLmZpbmRMYXN0S2V5YCxcbiAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYFxuICAgKiB1c2luZyBgZWFjaEZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50IG9yIGl0cyBrZXksIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEtleShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGVhY2hGdW5jKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgICA/IHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZldpdGgoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZWFuYCBhbmQgYF8ubWVhbkJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlTWVhbihhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuIGxlbmd0aCA/IChiYXNlU3VtKGFycmF5LCBpdGVyYXRlZSkgLyBsZW5ndGgpIDogTkFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgLCB3aXRob3V0IHN1cHBvcnRcbiAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gIHVzaW5nIGBlYWNoRnVuY2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpbml0QWNjdW0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50IG9mXG4gICAqICBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBlYWNoRnVuYykge1xuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgYWNjdW11bGF0b3IgPSBpbml0QWNjdW1cbiAgICAgICAgPyAoaW5pdEFjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gICAqIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAgICogdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zdW1gIGFuZCBgXy5zdW1CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlU3VtKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciByZXN1bHQsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSk7XG4gICAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gY3VycmVudCA6IChyZXN1bHQgKyBjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gICAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9QYWlyc2AgYW5kIGBfLnRvUGFpcnNJbmAgd2hpY2ggY3JlYXRlcyBhbiBhcnJheVxuICAgKiBvZiBrZXktdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzIG9mIGBwcm9wc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVG9QYWlycyhvYmplY3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBba2V5LCBvYmplY3Rba2V5XV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICAgKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAgICogb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICAgIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltU3RhcnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBgcGxhY2Vob2xkZXJgIG9jY3VycmVuY2VzIGluIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjb3VudC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvdW50SG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSAwO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoYXJyYXlbbGVuZ3RoXSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgKytyZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXG4gICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gICAqL1xuICB2YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcblxuICAvKipcbiAgICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNVbmljb2RlV29yZChzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYGl0ZXJhdG9yYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZXJhdG9yIFRoZSBpdGVyYXRvciB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcikge1xuICAgIHZhciBkYXRhLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICghKGRhdGEgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGRhdGEudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBgcGxhY2Vob2xkZXJgIGVsZW1lbnRzIGluIGBhcnJheWAgd2l0aCBhbiBpbnRlcm5hbCBwbGFjZWhvbGRlclxuICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVpciBpbmRleGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAodmFsdWUgPT09IHBsYWNlaG9sZGVyIHx8IHZhbHVlID09PSBQTEFDRUhPTERFUikge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBQTEFDRUhPTERFUjtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gaXRzIHZhbHVlLXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRvUGFpcnMoc2V0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSBbdmFsdWUsIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5sYXN0SW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaWN0TGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggKyAxO1xuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2Ygc3ltYm9scyBpbiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nU2l6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHVuaWNvZGVTaXplKHN0cmluZylcbiAgICAgIDogYXNjaWlTaXplKHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpXG4gICAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIHZhciB1bmVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbFVuZXNjYXBlcyk7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYSBVbmljb2RlIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gcmVVbmljb2RlLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKHJlVW5pY29kZS50ZXN0KHN0cmluZykpIHtcbiAgICAgICsrcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhIFVuaWNvZGUgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlV29yZHMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGBjb250ZXh0YCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDEuMS4wXG4gICAqIEBjYXRlZ29yeSBVdGlsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIG5ldyBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5taXhpbih7ICdmb28nOiBfLmNvbnN0YW50KCdmb28nKSB9KTtcbiAgICpcbiAgICogdmFyIGxvZGFzaCA9IF8ucnVuSW5Db250ZXh0KCk7XG4gICAqIGxvZGFzaC5taXhpbih7ICdiYXInOiBsb2Rhc2guY29uc3RhbnQoJ2JhcicpIH0pO1xuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oXy5mb28pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqIF8uaXNGdW5jdGlvbihfLmJhcik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5mb28pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guYmFyKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiAvLyBDcmVhdGUgYSBzdXBlZC11cCBgZGVmZXJgIGluIE5vZGUuanMuXG4gICAqIHZhciBkZWZlciA9IF8ucnVuSW5Db250ZXh0KHsgJ3NldFRpbWVvdXQnOiBzZXRJbW1lZGlhdGUgfSkuZGVmZXI7XG4gICAqL1xuICB2YXIgcnVuSW5Db250ZXh0ID0gKGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0KSB7XG4gICAgY29udGV4dCA9IGNvbnRleHQgPT0gbnVsbCA/IHJvb3QgOiBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKTtcblxuICAgIC8qKiBCdWlsdC1pbiBjb25zdHJ1Y3RvciByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBBcnJheSA9IGNvbnRleHQuQXJyYXksXG4gICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXG4gICAgICAgIEVycm9yID0gY29udGV4dC5FcnJvcixcbiAgICAgICAgRnVuY3Rpb24gPSBjb250ZXh0LkZ1bmN0aW9uLFxuICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICAgICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG4gICAgdmFyIGNvcmVKc0RhdGEgPSBjb250ZXh0WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbiAgICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xuICAgIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbiAgICB2YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gICAgICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG4gICAgdmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgXy5ub0NvbmZsaWN0YC4gKi9cbiAgICB2YXIgb2xkRGFzaCA9IHJvb3QuXztcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG4gICAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbiAgICApO1xuXG4gICAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyBjb250ZXh0LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgU3ltYm9sID0gY29udGV4dC5TeW1ib2wsXG4gICAgICAgIFVpbnQ4QXJyYXkgPSBjb250ZXh0LlVpbnQ4QXJyYXksXG4gICAgICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkLFxuICAgICAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcbiAgICAgICAgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgICAgIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1JdGVyYXRvciA9IFN5bWJvbCA/IFN5bWJvbC5pdGVyYXRvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgICAgICBmdW5jKHt9LCAnJywge30pO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfSgpKTtcblxuICAgIC8qKiBNb2NrZWQgYnVpbHQtaW5zLiAqL1xuICAgIHZhciBjdHhDbGVhclRpbWVvdXQgPSBjb250ZXh0LmNsZWFyVGltZW91dCAhPT0gcm9vdC5jbGVhclRpbWVvdXQgJiYgY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGN0eE5vdyA9IERhdGUgJiYgRGF0ZS5ub3cgIT09IHJvb3QuRGF0ZS5ub3cgJiYgRGF0ZS5ub3csXG4gICAgICAgIGN0eFNldFRpbWVvdXQgPSBjb250ZXh0LnNldFRpbWVvdXQgIT09IHJvb3Quc2V0VGltZW91dCAmJiBjb250ZXh0LnNldFRpbWVvdXQ7XG5cbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG4gICAgdmFyIG5hdGl2ZUNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICAgIG5hdGl2ZUZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG4gICAgICAgIG5hdGl2ZUpvaW4gPSBhcnJheVByb3RvLmpvaW4sXG4gICAgICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZU5vdyA9IERhdGUubm93LFxuICAgICAgICBuYXRpdmVQYXJzZUludCA9IGNvbnRleHQucGFyc2VJbnQsXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tLFxuICAgICAgICBuYXRpdmVSZXZlcnNlID0gYXJyYXlQcm90by5yZXZlcnNlO1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuICAgIHZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShjb250ZXh0LCAnRGF0YVZpZXcnKSxcbiAgICAgICAgTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdNYXAnKSxcbiAgICAgICAgUHJvbWlzZSA9IGdldE5hdGl2ZShjb250ZXh0LCAnUHJvbWlzZScpLFxuICAgICAgICBTZXQgPSBnZXROYXRpdmUoY29udGV4dCwgJ1NldCcpLFxuICAgICAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdXZWFrTWFwJyksXG4gICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuICAgIC8qKiBVc2VkIHRvIHN0b3JlIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICAgIHZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL1xuICAgIHZhciByZWFsTmFtZXMgPSB7fTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG4gICAgdmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICAgICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgICAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4gICAgLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG4gICAgdmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBpbXBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMuIE1ldGhvZHMgdGhhdCBvcGVyYXRlIG9uIGFuZCByZXR1cm4gYXJyYXlzLCBjb2xsZWN0aW9ucyxcbiAgICAgKiBhbmQgZnVuY3Rpb25zIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBNZXRob2RzIHRoYXQgcmV0cmlldmUgYSBzaW5nbGUgdmFsdWVcbiAgICAgKiBvciBtYXkgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlIHdpbGwgYXV0b21hdGljYWxseSBlbmQgdGhlIGNoYWluIHNlcXVlbmNlXG4gICAgICogYW5kIHJldHVybiB0aGUgdW53cmFwcGVkIHZhbHVlLiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBtdXN0IGJlIHVud3JhcHBlZFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxuICAgICAqXG4gICAgICogRXhwbGljaXQgY2hhaW4gc2VxdWVuY2VzLCB3aGljaCBtdXN0IGJlIHVud3JhcHBlZCB3aXRoIGBfI3ZhbHVlYCwgbWF5IGJlXG4gICAgICogZW5hYmxlZCB1c2luZyBgXy5jaGFpbmAuXG4gICAgICpcbiAgICAgKiBUaGUgZXhlY3V0aW9uIG9mIGNoYWluZWQgbWV0aG9kcyBpcyBsYXp5LCB0aGF0IGlzLCBpdCdzIGRlZmVycmVkIHVudGlsXG4gICAgICogYF8jdmFsdWVgIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBMYXp5IGV2YWx1YXRpb24gYWxsb3dzIHNldmVyYWwgbWV0aG9kcyB0byBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbi5cbiAgICAgKiBTaG9ydGN1dCBmdXNpb24gaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1lcmdlIGl0ZXJhdGVlIGNhbGxzOyB0aGlzIGF2b2lkc1xuICAgICAqIHRoZSBjcmVhdGlvbiBvZiBpbnRlcm1lZGlhdGUgYXJyYXlzIGFuZCBjYW4gZ3JlYXRseSByZWR1Y2UgdGhlIG51bWJlciBvZlxuICAgICAqIGl0ZXJhdGVlIGV4ZWN1dGlvbnMuIFNlY3Rpb25zIG9mIGEgY2hhaW4gc2VxdWVuY2UgcXVhbGlmeSBmb3Igc2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaWYgdGhlIHNlY3Rpb24gaXMgYXBwbGllZCB0byBhbiBhcnJheSBhbmQgaXRlcmF0ZWVzIGFjY2VwdCBvbmx5XG4gICAgICogb25lIGFyZ3VtZW50LiBUaGUgaGV1cmlzdGljIGZvciB3aGV0aGVyIGEgc2VjdGlvbiBxdWFsaWZpZXMgZm9yIHNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlzIHN1YmplY3QgdG8gY2hhbmdlLlxuICAgICAqXG4gICAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYF8jdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gbG9kYXNoIG1ldGhvZHMsIHdyYXBwZXJzIGhhdmUgYEFycmF5YCBhbmQgYFN0cmluZ2AgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBBcnJheWAgbWV0aG9kcyBhcmU6XG4gICAgICogYGNvbmNhdGAsIGBqb2luYCwgYHBvcGAsIGBwdXNoYCwgYHNoaWZ0YCwgYHNvcnRgLCBgc3BsaWNlYCwgYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYFN0cmluZ2AgbWV0aG9kcyBhcmU6XG4gICAgICogYHJlcGxhY2VgIGFuZCBgc3BsaXRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24gYXJlOlxuICAgICAqIGBhdGAsIGBjb21wYWN0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGRyb3BXaGlsZWAsIGBmaWx0ZXJgLCBgZmluZGAsXG4gICAgICogYGZpbmRMYXN0YCwgYGhlYWRgLCBgaW5pdGlhbGAsIGBsYXN0YCwgYG1hcGAsIGByZWplY3RgLCBgcmV2ZXJzZWAsIGBzbGljZWAsXG4gICAgICogYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYW5kIGB0b0FycmF5YFxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGFzc2lnbkluYCwgYGFzc2lnbkluV2l0aGAsIGBhc3NpZ25XaXRoYCwgYGF0YCxcbiAgICAgKiBgYmVmb3JlYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCwgYGNhc3RBcnJheWAsIGBjaGFpbmAsIGBjaHVua2AsXG4gICAgICogYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25mb3Jtc2AsIGBjb25zdGFudGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsXG4gICAgICogYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBkZWZlcmAsIGBkZWxheWAsXG4gICAgICogYGRpZmZlcmVuY2VgLCBgZGlmZmVyZW5jZUJ5YCwgYGRpZmZlcmVuY2VXaXRoYCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCxcbiAgICAgKiBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGV4dGVuZGAsIGBleHRlbmRXaXRoYCwgYGZpbGxgLCBgZmlsdGVyYCxcbiAgICAgKiBgZmxhdE1hcGAsIGBmbGF0TWFwRGVlcGAsIGBmbGF0TWFwRGVwdGhgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsXG4gICAgICogYGZsYXR0ZW5EZXB0aGAsIGBmbGlwYCwgYGZsb3dgLCBgZmxvd1JpZ2h0YCwgYGZyb21QYWlyc2AsIGBmdW5jdGlvbnNgLFxuICAgICAqIGBmdW5jdGlvbnNJbmAsIGBncm91cEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludGVyc2VjdGlvbkJ5YCxcbiAgICAgKiBgaW50ZXJzZWN0aW9uV2l0aGAsIGBpbnZlcnRgLCBgaW52ZXJ0QnlgLCBgaW52b2tlTWFwYCwgYGl0ZXJhdGVlYCwgYGtleUJ5YCxcbiAgICAgKiBga2V5c2AsIGBrZXlzSW5gLCBgbWFwYCwgYG1hcEtleXNgLCBgbWFwVmFsdWVzYCwgYG1hdGNoZXNgLCBgbWF0Y2hlc1Byb3BlcnR5YCxcbiAgICAgKiBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtZXJnZVdpdGhgLCBgbWV0aG9kYCwgYG1ldGhvZE9mYCwgYG1peGluYCwgYG5lZ2F0ZWAsXG4gICAgICogYG50aEFyZ2AsIGBvbWl0YCwgYG9taXRCeWAsIGBvbmNlYCwgYG9yZGVyQnlgLCBgb3ZlcmAsIGBvdmVyQXJnc2AsXG4gICAgICogYG92ZXJFdmVyeWAsIGBvdmVyU29tZWAsIGBwYXJ0aWFsYCwgYHBhcnRpYWxSaWdodGAsIGBwYXJ0aXRpb25gLCBgcGlja2AsXG4gICAgICogYHBpY2tCeWAsIGBwbGFudGAsIGBwcm9wZXJ0eWAsIGBwcm9wZXJ0eU9mYCwgYHB1bGxgLCBgcHVsbEFsbGAsIGBwdWxsQWxsQnlgLFxuICAgICAqIGBwdWxsQWxsV2l0aGAsIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlYXJnYCwgYHJlamVjdGAsXG4gICAgICogYHJlbW92ZWAsIGByZXN0YCwgYHJldmVyc2VgLCBgc2FtcGxlU2l6ZWAsIGBzZXRgLCBgc2V0V2l0aGAsIGBzaHVmZmxlYCxcbiAgICAgKiBgc2xpY2VgLCBgc29ydGAsIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHNwcmVhZGAsIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRvQXJyYXlgLFxuICAgICAqIGB0b1BhaXJzYCwgYHRvUGFpcnNJbmAsIGB0b1BhdGhgLCBgdG9QbGFpbk9iamVjdGAsIGB0cmFuc2Zvcm1gLCBgdW5hcnlgLFxuICAgICAqIGB1bmlvbmAsIGB1bmlvbkJ5YCwgYHVuaW9uV2l0aGAsIGB1bmlxYCwgYHVuaXFCeWAsIGB1bmlxV2l0aGAsIGB1bnNldGAsXG4gICAgICogYHVuc2hpZnRgLCBgdW56aXBgLCBgdW56aXBXaXRoYCwgYHVwZGF0ZWAsIGB1cGRhdGVXaXRoYCwgYHZhbHVlc2AsXG4gICAgICogYHZhbHVlc0luYCwgYHdpdGhvdXRgLCBgd3JhcGAsIGB4b3JgLCBgeG9yQnlgLCBgeG9yV2l0aGAsIGB6aXBgLFxuICAgICAqIGB6aXBPYmplY3RgLCBgemlwT2JqZWN0RGVlcGAsIGFuZCBgemlwV2l0aGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBhcmUgKipub3QqKiBjaGFpbmFibGUgYnkgZGVmYXVsdCBhcmU6XG4gICAgICogYGFkZGAsIGBhdHRlbXB0YCwgYGNhbWVsQ2FzZWAsIGBjYXBpdGFsaXplYCwgYGNlaWxgLCBgY2xhbXBgLCBgY2xvbmVgLFxuICAgICAqIGBjbG9uZURlZXBgLCBgY2xvbmVEZWVwV2l0aGAsIGBjbG9uZVdpdGhgLCBgY29uZm9ybXNUb2AsIGBkZWJ1cnJgLFxuICAgICAqIGBkZWZhdWx0VG9gLCBgZGl2aWRlYCwgYGVhY2hgLCBgZWFjaFJpZ2h0YCwgYGVuZHNXaXRoYCwgYGVxYCwgYGVzY2FwZWAsXG4gICAgICogYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCxcbiAgICAgKiBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaXJzdGAsIGBmbG9vcmAsIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsXG4gICAgICogYGZvckluYCwgYGZvckluUmlnaHRgLCBgZm9yT3duYCwgYGZvck93blJpZ2h0YCwgYGdldGAsIGBndGAsIGBndGVgLCBgaGFzYCxcbiAgICAgKiBgaGFzSW5gLCBgaGVhZGAsIGBpZGVudGl0eWAsIGBpbmNsdWRlc2AsIGBpbmRleE9mYCwgYGluUmFuZ2VgLCBgaW52b2tlYCxcbiAgICAgKiBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0FycmF5QnVmZmVyYCwgYGlzQXJyYXlMaWtlYCwgYGlzQXJyYXlMaWtlT2JqZWN0YCxcbiAgICAgKiBgaXNCb29sZWFuYCwgYGlzQnVmZmVyYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLCBgaXNFbXB0eWAsIGBpc0VxdWFsYCxcbiAgICAgKiBgaXNFcXVhbFdpdGhgLCBgaXNFcnJvcmAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzSW50ZWdlcmAsIGBpc0xlbmd0aGAsXG4gICAgICogYGlzTWFwYCwgYGlzTWF0Y2hgLCBgaXNNYXRjaFdpdGhgLCBgaXNOYU5gLCBgaXNOYXRpdmVgLCBgaXNOaWxgLCBgaXNOdWxsYCxcbiAgICAgKiBgaXNOdW1iZXJgLCBgaXNPYmplY3RgLCBgaXNPYmplY3RMaWtlYCwgYGlzUGxhaW5PYmplY3RgLCBgaXNSZWdFeHBgLFxuICAgICAqIGBpc1NhZmVJbnRlZ2VyYCwgYGlzU2V0YCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsXG4gICAgICogYGlzV2Vha01hcGAsIGBpc1dlYWtTZXRgLCBgam9pbmAsIGBrZWJhYkNhc2VgLCBgbGFzdGAsIGBsYXN0SW5kZXhPZmAsXG4gICAgICogYGxvd2VyQ2FzZWAsIGBsb3dlckZpcnN0YCwgYGx0YCwgYGx0ZWAsIGBtYXhgLCBgbWF4QnlgLCBgbWVhbmAsIGBtZWFuQnlgLFxuICAgICAqIGBtaW5gLCBgbWluQnlgLCBgbXVsdGlwbHlgLCBgbm9Db25mbGljdGAsIGBub29wYCwgYG5vd2AsIGBudGhgLCBgcGFkYCxcbiAgICAgKiBgcGFkRW5kYCwgYHBhZFN0YXJ0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCwgYHJlZHVjZVJpZ2h0YCxcbiAgICAgKiBgcmVwZWF0YCwgYHJlc3VsdGAsIGByb3VuZGAsIGBydW5JbkNvbnRleHRgLCBgc2FtcGxlYCwgYHNoaWZ0YCwgYHNpemVgLFxuICAgICAqIGBzbmFrZUNhc2VgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBzb3J0ZWRJbmRleEJ5YCwgYHNvcnRlZExhc3RJbmRleGAsXG4gICAgICogYHNvcnRlZExhc3RJbmRleEJ5YCwgYHN0YXJ0Q2FzZWAsIGBzdGFydHNXaXRoYCwgYHN0dWJBcnJheWAsIGBzdHViRmFsc2VgLFxuICAgICAqIGBzdHViT2JqZWN0YCwgYHN0dWJTdHJpbmdgLCBgc3R1YlRydWVgLCBgc3VidHJhY3RgLCBgc3VtYCwgYHN1bUJ5YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdGltZXNgLCBgdG9GaW5pdGVgLCBgdG9JbnRlZ2VyYCwgYHRvSlNPTmAsIGB0b0xlbmd0aGAsXG4gICAgICogYHRvTG93ZXJgLCBgdG9OdW1iZXJgLCBgdG9TYWZlSW50ZWdlcmAsIGB0b1N0cmluZ2AsIGB0b1VwcGVyYCwgYHRyaW1gLFxuICAgICAqIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGB0cnVuY2F0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGB1cHBlckNhc2VgLFxuICAgICAqIGB1cHBlckZpcnN0YCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gUmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogd3JhcHBlZC5yZWR1Y2UoXy5hZGQpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYSB3cmFwcGVkIHZhbHVlLlxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoc3F1YXJlKTtcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTG9kYXNoV3JhcHBlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpIHtcbiAgICAgICAgICByZXR1cm4gd3JhcHBlckNsb25lKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gICAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgICAgIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB3aG9zZSBwcm90b3R5cGUgY2hhaW4gc2VxdWVuY2Ugd3JhcHBlcnMgaW5oZXJpdCBmcm9tLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTG9kYXNoKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBjb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoYWluQWxsXSBFbmFibGUgZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgICAgdGhpcy5fX2luZGV4X18gPSAwO1xuICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXG4gICAgICogZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgJ2ltcG9ydHMnOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEVuc3VyZSB3cmFwcGVycyBhcmUgaW5zdGFuY2VzIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBsb2Rhc2gucHJvdG90eXBlID0gYmFzZUxvZGFzaC5wcm90b3R5cGU7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcblxuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxhenkgd3JhcHBlciBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgbGF6eSBldmFsdWF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fZGlyX18gPSAxO1xuICAgICAgdGhpcy5fX2ZpbHRlcmVkX18gPSBmYWxzZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gTUFYX0FSUkFZX0xFTkdUSDtcbiAgICAgIHRoaXMuX192aWV3c19fID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBsYXp5IHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbG9uZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMuX193cmFwcGVkX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9fZGlyX18gPSB0aGlzLl9fZGlyX187XG4gICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdGhpcy5fX2ZpbHRlcmVkX187XG4gICAgICByZXN1bHQuX19pdGVyYXRlZXNfXyA9IGNvcHlBcnJheSh0aGlzLl9faXRlcmF0ZWVzX18pO1xuICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSB0aGlzLl9fdGFrZUNvdW50X187XG4gICAgICByZXN1bHQuX192aWV3c19fID0gY29weUFycmF5KHRoaXMuX192aWV3c19fKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIGRpcmVjdGlvbiBvZiBsYXp5IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyByZXZlcnNlZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5UmV2ZXJzZSgpIHtcbiAgICAgIGlmICh0aGlzLl9fZmlsdGVyZWRfXykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyA9IC0xO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gKj0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB1bndyYXBwZWQgdmFsdWUgZnJvbSBpdHMgbGF6eSB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVZhbHVlKCkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5fX3dyYXBwZWRfXy52YWx1ZSgpLFxuICAgICAgICAgIGRpciA9IHRoaXMuX19kaXJfXyxcbiAgICAgICAgICBpc0FyciA9IGlzQXJyYXkoYXJyYXkpLFxuICAgICAgICAgIGlzUmlnaHQgPSBkaXIgPCAwLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGlzQXJyID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICB2aWV3ID0gZ2V0VmlldygwLCBhcnJMZW5ndGgsIHRoaXMuX192aWV3c19fKSxcbiAgICAgICAgICBzdGFydCA9IHZpZXcuc3RhcnQsXG4gICAgICAgICAgZW5kID0gdmlldy5lbmQsXG4gICAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQsXG4gICAgICAgICAgaW5kZXggPSBpc1JpZ2h0ID8gZW5kIDogKHN0YXJ0IC0gMSksXG4gICAgICAgICAgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLFxuICAgICAgICAgIGl0ZXJMZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICB0YWtlQ291bnQgPSBuYXRpdmVNaW4obGVuZ3RoLCB0aGlzLl9fdGFrZUNvdW50X18pO1xuXG4gICAgICBpZiAoIWlzQXJyIHx8ICghaXNSaWdodCAmJiBhcnJMZW5ndGggPT0gbGVuZ3RoICYmIHRha2VDb3VudCA9PSBsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKGFycmF5LCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuXG4gICAgICAgIHZhciBpdGVySW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIHdoaWxlICgrK2l0ZXJJbmRleCA8IGl0ZXJMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGl0ZXJhdGVlc1tpdGVySW5kZXhdLFxuICAgICAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXG4gICAgICAgICAgICAgIHR5cGUgPSBkYXRhLnR5cGUsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9NQVBfRkxBRykge1xuICAgICAgICAgICAgdmFsdWUgPSBjb21wdXRlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjb21wdXRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRykge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGBMYXp5V3JhcHBlcmAgaXMgYW4gaW5zdGFuY2Ugb2YgYGJhc2VMb2Rhc2hgLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhenlXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICAgICAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG4gICAgSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG4gICAgSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbiAgICBIYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuICAgIEhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG4gICAgSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICAgICAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgICAgICBkYXRhLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgLS10aGlzLnNpemU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgKyt0aGlzLnNpemU7XG4gICAgICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAgICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgYWRkXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQGFsaWFzIHB1c2hcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICAgICAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICAgICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICAgICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gICAgICB9XG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG4gICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcbiAgICBTdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG4gICAgU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuICAgIFN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcbiAgICBTdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICAgICAgKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2Jhc2VSYW5kb20oMCwgbGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVTaXplYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlU2l6ZShhcnJheSwgbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSksIGJhc2VDbGFtcChuLCAwLCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTaHVmZmxlKGFycmF5KSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAgICAgKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFnZ3JlZ2F0ZXMgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIG9uIGBhY2N1bXVsYXRvcmAgd2l0aCBrZXlzIHRyYW5zZm9ybWVkXG4gICAgICogYnkgYGl0ZXJhdGVlYCBhbmQgdmFsdWVzIHNldCBieSBgc2V0dGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFnZ3JlZ2F0b3IoY29sbGVjdGlvbiwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICAgICAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICAgICAqIHZhbHVlIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcGlja2VkIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBdChvYmplY3QsIHBhdGhzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBza2lwID0gb2JqZWN0ID09IG51bGw7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBza2lwID8gdW5kZWZpbmVkIDogZ2V0KG9iamVjdCwgcGF0aHNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xhbXBgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKG51bWJlciA9PT0gbnVtYmVyKSB7XG4gICAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPj0gbG93ZXIgPyBudW1iZXIgOiBsb3dlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gICAgICogdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIERlZXAgY2xvbmVcbiAgICAgKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAgICAgKiAgNCAtIENsb25lIHN5bWJvbHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgYmFzZUNsb25lLCBpc0RlZXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkO1xuICAgICAgfVxuICAgICAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gICAgICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICAgICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICAgICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgICAgIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICAgICAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zKHNvdXJjZSkge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY29uZm9ybXNUb2Agd2hpY2ggYWNjZXB0cyBgcHJvcHNgIHRvIGNoZWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcykge1xuICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tsZW5ndGhdLFxuICAgICAgICAgICAgcHJlZGljYXRlID0gc291cmNlW2tleV0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIGlmICgodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB8fCAhcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGVsYXlgIGFuZCBgXy5kZWZlcmAgd2hpY2ggYWNjZXB0cyBgYXJnc2BcbiAgICAgKiB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge251bWJlcnxPYmplY3R9IFJldHVybnMgdGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEZWxheShmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZGlmZmVyZW5jZWAgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGV4Y2x1ZGluZyBtdWx0aXBsZSBhcnJheXMgb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICB2YWx1ZXMgPSBhcnJheU1hcCh2YWx1ZXMsIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMgPSBuZXcgU2V0Q2FjaGUodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA9PSBudWxsID8gdmFsdWUgOiBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyh2YWx1ZXMsIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaFJpZ2h0ID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93blJpZ2h0LCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmV2ZXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gISFwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ubWF4YCBhbmQgYF8ubWluYCB3aGljaCBhY2NlcHRzIGFcbiAgICAgKiBgY29tcGFyYXRvcmAgdG8gZGV0ZXJtaW5lIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV4dHJlbXVtKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjdXJyZW50ID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgKGNvbXB1dGVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAoY3VycmVudCA9PT0gY3VycmVudCAmJiAhaXNTeW1ib2woY3VycmVudCkpXG4gICAgICAgICAgICAgIDogY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZClcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICB2YXIgY29tcHV0ZWQgPSBjdXJyZW50LFxuICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWxsYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiBsZW5ndGgpID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZW5kID0gc3RhcnQgPiBlbmQgPyAwIDogdG9MZW5ndGgoZW5kKTtcbiAgICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICBhcnJheVtzdGFydCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgICAgIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gICAgICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlRm9yYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXNcbiAgICAgKiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3JSaWdodCA9IGNyZWF0ZUJhc2VGb3IodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvclJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZ1bmN0aW9uc2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZlxuICAgICAqIGBvYmplY3RgIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZpbHRlcmVkIGZyb20gYHByb3BzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGZpbHRlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGdW5jdGlvbnMob2JqZWN0LCBwcm9wcykge1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob2JqZWN0W2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAgICAgKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAgICAgKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICAgICAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgICAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICAgICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ3RgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUd0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID4gb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhcyhvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluUmFuZ2VgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIG51bWJlciA+PSBuYXRpdmVNaW4oc3RhcnQsIGVuZCkgJiYgbnVtYmVyIDwgbmF0aXZlTWF4KHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gLCB3aXRob3V0IHN1cHBvcnRcbiAgICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW50ZXJzZWN0aW9uKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmNsdWRlcyA9IGNvbXBhcmF0b3IgPyBhcnJheUluY2x1ZGVzV2l0aCA6IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXlzWzBdLmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IEFycmF5KG90aExlbmd0aCksXG4gICAgICAgICAgbWF4TGVuZ3RoID0gSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlIChvdGhJbmRleC0tKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tvdGhJbmRleF07XG4gICAgICAgIGlmIChvdGhJbmRleCAmJiBpdGVyYXRlZSkge1xuICAgICAgICAgIGFycmF5ID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgICB9XG4gICAgICAgIG1heExlbmd0aCA9IG5hdGl2ZU1pbihhcnJheS5sZW5ndGgsIG1heExlbmd0aCk7XG4gICAgICAgIGNhY2hlc1tvdGhJbmRleF0gPSAhY29tcGFyYXRvciAmJiAoaXRlcmF0ZWUgfHwgKGxlbmd0aCA+PSAxMjAgJiYgYXJyYXkubGVuZ3RoID49IDEyMCkpXG4gICAgICAgICAgPyBuZXcgU2V0Q2FjaGUob3RoSW5kZXggJiYgYXJyYXkpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnJheSA9IGFycmF5c1swXTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgc2VlbiA9IGNhY2hlc1swXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKCEoc2VlblxuICAgICAgICAgICAgICA/IGNhY2hlSGFzKHNlZW4sIGNvbXB1dGVkKVxuICAgICAgICAgICAgICA6IGluY2x1ZGVzKHJlc3VsdCwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKC0tb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1tvdGhJbmRleF07XG4gICAgICAgICAgICBpZiAoIShjYWNoZVxuICAgICAgICAgICAgICAgICAgPyBjYWNoZUhhcyhjYWNoZSwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgICAgICA6IGluY2x1ZGVzKGFycmF5c1tvdGhJbmRleF0sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52ZXJ0YCBhbmQgYF8uaW52ZXJ0QnlgIHdoaWNoIGludmVydHNcbiAgICAgKiBgb2JqZWN0YCB3aXRoIHZhbHVlcyB0cmFuc2Zvcm1lZCBieSBgaXRlcmF0ZWVgIGFuZCBzZXQgYnkgYHNldHRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIGl0ZXJhdGVlKHZhbHVlKSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52b2tlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBtZXRob2QgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gICAgICB2YXIgZnVuYyA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICAgIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhcHBseShmdW5jLCBvYmplY3QsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FycmF5QnVmZmVyYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFycmF5QnVmZmVyVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRGF0ZWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNEYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBkYXRlVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAgICAgKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAgICAgKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gICAgICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gICAgICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gICAgICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICAgICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgICAgICBvYmpJc09iaiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgICAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNTYW1lVGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgICAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzUmVnRXhwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNSZWdFeHAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHJlZ2V4cFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gICAgICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubHRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUx0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDwgb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgICAgIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICBzcmNWYWx1ZSA9IHNvdXJjZVtrZXldLFxuICAgICAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IChzcmNJbmRleCAmJiBpc0Z1bmN0aW9uKG9ialZhbHVlKSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5udGhgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU50aChhcnJheSwgbikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG4gKz0gbiA8IDAgPyBsZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGlzSW5kZXgobiwgbGVuZ3RoKSA/IGFycmF5W25dIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcy5sZW5ndGggPyBpdGVyYXRlZXMgOiBbaWRlbnRpdHldLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBjcml0ZXJpYSA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBmdW5jdGlvbihvYmplY3QsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVBpY2sob2JqZWN0LCBwYXRocykge1xuICAgICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGhhc0luKG9iamVjdCwgcGF0aCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICAgICAgdmFsdWUgPSBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQWxsQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICAgKiBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXhPZiA9IGNvbXBhcmF0b3IgPyBiYXNlSW5kZXhPZldpdGggOiBiYXNlSW5kZXhPZixcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgc2VlbiA9IGFycmF5O1xuXG4gICAgICBpZiAoYXJyYXkgPT09IHZhbHVlcykge1xuICAgICAgICB2YWx1ZXMgPSBjb3B5QXJyYXkodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBzZWVuID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGZyb21JbmRleCA9IDAsXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1tpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tSW5kZXggPSBpbmRleE9mKHNlZW4sIGNvbXB1dGVkLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpKSA+IC0xKSB7XG4gICAgICAgICAgaWYgKHNlZW4gIT09IGFycmF5KSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChzZWVuLCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogaW5kZXhlcyBvciBjYXB0dXJpbmcgdGhlIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXhlcyBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gaW5kZXhlcy5sZW5ndGggOiAwLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGlmIChsZW5ndGggPT0gbGFzdEluZGV4IHx8IGluZGV4ICE9PSBwcmV2aW91cykge1xuICAgICAgICAgIHZhciBwcmV2aW91cyA9IGluZGV4O1xuICAgICAgICAgIGlmIChpc0luZGV4KGluZGV4KSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZVVuc2V0KGFycmF5LCBpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IHN1cHBvcnQgZm9yIHJldHVybmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKSB7XG4gICAgICByZXR1cm4gbG93ZXIgKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqICh1cHBlciAtIGxvd2VyICsgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmdlYCBhbmQgYF8ucmFuZ2VSaWdodGAgd2hpY2ggZG9lc24ndFxuICAgICAqIGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF0gPSBzdGFydDtcbiAgICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVwZWF0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByZXBlYXRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJlcGVhdChzdHJpbmcsIG4pIHtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIGlmICghc3RyaW5nIHx8IG4gPCAxIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICAvLyBMZXZlcmFnZSB0aGUgZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcgYWxnb3JpdGhtIGZvciBhIGZhc3RlciByZXBlYXQuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXhwb25lbnRpYXRpb25fYnlfc3F1YXJpbmcgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG4gJSAyKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBuID0gbmF0aXZlRmxvb3IobiAvIDIpO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgIHN0cmluZyArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKG4pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNhbXBsZShjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gYXJyYXlTYW1wbGUodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zYW1wbGVTaXplYCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTYW1wbGVTaXplKGNvbGxlY3Rpb24sIG4pIHtcbiAgICAgIHZhciBhcnJheSA9IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihhcnJheSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgICAgIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0RGF0YWAgd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBiYXNlU2V0RGF0YSA9ICFtZXRhTWFwID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBkYXRhKSB7XG4gICAgICBtZXRhTWFwLnNldChmdW5jLCBkYXRhKTtcbiAgICAgIHJldHVybiBmdW5jO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAgICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNodWZmbGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZih2YWx1ZXMoY29sbGVjdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICAgICAgc3RhcnQgPj4+PSAwO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29tZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiAhcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkSW5kZXhgIGFuZCBgXy5zb3J0ZWRMYXN0SW5kZXhgIHdoaWNoXG4gICAgICogcGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIG9mIGBhcnJheWAgdG8gZGV0ZXJtaW5lIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID09IG51bGwgPyBsb3cgOiBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT09IHZhbHVlICYmIGhpZ2ggPD0gSEFMRl9NQVhfQVJSQVlfTEVOR1RIKSB7XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMSxcbiAgICAgICAgICAgICAgY29tcHV0ZWQgPSBhcnJheVttaWRdO1xuXG4gICAgICAgICAgaWYgKGNvbXB1dGVkICE9PSBudWxsICYmICFpc1N5bWJvbChjb21wdXRlZCkgJiZcbiAgICAgICAgICAgICAgKHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpKSkge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZ2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpZGVudGl0eSwgcmV0SGlnaGVzdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkSW5kZXhCeWAgYW5kIGBfLnNvcnRlZExhc3RJbmRleEJ5YFxuICAgICAqIHdoaWNoIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZVxuICAgICAqIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhbHVlID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgdmFsSXNOYU4gPSB2YWx1ZSAhPT0gdmFsdWUsXG4gICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSksXG4gICAgICAgICAgdmFsSXNVbmRlZmluZWQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB2YXIgbWlkID0gbmF0aXZlRmxvb3IoKGxvdyArIGhpZ2gpIC8gMiksXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKGFycmF5W21pZF0pLFxuICAgICAgICAgICAgb3RoSXNEZWZpbmVkID0gY29tcHV0ZWQgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG90aElzTnVsbCA9IGNvbXB1dGVkID09PSBudWxsLFxuICAgICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBjb21wdXRlZCA9PT0gY29tcHV0ZWQsXG4gICAgICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKGNvbXB1dGVkKTtcblxuICAgICAgICBpZiAodmFsSXNOYU4pIHtcbiAgICAgICAgICB2YXIgc2V0TG93ID0gcmV0SGlnaGVzdCB8fCBvdGhJc1JlZmxleGl2ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1VuZGVmaW5lZCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIChyZXRIaWdoZXN0IHx8IG90aElzRGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNOdWxsKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc051bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzU3ltYm9sKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmICFvdGhJc051bGwgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzU3ltYm9sKTtcbiAgICAgICAgfSBlbHNlIGlmIChvdGhJc051bGwgfHwgb3RoSXNTeW1ib2wpIHtcbiAgICAgICAgICBzZXRMb3cgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRMb3cgPSByZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0TG93KSB7XG4gICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlTWluKGhpZ2gsIE1BWF9BUlJBWV9JTkRFWCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkVW5pcWAgYW5kIGBfLnNvcnRlZFVuaXFCeWAgd2l0aG91dFxuICAgICAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZFVuaXEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgaWYgKCFpbmRleCB8fCAhZXEoY29tcHV0ZWQsIHNlZW4pKSB7XG4gICAgICAgICAgdmFyIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b051bWJlcmAgd2hpY2ggZG9lc24ndCBlbnN1cmUgY29ycmVjdFxuICAgICAqIGNvbnZlcnNpb25zIG9mIGJpbmFyeSwgaGV4YWRlY2ltYWwsIG9yIG9jdGFsIHN0cmluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VUb051bWJlcih2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBOQU47XG4gICAgICB9XG4gICAgICByZXR1cm4gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICAgICAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICBzZWVuID0gcmVzdWx0O1xuXG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG4gICAgICAgIGlmIChzZXQpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VG9BcnJheShzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXMoc2VlbiwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcHJvcGVydHkgcGF0aCB0byB1bnNldC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsIHx8IGRlbGV0ZSBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVwZGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlciwgY3VzdG9taXplcikge1xuICAgICAgcmV0dXJuIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB1cGRhdGVyKGJhc2VHZXQob2JqZWN0LCBwYXRoKSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kcm9wV2hpbGVgIGFuZCBgXy50YWtlV2hpbGVgXG4gICAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEcm9wXSBTcGVjaWZ5IGRyb3BwaW5nIGVsZW1lbnRzIGluc3RlYWQgb2YgdGFraW5nIHRoZW0uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXaGlsZShhcnJheSwgcHJlZGljYXRlLCBpc0Ryb3AsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xO1xuXG4gICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSAmJlxuICAgICAgICBwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7fVxuXG4gICAgICByZXR1cm4gaXNEcm9wXG4gICAgICAgID8gYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gMCA6IGluZGV4KSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IGxlbmd0aCkpXG4gICAgICAgIDogYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogMCksIChmcm9tUmlnaHQgPyBsZW5ndGggOiBpbmRleCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGB3cmFwcGVyVmFsdWVgIHdoaWNoIHJldHVybnMgdGhlIHJlc3VsdCBvZlxuICAgICAqIHBlcmZvcm1pbmcgYSBzZXF1ZW5jZSBvZiBhY3Rpb25zIG9uIHRoZSB1bndyYXBwZWQgYHZhbHVlYCwgd2hlcmUgZWFjaFxuICAgICAqIHN1Y2Nlc3NpdmUgYWN0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYWN0aW9ucyBBY3Rpb25zIHRvIHBlcmZvcm0gdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV3JhcHBlclZhbHVlKHZhbHVlLCBhY3Rpb25zKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnZhbHVlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UoYWN0aW9ucywgZnVuY3Rpb24ocmVzdWx0LCBhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbi5mdW5jLmFwcGx5KGFjdGlvbi50aGlzQXJnLCBhcnJheVB1c2goW3Jlc3VsdF0sIGFjdGlvbi5hcmdzKSk7XG4gICAgICB9LCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy54b3JgLCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VYb3IoYXJyYXlzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVVuaXEoYXJyYXlzWzBdKSA6IFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW2luZGV4XSxcbiAgICAgICAgICAgIG90aEluZGV4ID0gLTE7XG5cbiAgICAgICAgd2hpbGUgKCsrb3RoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAob3RoSW5kZXggIT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBiYXNlRGlmZmVyZW5jZShyZXN1bHRbaW5kZXhdIHx8IGFycmF5LCBhcnJheXNbb3RoSW5kZXhdLCBpdGVyYXRlZSwgY29tcGFyYXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4ocmVzdWx0LCAxKSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy56aXBPYmplY3RgIHdoaWNoIGFzc2lnbnMgdmFsdWVzIHVzaW5nIGBhc3NpZ25GdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbkZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlWmlwT2JqZWN0KHByb3BzLCB2YWx1ZXMsIGFzc2lnbkZ1bmMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICB2YWxzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5kZXggPCB2YWxzTGVuZ3RoID8gdmFsdWVzW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgYXNzaWduRnVuYyhyZXN1bHQsIHByb3BzW2luZGV4XSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGFuIGVtcHR5IGFycmF5IGlmIGl0J3Mgbm90IGFuIGFycmF5IGxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGNhc3QgYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEFycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGlkZW50aXR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBgYmFzZVJlc3RgIGFsaWFzIHdoaWNoIGNhbiBiZSByZXBsYWNlZCB3aXRoIGBpZGVudGl0eWAgYnkgbW9kdWxlXG4gICAgICogcmVwbGFjZW1lbnQgcGx1Z2lucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdmFyIGNhc3RSZXN0ID0gYmFzZVJlc3Q7XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgYXJyYXlgIHRvIGEgc2xpY2UgaWYgaXQncyBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBzbGljZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcbiAgICAgIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIHRoZSBnbG9iYWwgW2BjbGVhclRpbWVvdXRgXShodHRwczovL21kbi5pby9jbGVhclRpbWVvdXQpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcnxPYmplY3R9IGlkIFRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdCBvZiB0aGUgdGltZXIgdG8gY2xlYXIuXG4gICAgICovXG4gICAgdmFyIGNsZWFyVGltZW91dCA9IGN0eENsZWFyVGltZW91dCB8fCBmdW5jdGlvbihpZCkge1xuICAgICAgcmV0dXJuIHJvb3QuY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBtYXBgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgbWFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lTWFwKG1hcCwgaXNEZWVwLCBjbG9uZUZ1bmMpIHtcbiAgICAgIHZhciBhcnJheSA9IGlzRGVlcCA/IGNsb25lRnVuYyhtYXBUb0FycmF5KG1hcCksIENMT05FX0RFRVBfRkxBRykgOiBtYXBUb0FycmF5KG1hcCk7XG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UoYXJyYXksIGFkZE1hcEVudHJ5LCBuZXcgbWFwLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICAgICAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHNldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVNldChzZXQsIGlzRGVlcCwgY2xvbmVGdW5jKSB7XG4gICAgICB2YXIgYXJyYXkgPSBpc0RlZXAgPyBjbG9uZUZ1bmMoc2V0VG9BcnJheShzZXQpLCBDTE9ORV9ERUVQX0ZMQUcpIDogc2V0VG9BcnJheShzZXQpO1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKGFycmF5LCBhZGRTZXRFbnRyeSwgbmV3IHNldC5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gICAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gICAgICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gICAgICpcbiAgICAgKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICAgICAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAgICAgKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcbiAgICAgICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXIgPT0gJ2Rlc2MnID8gLTEgOiAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAgICAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgICAgIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gICAgICogcGxhY2Vob2xkZXJzLCBhbmQgcHJvdmlkZWQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZWZ0TGVuZ3RoICsgcmFuZ2VMZW5ndGgpLFxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChyYW5nZUxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXgrK10gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBjb21wb3NlQXJnc2AgZXhjZXB0IHRoYXQgdGhlIGFyZ3VtZW50cyBjb21wb3NpdGlvblxuICAgICAqIGlzIHRhaWxvcmVkIGZvciBgXy5wYXJ0aWFsUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzSW5kZXggPSAtMSxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgcmlnaHRJbmRleCA9IC0xLFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShyYW5nZUxlbmd0aCArIHJpZ2h0TGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IHJhbmdlTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IGFyZ3NJbmRleDtcbiAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgcmlnaHRJbmRleF0gPSBwYXJ0aWFsc1tyaWdodEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbb2Zmc2V0ICsgaG9sZGVyc1tob2xkZXJzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICAgICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgICAgIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05ldykge1xuICAgICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5ncm91cEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGFjY3VtdWxhdG9yIG9iamVjdCBpbml0aWFsaXplci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyLCBpbml0aWFsaXplcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5QWdncmVnYXRvciA6IGJhc2VBZ2dyZWdhdG9yLFxuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBpbml0aWFsaXplciA/IGluaXRpYWxpemVyKCkgOiB7fTtcblxuICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBzZXR0ZXIsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYWNjdW11bGF0b3IpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5sb3dlckZpcnN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBTdHJpbmdgIGNhc2UgbWV0aG9kIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdChtZXRob2ROYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHZhciBjaHIgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgICAgIHZhciB0cmFpbGluZyA9IHN0clN5bWJvbHNcbiAgICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxuICAgICAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgICAgIHJldHVybiBjaHJbbWV0aG9kTmFtZV0oKSArIHRyYWlsaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5jYW1lbENhc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBhcnJheVJlZHVjZSh3b3JkcyhkZWJ1cnIoc3RyaW5nKS5yZXBsYWNlKHJlQXBvcywgJycpKSwgY2FsbGJhY2ssICcnKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gaW5zdGFuY2Ugb2YgYEN0b3JgIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3RvcihDdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFVzZSBhIGBzd2l0Y2hgIHN0YXRlbWVudCB0byB3b3JrIHdpdGggY2xhc3MgY29uc3RydWN0b3JzLiBTZWVcbiAgICAgICAgLy8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQ3RvcjtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICBjYXNlIDc6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuXG4gICAgICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBlbmFibGUgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJpdHkgVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KSB7XG4gICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob2xkZXJzID0gKGxlbmd0aCA8IDMgJiYgYXJnc1swXSAhPT0gcGxhY2Vob2xkZXIgJiYgYXJnc1tsZW5ndGggLSAxXSAhPT0gcGxhY2Vob2xkZXIpXG4gICAgICAgICAgPyBbXVxuICAgICAgICAgIDogcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuXG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFyZ3MsIGhvbGRlcnMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSAtIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUgPyBjb2xsZWN0aW9uW2luZGV4XSA6IGluZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZsb3dgIG9yIGBfLmZsb3dSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsb3cgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihmdW5jcykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gZnVuY3MubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwcmVyZXEgPSBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS50aHJ1O1xuXG4gICAgICAgIGlmIChmcm9tUmlnaHQpIHtcbiAgICAgICAgICBmdW5jcy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlcmVxICYmICF3cmFwcGVyICYmIGdldEZ1bmNOYW1lKGZ1bmMpID09ICd3cmFwcGVyJykge1xuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBuZXcgTG9kYXNoV3JhcHBlcihbXSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gd3JhcHBlciA/IGluZGV4IDogbGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGZ1bmMgPSBmdW5jc1tpbmRleF07XG5cbiAgICAgICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICAgICAgZGF0YSA9IGZ1bmNOYW1lID09ICd3cmFwcGVyJyA/IGdldERhdGEoZnVuYykgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoZGF0YSAmJiBpc0xhemlhYmxlKGRhdGFbMF0pICYmXG4gICAgICAgICAgICAgICAgZGF0YVsxXSA9PSAoV1JBUF9BUllfRkxBRyB8IFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9SRUFSR19GTEFHKSAmJlxuICAgICAgICAgICAgICAgICFkYXRhWzRdLmxlbmd0aCAmJiBkYXRhWzldID09IDFcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlcltnZXRGdW5jTmFtZShkYXRhWzBdKV0uYXBwbHkod3JhcHBlciwgZGF0YVszXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSAoZnVuYy5sZW5ndGggPT0gMSAmJiBpc0xhemlhYmxlKGZ1bmMpKVxuICAgICAgICAgICAgICA/IHdyYXBwZXJbZnVuY05hbWVdKClcbiAgICAgICAgICAgICAgOiB3cmFwcGVyLnRocnUoZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuXG4gICAgICAgICAgaWYgKHdyYXBwZXIgJiYgYXJncy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIucGxhbnQodmFsdWUpLnZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGxlbmd0aCA/IGZ1bmNzW2luZGV4XS5hcHBseSh0aGlzLCBhcmdzKSA6IHZhbHVlO1xuXG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNzW2luZGV4XS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AsIHBhcnRpYWwgYXBwbGljYXRpb24sIGFuZCBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzUmlnaHRdIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkXG4gICAgICogIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNSaWdodF0gVGhlIGBwYXJ0aWFsc1JpZ2h0YCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUh5YnJpZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBXUkFQX0FSWV9GTEFHLFxuICAgICAgICAgIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHLFxuICAgICAgICAgIGlzQ3VycmllZCA9IGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSxcbiAgICAgICAgICBpc0ZsaXAgPSBiaXRtYXNrICYgV1JBUF9GTElQX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDdXJyaWVkKSB7XG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpLFxuICAgICAgICAgICAgICBob2xkZXJzQ291bnQgPSBjb3VudEhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFscykge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHNSaWdodCkge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggLT0gaG9sZGVyc0NvdW50O1xuICAgICAgICBpZiAoaXNDdXJyaWVkICYmIGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgdmFyIG5ld0hvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHRoaXNBcmcsXG4gICAgICAgICAgICBhcmdzLCBuZXdIb2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkgLSBsZW5ndGhcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLFxuICAgICAgICAgICAgZm4gPSBpc0JpbmRLZXkgPyB0aGlzQmluZGluZ1tmdW5jXSA6IGZ1bmM7XG5cbiAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICAgIGlmIChhcmdQb3MpIHtcbiAgICAgICAgICBhcmdzID0gcmVvcmRlcihhcmdzLCBhcmdQb3MpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcCAmJiBsZW5ndGggPiAxKSB7XG4gICAgICAgICAgYXJncy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJ5ICYmIGFyeSA8IGxlbmd0aCkge1xuICAgICAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpIHtcbiAgICAgICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3Rvcihmbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmludmVydEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRvSXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgaXRlcmF0ZWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludmVydGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmVydGVyKHNldHRlciwgdG9JdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZlcnRlcihvYmplY3QsIHNldHRlciwgdG9JdGVyYXRlZShpdGVyYXRlZSksIHt9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSB1c2VkIGZvciBgdW5kZWZpbmVkYCBhcmd1bWVudHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVNYXRoT3BlcmF0aW9uKG9wZXJhdG9yLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9TdHJpbmcob3RoZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBvdGhlciA9IGJhc2VUb051bWJlcihvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ub3ZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBvdmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU92ZXIoYXJyYXlGdW5jKSB7XG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oaXRlcmF0ZWVzKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcbiAgICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICB2YXIgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGFycmF5RnVuYyhpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgIGJhc2VkIG9uIGBsZW5ndGhgLiBUaGUgYGNoYXJzYCBzdHJpbmdcbiAgICAgKiBpcyB0cnVuY2F0ZWQgaWYgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGV4Y2VlZHMgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWRkaW5nKGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIGNoYXJzID0gY2hhcnMgPT09IHVuZGVmaW5lZCA/ICcgJyA6IGJhc2VUb1N0cmluZyhjaGFycyk7XG5cbiAgICAgIHZhciBjaGFyc0xlbmd0aCA9IGNoYXJzLmxlbmd0aDtcbiAgICAgIGlmIChjaGFyc0xlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJzTGVuZ3RoID8gYmFzZVJlcGVhdChjaGFycywgbGVuZ3RoKSA6IGNoYXJzO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VSZXBlYXQoY2hhcnMsIG5hdGl2ZUNlaWwobGVuZ3RoIC8gc3RyaW5nU2l6ZShjaGFycykpKTtcbiAgICAgIHJldHVybiBoYXNVbmljb2RlKGNoYXJzKVxuICAgICAgICA/IGNhc3RTbGljZShzdHJpbmdUb0FycmF5KHJlc3VsdCksIDAsIGxlbmd0aCkuam9pbignJylcbiAgICAgICAgOiByZXN1bHQuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nXG4gICAgICogb2YgYHRoaXNBcmdgIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCksXG4gICAgICAgICAgICBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG5cbiAgICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzWysrYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJhbmdlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgICAgaWYgKHN0ZXAgJiYgdHlwZW9mIHN0ZXAgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyAoc3RhcnQgPCBlbmQgPyAxIDogLTEpIDogdG9GaW5pdGUoc3RlcCk7XG4gICAgICAgIHJldHVybiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSByZWxhdGlvbmFsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlbGF0aW9uYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24ob3BlcmF0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnICYmIHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBvdGhlciA9IHRvTnVtYmVyKG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGNvbnRpbnVlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgYGZ1bmNgIHdyYXBwZXIuXG4gICAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlY3VycnkoZnVuYywgYml0bWFzaywgd3JhcEZ1bmMsIHBsYWNlaG9sZGVyLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNDdXJyeSA9IGJpdG1hc2sgJiBXUkFQX0NVUlJZX0ZMQUcsXG4gICAgICAgICAgbmV3SG9sZGVycyA9IGlzQ3VycnkgPyBob2xkZXJzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBob2xkZXJzLFxuICAgICAgICAgIG5ld1BhcnRpYWxzID0gaXNDdXJyeSA/IHBhcnRpYWxzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogcGFydGlhbHM7XG5cbiAgICAgIGJpdG1hc2sgfD0gKGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfRkxBRyA6IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgIGJpdG1hc2sgJj0gfihpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgOiBXUkFQX1BBUlRJQUxfRkxBRyk7XG5cbiAgICAgIGlmICghKGJpdG1hc2sgJiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgbmV3UGFydGlhbHMsIG5ld0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsXG4gICAgICAgIG5ld0hvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gd3JhcEZ1bmMuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIGlmIChpc0xhemlhYmxlKGZ1bmMpKSB7XG4gICAgICAgIHNldERhdGEocmVzdWx0LCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhyZXN1bHQsIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLnJvdW5kYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBNYXRoYCBtZXRob2QgdG8gdXNlIHdoZW4gcm91bmRpbmcuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUm91bmQobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBNYXRoW21ldGhvZE5hbWVdO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG51bWJlciwgcHJlY2lzaW9uKSB7XG4gICAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PSBudWxsID8gMCA6IG5hdGl2ZU1pbih0b0ludGVnZXIocHJlY2lzaW9uKSwgMjkyKTtcbiAgICAgICAgaWYgKHByZWNpc2lvbikge1xuICAgICAgICAgIC8vIFNoaWZ0IHdpdGggZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYXZvaWQgZmxvYXRpbmctcG9pbnQgaXNzdWVzLlxuICAgICAgICAgIC8vIFNlZSBbTUROXShodHRwczovL21kbi5pby9yb3VuZCNFeGFtcGxlcykgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICB2YXIgcGFpciA9ICh0b1N0cmluZyhudW1iZXIpICsgJ2UnKS5zcGxpdCgnZScpLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGZ1bmMocGFpclswXSArICdlJyArICgrcGFpclsxXSArIHByZWNpc2lvbikpO1xuXG4gICAgICAgICAgcGFpciA9ICh0b1N0cmluZyh2YWx1ZSkgKyAnZScpLnNwbGl0KCdlJyk7XG4gICAgICAgICAgcmV0dXJuICsocGFpclswXSArICdlJyArICgrcGFpclsxXSAtIHByZWNpc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jKG51bWJlcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICAgICAqL1xuICAgIHZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8udG9QYWlyc2Agb3IgYF8udG9QYWlyc0luYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYWlycyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVUb1BhaXJzKGtleXNGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcob2JqZWN0KTtcbiAgICAgICAgaWYgKHRhZyA9PSBtYXBUYWcpIHtcbiAgICAgICAgICByZXR1cm4gbWFwVG9BcnJheShvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvUGFpcnMob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZVRvUGFpcnMob2JqZWN0LCBrZXlzRnVuYyhvYmplY3QpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZWl0aGVyIGN1cnJpZXMgb3IgaW52b2tlcyBgZnVuY2Agd2l0aCBvcHRpb25hbFxuICAgICAqIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAgIDEgLSBgXy5iaW5kYFxuICAgICAqICAgIDIgLSBgXy5iaW5kS2V5YFxuICAgICAqICAgIDQgLSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgb2YgYSBib3VuZCBmdW5jdGlvblxuICAgICAqICAgIDggLSBgXy5jdXJyeWBcbiAgICAgKiAgIDE2IC0gYF8uY3VycnlSaWdodGBcbiAgICAgKiAgIDMyIC0gYF8ucGFydGlhbGBcbiAgICAgKiAgIDY0IC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqICAxMjggLSBgXy5yZWFyZ2BcbiAgICAgKiAgMjU2IC0gYF8uYXJ5YFxuICAgICAqICA1MTIgLSBgXy5mbGlwYFxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAoIWlzQmluZEtleSAmJiB0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXJ0aWFscyA/IHBhcnRpYWxzLmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGFyeSA9IGFyeSA9PT0gdW5kZWZpbmVkID8gYXJ5IDogbmF0aXZlTWF4KHRvSW50ZWdlcihhcnkpLCAwKTtcbiAgICAgIGFyaXR5ID0gYXJpdHkgPT09IHVuZGVmaW5lZCA/IGFyaXR5IDogdG9JbnRlZ2VyKGFyaXR5KTtcbiAgICAgIGxlbmd0aCAtPSBob2xkZXJzID8gaG9sZGVycy5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAoYml0bWFzayAmIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsc1JpZ2h0ID0gcGFydGlhbHMsXG4gICAgICAgICAgICBob2xkZXJzUmlnaHQgPSBob2xkZXJzO1xuXG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogZ2V0RGF0YShmdW5jKTtcblxuICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsXG4gICAgICAgIGFyZ1BvcywgYXJ5LCBhcml0eVxuICAgICAgXTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgbWVyZ2VEYXRhKG5ld0RhdGEsIGRhdGEpO1xuICAgICAgfVxuICAgICAgZnVuYyA9IG5ld0RhdGFbMF07XG4gICAgICBiaXRtYXNrID0gbmV3RGF0YVsxXTtcbiAgICAgIHRoaXNBcmcgPSBuZXdEYXRhWzJdO1xuICAgICAgcGFydGlhbHMgPSBuZXdEYXRhWzNdO1xuICAgICAgaG9sZGVycyA9IG5ld0RhdGFbNF07XG4gICAgICBhcml0eSA9IG5ld0RhdGFbOV0gPSBuZXdEYXRhWzldID09PSB1bmRlZmluZWRcbiAgICAgICAgPyAoaXNCaW5kS2V5ID8gMCA6IGZ1bmMubGVuZ3RoKVxuICAgICAgICA6IG5hdGl2ZU1heChuZXdEYXRhWzldIC0gbGVuZ3RoLCAwKTtcblxuICAgICAgaWYgKCFhcml0eSAmJiBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRykpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyk7XG4gICAgICB9XG4gICAgICBpZiAoIWJpdG1hc2sgfHwgYml0bWFzayA9PSBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKTtcbiAgICAgIH0gZWxzZSBpZiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcgfHwgYml0bWFzayA9PSBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpO1xuICAgICAgfSBlbHNlIGlmICgoYml0bWFzayA9PSBXUkFQX1BBUlRJQUxfRkxBRyB8fCBiaXRtYXNrID09IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHKSkgJiYgIWhvbGRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICB2YXIgc2V0dGVyID0gZGF0YSA/IGJhc2VTZXREYXRhIDogc2V0RGF0YTtcbiAgICAgIHJldHVybiBzZXRXcmFwVG9TdHJpbmcoc2V0dGVyKHJlc3VsdCwgbmV3RGF0YSksIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xuICAgICAqIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzXG4gICAgICogdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNBc3NpZ25JbihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICByZXR1cm4gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c0RlZXBgIHRvIGN1c3RvbWl6ZSBpdHMgYF8ubWVyZ2VgIHVzZSB0byBtZXJnZSBzb3VyY2VcbiAgICAgKiBvYmplY3RzIGludG8gZGVzdGluYXRpb24gb2JqZWN0cyB0aGF0IGFyZSBwYXNzZWQgdGhydS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHBhcmVudCBvYmplY3Qgb2YgYHNyY1ZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c01lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIHtcbiAgICAgIGlmIChpc09iamVjdChvYmpWYWx1ZSkgJiYgaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG9ialZhbHVlKTtcbiAgICAgICAgYmFzZU1lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwgdW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vbWl0YCB0byBjdXN0b21pemUgaXRzIGBfLmNsb25lRGVlcGAgdXNlIHRvIG9ubHkgY2xvbmUgcGxhaW5cbiAgICAgKiBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW5jbG9uZWQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgdG8gZGVmZXIgY2xvbmluZyB0byBgXy5jbG9uZURlZXBgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbU9taXRDbG9uZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICAgICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gICAgICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICAgICAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gICAgICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAgICAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAgICAgKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICAgICAgY2FzZSBlcnJvclRhZzpcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gICAgICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gICAgICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgICAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZ1bmNOYW1lKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSAoZnVuYy5uYW1lICsgJycpLFxuICAgICAgICAgIGFycmF5ID0gcmVhbE5hbWVzW3Jlc3VsdF0sXG4gICAgICAgICAgbGVuZ3RoID0gaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIHJlc3VsdCkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBhcnJheVtsZW5ndGhdLFxuICAgICAgICAgICAgb3RoZXJGdW5jID0gZGF0YS5mdW5jO1xuICAgICAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFyZ3VtZW50IHBsYWNlaG9sZGVyIHZhbHVlIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcihmdW5jKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gsICdwbGFjZWhvbGRlcicpID8gbG9kYXNoIDogZnVuYztcbiAgICAgIHJldHVybiBvYmplY3QucGxhY2Vob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpdGVyYXRlZVwiIGZ1bmN0aW9uLiBJZiBgXy5pdGVyYXRlZWAgaXMgY3VzdG9taXplZCxcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBiYXNlSXRlcmF0ZWVgLlxuICAgICAqIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIHRoZSBjaG9zZW4gZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiB0aGUgY3JlYXRlZCBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdGVlKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaC5pdGVyYXRlZSB8fCBpdGVyYXRlZTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gaXRlcmF0ZWUgPyBiYXNlSXRlcmF0ZWUgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHJlc3VsdChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgICAgIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgICAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgICAgICA6IGRhdGEubWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICAgICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgaWYgKHVubWFza2VkKSB7XG4gICAgICAgIGlmIChpc093bikge1xuICAgICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIHZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4gICAgLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuICAgIGlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAgICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgICAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAgICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICAgICAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgICAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZpZXcsIGFwcGx5aW5nIGFueSBgdHJhbnNmb3Jtc2AgdG8gdGhlIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtcyBUaGUgdHJhbnNmb3JtYXRpb25zIHRvIGFwcGx5IHRvIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzdGFydGAgYW5kIGBlbmRgXG4gICAgICogIHBvc2l0aW9ucyBvZiB0aGUgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRWaWV3KHN0YXJ0LCBlbmQsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRyYW5zZm9ybXNbaW5kZXhdLFxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2Ryb3AnOiAgICAgIHN0YXJ0ICs9IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Ryb3BSaWdodCc6IGVuZCAtPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlJzogICAgICBlbmQgPSBuYXRpdmVNaW4oZW5kLCBzdGFydCArIHNpemUpOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlUmlnaHQnOiBzdGFydCA9IG5hdGl2ZU1heChzdGFydCwgZW5kIC0gc2l6ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyAnc3RhcnQnOiBzdGFydCwgJ2VuZCc6IGVuZCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHdyYXBwZXIgZGV0YWlscyBmcm9tIHRoZSBgc291cmNlYCBib2R5IGNvbW1lbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd3JhcHBlciBkZXRhaWxzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFdyYXBEZXRhaWxzKHNvdXJjZSkge1xuICAgICAgdmFyIG1hdGNoID0gc291cmNlLm1hdGNoKHJlV3JhcERldGFpbHMpO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQocmVTcGxpdERldGFpbHMpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICAgICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgICAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICAgICAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICAgICAgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGNsb25lRnVuYywgaXNEZWVwKSB7XG4gICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICAgICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVNYXAob2JqZWN0LCBpc0RlZXAsIGNsb25lRnVuYyk7XG5cbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVNldChvYmplY3QsIGlzRGVlcCwgY2xvbmVGdW5jKTtcblxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHdyYXBwZXIgYGRldGFpbHNgIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBgc291cmNlYCBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gbW9kaWZ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBpbnNlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc291cmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgZGV0YWlscykge1xuICAgICAgdmFyIGxlbmd0aCA9IGRldGFpbHMubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgZGV0YWlsc1tsYXN0SW5kZXhdID0gKGxlbmd0aCA+IDEgPyAnJiAnIDogJycpICsgZGV0YWlsc1tsYXN0SW5kZXhdO1xuICAgICAgZGV0YWlscyA9IGRldGFpbHMuam9pbihsZW5ndGggPiAyID8gJywgJyA6ICcgJyk7XG4gICAgICByZXR1cm4gc291cmNlLnJlcGxhY2UocmVXcmFwQ29tbWVudCwgJ3tcXG4vKiBbd3JhcHBlZCB3aXRoICcgKyBkZXRhaWxzICsgJ10gKi9cXG4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgICAgIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgICAgICkge1xuICAgICAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICAgICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgICAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xhemlhYmxlKGZ1bmMpIHtcbiAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgICAgIG90aGVyID0gbG9kYXNoW2Z1bmNOYW1lXTtcblxuICAgICAgaWYgKHR5cGVvZiBvdGhlciAhPSAnZnVuY3Rpb24nIHx8ICEoZnVuY05hbWUgaW4gTGF6eVdyYXBwZXIucHJvdG90eXBlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZnVuYyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGdldERhdGEob3RoZXIpO1xuICAgICAgcmV0dXJuICEhZGF0YSAmJiBmdW5jID09PSBkYXRhWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgICAgIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBpcyBjYXBhYmxlIG9mIGJlaW5nIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrYWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIHZhciBpc01hc2thYmxlID0gY29yZUpzRGF0YSA/IGlzRnVuY3Rpb24gOiBzdHViRmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gICAgICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gICAgICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAgICAgKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAgICAgKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAgICAgKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgICAgICBjYWNoZS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdGhlIGZ1bmN0aW9uIG1ldGFkYXRhIG9mIGBzb3VyY2VgIGludG8gYGRhdGFgLlxuICAgICAqXG4gICAgICogTWVyZ2luZyBtZXRhZGF0YSByZWR1Y2VzIHRoZSBudW1iZXIgb2Ygd3JhcHBlcnMgdXNlZCB0byBpbnZva2UgYSBmdW5jdGlvbi5cbiAgICAgKiBUaGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgbWV0aG9kcyBsaWtlIGBfLmJpbmRgLCBgXy5jdXJyeWAsIGFuZCBgXy5wYXJ0aWFsYFxuICAgICAqIG1heSBiZSBhcHBsaWVkIHJlZ2FyZGxlc3Mgb2YgZXhlY3V0aW9uIG9yZGVyLiBNZXRob2RzIGxpa2UgYF8uYXJ5YCBhbmRcbiAgICAgKiBgXy5yZWFyZ2AgbW9kaWZ5IGZ1bmN0aW9uIGFyZ3VtZW50cywgbWFraW5nIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFyZVxuICAgICAqIGV4ZWN1dGVkIGltcG9ydGFudCwgcHJldmVudGluZyB0aGUgbWVyZ2luZyBvZiBtZXRhZGF0YS4gSG93ZXZlciwgd2UgbWFrZVxuICAgICAqIGFuIGV4Y2VwdGlvbiBmb3IgYSBzYWZlIGNvbWJpbmVkIGNhc2Ugd2hlcmUgY3VycmllZCBmdW5jdGlvbnMgaGF2ZSBgXy5hcnlgXG4gICAgICogYW5kIG9yIGBfLnJlYXJnYCBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIFRoZSBkZXN0aW5hdGlvbiBtZXRhZGF0YS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIHNvdXJjZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRhdGFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlRGF0YShkYXRhLCBzb3VyY2UpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gZGF0YVsxXSxcbiAgICAgICAgICBzcmNCaXRtYXNrID0gc291cmNlWzFdLFxuICAgICAgICAgIG5ld0JpdG1hc2sgPSBiaXRtYXNrIHwgc3JjQml0bWFzayxcbiAgICAgICAgICBpc0NvbW1vbiA9IG5ld0JpdG1hc2sgPCAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcgfCBXUkFQX0FSWV9GTEFHKTtcblxuICAgICAgdmFyIGlzQ29tYm8gPVxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSkgfHxcbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfUkVBUkdfRkxBRykgJiYgKGRhdGFbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkpIHx8XG4gICAgICAgICgoc3JjQml0bWFzayA9PSAoV1JBUF9BUllfRkxBRyB8IFdSQVBfUkVBUkdfRkxBRykpICYmIChzb3VyY2VbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSk7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgbWV0YWRhdGEgY2FuJ3QgYmUgbWVyZ2VkLlxuICAgICAgaWYgKCEoaXNDb21tb24gfHwgaXNDb21ibykpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGB0aGlzQXJnYCBpZiBhdmFpbGFibGUuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQklORF9GTEFHKSB7XG4gICAgICAgIGRhdGFbMl0gPSBzb3VyY2VbMl07XG4gICAgICAgIC8vIFNldCB3aGVuIGN1cnJ5aW5nIGEgYm91bmQgZnVuY3Rpb24uXG4gICAgICAgIG5ld0JpdG1hc2sgfD0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHID8gMCA6IFdSQVBfQ1VSUllfQk9VTkRfRkxBRztcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCBhcmd1bWVudHMuXG4gICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbM107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzID0gZGF0YVszXTtcbiAgICAgICAgZGF0YVszXSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3MocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNF0pIDogdmFsdWU7XG4gICAgICAgIGRhdGFbNF0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbM10sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs0XTtcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCByaWdodCBhcmd1bWVudHMuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs1XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBwYXJ0aWFscyA9IGRhdGFbNV07XG4gICAgICAgIGRhdGFbNV0gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzUmlnaHQocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNl0pIDogdmFsdWU7XG4gICAgICAgIGRhdGFbNl0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbNV0sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs2XTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyZ1Bvc2AgaWYgYXZhaWxhYmxlLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbN107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZGF0YVs3XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJ5YCBpZiBpdCdzIHNtYWxsZXIuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQVJZX0ZMQUcpIHtcbiAgICAgICAgZGF0YVs4XSA9IGRhdGFbOF0gPT0gbnVsbCA/IHNvdXJjZVs4XSA6IG5hdGl2ZU1pbihkYXRhWzhdLCBzb3VyY2VbOF0pO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJpdHlgIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG4gICAgICBpZiAoZGF0YVs5XSA9PSBudWxsKSB7XG4gICAgICAgIGRhdGFbOV0gPSBzb3VyY2VbOV07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBmdW5jYCBhbmQgbWVyZ2UgYml0bWFza3MuXG4gICAgICBkYXRhWzBdID0gc291cmNlWzBdO1xuICAgICAgZGF0YVsxXSA9IG5ld0JpdG1hc2s7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICAgICAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICAgKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gICAgICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwYXJlbnQgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byBnZXQgdGhlIHBhcmVudCB2YWx1ZSBvZi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGFyZW50IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcmVudChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IDIgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVvcmRlciBgYXJyYXlgIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGluZGV4ZXMgd2hlcmUgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgZmlyc3QgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIGZpcnN0IGVsZW1lbnQsIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIHNlY29uZCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgc2Vjb25kIGVsZW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHJlb3JkZXIuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJyYXkgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW9yZGVyKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihpbmRleGVzLmxlbmd0aCwgYXJyTGVuZ3RoKSxcbiAgICAgICAgICBvbGRBcnJheSA9IGNvcHlBcnJheShhcnJheSk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGFycmF5W2xlbmd0aF0gPSBpc0luZGV4KGluZGV4LCBhcnJMZW5ndGgpID8gb2xkQXJyYXlbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiB0aGlzIGZ1bmN0aW9uIGJlY29tZXMgaG90LCBpLmUuIGlzIGludm9rZWQgYSBsb3QgaW4gYSBzaG9ydFxuICAgICAqIHBlcmlvZCBvZiB0aW1lLCBpdCB3aWxsIHRyaXAgaXRzIGJyZWFrZXIgYW5kIHRyYW5zaXRpb24gdG8gYW4gaWRlbnRpdHlcbiAgICAgKiBmdW5jdGlvbiB0byBhdm9pZCBnYXJiYWdlIGNvbGxlY3Rpb24gcGF1c2VzIGluIFY4LiBTZWVcbiAgICAgKiBbVjggaXNzdWUgMjA3MF0oaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjA3MClcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldERhdGEgPSBzaG9ydE91dChiYXNlU2V0RGF0YSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgc2V0VGltZW91dGBdKGh0dHBzOi8vbWRuLmlvL3NldFRpbWVvdXQpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9cbiAgICB2YXIgc2V0VGltZW91dCA9IGN0eFNldFRpbWVvdXQgfHwgZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgICAgcmV0dXJuIHJvb3Quc2V0VGltZW91dChmdW5jLCB3YWl0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYHdyYXBwZXJgIHRvIG1pbWljIHRoZSBzb3VyY2Ugb2YgYHJlZmVyZW5jZWBcbiAgICAgKiB3aXRoIHdyYXBwZXIgZGV0YWlscyBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgc291cmNlIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWZlcmVuY2UgVGhlIHJlZmVyZW5jZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgd3JhcHBlcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0V3JhcFRvU3RyaW5nKHdyYXBwZXIsIHJlZmVyZW5jZSwgYml0bWFzaykge1xuICAgICAgdmFyIHNvdXJjZSA9IChyZWZlcmVuY2UgKyAnJyk7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcod3JhcHBlciwgaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCB1cGRhdGVXcmFwRGV0YWlscyhnZXRXcmFwRGV0YWlscyhzb3VyY2UpLCBiaXRtYXNrKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICAgICAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICAgICAqIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgICAgIHZhciBjb3VudCA9IDAsXG4gICAgICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCB3aGljaCBtdXRhdGVzIGFuZCBzZXRzIHRoZSBzaXplIG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT1hcnJheS5sZW5ndGhdIFRoZSBzaXplIG9mIGBhcnJheWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZVNlbGYoYXJyYXksIHNpemUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gICAgICBzaXplID0gc2l6ZSA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogc2l6ZTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgc2l6ZSkge1xuICAgICAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oaW5kZXgsIGxhc3RJbmRleCksXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuXG4gICAgICAgIGFycmF5W3JhbmRdID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGFycmF5Lmxlbmd0aCA9IHNpemU7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICovXG4gICAgdmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAocmVMZWFkaW5nRG90LnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgICB9XG4gICAgICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3RyaW5nKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICAgICAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB3cmFwcGVyIGBkZXRhaWxzYCBiYXNlZCBvbiBgYml0bWFza2AgZmxhZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRldGFpbHNgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVdyYXBEZXRhaWxzKGRldGFpbHMsIGJpdG1hc2spIHtcbiAgICAgIGFycmF5RWFjaCh3cmFwRmxhZ3MsIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJ18uJyArIHBhaXJbMF07XG4gICAgICAgIGlmICgoYml0bWFzayAmIHBhaXJbMV0pICYmICFhcnJheUluY2x1ZGVzKGRldGFpbHMsIHZhbHVlKSkge1xuICAgICAgICAgIGRldGFpbHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRldGFpbHMuc29ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgd3JhcHBlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB3cmFwcGVyIFRoZSB3cmFwcGVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB3cmFwcGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDbG9uZSh3cmFwcGVyKSB7XG4gICAgICBpZiAod3JhcHBlciBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJldHVybiB3cmFwcGVyLmNsb25lKCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlci5fX3dyYXBwZWRfXywgd3JhcHBlci5fX2NoYWluX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHdyYXBwZXIuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9faW5kZXhfXyAgPSB3cmFwcGVyLl9faW5kZXhfXztcbiAgICAgIHJlc3VsdC5fX3ZhbHVlc19fID0gd3JhcHBlci5fX3ZhbHVlc19fO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gZ3JvdXBzIHRoZSBsZW5ndGggb2YgYHNpemVgLlxuICAgICAqIElmIGBhcnJheWAgY2FuJ3QgYmUgc3BsaXQgZXZlbmx5LCB0aGUgZmluYWwgY2h1bmsgd2lsbCBiZSB0aGUgcmVtYWluaW5nXG4gICAgICogZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9MV0gVGhlIGxlbmd0aCBvZiBlYWNoIGNodW5rXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjaHVua3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDIpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbJ2MnLCAnZCddXVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMyk7XG4gICAgICogLy8gPT4gW1snYScsICdiJywgJ2MnXSwgWydkJ11dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2h1bmsoYXJyYXksIHNpemUsIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIHNpemUsIGd1YXJkKSA6IHNpemUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gbmF0aXZlTWF4KHRvSW50ZWdlcihzaXplKSwgMCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCB8fCBzaXplIDwgMSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuYXRpdmVDZWlsKGxlbmd0aCAvIHNpemUpKTtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IGJhc2VTbGljZShhcnJheSwgaW5kZXgsIChpbmRleCArPSBzaXplKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyByZW1vdmVkLiBUaGUgdmFsdWVzIGBmYWxzZWAsIGBudWxsYCxcbiAgICAgKiBgMGAsIGBcIlwiYCwgYHVuZGVmaW5lZGAsIGFuZCBgTmFOYCBhcmUgZmFsc2V5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFycmF5IGNvbmNhdGVuYXRpbmcgYGFycmF5YCB3aXRoIGFueSBhZGRpdGlvbmFsIGFycmF5c1xuICAgICAqIGFuZC9vciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbmNhdGVuYXRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzFdO1xuICAgICAqIHZhciBvdGhlciA9IF8uY29uY2F0KGFycmF5LCAyLCBbM10sIFtbNF1dKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG90aGVyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGggLSAxKSxcbiAgICAgICAgICBhcnJheSA9IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgYXJnc1tpbmRleCAtIDFdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVB1c2goaXNBcnJheShhcnJheSkgPyBjb3B5QXJyYXkoYXJyYXkpIDogW2FycmF5XSwgYmFzZUZsYXR0ZW4oYXJncywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgYGFycmF5YCB2YWx1ZXMgbm90IGluY2x1ZGVkIGluIHRoZSBvdGhlciBnaXZlbiBhcnJheXNcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8ud2l0aG91dCwgXy54b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRpZmZlcmVuY2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGFuZCBgdmFsdWVzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxCeWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgW3sgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KHZhbHVlcyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBUaGUgb3JkZXIgYW5kXG4gICAgICogcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3JcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbFdpdGhgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlV2l0aChvYmplY3RzLCBbeyAneCc6IDEsICd5JzogMiB9XSwgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdCh2YWx1ZXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGNvbXBhcmF0b3IpKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3AoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIG4gPSBsZW5ndGggLSBuO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWxscyBlbGVtZW50cyBvZiBgYXJyYXlgIHdpdGggYHZhbHVlYCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3RcbiAgICAgKiBpbmNsdWRpbmcsIGBlbmRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXy5maWxsKGFycmF5LCAnYScpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYScsICdhJ11cbiAgICAgKlxuICAgICAqIF8uZmlsbChBcnJheSgzKSwgMik7XG4gICAgICogLy8gPT4gWzIsIDIsIDJdXG4gICAgICpcbiAgICAgKiBfLmZpbGwoWzQsIDYsIDgsIDEwXSwgJyonLCAxLCAzKTtcbiAgICAgKiAvLyA9PiBbNCwgJyonLCAnKicsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgJiYgdHlwZW9mIHN0YXJ0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdwZWJibGVzJzsgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgICBpbmRleCA9IGZyb21JbmRleCA8IDBcbiAgICAgICAgICA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMClcbiAgICAgICAgICA6IG5hdGl2ZU1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVucyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZWVwKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDQsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlZXAoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgSU5GSU5JVFkpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbiBgYXJyYXlgIHVwIHRvIGBkZXB0aGAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCBbMiwgWzMsIFs0XV0sIDVdXTtcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZXB0aChhcnJheSwgMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XSwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVwdGgoYXJyYXksIGRlcHRoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoKTtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLnRvUGFpcnNgOyB0aGlzIG1ldGhvZCByZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZFxuICAgICAqIGZyb20ga2V5LXZhbHVlIGBwYWlyc2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBUaGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZnJvbVBhaXJzKFtbJ2EnLCAxXSwgWydiJywgMl1dKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tUGFpcnMocGFpcnMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W3BhaXJbMF1dID0gcGFpclsxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIGZpcnN0XG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaGVhZChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uaGVhZChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGVhZChhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCBpbiBgYXJyYXlgXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXMgdGhlXG4gICAgICogb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0aWFsKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCAwLCAtMSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBhcmUgaW5jbHVkZWQgaW4gYWxsIGdpdmVuIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbihbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzJdXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludGVyc2VjdGlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbkJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjFdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmludGVyc2VjdGlvbkJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpLFxuICAgICAgICAgIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG5cbiAgICAgIGlmIChpdGVyYXRlZSA9PT0gbGFzdChtYXBwZWQpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwcGVkLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludGVyc2VjdGlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlc1xuICAgICAqIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvciBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyksXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcblxuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgbWFwcGVkLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbGwgZWxlbWVudHMgaW4gYGFycmF5YCBpbnRvIGEgc3RyaW5nIHNlcGFyYXRlZCBieSBgc2VwYXJhdG9yYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2VwYXJhdG9yPScsJ10gVGhlIGVsZW1lbnQgc2VwYXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGpvaW5lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uam9pbihbJ2EnLCAnYicsICdjJ10sICd+Jyk7XG4gICAgICogLy8gPT4gJ2F+Yn5jJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGpvaW4oYXJyYXksIHNlcGFyYXRvcikge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyAnJyA6IG5hdGl2ZUpvaW4uY2FsbChhcnJheSwgc2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbmRleE9mYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGFycmF5YCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICBpZiAoZnJvbUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgaW5kZXggPSBpbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICAgICAgPyBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KVxuICAgICAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgaW5kZXgsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGVsZW1lbnQgYXQgaW5kZXggYG5gIG9mIGBhcnJheWAuIElmIGBuYCBpcyBuZWdhdGl2ZSwgdGhlIG50aFxuICAgICAqIGVsZW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICpcbiAgICAgKiBfLm50aChhcnJheSwgMSk7XG4gICAgICogLy8gPT4gJ2InXG4gICAgICpcbiAgICAgKiBfLm50aChhcnJheSwgLTIpO1xuICAgICAqIC8vID0+ICdjJztcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudGgoYXJyYXksIG4pIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VOdGgoYXJyYXksIHRvSW50ZWdlcihuKSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZ2l2ZW4gdmFsdWVzIGZyb20gYGFycmF5YCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy53aXRob3V0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucmVtb3ZlYFxuICAgICAqIHRvIHJlbW92ZSBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGJ5IHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdhJywgJ2InLCAnYyddO1xuICAgICAqXG4gICAgICogXy5wdWxsKGFycmF5LCAnYScsICdjJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYicsICdiJ11cbiAgICAgKi9cbiAgICB2YXIgcHVsbCA9IGJhc2VSZXN0KHB1bGxBbGwpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdhJywgJ2InLCAnYyddO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsKGFycmF5LCBbJ2EnLCAnYyddKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydiJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGwoYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGFuZCBgdmFsdWVzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VCeWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAzIH0sIHsgJ3gnOiAxIH1dO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsQnkoYXJyYXksIFt7ICd4JzogMSB9LCB7ICd4JzogMyB9XSwgJ3gnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbEJ5KGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsQWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBUaGUgY29tcGFyYXRvciBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlV2l0aGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMywgJ3knOiA0IH0sIHsgJ3gnOiA1LCAneSc6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGxXaXRoKGFycmF5LCBbeyAneCc6IDMsICd5JzogNCB9XSwgXy5pc0VxdWFsKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDUsICd5JzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGxXaXRoKGFycmF5LCB2YWx1ZXMsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGVsZW1lbnRzIGZyb20gYGFycmF5YCBjb3JyZXNwb25kaW5nIHRvIGBpbmRleGVzYCBhbmQgcmV0dXJucyBhblxuICAgICAqIGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmF0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBbaW5kZXhlc10gVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCddO1xuICAgICAqIHZhciBwdWxsZWQgPSBfLnB1bGxBdChhcnJheSwgWzEsIDNdKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYyddXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhwdWxsZWQpO1xuICAgICAqIC8vID0+IFsnYicsICdkJ11cbiAgICAgKi9cbiAgICB2YXIgcHVsbEF0ID0gZmxhdFJlc3QoZnVuY3Rpb24oYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBiYXNlQXQoYXJyYXksIGluZGV4ZXMpO1xuXG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBhcnJheU1hcChpbmRleGVzLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gaXNJbmRleChpbmRleCwgbGVuZ3RoKSA/ICtpbmRleCA6IGluZGV4O1xuICAgICAgfSkuc29ydChjb21wYXJlQXNjZW5kaW5nKSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGBhcnJheWAgdGhhdCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3JcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZmlsdGVyYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucHVsbGBcbiAgICAgKiB0byBwdWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgNF07XG4gICAgICogdmFyIGV2ZW5zID0gXy5yZW1vdmUoYXJyYXksIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZXZlbnMpO1xuICAgICAqIC8vID0+IFsyLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyBgYXJyYXlgIHNvIHRoYXQgdGhlIGZpcnN0IGVsZW1lbnQgYmVjb21lcyB0aGUgbGFzdCwgdGhlIHNlY29uZFxuICAgICAqIGVsZW1lbnQgYmVjb21lcyB0aGUgc2Vjb25kIHRvIGxhc3QsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAgYW5kIGlzIGJhc2VkIG9uXG4gICAgICogW2BBcnJheSNyZXZlcnNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvcmV2ZXJzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLnJldmVyc2UoYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldmVyc2UoYXJyYXkpIHtcbiAgICAgIHJldHVybiBhcnJheSA9PSBudWxsID8gYXJyYXkgOiBuYXRpdmVSZXZlcnNlLmNhbGwoYXJyYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIHVzZWQgaW5zdGVhZCBvZlxuICAgICAqIFtgQXJyYXkjc2xpY2VgXShodHRwczovL21kbi5pby9BcnJheS9zbGljZSkgdG8gZW5zdXJlIGRlbnNlIGFycmF5cyBhcmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZW5kICYmIHR5cGVvZiBlbmQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHN0YXJ0LCBlbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBsb3dlc3QgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFszMCwgNTBdLCA0MCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ueDsgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sICd4Jyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IHBlcmZvcm1zIGEgYmluYXJ5XG4gICAgICogc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXhPZihbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGVxKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaGlnaGVzdFxuICAgICAqIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0b1xuICAgICAqIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXgoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4KGFycmF5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkTGFzdEluZGV4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyXG4gICAgICogc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogNCB9LCB7ICd4JzogNSB9XTtcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sICd4Jyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5sYXN0SW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhPZihbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSkgLSAxO1xuICAgICAgICBpZiAoZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkVW5pcShbMSwgMSwgMl0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZFVuaXEoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5KVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcUJ5YCBleGNlcHQgdGhhdCBpdCdzIGRlc2lnbmVkIGFuZCBvcHRpbWl6ZWRcbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkVW5pcUJ5KFsxLjEsIDEuMiwgMi4zLCAyLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4xLCAyLjNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFpbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhaWwoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDEsIGxlbmd0aCkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLiBFbGVtZW50cyBhcmVcbiAgICAgKiB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgZmFsc2UsIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuIEVsZW1lbnRzXG4gICAgICogYXJlIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBmcm9tIGFsbCBnaXZlbiBhcnJheXMgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb24oWzJdLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIHZhciB1bmlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnlcbiAgICAgKiB3aGljaCB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBSZXN1bHQgdmFsdWVzIGFyZSBjaG9zZW4gZnJvbSB0aGUgZmlyc3RcbiAgICAgKiBhcnJheSBpbiB3aGljaCB0aGUgdmFsdWUgb2NjdXJzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb25CeShbMi4xXSwgWzEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMSwgMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy51bmlvbkJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB1bmlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tXG4gICAgICogdGhlIGZpcnN0IGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnVuaW9uV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSwgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucywgaW4gd2hpY2ggb25seSB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBlYWNoIGVsZW1lbnRcbiAgICAgKiBpcyBrZXB0LiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyXG4gICAgICogaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcShbMiwgMSwgMl0pO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5KSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlXG4gICAgICogb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcUJ5KFsyLjEsIDEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMSwgMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy51bmlxQnkoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xuICAgICAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LlRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnVuaXFXaXRoKG9iamVjdHMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXFXaXRoKGFycmF5LCBjb21wYXJhdG9yKSB7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIGdyb3VwZWRcbiAgICAgKiBlbGVtZW50cyBhbmQgY3JlYXRlcyBhbiBhcnJheSByZWdyb3VwaW5nIHRoZSBlbGVtZW50cyB0byB0aGVpciBwcmUtemlwXG4gICAgICogY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjIuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMSwgdHJ1ZV0sIFsnYicsIDIsIGZhbHNlXV1cbiAgICAgKlxuICAgICAqIF8udW56aXAoemlwcGVkKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwKGFycmF5KSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgYXJyYXkgPSBhcnJheUZpbHRlcihhcnJheSwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGdyb3VwKSkge1xuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChncm91cC5sZW5ndGgsIGxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJhc2VUaW1lcyhsZW5ndGgsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcChhcnJheSwgYmFzZVByb3BlcnR5KGluZGV4KSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgdG8gc3BlY2lmeVxuICAgICAqIGhvdyByZWdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aGVcbiAgICAgKiBlbGVtZW50cyBvZiBlYWNoIGdyb3VwOiAoLi4uZ3JvdXApLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmVcbiAgICAgKiAgcmVncm91cGVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdKTtcbiAgICAgKiAvLyA9PiBbWzEsIDEwLCAxMDBdLCBbMiwgMjAsIDIwMF1dXG4gICAgICpcbiAgICAgKiBfLnVuemlwV2l0aCh6aXBwZWQsIF8uYWRkKTtcbiAgICAgKiAvLyA9PiBbMywgMzAsIDMwMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcFdpdGgoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB1bnppcChhcnJheSk7XG4gICAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5TWFwKHJlc3VsdCwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGl0ZXJhdGVlLCB1bmRlZmluZWQsIGdyb3VwKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCBnaXZlbiB2YWx1ZXMgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ueG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud2l0aG91dChbMiwgMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqL1xuICAgIHZhciB3aXRob3V0ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBpcyB0aGVcbiAgICAgKiBbc3ltbWV0cmljIGRpZmZlcmVuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bW1ldHJpY19kaWZmZXJlbmNlKVxuICAgICAqIG9mIHRoZSBnaXZlbiBhcnJheXMuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyXG4gICAgICogdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy53aXRob3V0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKi9cbiAgICB2YXIgeG9yID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnhvcmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieVxuICAgICAqIHdoaWNoIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWRcbiAgICAgKiBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZVxuICAgICAqIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMiwgMy40XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy54b3JCeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgeG9yQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXNcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnhvcldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgeG9yV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cywgdGhlIGZpcnN0IG9mIHdoaWNoIGNvbnRhaW5zIHRoZVxuICAgICAqIGZpcnN0IGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gICAgICogc2Vjb25kIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICAgICAqL1xuICAgIHZhciB6aXAgPSBiYXNlUmVzdCh1bnppcCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZyb21QYWlyc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyB0d28gYXJyYXlzLFxuICAgICAqIG9uZSBvZiBwcm9wZXJ0eSBpZGVudGlmaWVycyBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzPVtdXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdChbJ2EnLCAnYiddLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdChwcm9wcywgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBhc3NpZ25WYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBPYmplY3RgIGV4Y2VwdCB0aGF0IGl0IHN1cHBvcnRzIHByb3BlcnR5IHBhdGhzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzPVtdXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdERlZXAoWydhLmJbMF0uYycsICdhLmJbMV0uZCddLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdiJzogW3sgJ2MnOiAxIH0sIHsgJ2QnOiAyIH1dIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdERlZXAocHJvcHMsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHMgfHwgW10sIHZhbHVlcyB8fCBbXSwgYmFzZVNldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gICAgICogaG93IGdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aGVcbiAgICAgKiBlbGVtZW50cyBvZiBlYWNoIGdyb3VwOiAoLi4uZ3JvdXApLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICAgICAqICBncm91cGVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcFdpdGgoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSwgZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIGEgKyBiICsgYztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMTExLCAyMjJdXG4gICAgICovXG4gICAgdmFyIHppcFdpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIGl0ZXJhdGVlID0gbGVuZ3RoID4gMSA/IGFycmF5c1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaXRlcmF0ZWUgPSB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyA/IChhcnJheXMucG9wKCksIGl0ZXJhdGVlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB1bnppcFdpdGgoYXJyYXlzLCBpdGVyYXRlZSk7XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB0aGF0IHdyYXBzIGB2YWx1ZWAgd2l0aCBleHBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC4gVGhlIHJlc3VsdCBvZiBzdWNoIHNlcXVlbmNlcyBtdXN0IGJlIHVud3JhcHBlZFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciB5b3VuZ2VzdCA9IF9cbiAgICAgKiAgIC5jaGFpbih1c2VycylcbiAgICAgKiAgIC5zb3J0QnkoJ2FnZScpXG4gICAgICogICAubWFwKGZ1bmN0aW9uKG8pIHtcbiAgICAgKiAgICAgcmV0dXJuIG8udXNlciArICcgaXMgJyArIG8uYWdlO1xuICAgICAqICAgfSlcbiAgICAgKiAgIC5oZWFkKClcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdwZWJibGVzIGlzIDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2godmFsdWUpO1xuICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgYGludGVyY2VwdG9yYCBhbmQgcmV0dXJucyBgdmFsdWVgLiBUaGUgaW50ZXJjZXB0b3JcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0b1xuICAgICAqIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZSBpbiBvcmRlciB0byBtb2RpZnkgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pXG4gICAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgKiAgICAvLyBNdXRhdGUgaW5wdXQgYXJyYXkuXG4gICAgICogICAgYXJyYXkucG9wKCk7XG4gICAgICogIH0pXG4gICAgICogIC5yZXZlcnNlKClcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFwKHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udGFwYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInBhc3MgdGhydVwiIHZhbHVlcyByZXBsYWNpbmcgaW50ZXJtZWRpYXRlXG4gICAgICogcmVzdWx0cyBpbiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oJyAgYWJjICAnKVxuICAgICAqICAuY2hhaW4oKVxuICAgICAqICAudHJpbSgpXG4gICAgICogIC50aHJ1KGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICogIH0pXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnYWJjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJ1KHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgcmV0dXJuIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgd3JhcHBlciB2ZXJzaW9uIG9mIGBfLmF0YC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGF0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfSwgNF0gfTtcbiAgICAgKlxuICAgICAqIF8ob2JqZWN0KS5hdChbJ2FbMF0uYi5jJywgJ2FbMV0nXSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKi9cbiAgICB2YXIgd3JhcHBlckF0ID0gZmxhdFJlc3QoZnVuY3Rpb24ocGF0aHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgc3RhcnQgPSBsZW5ndGggPyBwYXRoc1swXSA6IDAsXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgIGludGVyY2VwdG9yID0gZnVuY3Rpb24ob2JqZWN0KSB7IHJldHVybiBiYXNlQXQob2JqZWN0LCBwYXRocyk7IH07XG5cbiAgICAgIGlmIChsZW5ndGggPiAxIHx8IHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoIHx8XG4gICAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB8fCAhaXNJbmRleChzdGFydCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKHN0YXJ0LCArc3RhcnQgKyAobGVuZ3RoID8gMSA6IDApKTtcbiAgICAgIHZhbHVlLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAnZnVuYyc6IHRocnUsXG4gICAgICAgICdhcmdzJzogW2ludGVyY2VwdG9yXSxcbiAgICAgICAgJ3RoaXNBcmcnOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlLCB0aGlzLl9fY2hhaW5fXykudGhydShmdW5jdGlvbihhcnJheSkge1xuICAgICAgICBpZiAobGVuZ3RoICYmICFhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICBhcnJheS5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB3aXRoIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNoYWluXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIEEgc2VxdWVuY2Ugd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZy5cbiAgICAgKiBfKHVzZXJzKS5oZWFkKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRoIGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpXG4gICAgICogICAuY2hhaW4oKVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnBpY2soJ3VzZXInKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICByZXR1cm4gY2hhaW4odGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIGFuZCByZXR1cm5zIHRoZSB3cmFwcGVkIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNvbW1pdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMl07XG4gICAgICogdmFyIHdyYXBwZWQgPSBfKGFycmF5KS5wdXNoKDMpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogd3JhcHBlZCA9IHdyYXBwZWQuY29tbWl0KCk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogd3JhcHBlZC5sYXN0KCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDb21taXQoKSB7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodGhpcy52YWx1ZSgpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmV4dCB2YWx1ZSBvbiBhIHdyYXBwZWQgb2JqZWN0IGZvbGxvd2luZyB0aGVcbiAgICAgKiBbaXRlcmF0b3IgcHJvdG9jb2xdKGh0dHBzOi8vbWRuLmlvL2l0ZXJhdGlvbl9wcm90b2NvbHMjaXRlcmF0b3IpLlxuICAgICAqXG4gICAgICogQG5hbWUgbmV4dFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5leHQgaXRlcmF0b3IgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAxIH1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiBmYWxzZSwgJ3ZhbHVlJzogMiB9XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogdHJ1ZSwgJ3ZhbHVlJzogdW5kZWZpbmVkIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyTmV4dCgpIHtcbiAgICAgIGlmICh0aGlzLl9fdmFsdWVzX18gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9fdmFsdWVzX18gPSB0b0FycmF5KHRoaXMudmFsdWUoKSk7XG4gICAgICB9XG4gICAgICB2YXIgZG9uZSA9IHRoaXMuX19pbmRleF9fID49IHRoaXMuX192YWx1ZXNfXy5sZW5ndGgsXG4gICAgICAgICAgdmFsdWUgPSBkb25lID8gdW5kZWZpbmVkIDogdGhpcy5fX3ZhbHVlc19fW3RoaXMuX19pbmRleF9fKytdO1xuXG4gICAgICByZXR1cm4geyAnZG9uZSc6IGRvbmUsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgd3JhcHBlciB0byBiZSBpdGVyYWJsZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIFN5bWJvbC5pdGVyYXRvclxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKTtcbiAgICAgKlxuICAgICAqIHdyYXBwZWRbU3ltYm9sLml0ZXJhdG9yXSgpID09PSB3cmFwcGVkO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIEFycmF5LmZyb20od3JhcHBlZCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclRvSXRlcmF0b3IoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGNoYWluIHNlcXVlbmNlIHBsYW50aW5nIGB2YWx1ZWAgYXMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBwbGFudFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHBsYW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pLm1hcChzcXVhcmUpO1xuICAgICAqIHZhciBvdGhlciA9IHdyYXBwZWQucGxhbnQoWzMsIDRdKTtcbiAgICAgKlxuICAgICAqIG90aGVyLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzksIDE2XVxuICAgICAqXG4gICAgICogd3JhcHBlZC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJQbGFudCh2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzO1xuXG4gICAgICB3aGlsZSAocGFyZW50IGluc3RhbmNlb2YgYmFzZUxvZGFzaCkge1xuICAgICAgICB2YXIgY2xvbmUgPSB3cmFwcGVyQ2xvbmUocGFyZW50KTtcbiAgICAgICAgY2xvbmUuX19pbmRleF9fID0gMDtcbiAgICAgICAgY2xvbmUuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gY2xvbmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzID0gY2xvbmU7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fX3dyYXBwZWRfXztcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8ucmV2ZXJzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyB0aGUgd3JhcHBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXyhhcnJheSkucmV2ZXJzZSgpLnZhbHVlKClcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUmV2ZXJzZSgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX187XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICB2YXIgd3JhcHBlZCA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgpIHtcbiAgICAgICAgICB3cmFwcGVkID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHdyYXBwZWQgPSB3cmFwcGVkLnJldmVyc2UoKTtcbiAgICAgICAgd3JhcHBlZC5fX2FjdGlvbnNfXy5wdXNoKHtcbiAgICAgICAgICAnZnVuYyc6IHRocnUsXG4gICAgICAgICAgJ2FyZ3MnOiBbcmV2ZXJzZV0sXG4gICAgICAgICAgJ3RoaXNBcmcnOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVkLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aHJ1KHJldmVyc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbiBzZXF1ZW5jZSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIHRvSlNPTiwgdmFsdWVPZlxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWUoKSB7XG4gICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZSh0aGlzLl9fd3JhcHBlZF9fLCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XG4gICAgICovXG4gICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgICsrcmVzdWx0W2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIDEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgIGZvclxuICAgICAqIFtlbXB0eSBjb2xsZWN0aW9uc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRW1wdHlfc2V0KSBiZWNhdXNlXG4gICAgICogW2V2ZXJ5dGhpbmcgaXMgdHJ1ZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmFjdW91c190cnV0aCkgb2ZcbiAgICAgKiBlbGVtZW50cyBvZiBlbXB0eSBjb2xsZWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RXZlcnkgOiBiYXNlRXZlcnk7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQHNlZSBfLnJlamVjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAgICovXG4gICAgdmFyIGZpbmQgPSBjcmVhdGVGaW5kKGZpbmRJbmRleCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1jb2xsZWN0aW9uLmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3QgPSBjcmVhdGVGaW5kKGZpbmRMYXN0SW5kZXgpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZsYXR0ZW5lZCBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gXG4gICAgICogdGhydSBgaXRlcmF0ZWVgIGFuZCBmbGF0dGVuaW5nIHRoZSBtYXBwZWQgcmVzdWx0cy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtuLCBuXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xuICAgICAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxuICAgICAqIG1hcHBlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtbW24sIG5dXV07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwRGVlcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcERlZXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCBJTkZJTklUWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbGF0TWFwYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBmbGF0dGVucyB0aGVcbiAgICAgKiBtYXBwZWQgcmVzdWx0cyB1cCB0byBgZGVwdGhgIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtbW24sIG5dXV07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwRGVwdGgoWzEsIDJdLCBkdXBsaWNhdGUsIDIpO1xuICAgICAqIC8vID0+IFtbMSwgMV0sIFsyLCAyXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwRGVwdGgoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoKTtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICAgICAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZWFjaFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoIDogYmFzZUVhY2g7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yRWFjaGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAYWxpYXMgZWFjaFJpZ2h0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQHNlZSBfLmZvckVhY2hcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoUmlnaHQoWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgYDJgIHRoZW4gYDFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoUmlnaHQgOiBiYXNlRWFjaFJpZ2h0O1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIG9yZGVyIG9mIGdyb3VwZWQgdmFsdWVzXG4gICAgICogaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiBgY29sbGVjdGlvbmAuIFRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogdmFsdWUgb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlXG4gICAgICoga2V5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuM10gfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ncm91cEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XG4gICAgICovXG4gICAgdmFyIGdyb3VwQnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBbdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYC4gSWYgYGNvbGxlY3Rpb25gIGlzIGEgc3RyaW5nLCBpdCdzXG4gICAgICogY2hlY2tlZCBmb3IgYSBzdWJzdHJpbmcgb2YgYHZhbHVlYCwgb3RoZXJ3aXNlXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBpcyB1c2VkIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhc1xuICAgICAqIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKHsgJ2EnOiAxLCAnYic6IDIgfSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcygnYWJjZCcsICdiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgICAgY29sbGVjdGlvbiA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggJiYgIWd1YXJkKSA/IHRvSW50ZWdlcihmcm9tSW5kZXgpIDogMDtcblxuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgZnJvbUluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbilcbiAgICAgICAgPyAoZnJvbUluZGV4IDw9IGxlbmd0aCAmJiBjb2xsZWN0aW9uLmluZGV4T2YodmFsdWUsIGZyb21JbmRleCkgPiAtMSlcbiAgICAgICAgOiAoISFsZW5ndGggJiYgYmFzZUluZGV4T2YoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCkgPiAtMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLCByZXR1cm5pbmdcbiAgICAgKiBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiBhcmUgcHJvdmlkZWQgdG8gZWFjaCBpbnZva2VkIG1ldGhvZC4gSWYgYHBhdGhgIGlzIGEgZnVuY3Rpb24sIGl0J3MgaW52b2tlZFxuICAgICAqIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb258c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgZWFjaCBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG4gICAgICogLy8gPT4gW1sxLCA1LCA3XSwgWzEsIDIsIDNdXVxuICAgICAqXG4gICAgICogXy5pbnZva2VNYXAoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuICAgICAqIC8vID0+IFtbJzEnLCAnMicsICczJ10sIFsnNCcsICc1JywgJzYnXV1cbiAgICAgKi9cbiAgICB2YXIgaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgcGF0aCwgYXJncykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gdHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpc0Z1bmMgPyBhcHBseShwYXRoLCB2YWx1ZSwgYXJncykgOiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1xuICAgICAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gICAgICogICB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksIGZ1bmN0aW9uKG8pIHtcbiAgICAgKiAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG8uY29kZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5rZXlCeShhcnJheSwgJ2RpcicpO1xuICAgICAqIC8vID0+IHsgJ2xlZnQnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ3JpZ2h0JzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGtleUJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnVcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhcnlgLCBgY2h1bmtgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsXG4gICAgICogYGZpbGxgLCBgaW52ZXJ0YCwgYHBhcnNlSW50YCwgYHJhbmRvbWAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlcGVhdGAsXG4gICAgICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1hcChbNCwgOF0sIHNxdWFyZSk7XG4gICAgICogLy8gPT4gWzE2LCA2NF1cbiAgICAgKlxuICAgICAqIF8ubWFwKHsgJ2EnOiA0LCAnYic6IDggfSwgc3F1YXJlKTtcbiAgICAgKiAvLyA9PiBbMTYsIDY0XSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheU1hcCA6IGJhc2VNYXA7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5YCBleGNlcHQgdGhhdCBpdCBhbGxvd3Mgc3BlY2lmeWluZyB0aGUgc29ydFxuICAgICAqIG9yZGVycyBvZiB0aGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzXG4gICAgICogYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3JcbiAgICAgKiBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheVtdfEZ1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW29yZGVyc10gVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFNvcnQgYnkgYHVzZXJgIGluIGFzY2VuZGluZyBvcmRlciBhbmQgYnkgYGFnZWAgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKiBfLm9yZGVyQnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSwgWydhc2MnLCAnZGVzYyddKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzLCBndWFyZCkge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkoaXRlcmF0ZWVzKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBpdGVyYXRlZXMgPT0gbnVsbCA/IFtdIDogW2l0ZXJhdGVlc107XG4gICAgICB9XG4gICAgICBvcmRlcnMgPSBndWFyZCA/IHVuZGVmaW5lZCA6IG9yZGVycztcbiAgICAgIGlmICghaXNBcnJheShvcmRlcnMpKSB7XG4gICAgICAgIG9yZGVycyA9IG9yZGVycyA9PSBudWxsID8gW10gOiBbb3JkZXJzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIHR3byBncm91cHMsIHRoZSBmaXJzdCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciwgdGhlIHNlY29uZCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5IGZvci4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ3BlYmJsZXMnXSwgWydiYXJuZXknLCAnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgJ3BlYmJsZXMnXSwgWydmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqL1xuICAgIHZhciBwYXJ0aXRpb24gPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleSA/IDAgOiAxXS5wdXNoKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbigpIHsgcmV0dXJuIFtbXSwgW11dOyB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAsIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAgICAgKiBpcyBub3QgZ2l2ZW4sIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXG4gICAgICogdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gICAgICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBvcmRlckJ5YCxcbiAgICAgKiBhbmQgYHNvcnRCeWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLnJlZHVjZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKFsxLCAyXSwgZnVuY3Rpb24oc3VtLCBuKSB7XG4gICAgICogICByZXR1cm4gc3VtICsgbjtcbiAgICAgKiB9LCAwKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICAgICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlIDogYmFzZVJlZHVjZSxcbiAgICAgICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yZWR1Y2VgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8ucmVkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtbMCwgMV0sIFsyLCAzXSwgWzQsIDVdXTtcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlUmlnaHQoYXJyYXksIGZ1bmN0aW9uKGZsYXR0ZW5lZCwgb3RoZXIpIHtcbiAgICAgKiAgIHJldHVybiBmbGF0dGVuZWQuY29uY2F0KG90aGVyKTtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZVJpZ2h0IDogYmFzZVJlZHVjZSxcbiAgICAgICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaFJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZmlsdGVyYDsgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gXG4gICAgICogdGhhdCBgcHJlZGljYXRlYCBkb2VzICoqbm90KiogcmV0dXJuIHRydXRoeSBmb3IuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQHNlZSBfLmZpbHRlclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnJlamVjdCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgeyAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSByYW5kb20gZWxlbWVudCBmcm9tIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlIDogYmFzZVNhbXBsZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYG5gIHJhbmRvbSBlbGVtZW50cyBhdCB1bmlxdWUga2V5cyBmcm9tIGBjb2xsZWN0aW9uYCB1cCB0byB0aGVcbiAgICAgKiBzaXplIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMywgMV1cbiAgICAgKlxuICAgICAqIF8uc2FtcGxlU2l6ZShbMSwgMiwgM10sIDQpO1xuICAgICAqIC8vID0+IFsyLCAzLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZVNpemUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIH1cbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlU2l6ZSA6IGJhc2VTYW1wbGVTaXplO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGVcbiAgICAgKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNodWZmbGUgOiBiYXNlU2h1ZmZsZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gICAgICogdmFsdWVzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbGxlY3Rpb24gc2l6ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5zaXplKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gN1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbikgPyBzdHJpbmdTaXplKGNvbGxlY3Rpb24pIDogY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5zaXplO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VLZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYW55KiogZWxlbWVudCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTb21lIDogYmFzZVNvbWU7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICAgICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mXG4gICAgICogZXF1YWwgZWxlbWVudHMuIFRoZSBpdGVyYXRlZXMgYXJlIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXSwgWydmcmVkJywgNDhdXVxuICAgICAqL1xuICAgIHZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW107XG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0sIGl0ZXJhdGVlc1syXSkpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgYmFzZUZsYXR0ZW4oaXRlcmF0ZWVzLCAxKSwgW10pO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gICAgICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgRGF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICAgICAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAgICAgKiB9LCBfLm5vdygpKTtcbiAgICAgKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHZhciBub3cgPSBjdHhOb3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uYmVmb3JlYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIGBmdW5jYCBvbmNlIGl0J3MgY2FsbGVkIGBuYCBvciBtb3JlIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBiZWZvcmUgYGZ1bmNgIGlzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNhdmVzID0gWydwcm9maWxlJywgJ3NldHRpbmdzJ107XG4gICAgICpcbiAgICAgKiB2YXIgZG9uZSA9IF8uYWZ0ZXIoc2F2ZXMubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdkb25lIHNhdmluZyEnKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChzYXZlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAqICAgYXN5bmNTYXZlKHsgJ3R5cGUnOiB0eXBlLCAnY29tcGxldGUnOiBkb25lIH0pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2RvbmUgc2F2aW5nIScgYWZ0ZXIgdGhlIHR3byBhc3luYyBzYXZlcyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uIDwgMSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdXAgdG8gYG5gIGFyZ3VtZW50cyxcbiAgICAgKiBpZ25vcmluZyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBjYXAuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8uYXJ5KHBhcnNlSW50LCAxKSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFyeShmdW5jLCBuLCBndWFyZCkge1xuICAgICAgbiA9IGd1YXJkID8gdW5kZWZpbmVkIDogbjtcbiAgICAgIG4gPSAoZnVuYyAmJiBuID09IG51bGwpID8gZnVuYy5sZW5ndGggOiBuO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9BUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50c1xuICAgICAqIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGlsZSBpdCdzIGNhbGxlZCBsZXNzIHRoYW4gYG5gIHRpbWVzLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGF0IHdoaWNoIGBmdW5jYCBpcyBubyBsb25nZXIgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5iZWZvcmUoNSwgYWRkQ29udGFjdFRvTGlzdCkpO1xuICAgICAqIC8vID0+IEFsbG93cyBhZGRpbmcgdXAgdG8gNCBjb250YWN0cyB0byB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiZWZvcmUobiwgZnVuYykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuIDw9IDEpIHtcbiAgICAgICAgICBmdW5jID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYFxuICAgICAqIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBuYXRpdmUgYEZ1bmN0aW9uI2JpbmRgLCB0aGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIlxuICAgICAqIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIEJvdW5kIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKi9cbiAgICB2YXIgYmluZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZCkpO1xuICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBvYmplY3Rba2V5XWAgd2l0aCBgcGFydGlhbHNgXG4gICAgICogcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvIHJlZmVyZW5jZVxuICAgICAqIG1ldGhvZHMgdGhhdCBtYXkgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC4gU2VlXG4gICAgICogW1BldGVyIE1pY2hhdXgncyBhcnRpY2xlXShodHRwOi8vcGV0ZXIubWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybilcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmRLZXkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZva2UgdGhlIG1ldGhvZCBvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICd1c2VyJzogJ2ZyZWQnLFxuICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIEJvdW5kIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmRLZXkgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGtleSwgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kS2V5KSk7XG4gICAgICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChrZXksIGJpdG1hc2ssIG9iamVjdCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhcmd1bWVudHMgb2YgYGZ1bmNgIGFuZCBlaXRoZXIgaW52b2tlc1xuICAgICAqIGBmdW5jYCByZXR1cm5pbmcgaXRzIHJlc3VsdCwgaWYgYXQgbGVhc3QgYGFyaXR5YCBudW1iZXIgb2YgYXJndW1lbnRzIGhhdmVcbiAgICAgKiBiZWVuIHByb3ZpZGVkLCBvciByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSByZW1haW5pbmcgYGZ1bmNgXG4gICAgICogYXJndW1lbnRzLCBhbmQgc28gb24uIFRoZSBhcml0eSBvZiBgZnVuY2AgbWF5IGJlIHNwZWNpZmllZCBpZiBgZnVuYy5sZW5ndGhgXG4gICAgICogaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnkoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSkoMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogY3VycmllZCgxKShfLCAzKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeShmdW5jLCBhcml0eSwgZ3VhcmQpIHtcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcbiAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQ1VSUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5LnBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmN1cnJ5YCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYXJlIGFwcGxpZWQgdG8gYGZ1bmNgXG4gICAgICogaW4gdGhlIG1hbm5lciBvZiBgXy5wYXJ0aWFsUmlnaHRgIGluc3RlYWQgb2YgYF8ucGFydGlhbGAuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnlSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeVJpZ2h0KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDMpKDIpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgyLCAzKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyBDdXJyaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIGN1cnJpZWQoMykoMSwgXykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnlSaWdodChmdW5jLCBhcml0eSwgZ3VhcmQpIHtcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcbiAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQ1VSUllfUklHSFRfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5UmlnaHQucGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICAgICAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICAgICAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAgICAgKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAgICAgKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAgICAgKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gICAgICogaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICAgICAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gICAgICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAgICAgKlxuICAgICAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAgICAgKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAgICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICAgICAqXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGFzdEFyZ3MsXG4gICAgICAgICAgbGFzdFRoaXMsXG4gICAgICAgICAgbWF4V2FpdCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgdGltZXJJZCxcbiAgICAgICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgICAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgICAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgICAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgICAgICByZXR1cm4gbWF4aW5nID8gbmF0aXZlTWluKHJlc3VsdCwgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgICAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgICAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgICAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgICAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgICAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICAgICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgICAgIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnMgaW52b2tpbmcgdGhlIGBmdW5jYCB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLiBBbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVmZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgJ2RlZmVycmVkJyk7XG4gICAgICogLy8gPT4gTG9ncyAnZGVmZXJyZWQnIGFmdGVyIG9uZSBtaWxsaXNlY29uZC5cbiAgICAgKi9cbiAgICB2YXIgZGVmZXIgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIDEsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBgZnVuY2AgYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kcy4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVsYXkoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgMTAwMCwgJ2xhdGVyJyk7XG4gICAgICogLy8gPT4gTG9ncyAnbGF0ZXInIGFmdGVyIG9uZSBzZWNvbmQuXG4gICAgICovXG4gICAgdmFyIGRlbGF5ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCB0b051bWJlcih3YWl0KSB8fCAwLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIHJldmVyc2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZmxpcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsaXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmbGlwcGVkID0gXy5mbGlwKGZ1bmN0aW9uKCkge1xuICAgICAqICAgcmV0dXJuIF8udG9BcnJheShhcmd1bWVudHMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZmxpcHBlZCgnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+IFsnZCcsICdjJywgJ2InLCAnYSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxpcChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0ZMSVBfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICAgKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gICAgICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAgICAgKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAgICAgKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICAgICAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gICAgICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAgICAgKlxuICAgICAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFsdWVzKG90aGVyKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKlxuICAgICAqIG9iamVjdC5hID0gMjtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICAgICAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICpcbiAgICAgKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICAgICAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfVxuXG4gICAgLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG4gICAgbWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbmVnYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBwcmVkaWNhdGUgYGZ1bmNgLiBUaGVcbiAgICAgKiBgZnVuY2AgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbmVnYXRlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG5lZ2F0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzRXZlbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIF8ubmVnYXRlKGlzRXZlbikpO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBpbnZva2luZyBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzXG4gICAgICogdG8gdGhlIGZ1bmN0aW9uIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGludm9jYXRpb24uIFRoZSBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiAvLyA9PiBgY3JlYXRlQXBwbGljYXRpb25gIGlzIGludm9rZWQgb25jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgICAgcmV0dXJuIGJlZm9yZSgyLCBmdW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudHMgdHJhbnNmb3JtZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbdHJhbnNmb3Jtcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm1zLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkb3VibGVkKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyQXJncyhmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4gW3gsIHldO1xuICAgICAqIH0sIFtzcXVhcmUsIGRvdWJsZWRdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoOSwgMyk7XG4gICAgICogLy8gPT4gWzgxLCA2XVxuICAgICAqXG4gICAgICogZnVuYygxMCwgNSk7XG4gICAgICogLy8gPT4gWzEwMCwgMTBdXG4gICAgICovXG4gICAgdmFyIG92ZXJBcmdzID0gY2FzdFJlc3QoZnVuY3Rpb24oZnVuYywgdHJhbnNmb3Jtcykge1xuICAgICAgdHJhbnNmb3JtcyA9ICh0cmFuc2Zvcm1zLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkodHJhbnNmb3Jtc1swXSkpXG4gICAgICAgID8gYXJyYXlNYXAodHJhbnNmb3Jtc1swXSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKVxuICAgICAgICA6IGFycmF5TWFwKGJhc2VGbGF0dGVuKHRyYW5zZm9ybXMsIDEpLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuXG4gICAgICB2YXIgZnVuY3NMZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGFyZ3MubGVuZ3RoLCBmdW5jc0xlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IHRyYW5zZm9ybXNbaW5kZXhdLmNhbGwodGhpcywgYXJnc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGVcbiAgICAgKiBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYmluZGAgZXhjZXB0IGl0IGRvZXMgKipub3QqKlxuICAgICAqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGVsbG8nKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBQYXJ0aWFsbHkgYXBwbGllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsKGdyZWV0LCBfLCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIocGFydGlhbCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wYXJ0aWFsYCBleGNlcHQgdGhhdCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHNcbiAgICAgKiBhcmUgYXBwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsUmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdoZWxsbycsIF8pO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbFJpZ2h0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsUmlnaHQpKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIGFycmFuZ2VkIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBzcGVjaWZpZWQgYGluZGV4ZXNgIHdoZXJlIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgZmlyc3QgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgc2Vjb25kIGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVhcnJhbmdlIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJndW1lbnQgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlYXJnZWQgPSBfLnJlYXJnKGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfSwgWzIsIDAsIDFdKTtcbiAgICAgKlxuICAgICAqIHJlYXJnZWQoJ2InLCAnYycsICdhJylcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICB2YXIgcmVhcmcgPSBmbGF0UmVzdChmdW5jdGlvbihmdW5jLCBpbmRleGVzKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1JFQVJHX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGluZGV4ZXMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiBhbmQgYXJndW1lbnRzIGZyb20gYHN0YXJ0YCBhbmQgYmV5b25kIHByb3ZpZGVkIGFzXG4gICAgICogYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL21kbi5pby9yZXN0X3BhcmFtZXRlcnMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnJlc3QoZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAgICAgKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAgICAgKiAgICAgKF8uc2l6ZShuYW1lcykgPiAxID8gJywgJiAnIDogJycpICsgXy5sYXN0KG5hbWVzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheSgnaGVsbG8nLCAnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0ID09PSB1bmRlZmluZWQgPyBzdGFydCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuYywgc3RhcnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZSBmdW5jdGlvbiBhbmQgYW4gYXJyYXkgb2YgYXJndW1lbnRzIG11Y2ggbGlrZVxuICAgICAqIFtgRnVuY3Rpb24jYXBwbHlgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3ByZWFkIG9wZXJhdG9yXShodHRwczovL21kbi5pby9zcHJlYWRfb3BlcmF0b3IpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc3ByZWFkIGFyZ3VtZW50cyBvdmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBzcHJlYWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnNwcmVhZChmdW5jdGlvbih3aG8sIHdoYXQpIHtcbiAgICAgKiAgIHJldHVybiB3aG8gKyAnIHNheXMgJyArIHdoYXQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoWydmcmVkJywgJ2hlbGxvJ10pO1xuICAgICAqIC8vID0+ICdmcmVkIHNheXMgaGVsbG8nXG4gICAgICpcbiAgICAgKiB2YXIgbnVtYmVycyA9IFByb21pc2UuYWxsKFtcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSg0MCksXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoMzYpXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBudW1iZXJzLnRoZW4oXy5zcHJlYWQoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIHggKyB5O1xuICAgICAqIH0pKTtcbiAgICAgKiAvLyA9PiBhIFByb21pc2Ugb2YgNzZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcHJlYWQoZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKHN0YXJ0KSwgMCk7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcmdzW3N0YXJ0XSxcbiAgICAgICAgICAgIG90aGVyQXJncyA9IGNhc3RTbGljZShhcmdzLCAwLCBzdGFydCk7XG5cbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlQdXNoKG90aGVyQXJncywgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICAgICAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gICAgICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICAgICAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICAgICAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAgICAgKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gICAgICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICAgICAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICAgICAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAgICAgKlxuICAgICAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICAgICAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAgICAgKlxuICAgICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAgICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byBvbmUgYXJndW1lbnQsIGlnbm9yaW5nIGFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLnVuYXJ5KHBhcnNlSW50KSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuYXJ5KGZ1bmMpIHtcbiAgICAgIHJldHVybiBhcnkoZnVuYywgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byBgd3JhcHBlcmAgYXMgaXRzIGZpcnN0XG4gICAgICogYXJndW1lbnQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlIGFwcGVuZGVkXG4gICAgICogdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIGB3cmFwcGVyYC4gVGhlIHdyYXBwZXIgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbd3JhcHBlcj1pZGVudGl0eV0gVGhlIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBwID0gXy53cmFwKF8uZXNjYXBlLCBmdW5jdGlvbihmdW5jLCB0ZXh0KSB7XG4gICAgICogICByZXR1cm4gJzxwPicgKyBmdW5jKHRleHQpICsgJzwvcD4nO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogcCgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnPHA+ZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzPC9wPidcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gcGFydGlhbChjYXN0RnVuY3Rpb24od3JhcHBlciksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIGFzIGFuIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KDEpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkobnVsbCk7XG4gICAgICogLy8gPT4gW251bGxdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSh1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IFt1bmRlZmluZWRdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICogY29uc29sZS5sb2coXy5jYXN0QXJyYXkoYXJyYXkpID09PSBhcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheSgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gICAgICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZFxuICAgICAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gICAgICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICAgICAqIGFzIGVycm9yIG9iamVjdHMsIGZ1bmN0aW9ucywgRE9NIG5vZGVzLCBhbmQgV2Vha01hcHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAgICAgKlxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZS4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsXG4gICAgICogY2xvbmluZyBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB1cCB0byBmb3VyIGFyZ3VtZW50czsgKHZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBzdGFja10pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGVsID09PSBkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGNvbnNvbGUubG9nKGVsLm5vZGVOYW1lKTtcbiAgICAgKiAvLyA9PiAnQk9EWSdcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lV2l0aCh2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gICAgICogY29uc29sZS5sb2coZGVlcFswXSA9PT0gb2JqZWN0c1swXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZVdpdGhgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIodmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lRGVlcFdpdGgoZG9jdW1lbnQuYm9keSwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5ub2RlTmFtZSk7XG4gICAgICogLy8gPT4gJ0JPRFknXG4gICAgICogY29uc29sZS5sb2coZWwuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwV2l0aCh2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG9iamVjdGAgY29uZm9ybXMgdG8gYHNvdXJjZWAgYnkgaW52b2tpbmcgdGhlIHByZWRpY2F0ZVxuICAgICAqIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5jb25mb3Jtc2Agd2hlbiBgc291cmNlYCBpc1xuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDI7IH0gfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtc1RvKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlID09IG51bGwgfHwgYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lcSgnYScsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lcShOYU4sIE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5sdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZ3QoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgZ3QgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VHdCk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0b1xuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmx0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBndGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID49IG90aGVyO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlCdWZmZXJgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXlCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXlCdWZmZXIgPSBub2RlSXNBcnJheUJ1ZmZlciA/IGJhc2VVbmFyeShub2RlSXNBcnJheUJ1ZmZlcikgOiBiYXNlSXNBcnJheUJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAgICAgKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gICAgICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICAgICAqIGlzIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKGZhbHNlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBib29sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRGF0ZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKG5ldyBEYXRlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZSgnTW9uIEFwcmlsIDIzIDIwMTInKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0RhdGUgPSBub2RlSXNEYXRlID8gYmFzZVVuYXJ5KG5vZGVJc0RhdGUpIDogYmFzZUlzRGF0ZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KCc8Ym9keT4nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDEgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGVtcHR5IG9iamVjdCwgY29sbGVjdGlvbiwgbWFwLCBvciBzZXQuXG4gICAgICpcbiAgICAgKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAgICAgKiBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gICAgICogalF1ZXJ5LWxpa2UgY29sbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYGxlbmd0aGAgb2YgYDBgLlxuICAgICAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHRydWUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSgxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICAgICAgfVxuICAgICAgaWYgKGlzUHJvdG90eXBlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAgICAgKiBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICAgICAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAgICAgKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICAgICAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICAgICAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIG9iamVjdCA9PT0gb3RoZXI7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0VxdWFsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggdXAgdG9cbiAgICAgKiBzaXggYXJndW1lbnRzOiAob2JqVmFsdWUsIG90aFZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2tdKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzR3JlZXRpbmcodmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUpIHtcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKG90aFZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAgICAgKiB2YXIgb3RoZXIgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbFdpdGgoYXJyYXksIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbFdpdGgodmFsdWUsIG90aGVyLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIG90aGVyKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgdW5kZWZpbmVkLCBjdXN0b21pemVyKSA6ICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG4gICAgICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBlcnJvciBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKG5ldyBFcnJvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKEVycm9yKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZS5tZXNzYWdlID09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZS5uYW1lID09ICdzdHJpbmcnICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgcHJpbWl0aXZlIG51bWJlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzRmluaXRlYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzRmluaXRlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAgICAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc0ludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNJbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09IHRvSW50ZWdlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aCgzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aCgnMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICAgICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICAgICAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAgICAgKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChfLm5vb3ApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICAgICAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2Uoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTWFwKG5ldyBNYXApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYG9iamVjdGAgYW5kIGBzb3VyY2VgIHRvXG4gICAgICogZGV0ZXJtaW5lIGlmIGBvYmplY3RgIGNvbnRhaW5zIGVxdWl2YWxlbnQgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8ubWF0Y2hlc2Agd2hlbiBgc291cmNlYCBpc1xuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3QgYHNvdXJjZWBcbiAgICAgKiB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZSBgXy5pc0VxdWFsYFxuICAgICAqIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdiJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2gob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNNYXRjaGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcbiAgICAgKiBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIGZpdmVcbiAgICAgKiBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGluZGV4fGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzR3JlZXRpbmcodmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKHNyY1ZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnZ3JlZXRpbmcnOiAnaGVsbG8nIH07XG4gICAgICogdmFyIHNvdXJjZSA9IHsgJ2dyZWV0aW5nJzogJ2hpJyB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGdldE1hdGNoRGF0YShzb3VyY2UpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzTmFOKSBhbmQgaXMgbm90IHRoZSBzYW1lIGFzXG4gICAgICogZ2xvYmFsIFtgaXNOYU5gXShodHRwczovL21kbi5pby9pc05hTikgd2hpY2ggcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1iZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgIC8vIEFuIGBOYU5gIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGYuXG4gICAgICAvLyBQZXJmb3JtIHRoZSBgdG9TdHJpbmdUYWdgIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWVcbiAgICAgIC8vIEFjdGl2ZVggb2JqZWN0cyBpbiBJRS5cbiAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJpc3RpbmUgbmF0aXZlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGNhbid0IHJlbGlhYmx5IGRldGVjdCBuYXRpdmUgZnVuY3Rpb25zIGluIHRoZSBwcmVzZW5jZVxuICAgICAqIG9mIHRoZSBjb3JlLWpzIHBhY2thZ2UgYmVjYXVzZSBjb3JlLWpzIGNpcmN1bXZlbnRzIHRoaXMga2luZCBvZiBkZXRlY3Rpb24uXG4gICAgICogRGVzcGl0ZSBtdWx0aXBsZSByZXF1ZXN0cywgdGhlIGNvcmUtanMgbWFpbnRhaW5lciBoYXMgbWFkZSBpdCBjbGVhcjogYW55XG4gICAgICogYXR0ZW1wdCB0byBmaXggdGhlIGRldGVjdGlvbiB3aWxsIGJlIG9ic3RydWN0ZWQuIEFzIGEgcmVzdWx0LCB3ZSdyZSBsZWZ0XG4gICAgICogd2l0aCBsaXR0bGUgY2hvaWNlIGJ1dCB0byB0aHJvdyBhbiBlcnJvci4gVW5mb3J0dW5hdGVseSwgdGhpcyBhbHNvIGFmZmVjdHNcbiAgICAgKiBwYWNrYWdlcywgbGlrZSBbYmFiZWwtcG9seWZpbGxdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2JhYmVsLXBvbHlmaWxsKSxcbiAgICAgKiB3aGljaCByZWx5IG9uIGNvcmUtanMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoXyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKGlzTWFza2FibGUodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihDT1JFX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bGwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bGwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbnVsbGlzaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmVcbiAgICAgKiBjbGFzc2lmaWVkIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IG51bWJlclRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICAgICAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjguMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgICAgIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgICAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgUmVnRXhwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoL2FiYy8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoJy9hYmMvJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNSZWdFeHAgPSBub2RlSXNSZWdFeHAgPyBiYXNlVW5hcnkobm9kZUlzUmVnRXhwKSA6IGJhc2VJc1JlZ0V4cDtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLiBBbiBpbnRlZ2VyIGlzIHNhZmUgaWYgaXQncyBhbiBJRUVFLTc1NFxuICAgICAqIGRvdWJsZSBwcmVjaXNpb24gbnVtYmVyIHdoaWNoIGlzbid0IHRoZSByZXN1bHQgb2YgYSByb3VuZGVkIHVuc2FmZSBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNTYWZlSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc1NhZmVJbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzYWZlIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA+PSAtTUFYX1NBRkVfSU5URUdFUiAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTZXQobmV3IFNldCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1NldChuZXcgV2Vha1NldCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBXZWFrTWFwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgd2VhayBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtNYXAobmV3IFdlYWtNYXApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBNYXApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHdlYWtNYXBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBXZWFrU2V0YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgd2VhayBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtTZXQobmV3IFdlYWtTZXQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBTZXQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSB3ZWFrU2V0VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8uZ3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdCgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmx0KDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGx0ID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihiYXNlTHQpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAgKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5ndGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdGUoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHRlID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8PSBvdGhlcjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9BcnJheSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIF8udG9BcnJheSgxKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KG51bGwpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgPyBzdHJpbmdUb0FycmF5KHZhbHVlKSA6IGNvcHlBcnJheSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3ltSXRlcmF0b3IgJiYgdmFsdWVbc3ltSXRlcmF0b3JdKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclRvQXJyYXkodmFsdWVbc3ltSXRlcmF0b3JdKCkpO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgZnVuYyA9IHRhZyA9PSBtYXBUYWcgPyBtYXBUb0FycmF5IDogKHRhZyA9PSBzZXRUYWcgPyBzZXRUb0FycmF5IDogdmFsdWVzKTtcblxuICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTIuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKDMuMik7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDVlLTMyNFxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoJzMuMicpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XG4gICAgICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIgc3VpdGFibGUgZm9yIHVzZSBhcyB0aGUgbGVuZ3RoIG9mIGFuXG4gICAgICogYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiA0Mjk0OTY3Mjk1XG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9MZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAwLCBNQVhfQVJSQVlfTEVOR1RIKSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gNWUtMzI0XG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBJbmZpbml0eVxuICAgICAqXG4gICAgICogXy50b051bWJlcignMy4yJyk7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTkFOO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICAgICAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgICAgIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgICAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICAgICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICAgICAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc2FmZSBpbnRlZ2VyLiBBIHNhZmUgaW50ZWdlciBjYW4gYmUgY29tcGFyZWQgYW5kXG4gICAgICogcmVwcmVzZW50ZWQgY29ycmVjdGx5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiA5MDA3MTk5MjU0NzQwOTkxXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpXG4gICAgICAgIDogKHZhbHVlID09PSAwID8gdmFsdWUgOiAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICAgICAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcobnVsbCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcoLTApO1xuICAgICAqIC8vID0+ICctMCdcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAnMSwyLDMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYE9iamVjdC5hc3NpZ25gXShodHRwczovL21kbi5pby9PYmplY3QvYXNzaWduKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbkluXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgICAqICAgdGhpcy5jID0gMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIGlmIChpc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlKHNvdXJjZSkpIHtcbiAgICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIHNvdXJjZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZXh0ZW5kXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBCYXIoKSB7XG4gICAgICogICB0aGlzLmMgPSAzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gICAgICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAgICAgKlxuICAgICAqIF8uYXNzaWduSW4oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzLCAnZCc6IDQgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25JbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGV4dGVuZFdpdGhcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbkluV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduSW5XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JbldpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25XaXRoLCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byBgcGF0aHNgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gICAgICpcbiAgICAgKiBfLmF0KG9iamVjdCwgWydhWzBdLmIuYycsICdhWzFdJ10pO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL1xuICAgIHZhciBhdCA9IGZsYXRSZXN0KGJhc2VBdCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgZ2l2ZW4sIGl0cyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllc1xuICAgICAqIGFyZSBhc3NpZ25lZCB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgICAqICAgU2hhcGUuY2FsbCh0aGlzKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBDaXJjbGUucHJvdG90eXBlID0gXy5jcmVhdGUoU2hhcGUucHJvdG90eXBlLCB7XG4gICAgICogICAnY29uc3RydWN0b3InOiBDaXJjbGVcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBjaXJjbGUgPSBuZXcgQ2lyY2xlO1xuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzID09IG51bGwgPyByZXN1bHQgOiBiYXNlQXNzaWduKHJlc3VsdCwgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZVxuICAgICAqIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdFxuICAgICAqIHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgKiBPbmNlIGEgcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5kZWZhdWx0c0RlZXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHMgPSBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICBhcmdzLnB1c2godW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtcbiAgICAgIHJldHVybiBhcHBseShhc3NpZ25JbldpdGgsIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRlZmF1bHRzYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBhc3NpZ25zXG4gICAgICogZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5kZWZhdWx0c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzRGVlcCh7ICdhJzogeyAnYic6IDIgfSB9LCB7ICdhJzogeyAnYic6IDEsICdjJzogMyB9IH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdiJzogMiwgJ2MnOiAzIH0gfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0c0RlZXAgPSBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICBhcmdzLnB1c2godW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlKTtcbiAgICAgIHJldHVybiBhcHBseShtZXJnZVdpdGgsIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGtleSBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxuICAgICAqICBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZEtleSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93bik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kS2V5YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYSBjb2xsZWN0aW9uIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxuICAgICAqICBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+IHJldHVybnMgJ3BlYmJsZXMnIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0S2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmRLZXkob2JqZWN0LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBiYXNlRm9yT3duUmlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhblxuICAgICAqIG9iamVjdCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0XG4gICAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JJblJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScsICdiJywgdGhlbiAnYycgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW4ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsXG4gICAgICAgID8gb2JqZWN0XG4gICAgICAgIDogYmFzZUZvcihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JJblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYycsICdiJywgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9ySW5gIGxvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsXG4gICAgICAgID8gb2JqZWN0XG4gICAgICAgIDogYmFzZUZvclJpZ2h0KG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGFuZFxuICAgICAqIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb25cbiAgICAgKiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9yT3duUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93bihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JPd25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvck93blxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JPd25SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2InIHRoZW4gJ2EnIGFzc3VtaW5nIGBfLmZvck93bmAgbG9ncyAnYScgdGhlbiAnYicuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gICAgICogb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zSW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gXy5jb25zdGFudCgnYScpO1xuICAgICAqICAgdGhpcy5iID0gXy5jb25zdGFudCgnYicpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IF8uY29uc3RhbnQoJ2MnKTtcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBvd24gYW5kIGluaGVyaXRlZFxuICAgICAqIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqIEBzZWUgXy5mdW5jdGlvbnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gXy5jb25zdGFudCgnYScpO1xuICAgICAqICAgdGhpcy5iID0gXy5jb25zdGFudCgnYicpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IF8uY29uc3RhbnQoJ2MnKTtcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogeyAnYic6IDIgfSB9O1xuICAgICAqIHZhciBvdGhlciA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhLmInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG90aGVyLCAnYScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzKG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGludmVydGVkIGtleXMgYW5kIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKiBJZiBgb2JqZWN0YCBjb250YWlucyBkdXBsaWNhdGUgdmFsdWVzLCBzdWJzZXF1ZW50IHZhbHVlcyBvdmVyd3JpdGVcbiAgICAgKiBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydChvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzEnOiAnYycsICcyJzogJ2InIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRbdmFsdWVdID0ga2V5O1xuICAgIH0sIGNvbnN0YW50KGlkZW50aXR5KSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludmVydGAgZXhjZXB0IHRoYXQgdGhlIGludmVydGVkIG9iamVjdCBpcyBnZW5lcmF0ZWRcbiAgICAgKiBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBlbGVtZW50IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogY29ycmVzcG9uZGluZyBpbnZlcnRlZCB2YWx1ZSBvZiBlYWNoIGludmVydGVkIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzXG4gICAgICogcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGludmVydGVkIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0Qnkob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAnZ3JvdXAnICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZ3JvdXAxJzogWydhJywgJ2MnXSwgJ2dyb3VwMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0QnkgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdFt2YWx1ZV0ucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IFtrZXldO1xuICAgICAgfVxuICAgIH0sIGdldEl0ZXJhdGVlKTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiBbMSwgMiwgMywgNF0gfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5pbnZva2Uob2JqZWN0LCAnYVswXS5iLmMuc2xpY2UnLCAxLCAzKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICB2YXIgaW52b2tlID0gYmFzZVJlc3QoYmFzZUludm9rZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gICAgICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy5rZXlzKCdoaScpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5c0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tYXBWYWx1ZXNgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZVxuICAgICAqIHNhbWUgdmFsdWVzIGFzIGBvYmplY3RgIGFuZCBrZXlzIGdlbmVyYXRlZCBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGVcbiAgICAgKiBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgXy5tYXBWYWx1ZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXBLZXlzKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgcmV0dXJuIGtleSArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ExJzogMSwgJ2IyJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwS2V5cyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkXG4gICAgICogYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAc2VlIF8ubWFwS2V5c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnZnJlZCc6ICAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAgICAgKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICAgICAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICAgICAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlciA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lcmdlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb24gYW5kIHNvdXJjZVxuICAgICAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXG4gICAgICogbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHNpeCBhcmd1bWVudHM6XG4gICAgICogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFsxXSwgJ2InOiBbMl0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogWzNdLCAnYic6IFs0XSB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZVdpdGgob2JqZWN0LCBvdGhlciwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4geyAnYSc6IFsxLCAzXSwgJ2InOiBbMiwgNF0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZVdpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGVcbiAgICAgKiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IHBhdGhzIG9mIGBvYmplY3RgIHRoYXQgYXJlIG5vdCBvbWl0dGVkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGNvbnNpZGVyYWJseSBzbG93ZXIgdGhhbiBgXy5waWNrYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIG9taXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXQob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cbiAgICAgKi9cbiAgICB2YXIgb21pdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgcGF0aHMgPSBhcnJheU1hcChwYXRocywgZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgaXNEZWVwIHx8IChpc0RlZXAgPSBwYXRoLmxlbmd0aCA+IDEpO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH0pO1xuICAgICAgY29weU9iamVjdChvYmplY3QsIGdldEFsbEtleXNJbihvYmplY3QpLCByZXN1bHQpO1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICByZXN1bHQgPSBiYXNlQ2xvbmUocmVzdWx0LCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9GTEFUX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbU9taXRDbG9uZSk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGJhc2VVbnNldChyZXN1bHQsIHBhdGhzW2xlbmd0aF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrQnlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZlxuICAgICAqIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgIHRoYXRcbiAgICAgKiBgcHJlZGljYXRlYCBkb2Vzbid0IHJldHVybiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d29cbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5vbWl0Qnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbWl0Qnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBwaWNrQnkob2JqZWN0LCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICB2YXIgcGljayA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgYG9iamVjdGAgcHJvcGVydGllcyBgcHJlZGljYXRlYCByZXR1cm5zXG4gICAgICogdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2tCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2tCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wcyA9IGFycmF5TWFwKGdldEFsbEtleXNJbihvYmplY3QpLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHJldHVybiBbcHJvcF07XG4gICAgICB9KTtcbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSk7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHByb3BzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlKHZhbHVlLCBwYXRoWzBdKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZ2V0YCBleGNlcHQgdGhhdCBpZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXMgYVxuICAgICAqIGZ1bmN0aW9uIGl0J3MgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBpdHMgcGFyZW50IG9iamVjdCBhbmRcbiAgICAgKiBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MxJzogMywgJ2MyJzogXy5jb25zdGFudCg0KSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzEnKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzInKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMzJywgXy5jb25zdGFudCgnZGVmYXVsdCcpKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgLy8gRW5zdXJlIHRoZSBsb29wIGlzIGVudGVyZWQgd2hlbiBwYXRoIGlzIGVtcHR5LlxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgb2JqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3RbdG9LZXkocGF0aFtpbmRleF0pXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcbiAgICAgKiBpdCdzIGNyZWF0ZWQuIEFycmF5cyBhcmUgY3JlYXRlZCBmb3IgbWlzc2luZyBpbmRleCBwcm9wZXJ0aWVzIHdoaWxlIG9iamVjdHNcbiAgICAgKiBhcmUgY3JlYXRlZCBmb3IgYWxsIG90aGVyIG1pc3NpbmcgcHJvcGVydGllcy4gVXNlIGBfLnNldFdpdGhgIHRvIGN1c3RvbWl6ZVxuICAgICAqIGBwYXRoYCBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsIFsneCcsICcwJywgJ3knLCAneiddLCA1KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xuICAgICAqXG4gICAgICogXy5zZXRXaXRoKG9iamVjdCwgJ1swXVsxXScsICdhJywgT2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRXaXRoKG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgXG4gICAgICogd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwIG9yIHNldCwgaXRzXG4gICAgICogZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgdG9QYWlycyA9IGNyZWF0ZVRvUGFpcnMoa2V5cyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkLXZhbHVlIHBhaXJzXG4gICAgICogZm9yIGBvYmplY3RgIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcFxuICAgICAqIG9yIHNldCwgaXRzIGVudHJpZXMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGVudHJpZXNJblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdLCBbJ2MnLCAzXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgdG9QYWlyc0luID0gY3JlYXRlVG9QYWlycyhrZXlzSW4pO1xuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd25cbiAgICAgKiBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIHRocnUgYGl0ZXJhdGVlYCwgd2l0aCBlYWNoIGludm9jYXRpb25cbiAgICAgKiBwb3RlbnRpYWxseSBtdXRhdGluZyB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIElmIGBhY2N1bXVsYXRvcmAgaXMgbm90XG4gICAgICogcHJvdmlkZWQsIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGBbW1Byb3RvdHlwZV1dYCB3aWxsIGJlIHVzZWQuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAgICAgKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDldXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgICAgaXNBcnJMaWtlID0gaXNBcnIgfHwgaXNCdWZmZXIob2JqZWN0KSB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KTtcblxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCk7XG4gICAgICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgICAgICB2YXIgQ3RvciA9IG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICAgIGlmIChpc0Fyckxpa2UpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzQXJyID8gbmV3IEN0b3IgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0Z1bmN0aW9uKEN0b3IpID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSkgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAoaXNBcnJMaWtlID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHByb3BlcnR5IGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVuc2V0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDcgfSB9XSB9O1xuICAgICAqIF8udW5zZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHRydWUgOiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgYWNjZXB0cyBgdXBkYXRlcmAgdG8gcHJvZHVjZSB0aGVcbiAgICAgKiB2YWx1ZSB0byBzZXQuIFVzZSBgXy51cGRhdGVXaXRoYCB0byBjdXN0b21pemUgYHBhdGhgIGNyZWF0aW9uLiBUaGUgYHVwZGF0ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICdhWzBdLmIuYycsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gKiBuOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ3hbMF0ueS56JywgZnVuY3Rpb24obikgeyByZXR1cm4gbiA/IG4gKyAxIDogMDsgfSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlcikge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIGNhc3RGdW5jdGlvbih1cGRhdGVyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51cGRhdGVgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogcGF0aCBjcmVhdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6IChuc1ZhbHVlLCBrZXksIG5zT2JqZWN0KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZVdpdGgob2JqZWN0LCAnWzBdWzFdJywgXy5jb25zdGFudCgnYScpLCBPYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVdpdGgob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLnZhbHVlcygnaGknKTtcbiAgICAgKiAvLyA9PiBbJ2gnLCAnaSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eVxuICAgICAqIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIGBudW1iZXJgIHdpdGhpbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jbGFtcCgtMTAsIC01LCA1KTtcbiAgICAgKiAvLyA9PiAtNVxuICAgICAqXG4gICAgICogXy5jbGFtcCgxMCwgLTUsIDUpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgbG93ZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cHBlciA9IHRvTnVtYmVyKHVwcGVyKTtcbiAgICAgICAgdXBwZXIgPSB1cHBlciA9PT0gdXBwZXIgPyB1cHBlciA6IDA7XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb3dlciA9IHRvTnVtYmVyKGxvd2VyKTtcbiAgICAgICAgbG93ZXIgPSBsb3dlciA9PT0gbG93ZXIgPyBsb3dlciA6IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUNsYW1wKHRvTnVtYmVyKG51bWJlciksIGxvd2VyLCB1cHBlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBuYCBpcyBiZXR3ZWVuIGBzdGFydGAgYW5kIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIElmXG4gICAgICogYGVuZGAgaXMgbm90IHNwZWNpZmllZCwgaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICAgICAqIElmIGBzdGFydGAgaXMgZ3JlYXRlciB0aGFuIGBlbmRgIHRoZSBwYXJhbXMgYXJlIHN3YXBwZWQgdG8gc3VwcG9ydFxuICAgICAqIG5lZ2F0aXZlIHJhbmdlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5yYW5nZSwgXy5yYW5nZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgzLCAyLCA0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgOCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMiwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgxLjIsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg1LjIsIDQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoLTMsIC0yLCAtNik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICAgIH1cbiAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICByZXR1cm4gYmFzZUluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxuICAgICAqIElmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyXG4gICAgICogaXMgcmV0dXJuZWQuIElmIGBmbG9hdGluZ2AgaXMgYHRydWVgLCBvciBlaXRoZXIgYGxvd2VyYCBvciBgdXBwZXJgIGFyZVxuICAgICAqIGZsb2F0cywgYSBmbG9hdGluZy1wb2ludCBudW1iZXIgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcj0wXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt1cHBlcj0xXSBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZmxvYXRpbmddIFNwZWNpZnkgcmV0dXJuaW5nIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDAsIDUpO1xuICAgICAqIC8vID0+IGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1KTtcbiAgICAgKiAvLyA9PiBhbHNvIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1LCB0cnVlKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDEuMiwgNS4yKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDEuMiBhbmQgNS4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tKGxvd2VyLCB1cHBlciwgZmxvYXRpbmcpIHtcbiAgICAgIGlmIChmbG9hdGluZyAmJiB0eXBlb2YgZmxvYXRpbmcgIT0gJ2Jvb2xlYW4nICYmIGlzSXRlcmF0ZWVDYWxsKGxvd2VyLCB1cHBlciwgZmxvYXRpbmcpKSB7XG4gICAgICAgIHVwcGVyID0gZmxvYXRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHVwcGVyID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gdXBwZXI7XG4gICAgICAgICAgdXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxvd2VyID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbG93ZXI7XG4gICAgICAgICAgbG93ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciA9PT0gdW5kZWZpbmVkICYmIHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICB1cHBlciA9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbG93ZXIgPSB0b0Zpbml0ZShsb3dlcik7XG4gICAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBwZXIgPSB0b0Zpbml0ZSh1cHBlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciA+IHVwcGVyKSB7XG4gICAgICAgIHZhciB0ZW1wID0gbG93ZXI7XG4gICAgICAgIGxvd2VyID0gdXBwZXI7XG4gICAgICAgIHVwcGVyID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyB8fCBsb3dlciAlIDEgfHwgdXBwZXIgJSAxKSB7XG4gICAgICAgIHZhciByYW5kID0gbmF0aXZlUmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNaW4obG93ZXIgKyAocmFuZCAqICh1cHBlciAtIGxvd2VyICsgZnJlZVBhcnNlRmxvYXQoJzFlLScgKyAoKHJhbmQgKyAnJykubGVuZ3RoIC0gMSkpKSksIHVwcGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcik7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2NhbWVsIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbWVsQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYW1lbCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqL1xuICAgIHZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gY2FwaXRhbGl6ZSh3b3JkKSA6IHdvcmQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlIGFuZCB0aGUgcmVtYWluaW5nXG4gICAgICogdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXBpdGFsaXplKCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiB1cHBlckZpcnN0KHRvU3RyaW5nKHN0cmluZykudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXG4gICAgICogW0xhdGluLTEgU3VwcGxlbWVudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW4tMV9TdXBwbGVtZW50XyhVbmljb2RlX2Jsb2NrKSNDaGFyYWN0ZXJfdGFibGUpXG4gICAgICogYW5kIFtMYXRpbiBFeHRlbmRlZC1BXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9FeHRlbmRlZC1BKVxuICAgICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcbiAgICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGRlYnVyci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcbiAgICAgKiAvLyA9PiAnZGVqYSB2dSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluLCBkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPXN0cmluZy5sZW5ndGhdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggdXAgdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCBgdGFyZ2V0YCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJywgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGxlbmd0aFxuICAgICAgICA6IGJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLCAwLCBsZW5ndGgpO1xuXG4gICAgICB2YXIgZW5kID0gcG9zaXRpb247XG4gICAgICBwb3NpdGlvbiAtPSB0YXJnZXQubGVuZ3RoO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID49IDAgJiYgc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBlbmQpID09IHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBhbmQgXCInXCIgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWxcbiAgICAgKiBjaGFyYWN0ZXJzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIFRob3VnaCB0aGUgXCI+XCIgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2VcbiAgICAgKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuICAgICAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcbiAgICAgKiBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXG4gICAgICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzXG4gICAgICogW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKSB0byByZWR1Y2VcbiAgICAgKiBYU1MgdmVjdG9ycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlcyB0aGUgYFJlZ0V4cGAgc3BlY2lhbCBjaGFyYWN0ZXJzIFwiXlwiLCBcIiRcIiwgXCJcXFwiLCBcIi5cIiwgXCIqXCIsIFwiK1wiLFxuICAgICAqIFwiP1wiLCBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIl1cIiwgXCJ7XCIsIFwifVwiLCBhbmQgXCJ8XCIgaW4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZVJlZ0V4cCgnW2xvZGFzaF0oaHR0cHM6Ly9sb2Rhc2guY29tLyknKTtcbiAgICAgKiAvLyA9PiAnXFxbbG9kYXNoXFxdXFwoaHR0cHM6Ly9sb2Rhc2hcXC5jb20vXFwpJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1JlZ0V4cENoYXIudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW2tlYmFiIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1NwZWNpYWxfY2FzZV9zdHlsZXMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICovXG4gICAgdmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICctJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCctLUZvby1CYXItLScpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICovXG4gICAgdmFyIGxvd2VyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubG93ZXJGaXJzdCgnRnJlZCcpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ2ZSRUQnXG4gICAgICovXG4gICAgdmFyIGxvd2VyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvTG93ZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlcyBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC5cbiAgICAgKiBQYWRkaW5nIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGNhbid0IGJlIGV2ZW5seSBkaXZpZGVkIGJ5IGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4KTtcbiAgICAgKiAvLyA9PiAnICBhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHN0ckxlbmd0aCA+PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBtaWQgPSAobGVuZ3RoIC0gc3RyTGVuZ3RoKSAvIDI7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBjcmVhdGVQYWRkaW5nKG5hdGl2ZUZsb29yKG1pZCksIGNoYXJzKSArXG4gICAgICAgIHN0cmluZyArXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlQ2VpbChtaWQpLCBjaGFycylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgcmlnaHQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJ2FiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkRW5kKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgPyAoc3RyaW5nICsgY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSlcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICcgICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1fYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWRTdGFydChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICByZXR1cm4gKGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGgpXG4gICAgICAgID8gKGNyZWF0ZVBhZGRpbmcobGVuZ3RoIC0gc3RyTGVuZ3RoLCBjaGFycykgKyBzdHJpbmcpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC4gSWYgYHJhZGl4YCBpc1xuICAgICAqIGB1bmRlZmluZWRgIG9yIGAwYCwgYSBgcmFkaXhgIG9mIGAxMGAgaXMgdXNlZCB1bmxlc3MgYHZhbHVlYCBpcyBhXG4gICAgICogaGV4YWRlY2ltYWwsIGluIHdoaWNoIGNhc2UgYSBgcmFkaXhgIG9mIGAxNmAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhbGlnbnMgd2l0aCB0aGVcbiAgICAgKiBbRVM1IGltcGxlbWVudGF0aW9uXShodHRwczovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuMikgb2YgYHBhcnNlSW50YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4PTEwXSBUaGUgcmFkaXggdG8gaW50ZXJwcmV0IGB2YWx1ZWAgYnkuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYXJzZUludCgnMDgnKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnMDgnLCAnMTAnXSwgXy5wYXJzZUludCk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlSW50KHN0cmluZywgcmFkaXgsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgfHwgcmFkaXggPT0gbnVsbCkge1xuICAgICAgICByYWRpeCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHJhZGl4KSB7XG4gICAgICAgIHJhZGl4ID0gK3JhZGl4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KHRvU3RyaW5nKHN0cmluZykucmVwbGFjZShyZVRyaW1TdGFydCwgJycpLCByYWRpeCB8fCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBlYXRzIHRoZSBnaXZlbiBzdHJpbmcgYG5gIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBlYXQoJyonLCAzKTtcbiAgICAgKiAvLyA9PiAnKioqJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDIpO1xuICAgICAqIC8vID0+ICdhYmNhYmMnXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBuLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJlcGVhdCh0b1N0cmluZyhzdHJpbmcpLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBtYXRjaGVzIGZvciBgcGF0dGVybmAgaW4gYHN0cmluZ2Agd2l0aCBgcmVwbGFjZW1lbnRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BTdHJpbmcjcmVwbGFjZWBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9yZXBsYWNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IHJlcGxhY2VtZW50IFRoZSBtYXRjaCByZXBsYWNlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBtb2RpZmllZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVwbGFjZSgnSGkgRnJlZCcsICdGcmVkJywgJ0Jhcm5leScpO1xuICAgICAqIC8vID0+ICdIaSBCYXJuZXknXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZSgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKGFyZ3NbMF0pO1xuXG4gICAgICByZXR1cm4gYXJncy5sZW5ndGggPCAzID8gc3RyaW5nIDogc3RyaW5nLnJlcGxhY2UoYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBbc25ha2UgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU25ha2VfY2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzbmFrZSBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnLS1GT08tQkFSLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKi9cbiAgICB2YXIgc25ha2VDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJ18nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BTdHJpbmcjc3BsaXRgXShodHRwczovL21kbi5pby9TdHJpbmcvc3BsaXQpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNwbGl0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gc2VwYXJhdG9yIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byBzcGxpdCBieS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBUaGUgbGVuZ3RoIHRvIHRydW5jYXRlIHJlc3VsdHMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzdHJpbmcgc2VnbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3BsaXQoJ2EtYi1jJywgJy0nLCAyKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3BsaXQoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICBpZiAobGltaXQgJiYgdHlwZW9mIGxpbWl0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gbGltaXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBsaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfQVJSQVlfTEVOR1RIIDogbGltaXQgPj4+IDA7XG4gICAgICBpZiAoIWxpbWl0KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChcbiAgICAgICAgICAgIHR5cGVvZiBzZXBhcmF0b3IgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIChzZXBhcmF0b3IgIT0gbnVsbCAmJiAhaXNSZWdFeHAoc2VwYXJhdG9yKSlcbiAgICAgICAgICApKSB7XG4gICAgICAgIHNlcGFyYXRvciA9IGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoIXNlcGFyYXRvciAmJiBoYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICAgICAgICByZXR1cm4gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkoc3RyaW5nKSwgMCwgbGltaXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW3N0YXJ0IGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1N0eWxpc3RpY19vcl9zcGVjaWFsaXNlZF91c2FnZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdGFydCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICovXG4gICAgdmFyIHN0YXJ0Q2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHVwcGVyRmlyc3Qod29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249MF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCBgdGFyZ2V0YCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PSBudWxsXG4gICAgICAgID8gMFxuICAgICAgICA6IGJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLCAwLCBzdHJpbmcubGVuZ3RoKTtcblxuICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIHRhcmdldC5sZW5ndGgpID09IHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCBjYW4gaW50ZXJwb2xhdGUgZGF0YSBwcm9wZXJ0aWVzXG4gICAgICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cbiAgICAgKiBcImVzY2FwZVwiIGRlbGltaXRlcnMsIGFuZCBleGVjdXRlIEphdmFTY3JpcHQgaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuIERhdGFcbiAgICAgKiBwcm9wZXJ0aWVzIG1heSBiZSBhY2Nlc3NlZCBhcyBmcmVlIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUuIElmIGEgc2V0dGluZ1xuICAgICAqIG9iamVjdCBpcyBnaXZlbiwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXG4gICAgICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gICAgICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICAgICAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICAgICAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXNjYXBlXVxuICAgICAqICBUaGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXZhbHVhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmV2YWx1YXRlXVxuICAgICAqICBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0cz1fLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c11cbiAgICAgKiAgQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxuICAgICAqICBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMPSdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzW25dJ11cbiAgICAgKiAgVGhlIHNvdXJjZVVSTCBvZiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhcmlhYmxlPSdvYmonXVxuICAgICAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlciB0byBlc2NhcGUgZGF0YSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBfLmZvckVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBFUyB0ZW1wbGF0ZSBsaXRlcmFsIGRlbGltaXRlciBhcyBhbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIC8vIERpc2FibGUgc3VwcG9ydCBieSByZXBsYWNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dC5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JT0gXCJcXFxcPCUtIHZhbHVlICVcXFxcPlwiICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gICAgICogLy8gPT4gJzwlLSB2YWx1ZSAlPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cbiAgICAgKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAgICAgKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAvLyAgIHJldHVybiBfX3A7XG4gICAgICogLy8gfVxuICAgICAqXG4gICAgICogLy8gVXNlIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLlxuICAgICAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXG4gICAgICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2pzdC5qcycpLCAnXFxcbiAgICAgKiAgIHZhciBKU1QgPSB7XFxcbiAgICAgKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAgICAgKiAgIH07XFxcbiAgICAgKiAnKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG4gICAgICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gICAgICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzIChodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UKS5cbiAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuXG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBvcHRpb25zID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbik7XG5cbiAgICAgIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgICAgIHZhciBpc0VzY2FwaW5nLFxuICAgICAgICAgIGlzRXZhbHVhdGluZyxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgICAgIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgICAgIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICAgICAsICdnJyk7XG5cbiAgICAgIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnLy8jIHNvdXJjZVVSTD0nICtcbiAgICAgICAgKCdzb3VyY2VVUkwnIGluIG9wdGlvbnNcbiAgICAgICAgICA/IG9wdGlvbnMuc291cmNlVVJMXG4gICAgICAgICAgOiAoJ2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbJyArICgrK3RlbXBsYXRlQ291bnRlcikgKyAnXScpXG4gICAgICAgICkgKyAnXFxuJztcblxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2FuJ3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgICAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIG5lZWRzIGBtYXRjaGAgcmV0dXJuZWQgaW5cbiAgICAgICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cbiAgICAgIHZhciB2YXJpYWJsZSA9IG9wdGlvbnMudmFyaWFibGU7XG4gICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgIHNvdXJjZSA9ICd3aXRoIChvYmopIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICAgICAgfVxuICAgICAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxuICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gICAgICAvLyBGcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5LlxuICAgICAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xuICAgICAgICAodmFyaWFibGVcbiAgICAgICAgICA/ICcnXG4gICAgICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgXCJ2YXIgX190LCBfX3AgPSAnJ1wiICtcbiAgICAgICAgKGlzRXNjYXBpbmdcbiAgICAgICAgICAgPyAnLCBfX2UgPSBfLmVzY2FwZSdcbiAgICAgICAgICAgOiAnJ1xuICAgICAgICApICtcbiAgICAgICAgKGlzRXZhbHVhdGluZ1xuICAgICAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICAgICAgOiAnO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIHNvdXJjZSArXG4gICAgICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgICAgIHZhciByZXN1bHQgPSBhdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSlcbiAgICAgICAgICAuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgICAgIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgaWYgKGlzRXJyb3IocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBhIHdob2xlLCB0byBsb3dlciBjYXNlIGp1c3QgbGlrZVxuICAgICAqIFtTdHJpbmcjdG9Mb3dlckNhc2VdKGh0dHBzOi8vbWRuLmlvL3RvTG93ZXJDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0xvd2VyKCctLUZvby1CYXItLScpO1xuICAgICAqIC8vID0+ICctLWZvby1iYXItLSdcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb2JhcidcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnX19mb29fYmFyX18nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Mb3dlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBhIHdob2xlLCB0byB1cHBlciBjYXNlIGp1c3QgbGlrZVxuICAgICAqIFtTdHJpbmcjdG9VcHBlckNhc2VdKGh0dHBzOi8vbWRuLmlvL3RvVXBwZXJDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVwcGVyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1VwcGVyKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICctLUZPTy1CQVItLSdcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPT0JBUidcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnX19GT09fQkFSX18nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9VcHBlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbSgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLm1hcChbJyAgZm9vICAnLCAnICBiYXIgICddLCBfLnRyaW0pO1xuICAgICAqIC8vID0+IFsnZm9vJywgJ2JhciddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbShzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgY2hyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoY2hhcnMpLFxuICAgICAgICAgIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpLFxuICAgICAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykgKyAxO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0LCBlbmQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbUVuZCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICcgIGFiYydcbiAgICAgKlxuICAgICAqIF8udHJpbUVuZCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJy1fLWFiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltRW5kKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbUVuZCwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKSArIDE7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMCwgZW5kKS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbVN0YXJ0KCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYyAgJ1xuICAgICAqXG4gICAgICogXy50cmltU3RhcnQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMtXy0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbVN0YXJ0KHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIGBzdHJpbmdgIGlmIGl0J3MgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBUaGUgbGFzdCBjaGFyYWN0ZXJzIG9mIHRoZSB0cnVuY2F0ZWQgc3RyaW5nIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBvbWlzc2lvblxuICAgICAqIHN0cmluZyB3aGljaCBkZWZhdWx0cyB0byBcIi4uLlwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRydW5jYXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MzBdIFRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9taXNzaW9uPScuLi4nXSBUaGUgc3RyaW5nIHRvIGluZGljYXRlIHRleHQgaXMgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtvcHRpb25zLnNlcGFyYXRvcl0gVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHRydW5jYXRlIHRvLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRydW5jYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nKTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAnICdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLC4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogLyw/ICsvXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZS4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnb21pc3Npb24nOiAnIFsuLi5dJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWcgWy4uLl0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gREVGQVVMVF9UUlVOQ19MRU5HVEgsXG4gICAgICAgICAgb21pc3Npb24gPSBERUZBVUxUX1RSVU5DX09NSVNTSU9OO1xuXG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9ICdzZXBhcmF0b3InIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlcGFyYXRvciA6IHNlcGFyYXRvcjtcbiAgICAgICAgbGVuZ3RoID0gJ2xlbmd0aCcgaW4gb3B0aW9ucyA/IHRvSW50ZWdlcihvcHRpb25zLmxlbmd0aCkgOiBsZW5ndGg7XG4gICAgICAgIG9taXNzaW9uID0gJ29taXNzaW9uJyBpbiBvcHRpb25zID8gYmFzZVRvU3RyaW5nKG9wdGlvbnMub21pc3Npb24pIDogb21pc3Npb247XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIGlmIChoYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyk7XG4gICAgICAgIHN0ckxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA+PSBzdHJMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBlbmQgPSBsZW5ndGggLSBzdHJpbmdTaXplKG9taXNzaW9uKTtcbiAgICAgIGlmIChlbmQgPCAxKSB7XG4gICAgICAgIHJldHVybiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzdHJTeW1ib2xzXG4gICAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJylcbiAgICAgICAgOiBzdHJpbmcuc2xpY2UoMCwgZW5kKTtcblxuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJTeW1ib2xzKSB7XG4gICAgICAgIGVuZCArPSAocmVzdWx0Lmxlbmd0aCAtIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICBpZiAoc3RyaW5nLnNsaWNlKGVuZCkuc2VhcmNoKHNlcGFyYXRvcikpIHtcbiAgICAgICAgICB2YXIgbWF0Y2gsXG4gICAgICAgICAgICAgIHN1YnN0cmluZyA9IHJlc3VsdDtcblxuICAgICAgICAgIGlmICghc2VwYXJhdG9yLmdsb2JhbCkge1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIHRvU3RyaW5nKHJlRmxhZ3MuZXhlYyhzZXBhcmF0b3IpKSArICdnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdWJzdHJpbmcpKSkge1xuICAgICAgICAgICAgdmFyIG5ld0VuZCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgbmV3RW5kID09PSB1bmRlZmluZWQgPyBlbmQgOiBuZXdFbmQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZy5pbmRleE9mKGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpLCBlbmQpICE9IGVuZCkge1xuICAgICAgICB2YXIgaW5kZXggPSByZXN1bHQubGFzdEluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYDsgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcbiAgICAgKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGFuZCBgJiMzOTtgIGluIGBzdHJpbmdgIHRvXG4gICAgICogdGhlaXIgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIEhUTUwgZW50aXRpZXMgYXJlIHVuZXNjYXBlZC4gVG8gdW5lc2NhcGUgYWRkaXRpb25hbFxuICAgICAqIEhUTUwgZW50aXRpZXMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNi4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc0VzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZWRIdG1sLCB1bmVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgc3BhY2Ugc2VwYXJhdGVkIHdvcmRzLCB0byB1cHBlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnLS1mb28tYmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKi9cbiAgICB2YXIgdXBwZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51cHBlckZpcnN0KCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfLnVwcGVyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnRlJFRCdcbiAgICAgKi9cbiAgICB2YXIgdXBwZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9VcHBlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3BhdHRlcm5dIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdvcmRzLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcGF0dGVybiA9IGd1YXJkID8gdW5kZWZpbmVkIDogcGF0dGVybjtcblxuICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSA/IHVuaWNvZGVXb3JkcyhzdHJpbmcpIDogYXNjaWlXb3JkcyhzdHJpbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICAgICAqIG9iamVjdC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGF0dGVtcHQuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICAgICAqIHZhciBlbGVtZW50cyA9IF8uYXR0ZW1wdChmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAqIH0sICc+Xz4nKTtcbiAgICAgKlxuICAgICAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gICAgICogICBlbGVtZW50cyA9IFtdO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICB2YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gaXNFcnJvcihlKSA/IGUgOiBuZXcgRXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBtZXRob2RzIG9mIGFuIG9iamVjdCB0byB0aGUgb2JqZWN0IGl0c2VsZiwgb3ZlcndyaXRpbmcgdGhlIGV4aXN0aW5nXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBtZXRob2ROYW1lcyBUaGUgb2JqZWN0IG1ldGhvZCBuYW1lcyB0byBiaW5kLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ2NsaWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdjbGlja2VkICcgKyB0aGlzLmxhYmVsKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5iaW5kQWxsKHZpZXcsIFsnY2xpY2snXSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHZpZXcuY2xpY2spO1xuICAgICAqIC8vID0+IExvZ3MgJ2NsaWNrZWQgZG9jcycgd2hlbiBjbGlja2VkLlxuICAgICAqL1xuICAgIHZhciBiaW5kQWxsID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBtZXRob2ROYW1lcykge1xuICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAga2V5ID0gdG9LZXkoa2V5KTtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBiaW5kKG9iamVjdFtrZXldLCBvYmplY3QpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGl0ZXJhdGVzIG92ZXIgYHBhaXJzYCBhbmQgaW52b2tlcyB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqIGZ1bmN0aW9uIG9mIHRoZSBmaXJzdCBwcmVkaWNhdGUgdG8gcmV0dXJuIHRydXRoeS4gVGhlIHByZWRpY2F0ZS1mdW5jdGlvblxuICAgICAqIHBhaXJzIGFyZSBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIHByZWRpY2F0ZS1mdW5jdGlvbiBwYWlycy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5jb25kKFtcbiAgICAgKiAgIFtfLm1hdGNoZXMoeyAnYSc6IDEgfSksICAgICAgICAgICBfLmNvbnN0YW50KCdtYXRjaGVzIEEnKV0sXG4gICAgICogICBbXy5jb25mb3Jtcyh7ICdiJzogXy5pc051bWJlciB9KSwgXy5jb25zdGFudCgnbWF0Y2hlcyBCJyldLFxuICAgICAqICAgW18uc3R1YlRydWUsICAgICAgICAgICAgICAgICAgICAgIF8uY29uc3RhbnQoJ25vIG1hdGNoJyldXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gJ21hdGNoZXMgQSdcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6IDAsICdiJzogMSB9KTtcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBCJ1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogJzEnLCAnYic6ICcyJyB9KTtcbiAgICAgKiAvLyA9PiAnbm8gbWF0Y2gnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZChwYWlycykge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLFxuICAgICAgICAgIHRvSXRlcmF0ZWUgPSBnZXRJdGVyYXRlZSgpO1xuXG4gICAgICBwYWlycyA9ICFsZW5ndGggPyBbXSA6IGFycmF5TWFwKHBhaXJzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFpclsxXSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdG9JdGVyYXRlZShwYWlyWzBdKSwgcGFpclsxXV07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpbmRleF07XG4gICAgICAgICAgaWYgKGFwcGx5KHBhaXJbMF0sIHRoaXMsIGFyZ3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkocGFpclsxXSwgdGhpcywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBwcmVkaWNhdGUgcHJvcGVydGllcyBvZiBgc291cmNlYCB3aXRoXG4gICAgICogdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdmFsdWVzIG9mIGEgZ2l2ZW4gb2JqZWN0LCByZXR1cm5pbmcgYHRydWVgIGlmXG4gICAgICogYWxsIHByZWRpY2F0ZXMgcmV0dXJuIHRydXRoeSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gYF8uY29uZm9ybXNUb2Agd2l0aFxuICAgICAqIGBzb3VyY2VgIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDIsICdiJzogMSB9LFxuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8uY29uZm9ybXMoeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAxOyB9IH0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmZvcm1zKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGJhc2VDb25mb3JtcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGB2YWx1ZWAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBkZWZhdWx0IHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZCBpblxuICAgICAqIGl0cyBwbGFjZS4gVGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGBudWxsYCxcbiAgICAgKiBvciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIFRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0VG8oMSwgMTApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdFRvKHVuZGVmaW5lZCwgMTApO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmYXVsdFRvKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUpID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBnaXZlbiBmdW5jdGlvbnNcbiAgICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtmdW5jc10gVGhlIGZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgXy5mbG93UmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93KFtfLmFkZCwgc3F1YXJlXSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvdyA9IGNyZWF0ZUZsb3coKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxvd2AgZXhjZXB0IHRoYXQgaXQgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXRcbiAgICAgKiBpbnZva2VzIHRoZSBnaXZlbiBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQHNlZSBfLmZsb3dcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93UmlnaHQoW3NxdWFyZSwgXy5hZGRdKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93UmlnaHQgPSBjcmVhdGVGbG93KHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZFxuICAgICAqIGZ1bmN0aW9uLiBJZiBgZnVuY2AgaXMgYSBwcm9wZXJ0eSBuYW1lLCB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm5zIHRoZVxuICAgICAqIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIGVsZW1lbnQuIElmIGBmdW5jYCBpcyBhbiBhcnJheSBvciBvYmplY3QsIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgY29udGFpbiB0aGUgZXF1aXZhbGVudFxuICAgICAqIHNvdXJjZSBwcm9wZXJ0aWVzLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5pdGVyYXRlZSh7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH1dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoWyd1c2VyJywgJ2ZyZWQnXSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwKHVzZXJzLCBfLml0ZXJhdGVlKCd1c2VyJykpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gQ3JlYXRlIGN1c3RvbSBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqIF8uaXRlcmF0ZWUgPSBfLndyYXAoXy5pdGVyYXRlZSwgZnVuY3Rpb24oaXRlcmF0ZWUsIGZ1bmMpIHtcbiAgICAgKiAgIHJldHVybiAhXy5pc1JlZ0V4cChmdW5jKSA/IGl0ZXJhdGVlKGZ1bmMpIDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICogICAgIHJldHVybiBmdW5jLnRlc3Qoc3RyaW5nKTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbJ2FiYycsICdkZWYnXSwgL2VmLyk7XG4gICAgICogLy8gPT4gWydkZWYnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGl0ZXJhdGVlKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiYXNlSXRlcmF0ZWUodHlwZW9mIGZ1bmMgPT0gJ2Z1bmN0aW9uJyA/IGZ1bmMgOiBiYXNlQ2xvbmUoZnVuYywgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGEgZ2l2ZW5cbiAgICAgKiBvYmplY3QgYW5kIGBzb3VyY2VgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGVxdWl2YWxlbnRcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmlzTWF0Y2hgIHdpdGggYHNvdXJjZWBcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXG4gICAgICogdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWUgYF8uaXNFcXVhbGBcbiAgICAgKiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5tYXRjaGVzKHsgJ2EnOiA0LCAnYyc6IDYgfSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0aGVcbiAgICAgKiB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QgdG8gYHNyY1ZhbHVlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGVcbiAgICAgKiBvYmplY3QgdmFsdWUgaXMgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0XG4gICAgICogYHNyY1ZhbHVlYCB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZVxuICAgICAqIGBfLmlzRXF1YWxgIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sXG4gICAgICogICB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQob2JqZWN0cywgXy5tYXRjaGVzUHJvcGVydHkoJ2EnLCA0KSk7XG4gICAgICogLy8gPT4geyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIGJhc2VDbG9uZShzcmNWYWx1ZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludm9rZXIgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDIpIH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogXy5jb25zdGFudCgxKSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoJ2EuYicpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKFsnYScsICdiJ10pKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kID0gYmFzZVJlc3QoZnVuY3Rpb24ocGF0aCwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tZXRob2RgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogdGhlIG1ldGhvZCBhdCBhIGdpdmVuIHBhdGggb2YgYG9iamVjdGAuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gXy50aW1lcygzLCBfLmNvbnN0YW50KSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL1xuICAgIHZhciBtZXRob2RPZiA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgZnVuY3Rpb24gcHJvcGVydGllcyBvZiBhIHNvdXJjZVxuICAgICAqIG9iamVjdCB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LiBJZiBgb2JqZWN0YCBpcyBhIGZ1bmN0aW9uLCB0aGVuIG1ldGhvZHNcbiAgICAgKiBhcmUgYWRkZWQgdG8gaXRzIHByb3RvdHlwZSBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVzZSBgXy5ydW5JbkNvbnRleHRgIHRvIGNyZWF0ZSBhIHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHRvXG4gICAgICogYXZvaWQgY29uZmxpY3RzIGNhdXNlZCBieSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gW29iamVjdD1sb2Rhc2hdIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGFpbj10cnVlXSBTcGVjaWZ5IHdoZXRoZXIgbWl4aW5zIGFyZSBjaGFpbmFibGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufE9iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gdm93ZWxzKHN0cmluZykge1xuICAgICAqICAgcmV0dXJuIF8uZmlsdGVyKHN0cmluZywgZnVuY3Rpb24odikge1xuICAgICAqICAgICByZXR1cm4gL1thZWlvdV0vaS50ZXN0KHYpO1xuICAgICAqICAgfSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSk7XG4gICAgICogXy52b3dlbHMoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXygnZnJlZCcpLnZvd2VscygpLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0sIHsgJ2NoYWluJzogZmFsc2UgfSk7XG4gICAgICogXygnZnJlZCcpLnZvd2VscygpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKSxcbiAgICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBwcm9wcyk7XG5cbiAgICAgIGlmIChvcHRpb25zID09IG51bGwgJiZcbiAgICAgICAgICAhKGlzT2JqZWN0KHNvdXJjZSkgJiYgKG1ldGhvZE5hbWVzLmxlbmd0aCB8fCAhcHJvcHMubGVuZ3RoKSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHNvdXJjZTtcbiAgICAgICAgc291cmNlID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSB0aGlzO1xuICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgICAgfVxuICAgICAgdmFyIGNoYWluID0gIShpc09iamVjdChvcHRpb25zKSAmJiAnY2hhaW4nIGluIG9wdGlvbnMpIHx8ICEhb3B0aW9ucy5jaGFpbixcbiAgICAgICAgICBpc0Z1bmMgPSBpc0Z1bmN0aW9uKG9iamVjdCk7XG5cbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgZnVuYyA9IHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICAgICAgb2JqZWN0W21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fO1xuICAgICAgICAgICAgaWYgKGNoYWluIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvYmplY3QodGhpcy5fX3dyYXBwZWRfXyksXG4gICAgICAgICAgICAgICAgICBhY3Rpb25zID0gcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO1xuXG4gICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7ICdmdW5jJzogZnVuYywgJ2FyZ3MnOiBhcmd1bWVudHMsICd0aGlzQXJnJzogb2JqZWN0IH0pO1xuICAgICAgICAgICAgICByZXN1bHQuX19jaGFpbl9fID0gY2hhaW5BbGw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShvYmplY3QsIGFycmF5UHVzaChbdGhpcy52YWx1ZSgpXSwgYXJndW1lbnRzKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxvZGFzaCA9IF8ubm9Db25mbGljdCgpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICBpZiAocm9vdC5fID09PSB0aGlzKSB7XG4gICAgICAgIHJvb3QuXyA9IG9sZERhc2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLm5vb3ApO1xuICAgICAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBnZXRzIHRoZSBhcmd1bWVudCBhdCBpbmRleCBgbmAuIElmIGBuYCBpcyBuZWdhdGl2ZSxcbiAgICAgKiB0aGUgbnRoIGFyZ3VtZW50IGZyb20gdGhlIGVuZCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBpbmRleCBvZiB0aGUgYXJndW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhc3MtdGhydSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm50aEFyZygxKTtcbiAgICAgKiBmdW5jKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gJ2InXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ubnRoQXJnKC0yKTtcbiAgICAgKiBmdW5jKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gJ2MnXG4gICAgICovXG4gICAgZnVuY3Rpb24gbnRoQXJnKG4pIHtcbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gYmFzZU50aChhcmdzLCBuKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGl0ZXJhdGVlc2Agd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzXG4gICAgICogYW5kIHJldHVybnMgdGhlaXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXIoW01hdGgubWF4LCBNYXRoLm1pbl0pO1xuICAgICAqXG4gICAgICogZnVuYygxLCAyLCAzLCA0KTtcbiAgICAgKiAvLyA9PiBbNCwgMV1cbiAgICAgKi9cbiAgICB2YXIgb3ZlciA9IGNyZWF0ZU92ZXIoYXJyYXlNYXApO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmICoqYWxsKiogb2YgdGhlIGBwcmVkaWNhdGVzYCByZXR1cm5cbiAgICAgKiB0cnV0aHkgd2hlbiBpbnZva2VkIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtwcmVkaWNhdGVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIHByZWRpY2F0ZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyRXZlcnkoW0Jvb2xlYW4sIGlzRmluaXRlXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKCcxJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogZnVuYyhOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIG92ZXJFdmVyeSA9IGNyZWF0ZU92ZXIoYXJyYXlFdmVyeSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgKiphbnkqKiBvZiB0aGUgYHByZWRpY2F0ZXNgIHJldHVyblxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJTb21lKFtCb29sZWFuLCBpc0Zpbml0ZV0pO1xuICAgICAqXG4gICAgICogZnVuYygnMScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIG92ZXJTb21lID0gY3JlYXRlT3ZlcihhcnJheVNvbWUpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICAgICAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnByb3BlcnR5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJuc1xuICAgICAqIHRoZSB2YWx1ZSBhdCBhIGdpdmVuIHBhdGggb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzAsIDEsIDJdLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBBIHN0ZXAgb2YgYC0xYCBpcyB1c2VkIGlmIGEgbmVnYXRpdmVcbiAgICAgKiBgc3RhcnRgIGlzIHNwZWNpZmllZCB3aXRob3V0IGFuIGBlbmRgIG9yIGBzdGVwYC4gSWYgYGVuZGAgaXMgbm90IHNwZWNpZmllZCxcbiAgICAgKiBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoNCk7XG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKC00KTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICB2YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yYW5nZWAgZXhjZXB0IHRoYXQgaXQgcG9wdWxhdGVzIHZhbHVlcyBpblxuICAgICAqIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDQpO1xuICAgICAqIC8vID0+IFszLCAyLCAxLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KC00KTtcbiAgICAgKiAvLyA9PiBbLTMsIC0yLCAtMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA1KTtcbiAgICAgKiAvLyA9PiBbNCwgMywgMiwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzE1LCAxMCwgNSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgdmFyIHJhbmdlUmlnaHQgPSBjcmVhdGVSYW5nZSh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAgICAgKiAvLyA9PiBbW10sIFtdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICAgICAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uc3R1Yk9iamVjdCk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAgICAgKiAvLyA9PiBbe30sIHt9XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YlN0cmluZyk7XG4gICAgICogLy8gPT4gWycnLCAnJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YlRydWUpO1xuICAgICAqIC8vID0+IFt0cnVlLCB0cnVlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJUcnVlKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgaXRlcmF0ZWUgYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBlYWNoIGludm9jYXRpb24uIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBTdHJpbmcpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJywgJzInXVxuICAgICAqXG4gICAgICogIF8udGltZXMoNCwgXy5jb25zdGFudCgwKSk7XG4gICAgICogLy8gPT4gWzAsIDAsIDAsIDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICBpZiAobiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gTUFYX0FSUkFZX0xFTkdUSCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCk7XG5cbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUpO1xuICAgICAgbiAtPSBNQVhfQVJSQVlfTEVOR1RIO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZVRpbWVzKGxlbmd0aCwgaXRlcmF0ZWUpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIGl0ZXJhdGVlKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1BhdGgoJ2EuYi5jJyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiBfLnRvUGF0aCgnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnMCcsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGF0aCh2YWx1ZSkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgdG9LZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3ltYm9sKHZhbHVlKSA/IFt2YWx1ZV0gOiBjb3B5QXJyYXkoc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgZ2l2ZW4sIHRoZSBJRCBpcyBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXg9JyddIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICAgICAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoKTtcbiAgICAgKiAvLyA9PiAnMTA1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gICAgICByZXR1cm4gdG9TdHJpbmcocHJlZml4KSArIGlkO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdWdlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhbiBhZGRpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWRkZW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGFuIGFkZGl0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRvdGFsLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmFkZCg2LCA0KTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIHZhciBhZGQgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGF1Z2VuZCwgYWRkZW5kKSB7XG4gICAgICByZXR1cm4gYXVnZW5kICsgYWRkZW5kO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB1cCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZCB1cC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgdXAgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNC4wMDYpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2LjAwNCwgMik7XG4gICAgICogLy8gPT4gNi4wMVxuICAgICAqXG4gICAgICogXy5jZWlsKDYwNDAsIC0yKTtcbiAgICAgKiAvLyA9PiA2MTAwXG4gICAgICovXG4gICAgdmFyIGNlaWwgPSBjcmVhdGVSb3VuZCgnY2VpbCcpO1xuXG4gICAgLyoqXG4gICAgICogRGl2aWRlIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aWRlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhIGRpdmlzaW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpc29yIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgZGl2aXNpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcXVvdGllbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGl2aWRlKDYsIDQpO1xuICAgICAqIC8vID0+IDEuNVxuICAgICAqL1xuICAgIHZhciBkaXZpZGUgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICByZXR1cm4gZGl2aWRlbmQgLyBkaXZpc29yO1xuICAgIH0sIDEpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCBkb3duIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIGRvd24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCBkb3duIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgZG93biBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoMC4wNDYsIDIpO1xuICAgICAqIC8vID0+IDAuMDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQwMDBcbiAgICAgKi9cbiAgICB2YXIgZmxvb3IgPSBjcmVhdGVSb3VuZCgnZmxvb3InKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICAgICAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWF4KFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VHdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tYXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5tYXhCeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IHsgJ24nOiAyIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWF4Qnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiB7ICduJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4QnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUd0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWVhbiBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tZWFuKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYW4oYXJyYXkpIHtcbiAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgaWRlbnRpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVhbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHRvIGJlIGF2ZXJhZ2VkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogNCB9LCB7ICduJzogMiB9LCB7ICduJzogOCB9LCB7ICduJzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tZWFuQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICAgICAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1pbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8ubWluKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW4oYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VMdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5taW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5taW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWluQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUx0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxpZXIgVGhlIGZpcnN0IG51bWJlciBpbiBhIG11bHRpcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aXBsaWNhbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwcm9kdWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm11bHRpcGx5KDYsIDQpO1xuICAgICAqIC8vID0+IDI0XG4gICAgICovXG4gICAgdmFyIG11bHRpcGx5ID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtdWx0aXBsaWVyLCBtdWx0aXBsaWNhbmQpIHtcbiAgICAgIHJldHVybiBtdWx0aXBsaWVyICogbXVsdGlwbGljYW5kO1xuICAgIH0sIDEpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2LCAyKTtcbiAgICAgKiAvLyA9PiA0LjAxXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MTAwXG4gICAgICovXG4gICAgdmFyIHJvdW5kID0gY3JlYXRlUm91bmQoJ3JvdW5kJyk7XG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdCB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbnVlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhIHN1YnRyYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdWJ0cmFoZW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgZGlmZmVyZW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdWJ0cmFjdCg2LCA0KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgdmFyIHN1YnRyYWN0ID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtaW51ZW5kLCBzdWJ0cmFoZW5kKSB7XG4gICAgICByZXR1cm4gbWludWVuZCAtIHN1YnRyYWhlbmQ7XG4gICAgfSwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VtKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW0oYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTdW0oYXJyYXksIGlkZW50aXR5KVxuICAgICAgICA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zdW1gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBzdW1tZWQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVN1bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IDA7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdGhhdCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgaW4gY2hhaW4gc2VxdWVuY2VzLlxuICAgIGxvZGFzaC5hZnRlciA9IGFmdGVyO1xuICAgIGxvZGFzaC5hcnkgPSBhcnk7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXNzaWduSW4gPSBhc3NpZ25JbjtcbiAgICBsb2Rhc2guYXNzaWduSW5XaXRoID0gYXNzaWduSW5XaXRoO1xuICAgIGxvZGFzaC5hc3NpZ25XaXRoID0gYXNzaWduV2l0aDtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmVmb3JlID0gYmVmb3JlO1xuICAgIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgICBsb2Rhc2guYmluZEFsbCA9IGJpbmRBbGw7XG4gICAgbG9kYXNoLmJpbmRLZXkgPSBiaW5kS2V5O1xuICAgIGxvZGFzaC5jYXN0QXJyYXkgPSBjYXN0QXJyYXk7XG4gICAgbG9kYXNoLmNoYWluID0gY2hhaW47XG4gICAgbG9kYXNoLmNodW5rID0gY2h1bms7XG4gICAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgIGxvZGFzaC5jb25jYXQgPSBjb25jYXQ7XG4gICAgbG9kYXNoLmNvbmQgPSBjb25kO1xuICAgIGxvZGFzaC5jb25mb3JtcyA9IGNvbmZvcm1zO1xuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5jdXJyeVJpZ2h0ID0gY3VycnlSaWdodDtcbiAgICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICBsb2Rhc2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICBsb2Rhc2guZGVmYXVsdHNEZWVwID0gZGVmYXVsdHNEZWVwO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZUJ5ID0gZGlmZmVyZW5jZUJ5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlV2l0aCA9IGRpZmZlcmVuY2VXaXRoO1xuICAgIGxvZGFzaC5kcm9wID0gZHJvcDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0ID0gZHJvcFJpZ2h0O1xuICAgIGxvZGFzaC5kcm9wUmlnaHRXaGlsZSA9IGRyb3BSaWdodFdoaWxlO1xuICAgIGxvZGFzaC5kcm9wV2hpbGUgPSBkcm9wV2hpbGU7XG4gICAgbG9kYXNoLmZpbGwgPSBmaWxsO1xuICAgIGxvZGFzaC5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgbG9kYXNoLmZsYXRNYXAgPSBmbGF0TWFwO1xuICAgIGxvZGFzaC5mbGF0TWFwRGVlcCA9IGZsYXRNYXBEZWVwO1xuICAgIGxvZGFzaC5mbGF0TWFwRGVwdGggPSBmbGF0TWFwRGVwdGg7XG4gICAgbG9kYXNoLmZsYXR0ZW4gPSBmbGF0dGVuO1xuICAgIGxvZGFzaC5mbGF0dGVuRGVlcCA9IGZsYXR0ZW5EZWVwO1xuICAgIGxvZGFzaC5mbGF0dGVuRGVwdGggPSBmbGF0dGVuRGVwdGg7XG4gICAgbG9kYXNoLmZsaXAgPSBmbGlwO1xuICAgIGxvZGFzaC5mbG93ID0gZmxvdztcbiAgICBsb2Rhc2guZmxvd1JpZ2h0ID0gZmxvd1JpZ2h0O1xuICAgIGxvZGFzaC5mcm9tUGFpcnMgPSBmcm9tUGFpcnM7XG4gICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2guZnVuY3Rpb25zSW4gPSBmdW5jdGlvbnNJbjtcbiAgICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XG4gICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbkJ5ID0gaW50ZXJzZWN0aW9uQnk7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbldpdGggPSBpbnRlcnNlY3Rpb25XaXRoO1xuICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgbG9kYXNoLmludmVydEJ5ID0gaW52ZXJ0Qnk7XG4gICAgbG9kYXNoLmludm9rZU1hcCA9IGludm9rZU1hcDtcbiAgICBsb2Rhc2guaXRlcmF0ZWUgPSBpdGVyYXRlZTtcbiAgICBsb2Rhc2gua2V5QnkgPSBrZXlCeTtcbiAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgbG9kYXNoLmtleXNJbiA9IGtleXNJbjtcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBLZXlzID0gbWFwS2V5cztcbiAgICBsb2Rhc2gubWFwVmFsdWVzID0gbWFwVmFsdWVzO1xuICAgIGxvZGFzaC5tYXRjaGVzID0gbWF0Y2hlcztcbiAgICBsb2Rhc2gubWF0Y2hlc1Byb3BlcnR5ID0gbWF0Y2hlc1Byb3BlcnR5O1xuICAgIGxvZGFzaC5tZW1vaXplID0gbWVtb2l6ZTtcbiAgICBsb2Rhc2gubWVyZ2UgPSBtZXJnZTtcbiAgICBsb2Rhc2gubWVyZ2VXaXRoID0gbWVyZ2VXaXRoO1xuICAgIGxvZGFzaC5tZXRob2QgPSBtZXRob2Q7XG4gICAgbG9kYXNoLm1ldGhvZE9mID0gbWV0aG9kT2Y7XG4gICAgbG9kYXNoLm1peGluID0gbWl4aW47XG4gICAgbG9kYXNoLm5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgICBsb2Rhc2gubnRoQXJnID0gbnRoQXJnO1xuICAgIGxvZGFzaC5vbWl0ID0gb21pdDtcbiAgICBsb2Rhc2gub21pdEJ5ID0gb21pdEJ5O1xuICAgIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgICBsb2Rhc2gub3JkZXJCeSA9IG9yZGVyQnk7XG4gICAgbG9kYXNoLm92ZXIgPSBvdmVyO1xuICAgIGxvZGFzaC5vdmVyQXJncyA9IG92ZXJBcmdzO1xuICAgIGxvZGFzaC5vdmVyRXZlcnkgPSBvdmVyRXZlcnk7XG4gICAgbG9kYXNoLm92ZXJTb21lID0gb3ZlclNvbWU7XG4gICAgbG9kYXNoLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgIGxvZGFzaC5wYXJ0aWFsUmlnaHQgPSBwYXJ0aWFsUmlnaHQ7XG4gICAgbG9kYXNoLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcbiAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgbG9kYXNoLnBpY2tCeSA9IHBpY2tCeTtcbiAgICBsb2Rhc2gucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICBsb2Rhc2gucHJvcGVydHlPZiA9IHByb3BlcnR5T2Y7XG4gICAgbG9kYXNoLnB1bGwgPSBwdWxsO1xuICAgIGxvZGFzaC5wdWxsQWxsID0gcHVsbEFsbDtcbiAgICBsb2Rhc2gucHVsbEFsbEJ5ID0gcHVsbEFsbEJ5O1xuICAgIGxvZGFzaC5wdWxsQWxsV2l0aCA9IHB1bGxBbGxXaXRoO1xuICAgIGxvZGFzaC5wdWxsQXQgPSBwdWxsQXQ7XG4gICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgbG9kYXNoLnJhbmdlUmlnaHQgPSByYW5nZVJpZ2h0O1xuICAgIGxvZGFzaC5yZWFyZyA9IHJlYXJnO1xuICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgbG9kYXNoLnJlbW92ZSA9IHJlbW92ZTtcbiAgICBsb2Rhc2gucmVzdCA9IHJlc3Q7XG4gICAgbG9kYXNoLnJldmVyc2UgPSByZXZlcnNlO1xuICAgIGxvZGFzaC5zYW1wbGVTaXplID0gc2FtcGxlU2l6ZTtcbiAgICBsb2Rhc2guc2V0ID0gc2V0O1xuICAgIGxvZGFzaC5zZXRXaXRoID0gc2V0V2l0aDtcbiAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgbG9kYXNoLnNsaWNlID0gc2xpY2U7XG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICBsb2Rhc2guc29ydGVkVW5pcSA9IHNvcnRlZFVuaXE7XG4gICAgbG9kYXNoLnNvcnRlZFVuaXFCeSA9IHNvcnRlZFVuaXFCeTtcbiAgICBsb2Rhc2guc3BsaXQgPSBzcGxpdDtcbiAgICBsb2Rhc2guc3ByZWFkID0gc3ByZWFkO1xuICAgIGxvZGFzaC50YWlsID0gdGFpbDtcbiAgICBsb2Rhc2gudGFrZSA9IHRha2U7XG4gICAgbG9kYXNoLnRha2VSaWdodCA9IHRha2VSaWdodDtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0V2hpbGUgPSB0YWtlUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2gudGFrZVdoaWxlID0gdGFrZVdoaWxlO1xuICAgIGxvZGFzaC50YXAgPSB0YXA7XG4gICAgbG9kYXNoLnRocm90dGxlID0gdGhyb3R0bGU7XG4gICAgbG9kYXNoLnRocnUgPSB0aHJ1O1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudG9QYWlycyA9IHRvUGFpcnM7XG4gICAgbG9kYXNoLnRvUGFpcnNJbiA9IHRvUGFpcnNJbjtcbiAgICBsb2Rhc2gudG9QYXRoID0gdG9QYXRoO1xuICAgIGxvZGFzaC50b1BsYWluT2JqZWN0ID0gdG9QbGFpbk9iamVjdDtcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGxvZGFzaC51bmFyeSA9IHVuYXJ5O1xuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuICAgIGxvZGFzaC51bmlvbkJ5ID0gdW5pb25CeTtcbiAgICBsb2Rhc2gudW5pb25XaXRoID0gdW5pb25XaXRoO1xuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgICBsb2Rhc2gudW5pcUJ5ID0gdW5pcUJ5O1xuICAgIGxvZGFzaC51bmlxV2l0aCA9IHVuaXFXaXRoO1xuICAgIGxvZGFzaC51bnNldCA9IHVuc2V0O1xuICAgIGxvZGFzaC51bnppcCA9IHVuemlwO1xuICAgIGxvZGFzaC51bnppcFdpdGggPSB1bnppcFdpdGg7XG4gICAgbG9kYXNoLnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICBsb2Rhc2gudXBkYXRlV2l0aCA9IHVwZGF0ZVdpdGg7XG4gICAgbG9kYXNoLnZhbHVlcyA9IHZhbHVlcztcbiAgICBsb2Rhc2gudmFsdWVzSW4gPSB2YWx1ZXNJbjtcbiAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gICAgbG9kYXNoLndvcmRzID0gd29yZHM7XG4gICAgbG9kYXNoLndyYXAgPSB3cmFwO1xuICAgIGxvZGFzaC54b3IgPSB4b3I7XG4gICAgbG9kYXNoLnhvckJ5ID0geG9yQnk7XG4gICAgbG9kYXNoLnhvcldpdGggPSB4b3JXaXRoO1xuICAgIGxvZGFzaC56aXAgPSB6aXA7XG4gICAgbG9kYXNoLnppcE9iamVjdCA9IHppcE9iamVjdDtcbiAgICBsb2Rhc2guemlwT2JqZWN0RGVlcCA9IHppcE9iamVjdERlZXA7XG4gICAgbG9kYXNoLnppcFdpdGggPSB6aXBXaXRoO1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmVudHJpZXMgPSB0b1BhaXJzO1xuICAgIGxvZGFzaC5lbnRyaWVzSW4gPSB0b1BhaXJzSW47XG4gICAgbG9kYXNoLmV4dGVuZCA9IGFzc2lnbkluO1xuICAgIGxvZGFzaC5leHRlbmRXaXRoID0gYXNzaWduSW5XaXRoO1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIG1peGluKGxvZGFzaCwgbG9kYXNoKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgaW4gY2hhaW4gc2VxdWVuY2VzLlxuICAgIGxvZGFzaC5hZGQgPSBhZGQ7XG4gICAgbG9kYXNoLmF0dGVtcHQgPSBhdHRlbXB0O1xuICAgIGxvZGFzaC5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG4gICAgbG9kYXNoLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuICAgIGxvZGFzaC5jZWlsID0gY2VpbDtcbiAgICBsb2Rhc2guY2xhbXAgPSBjbGFtcDtcbiAgICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcbiAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgIGxvZGFzaC5jbG9uZURlZXBXaXRoID0gY2xvbmVEZWVwV2l0aDtcbiAgICBsb2Rhc2guY2xvbmVXaXRoID0gY2xvbmVXaXRoO1xuICAgIGxvZGFzaC5jb25mb3Jtc1RvID0gY29uZm9ybXNUbztcbiAgICBsb2Rhc2guZGVidXJyID0gZGVidXJyO1xuICAgIGxvZGFzaC5kZWZhdWx0VG8gPSBkZWZhdWx0VG87XG4gICAgbG9kYXNoLmRpdmlkZSA9IGRpdmlkZTtcbiAgICBsb2Rhc2guZW5kc1dpdGggPSBlbmRzV2l0aDtcbiAgICBsb2Rhc2guZXEgPSBlcTtcbiAgICBsb2Rhc2guZXNjYXBlID0gZXNjYXBlO1xuICAgIGxvZGFzaC5lc2NhcGVSZWdFeHAgPSBlc2NhcGVSZWdFeHA7XG4gICAgbG9kYXNoLmV2ZXJ5ID0gZXZlcnk7XG4gICAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICAgIGxvZGFzaC5maW5kSW5kZXggPSBmaW5kSW5kZXg7XG4gICAgbG9kYXNoLmZpbmRLZXkgPSBmaW5kS2V5O1xuICAgIGxvZGFzaC5maW5kTGFzdCA9IGZpbmRMYXN0O1xuICAgIGxvZGFzaC5maW5kTGFzdEluZGV4ID0gZmluZExhc3RJbmRleDtcbiAgICBsb2Rhc2guZmluZExhc3RLZXkgPSBmaW5kTGFzdEtleTtcbiAgICBsb2Rhc2guZmxvb3IgPSBmbG9vcjtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICBsb2Rhc2guZ2V0ID0gZ2V0O1xuICAgIGxvZGFzaC5ndCA9IGd0O1xuICAgIGxvZGFzaC5ndGUgPSBndGU7XG4gICAgbG9kYXNoLmhhcyA9IGhhcztcbiAgICBsb2Rhc2guaGFzSW4gPSBoYXNJbjtcbiAgICBsb2Rhc2guaGVhZCA9IGhlYWQ7XG4gICAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgbG9kYXNoLmluY2x1ZGVzID0gaW5jbHVkZXM7XG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIGxvZGFzaC5pblJhbmdlID0gaW5SYW5nZTtcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG4gICAgbG9kYXNoLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG4gICAgbG9kYXNoLmlzQXJyYXlMaWtlT2JqZWN0ID0gaXNBcnJheUxpa2VPYmplY3Q7XG4gICAgbG9kYXNoLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbiAgICBsb2Rhc2guaXNCdWZmZXIgPSBpc0J1ZmZlcjtcbiAgICBsb2Rhc2guaXNEYXRlID0gaXNEYXRlO1xuICAgIGxvZGFzaC5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG4gICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgIGxvZGFzaC5pc0VxdWFsID0gaXNFcXVhbDtcbiAgICBsb2Rhc2guaXNFcXVhbFdpdGggPSBpc0VxdWFsV2l0aDtcbiAgICBsb2Rhc2guaXNFcnJvciA9IGlzRXJyb3I7XG4gICAgbG9kYXNoLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIGxvZGFzaC5pc0ludGVnZXIgPSBpc0ludGVnZXI7XG4gICAgbG9kYXNoLmlzTGVuZ3RoID0gaXNMZW5ndGg7XG4gICAgbG9kYXNoLmlzTWFwID0gaXNNYXA7XG4gICAgbG9kYXNoLmlzTWF0Y2ggPSBpc01hdGNoO1xuICAgIGxvZGFzaC5pc01hdGNoV2l0aCA9IGlzTWF0Y2hXaXRoO1xuICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xuICAgIGxvZGFzaC5pc05hdGl2ZSA9IGlzTmF0aXZlO1xuICAgIGxvZGFzaC5pc05pbCA9IGlzTmlsO1xuICAgIGxvZGFzaC5pc051bGwgPSBpc051bGw7XG4gICAgbG9kYXNoLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4gICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgbG9kYXNoLmlzT2JqZWN0TGlrZSA9IGlzT2JqZWN0TGlrZTtcbiAgICBsb2Rhc2guaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gICAgbG9kYXNoLmlzU2FmZUludGVnZXIgPSBpc1NhZmVJbnRlZ2VyO1xuICAgIGxvZGFzaC5pc1NldCA9IGlzU2V0O1xuICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgIGxvZGFzaC5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuICAgIGxvZGFzaC5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG4gICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgbG9kYXNoLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcbiAgICBsb2Rhc2guaXNXZWFrU2V0ID0gaXNXZWFrU2V0O1xuICAgIGxvZGFzaC5qb2luID0gam9pbjtcbiAgICBsb2Rhc2gua2ViYWJDYXNlID0ga2ViYWJDYXNlO1xuICAgIGxvZGFzaC5sYXN0ID0gbGFzdDtcbiAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2gubG93ZXJDYXNlID0gbG93ZXJDYXNlO1xuICAgIGxvZGFzaC5sb3dlckZpcnN0ID0gbG93ZXJGaXJzdDtcbiAgICBsb2Rhc2gubHQgPSBsdDtcbiAgICBsb2Rhc2gubHRlID0gbHRlO1xuICAgIGxvZGFzaC5tYXggPSBtYXg7XG4gICAgbG9kYXNoLm1heEJ5ID0gbWF4Qnk7XG4gICAgbG9kYXNoLm1lYW4gPSBtZWFuO1xuICAgIGxvZGFzaC5tZWFuQnkgPSBtZWFuQnk7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gubWluQnkgPSBtaW5CeTtcbiAgICBsb2Rhc2guc3R1YkFycmF5ID0gc3R1YkFycmF5O1xuICAgIGxvZGFzaC5zdHViRmFsc2UgPSBzdHViRmFsc2U7XG4gICAgbG9kYXNoLnN0dWJPYmplY3QgPSBzdHViT2JqZWN0O1xuICAgIGxvZGFzaC5zdHViU3RyaW5nID0gc3R1YlN0cmluZztcbiAgICBsb2Rhc2guc3R1YlRydWUgPSBzdHViVHJ1ZTtcbiAgICBsb2Rhc2gubXVsdGlwbHkgPSBtdWx0aXBseTtcbiAgICBsb2Rhc2gubnRoID0gbnRoO1xuICAgIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgICBsb2Rhc2gubm9vcCA9IG5vb3A7XG4gICAgbG9kYXNoLm5vdyA9IG5vdztcbiAgICBsb2Rhc2gucGFkID0gcGFkO1xuICAgIGxvZGFzaC5wYWRFbmQgPSBwYWRFbmQ7XG4gICAgbG9kYXNoLnBhZFN0YXJ0ID0gcGFkU3RhcnQ7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXBlYXQgPSByZXBlYXQ7XG4gICAgbG9kYXNoLnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJvdW5kID0gcm91bmQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2FtcGxlID0gc2FtcGxlO1xuICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgICBsb2Rhc2guc25ha2VDYXNlID0gc25ha2VDYXNlO1xuICAgIGxvZGFzaC5zb21lID0gc29tZTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhCeSA9IHNvcnRlZEluZGV4Qnk7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4T2YgPSBzb3J0ZWRJbmRleE9mO1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXggPSBzb3J0ZWRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleEJ5ID0gc29ydGVkTGFzdEluZGV4Qnk7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleE9mID0gc29ydGVkTGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLnN0YXJ0Q2FzZSA9IHN0YXJ0Q2FzZTtcbiAgICBsb2Rhc2guc3RhcnRzV2l0aCA9IHN0YXJ0c1dpdGg7XG4gICAgbG9kYXNoLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG4gICAgbG9kYXNoLnN1bSA9IHN1bTtcbiAgICBsb2Rhc2guc3VtQnkgPSBzdW1CeTtcbiAgICBsb2Rhc2gudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICBsb2Rhc2gudG9GaW5pdGUgPSB0b0Zpbml0ZTtcbiAgICBsb2Rhc2gudG9JbnRlZ2VyID0gdG9JbnRlZ2VyO1xuICAgIGxvZGFzaC50b0xlbmd0aCA9IHRvTGVuZ3RoO1xuICAgIGxvZGFzaC50b0xvd2VyID0gdG9Mb3dlcjtcbiAgICBsb2Rhc2gudG9OdW1iZXIgPSB0b051bWJlcjtcbiAgICBsb2Rhc2gudG9TYWZlSW50ZWdlciA9IHRvU2FmZUludGVnZXI7XG4gICAgbG9kYXNoLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgbG9kYXNoLnRvVXBwZXIgPSB0b1VwcGVyO1xuICAgIGxvZGFzaC50cmltID0gdHJpbTtcbiAgICBsb2Rhc2gudHJpbUVuZCA9IHRyaW1FbmQ7XG4gICAgbG9kYXNoLnRyaW1TdGFydCA9IHRyaW1TdGFydDtcbiAgICBsb2Rhc2gudHJ1bmNhdGUgPSB0cnVuY2F0ZTtcbiAgICBsb2Rhc2gudW5lc2NhcGUgPSB1bmVzY2FwZTtcbiAgICBsb2Rhc2gudW5pcXVlSWQgPSB1bmlxdWVJZDtcbiAgICBsb2Rhc2gudXBwZXJDYXNlID0gdXBwZXJDYXNlO1xuICAgIGxvZGFzaC51cHBlckZpcnN0ID0gdXBwZXJGaXJzdDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5maXJzdCA9IGhlYWQ7XG5cbiAgICBtaXhpbihsb2Rhc2gsIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB7fTtcbiAgICAgIGJhc2VGb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gucHJvdG90eXBlLCBtZXRob2ROYW1lKSkge1xuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9KCkpLCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XG5cbiAgICAvLyBBc3NpZ24gZGVmYXVsdCBwbGFjZWhvbGRlcnMuXG4gICAgYXJyYXlFYWNoKFsnYmluZCcsICdiaW5kS2V5JywgJ2N1cnJ5JywgJ2N1cnJ5UmlnaHQnLCAncGFydGlhbCcsICdwYXJ0aWFsUmlnaHQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgbG9kYXNoW21ldGhvZE5hbWVdLnBsYWNlaG9sZGVyID0gbG9kYXNoO1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uZHJvcGAgYW5kIGBfLnRha2VgIHZhcmlhbnRzLlxuICAgIGFycmF5RWFjaChbJ2Ryb3AnLCAndGFrZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xuICAgICAgICBuID0gbiA9PT0gdW5kZWZpbmVkID8gMSA6IG5hdGl2ZU1heCh0b0ludGVnZXIobiksIDApO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSAodGhpcy5fX2ZpbHRlcmVkX18gJiYgIWluZGV4KVxuICAgICAgICAgID8gbmV3IExhenlXcmFwcGVyKHRoaXMpXG4gICAgICAgICAgOiB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IG5hdGl2ZU1pbihuLCByZXN1bHQuX190YWtlQ291bnRfXyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdmlld3NfXy5wdXNoKHtcbiAgICAgICAgICAgICdzaXplJzogbmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpLFxuICAgICAgICAgICAgJ3R5cGUnOiBtZXRob2ROYW1lICsgKHJlc3VsdC5fX2Rpcl9fIDwgMCA/ICdSaWdodCcgOiAnJylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWUgKyAnUmlnaHQnXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpW21ldGhvZE5hbWVdKG4pLnJldmVyc2UoKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRoYXQgYWNjZXB0IGFuIGBpdGVyYXRlZWAgdmFsdWUuXG4gICAgYXJyYXlFYWNoKFsnZmlsdGVyJywgJ21hcCcsICd0YWtlV2hpbGUnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0eXBlID0gaW5kZXggKyAxLFxuICAgICAgICAgIGlzRmlsdGVyID0gdHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHIHx8IHR5cGUgPT0gTEFaWV9XSElMRV9GTEFHO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19pdGVyYXRlZXNfXy5wdXNoKHtcbiAgICAgICAgICAnaXRlcmF0ZWUnOiBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksXG4gICAgICAgICAgJ3R5cGUnOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gcmVzdWx0Ll9fZmlsdGVyZWRfXyB8fCBpc0ZpbHRlcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5oZWFkYCBhbmQgYF8ubGFzdGAuXG4gICAgYXJyYXlFYWNoKFsnaGVhZCcsICdsYXN0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdGFrZU5hbWUgPSAndGFrZScgKyAoaW5kZXggPyAnUmlnaHQnIDogJycpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdGFrZU5hbWVdKDEpLnZhbHVlKClbMF07XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaW5pdGlhbGAgYW5kIGBfLnRhaWxgLlxuICAgIGFycmF5RWFjaChbJ2luaXRpYWwnLCAndGFpbCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIGRyb3BOYW1lID0gJ2Ryb3AnICsgKGluZGV4ID8gJycgOiAnUmlnaHQnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZmlsdGVyZWRfXyA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKSA6IHRoaXNbZHJvcE5hbWVdKDEpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaWRlbnRpdHkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKHByZWRpY2F0ZSkuaGVhZCgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZExhc3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maW5kKHByZWRpY2F0ZSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5pbnZva2VNYXAgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XG4gICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXyAmJiAoc3RhcnQgPiAwIHx8IGVuZCA8IDApKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRha2VSaWdodCgtc3RhcnQpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuZHJvcChzdGFydCk7XG4gICAgICB9XG4gICAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gdG9JbnRlZ2VyKGVuZCk7XG4gICAgICAgIHJlc3VsdCA9IGVuZCA8IDAgPyByZXN1bHQuZHJvcFJpZ2h0KC1lbmQpIDogcmVzdWx0LnRha2UoZW5kIC0gc3RhcnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRha2VSaWdodFdoaWxlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkudGFrZVdoaWxlKHByZWRpY2F0ZSkucmV2ZXJzZSgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFrZShNQVhfQVJSQVlfTEVOR1RIKTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBjaGVja0l0ZXJhdGVlID0gL14oPzpmaWx0ZXJ8ZmluZHxtYXB8cmVqZWN0KXxXaGlsZSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgaXNUYWtlciA9IC9eKD86aGVhZHxsYXN0KSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgbG9kYXNoRnVuYyA9IGxvZGFzaFtpc1Rha2VyID8gKCd0YWtlJyArIChtZXRob2ROYW1lID09ICdsYXN0JyA/ICdSaWdodCcgOiAnJykpIDogbWV0aG9kTmFtZV0sXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gaXNUYWtlciB8fCAvXmZpbmQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGlmICghbG9kYXNoRnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICBhcmdzID0gaXNUYWtlciA/IFsxXSA6IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGlzTGF6eSA9IHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIsXG4gICAgICAgICAgICBpdGVyYXRlZSA9IGFyZ3NbMF0sXG4gICAgICAgICAgICB1c2VMYXp5ID0gaXNMYXp5IHx8IGlzQXJyYXkodmFsdWUpO1xuXG4gICAgICAgIHZhciBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaEZ1bmMuYXBwbHkobG9kYXNoLCBhcnJheVB1c2goW3ZhbHVlXSwgYXJncykpO1xuICAgICAgICAgIHJldHVybiAoaXNUYWtlciAmJiBjaGFpbkFsbCkgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHVzZUxhenkgJiYgY2hlY2tJdGVyYXRlZSAmJiB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiBpdGVyYXRlZS5sZW5ndGggIT0gMSkge1xuICAgICAgICAgIC8vIEF2b2lkIGxhenkgdXNlIGlmIHRoZSBpdGVyYXRlZSBoYXMgYSBcImxlbmd0aFwiIHZhbHVlIG90aGVyIHRoYW4gYDFgLlxuICAgICAgICAgIGlzTGF6eSA9IHVzZUxhenkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgIGlzSHlicmlkID0gISF0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCxcbiAgICAgICAgICAgIGlzVW53cmFwcGVkID0gcmV0VW53cmFwcGVkICYmICFjaGFpbkFsbCxcbiAgICAgICAgICAgIG9ubHlMYXp5ID0gaXNMYXp5ICYmICFpc0h5YnJpZDtcblxuICAgICAgICBpZiAoIXJldFVud3JhcHBlZCAmJiB1c2VMYXp5KSB7XG4gICAgICAgICAgdmFsdWUgPSBvbmx5TGF6eSA/IHZhbHVlIDogbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgICByZXN1bHQuX19hY3Rpb25zX18ucHVzaCh7ICdmdW5jJzogdGhydSwgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLCAndGhpc0FyZyc6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW53cmFwcGVkICYmIG9ubHlMYXp5KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgICAgcmV0dXJuIGlzVW53cmFwcGVkID8gKGlzVGFrZXIgPyByZXN1bHQudmFsdWUoKVswXSA6IHJlc3VsdC52YWx1ZSgpKSA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYEFycmF5YCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBhcnJheUVhY2goWydwb3AnLCAncHVzaCcsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlQcm90b1ttZXRob2ROYW1lXSxcbiAgICAgICAgICBjaGFpbk5hbWUgPSAvXig/OnB1c2h8c29ydHx1bnNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSkgPyAndGFwJyA6ICd0aHJ1JyxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OnBvcHxzaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBpZiAocmV0VW53cmFwcGVkICYmICF0aGlzLl9fY2hhaW5fXykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2NoYWluTmFtZV0oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBNYXAgbWluaWZpZWQgbWV0aG9kIG5hbWVzIHRvIHRoZWlyIHJlYWwgbmFtZXMuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBsb2Rhc2hGdW5jID0gbG9kYXNoW21ldGhvZE5hbWVdO1xuICAgICAgaWYgKGxvZGFzaEZ1bmMpIHtcbiAgICAgICAgdmFyIGtleSA9IChsb2Rhc2hGdW5jLm5hbWUgKyAnJyksXG4gICAgICAgICAgICBuYW1lcyA9IHJlYWxOYW1lc1trZXldIHx8IChyZWFsTmFtZXNba2V5XSA9IFtdKTtcblxuICAgICAgICBuYW1lcy5wdXNoKHsgJ25hbWUnOiBtZXRob2ROYW1lLCAnZnVuYyc6IGxvZGFzaEZ1bmMgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWFsTmFtZXNbY3JlYXRlSHlicmlkKHVuZGVmaW5lZCwgV1JBUF9CSU5EX0tFWV9GTEFHKS5uYW1lXSA9IFt7XG4gICAgICAnbmFtZSc6ICd3cmFwcGVyJyxcbiAgICAgICdmdW5jJzogdW5kZWZpbmVkXG4gICAgfV07XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTGF6eVdyYXBwZXJgLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jbG9uZSA9IGxhenlDbG9uZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmV2ZXJzZSA9IGxhenlSZXZlcnNlO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS52YWx1ZSA9IGxhenlWYWx1ZTtcblxuICAgIC8vIEFkZCBjaGFpbiBzZXF1ZW5jZSBtZXRob2RzIHRvIHRoZSBgbG9kYXNoYCB3cmFwcGVyLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuYXQgPSB3cmFwcGVyQXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbW1pdCA9IHdyYXBwZXJDb21taXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5uZXh0ID0gd3JhcHBlck5leHQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5wbGFudCA9IHdyYXBwZXJQbGFudDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnJldmVyc2UgPSB3cmFwcGVyUmV2ZXJzZTtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRvSlNPTiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWUgPSB3cmFwcGVyVmFsdWU7XG5cbiAgICAvLyBBZGQgbGF6eSBhbGlhc2VzLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuZmlyc3QgPSBsb2Rhc2gucHJvdG90eXBlLmhlYWQ7XG5cbiAgICBpZiAoc3ltSXRlcmF0b3IpIHtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbc3ltSXRlcmF0b3JdID0gd3JhcHBlclRvSXRlcmF0b3I7XG4gICAgfVxuICAgIHJldHVybiBsb2Rhc2g7XG4gIH0pO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEV4cG9ydCBsb2Rhc2guXG4gIHZhciBfID0gcnVuSW5Db250ZXh0KCk7XG5cbiAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2U6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBMb2Rhc2ggb24gdGhlIGdsb2JhbCBvYmplY3QgdG8gcHJldmVudCBlcnJvcnMgd2hlbiBMb2Rhc2ggaXNcbiAgICAvLyBsb2FkZWQgYnkgYSBzY3JpcHQgdGFnIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTUQgbG9hZGVyLlxuICAgIC8vIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2Vycm9ycy5odG1sI21pc21hdGNoIGZvciBtb3JlIGRldGFpbHMuXG4gICAgLy8gVXNlIGBfLm5vQ29uZmxpY3RgIHRvIHJlbW92ZSBMb2Rhc2ggZnJvbSB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICByb290Ll8gPSBfO1xuXG4gICAgLy8gRGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGUuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgaXQuXG4gIGVsc2UgaWYgKGZyZWVNb2R1bGUpIHtcbiAgICAvLyBFeHBvcnQgZm9yIE5vZGUuanMuXG4gICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IF8pLl8gPSBfO1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgc3VwcG9ydC5cbiAgICBmcmVlRXhwb3J0cy5fID0gXztcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBFeHBvcnQgdG8gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5fID0gXztcbiAgfVxufS5jYWxsKHRoaXMpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvbG9kYXNoLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiKGZ1bmN0aW9uIChyb290KSB7XG5cbiAgLy8gU3RvcmUgc2V0VGltZW91dCByZWZlcmVuY2Ugc28gcHJvbWlzZS1wb2x5ZmlsbCB3aWxsIGJlIHVuYWZmZWN0ZWQgYnlcbiAgLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG4gIHZhciBzZXRUaW1lb3V0RnVuYyA9IHNldFRpbWVvdXQ7XG5cbiAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gIFxuICAvLyBQb2x5ZmlsbCBmb3IgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmbi5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBQcm9taXNlKGZuKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0JykgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3Jyk7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgZnVuY3Rpb24nKTtcbiAgICB0aGlzLl9zdGF0ZSA9IDA7XG4gICAgdGhpcy5faGFuZGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3ZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RlZmVycmVkcyA9IFtdO1xuXG4gICAgZG9SZXNvbHZlKGZuLCB0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZShzZWxmLCBkZWZlcnJlZCkge1xuICAgIHdoaWxlIChzZWxmLl9zdGF0ZSA9PT0gMykge1xuICAgICAgc2VsZiA9IHNlbGYuX3ZhbHVlO1xuICAgIH1cbiAgICBpZiAoc2VsZi5fc3RhdGUgPT09IDApIHtcbiAgICAgIHNlbGYuX2RlZmVycmVkcy5wdXNoKGRlZmVycmVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi5faGFuZGxlZCA9IHRydWU7XG4gICAgUHJvbWlzZS5faW1tZWRpYXRlRm4oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNiID0gc2VsZi5fc3RhdGUgPT09IDEgPyBkZWZlcnJlZC5vbkZ1bGZpbGxlZCA6IGRlZmVycmVkLm9uUmVqZWN0ZWQ7XG4gICAgICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICAgICAgKHNlbGYuX3N0YXRlID09PSAxID8gcmVzb2x2ZSA6IHJlamVjdCkoZGVmZXJyZWQucHJvbWlzZSwgc2VsZi5fdmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmV0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0ID0gY2Ioc2VsZi5fdmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZGVmZXJyZWQucHJvbWlzZSwgZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoZGVmZXJyZWQucHJvbWlzZSwgcmV0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmUoc2VsZiwgbmV3VmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgLy8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZTogaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMjdGhlLXByb21pc2UtcmVzb2x1dGlvbi1wcm9jZWR1cmVcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICAgIGlmIChuZXdWYWx1ZSAmJiAodHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmV3VmFsdWUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHZhciB0aGVuID0gbmV3VmFsdWUudGhlbjtcbiAgICAgICAgaWYgKG5ld1ZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgIHNlbGYuX3N0YXRlID0gMztcbiAgICAgICAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgIGZpbmFsZShzZWxmKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkb1Jlc29sdmUoYmluZCh0aGVuLCBuZXdWYWx1ZSksIHNlbGYpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2VsZi5fc3RhdGUgPSAxO1xuICAgICAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIGZpbmFsZShzZWxmKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZWplY3Qoc2VsZiwgZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVqZWN0KHNlbGYsIG5ld1ZhbHVlKSB7XG4gICAgc2VsZi5fc3RhdGUgPSAyO1xuICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgZmluYWxlKHNlbGYpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluYWxlKHNlbGYpIHtcbiAgICBpZiAoc2VsZi5fc3RhdGUgPT09IDIgJiYgc2VsZi5fZGVmZXJyZWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgUHJvbWlzZS5faW1tZWRpYXRlRm4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghc2VsZi5faGFuZGxlZCkge1xuICAgICAgICAgIFByb21pc2UuX3VuaGFuZGxlZFJlamVjdGlvbkZuKHNlbGYuX3ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGYuX2RlZmVycmVkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaGFuZGxlKHNlbGYsIHNlbGYuX2RlZmVycmVkc1tpXSk7XG4gICAgfVxuICAgIHNlbGYuX2RlZmVycmVkcyA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBwcm9taXNlKSB7XG4gICAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbDtcbiAgICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogVGFrZSBhIHBvdGVudGlhbGx5IG1pc2JlaGF2aW5nIHJlc29sdmVyIGZ1bmN0aW9uIGFuZCBtYWtlIHN1cmVcbiAgICogb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgYXJlIG9ubHkgY2FsbGVkIG9uY2UuXG4gICAqXG4gICAqIE1ha2VzIG5vIGd1YXJhbnRlZXMgYWJvdXQgYXN5bmNocm9ueS5cbiAgICovXG4gIGZ1bmN0aW9uIGRvUmVzb2x2ZShmbiwgc2VsZikge1xuICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGZuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZShzZWxmLCB2YWx1ZSk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICByZWplY3Qoc2VsZiwgcmVhc29uKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICByZWplY3Qoc2VsZiwgZXgpO1xuICAgIH1cbiAgfVxuXG4gIFByb21pc2UucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xuICB9O1xuXG4gIFByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICB2YXIgcHJvbSA9IG5ldyAodGhpcy5jb25zdHJ1Y3Rvcikobm9vcCk7XG5cbiAgICBoYW5kbGUodGhpcywgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb20pKTtcbiAgICByZXR1cm4gcHJvbTtcbiAgfTtcblxuICBQcm9taXNlLmFsbCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycik7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzb2x2ZShbXSk7XG4gICAgICB2YXIgcmVtYWluaW5nID0gYXJncy5sZW5ndGg7XG5cbiAgICAgIGZ1bmN0aW9uIHJlcyhpLCB2YWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgdmFyIHRoZW4gPSB2YWwudGhlbjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB0aGVuLmNhbGwodmFsLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgcmVzKGksIHZhbCk7XG4gICAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXJnc1tpXSA9IHZhbDtcbiAgICAgICAgICBpZiAoLS1yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHJlamVjdChleCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlcyhpLCBhcmdzW2ldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBQcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVqZWN0KHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICBQcm9taXNlLnJhY2UgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFsdWVzW2ldLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyBVc2UgcG9seWZpbGwgZm9yIHNldEltbWVkaWF0ZSBmb3IgcGVyZm9ybWFuY2UgZ2FpbnNcbiAgUHJvbWlzZS5faW1tZWRpYXRlRm4gPSAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBmdW5jdGlvbiAoZm4pIHsgc2V0SW1tZWRpYXRlKGZuKTsgfSkgfHxcbiAgICBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHNldFRpbWVvdXRGdW5jKGZuLCAwKTtcbiAgICB9O1xuXG4gIFByb21pc2UuX3VuaGFuZGxlZFJlamVjdGlvbkZuID0gZnVuY3Rpb24gX3VuaGFuZGxlZFJlamVjdGlvbkZuKGVycikge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZSkge1xuICAgICAgY29uc29sZS53YXJuKCdQb3NzaWJsZSBVbmhhbmRsZWQgUHJvbWlzZSBSZWplY3Rpb246JywgZXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGltbWVkaWF0ZSBmdW5jdGlvbiB0byBleGVjdXRlIGNhbGxiYWNrc1xuICAgKiBAcGFyYW0gZm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0byBleGVjdXRlXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBQcm9taXNlLl9zZXRJbW1lZGlhdGVGbiA9IGZ1bmN0aW9uIF9zZXRJbW1lZGlhdGVGbihmbikge1xuICAgIFByb21pc2UuX2ltbWVkaWF0ZUZuID0gZm47XG4gIH07XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiB1bmhhbmRsZWQgcmVqZWN0aW9uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gdW5oYW5kbGVkIHJlamVjdGlvblxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgUHJvbWlzZS5fc2V0VW5oYW5kbGVkUmVqZWN0aW9uRm4gPSBmdW5jdGlvbiBfc2V0VW5oYW5kbGVkUmVqZWN0aW9uRm4oZm4pIHtcbiAgICBQcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbiA9IGZuO1xuICB9O1xuICBcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuICB9IGVsc2UgaWYgKCFyb290LlByb21pc2UpIHtcbiAgICByb290LlByb21pc2UgPSBQcm9taXNlO1xuICB9XG5cbn0pKHRoaXMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb21pc2UtcG9seWZpbGwvcHJvbWlzZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdGlmICh0eXBlb2YgbWVtb1tzZWxlY3Rvcl0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdG1lbW9bc2VsZWN0b3JdID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdH07XG59KShmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldClcbn0pO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcblx0aWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC8pL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXNwYXRjaGVyIHtcblxuICBjb25zdHJ1Y3RvcigpIHtcblxuICAgIHRoaXMuY2FsbGJhY2tzICA9IFtdO1xuXG4gIH1cblxuICBhZGRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaykge1xuXG4gICAgaWYgKCF0eXBlIHx8ICFjYWxsYmFjaykgcmV0dXJuO1xuXG4gICAgaWYgKHRoaXMuY2FsbGJhY2tzW3R5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzW3R5cGVdICA9IFtdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNhbGxiYWNrc1t0eXBlXS5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzW3R5cGVdLnB1c2goY2FsbGJhY2spO1xuICAgIH1cblxuICB9XG4gIGhhc0xpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAoKHRoaXMuY2FsbGJhY2tzW3R5cGVdICE9PSB1bmRlZmluZWQpICYmICh0aGlzLmNhbGxiYWNrc1t0eXBlXS5pbmRleE9mKGNhbGxiYWNrKSAhPT0gLTEpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgfVxuXG4gIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7XG5cbiAgICBsZXQgdHlwZUNhbGxiYWNrcyAgPSB0aGlzLmNhbGxiYWNrc1t0eXBlXTtcblxuICAgIGlmICh0eXBlQ2FsbGJhY2tzICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgbGV0IGluZGV4ID0gdHlwZUNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcblxuICAgICAgaWYgKGluZGV4ICE9PSAtIDEpIHtcbiAgICAgICAgdHlwZUNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcblxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhpcy5jYWxsYmFja3MgPSB7IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmNhbGxiYWNrcykge1xuICAgICAgICBkZWxldGUodGhpcy5jYWxsYmFja3NbdHlwZV0pO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgZGlzcGF0Y2godHlwZSwgZGF0YSkge1xuXG4gICAgaWYgKCF0eXBlKSByZXR1cm47XG5cbiAgICBsZXQgdHlwZUNhbGxiYWNrcyAgPSB0aGlzLmNhbGxiYWNrc1t0eXBlXTtcblxuICAgIGlmICh0eXBlQ2FsbGJhY2tzICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgZGF0YSAgICAgICAgICA9IChkYXRhID09PSB1bmRlZmluZWQpID8geyB9IDogZGF0YTtcbiAgICAgIGRhdGEudGFyZ2V0ICAgPSB0aGlzO1xuICAgICAgZGF0YS50eXBlICAgICA9IHR5cGU7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZUNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0eXBlQ2FsbGJhY2tzW2ldLmNhbGwodGhpcywgZGF0YSk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG59XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92YXJ5ZC11dGlscy9EaXNwYXRjaGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5pbXBvcnQgKiBhcyBtYXRocyBmcm9tIFwiLi9tYXRoc1wiO1xuaW1wb3J0ICogYXMgcmFuZG9tIGZyb20gXCIuL3JhbmRvbVwiO1xuaW1wb3J0ICogYXMgUmFuZ2UgZnJvbSBcIi4vUmFuZ2VcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjdCB7XG5cbiAgLy8gQ29uc3RydWN0b3JcblxuICBjb25zdHJ1Y3Rvcih4LCB5LCB3LCBoKSB7XG5cbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53ID0gdztcbiAgICB0aGlzLmggPSBoO1xuXG4gIH1cblxuICAvLyBHZXQvc2V0XG5cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnc7XG4gIH1cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5oO1xuICB9XG5cbiAgc2V0IHdpZHRoKHZhbCkge1xuICAgIHRoaXMudyA9IHZhbDtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbCkge1xuICAgIHRoaXMuaCA9IHZhbDtcbiAgfVxuXG4gIGdldCBsZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLng7XG4gIH1cbiAgZ2V0IHRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy55O1xuICB9XG4gIGdldCByaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy54ICsgdGhpcy53O1xuICB9XG4gIGdldCBib3R0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaDtcbiAgfVxuXG4gIGdldCB4UmFuZ2UoKSB7XG4gICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLngsIHRoaXMueCArIHRoaXMudyk7XG4gIH1cbiAgZ2V0IHlSYW5nZSgpIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMueSwgdGhpcy55ICsgdGhpcy5oKTtcbiAgfVxuXG4gIGdldCBjZW50ZXJYKCkge1xuICAgIHJldHVybiB0aGlzLmxlcnBYKDAuNSk7XG4gIH1cbiAgZ2V0IGNlbnRlclkoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVycFkoMC41KTtcbiAgfVxuICBnZXQgY2VudGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB0aGlzLmNlbnRlclgsXG4gICAgICB5OiB0aGlzLmNlbnRlcllcbiAgICB9O1xuICB9XG5cbiAgZ2V0IGJvdHRvbVJpZ2h0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB0aGlzLnJpZ2h0LFxuICAgICAgeTogdGhpcy5ib3R0b21cbiAgICB9XG4gIH1cbiAgZ2V0IHRvcExlZnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHRoaXMubGVmdCxcbiAgICAgIHk6IHRoaXMudG9wXG4gICAgfVxuICB9XG5cbiAgZ2V0IHJhbmRvbVgoKSB7XG4gICAgcmV0dXJuIHJhbmRvbS5udW0odGhpcy5sZWZ0LCB0aGlzLnJpZ2h0KTtcbiAgfVxuICBnZXQgcmFuZG9tWSgpIHtcbiAgICByZXR1cm4gcmFuZG9tLm51bSh0aGlzLnRvcCwgdGhpcy5ib3R0b20pO1xuICB9XG4gIGdldCByYW5kb21QdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy5yYW5kb21YLFxuICAgICAgeTogdGhpcy5yYW5kb21ZXG4gICAgfTtcbiAgfVxuXG4gIGdldCB3aFJhdGlvKCkge1xuICAgIHJldHVybiB0aGlzLncgLyB0aGlzLmg7XG4gIH1cbiAgZ2V0IGh3UmF0aW8oKSB7XG4gICAgcmV0dXJuIHRoaXMuaCAvIHRoaXMudztcbiAgfVxuXG5cbiAgLy8gUHVibGljIG1ldGhvZHNcblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMudywgdGhpcy5oKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgKHg6ICR7dGhpcy54fSwgeTogJHt0aGlzLnl9LCB3OiAke3RoaXMud30sIGg6ICR7dGhpcy5ofSlgO1xuICB9XG5cbiAgY29udGFpbnMoeCwgeSkge1xuICAgIGlmICh4IDwgdGhpcy5sZWZ0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHggPiB0aGlzLnJpZ2h0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHkgPCB0aGlzLnRvcCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh5ID4gdGhpcy5ib3R0b20pIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGVxdWFscyhyZWN0Qikge1xuICAgIGlmICh0aGlzLnggIT09IHJlY3RCLngpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy55ICE9PSByZWN0Qi55KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMudyAhPT0gcmVjdEIudykgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aGlzLmggIT09IHJlY3RCLmgpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNsYW1wWFkoeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBtYXRocy5jbGFtcCh4LCB0aGlzLmxlZnQsIHRoaXMucmlnaHQpLFxuICAgICAgeTogbWF0aHMuY2xhbXAoeSwgdGhpcy50b3AsIHRoaXMuYm90dG9tKVxuICAgIH1cbiAgfVxuXG4gIGxlcnBYKHZhbCkge1xuICAgIHJldHVybiBtYXRocy5sZXJwKHRoaXMubGVmdCwgdGhpcy5yaWdodCwgdmFsKTtcbiAgfVxuICBsZXJwWSh2YWwpIHtcbiAgICByZXR1cm4gbWF0aHMubGVycCh0aGlzLnRvcCwgdGhpcy5ib3R0b20sIHZhbCk7XG4gIH1cblxuICBub3JtWCh2YWwpIHtcbiAgICByZXR1cm4gbWF0aHMubm9ybSh2YWwsIHRoaXMubGVmdCwgdGhpcy5yaWdodCk7XG4gIH1cbiAgbm9ybVkodmFsKSB7XG4gICAgcmV0dXJuIG1hdGhzLm5vcm0odmFsLCB0aGlzLnRvcCwgdGhpcy5ib3R0b20pO1xuICB9XG5cbiAgbWFwWCh2YWwsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIG1hdGhzLmxlcnAobWluLCBtYXgsIHRoaXMubm9ybVgodmFsKSk7XG4gIH1cbiAgbWFwWSh2YWwsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIG1hdGhzLmxlcnAobWluLCBtYXgsIHRoaXMubm9ybVkodmFsKSk7XG4gIH1cblxuICBhYnNvbHV0aXplKCkge1xuICAgIGlmICh0aGlzLncgPCAwKSB7XG4gICAgICB0aGlzLnggICs9IHRoaXMudztcbiAgICAgIHRoaXMudyAgPSAtdGhpcy53O1xuICAgIH1cbiAgICBpZiAodGhpcy5oIDwgMCkge1xuICAgICAgdGhpcy55ICArPSB0aGlzLmg7XG4gICAgICB0aGlzLmggID0gLXRoaXMuaDtcbiAgICB9XG4gIH1cbiAgYWJzb2x1dGl6ZWQoKSB7XG4gICAgbGV0IHIgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHIuYWJzb2x1dGl6ZSgpXG4gICAgcmV0dXJuIHI7XG4gIH1cblxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ZhcnlkLXV0aWxzL1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbmltcG9ydCAqIGFzIGdlb20gZnJvbSBcIi4vZ2VvbVwiO1xuaW1wb3J0ICogYXMgcmFuZG9tIGZyb20gXCIuL3JhbmRvbVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZWMge1xuXG4gIGNvbnN0cnVjdG9yKHgsIHkpIHtcblxuICAgIGNvbnN0IHhJc1ZlYyAgPSAoeCAhPT0gbnVsbCkgJiYgKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiKSAmJiAoeC54ICE9PSB1bmRlZmluZWQpICYmICh4LnkgIT09IHVuZGVmaW5lZCk7XG5cbiAgICBpZiAoeElzVmVjKSB7XG4gICAgICB0aGlzLnggID0geC54O1xuICAgICAgdGhpcy55ICA9IHgueTtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnggID0geDtcbiAgICAgIHRoaXMueSAgPSB5O1xuICAgIH1cblxuICB9XG5cbiAgLy8gR2V0L3NldFxuXG4gIGdldCBtYWduaXR1ZGUoKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLm1hZ1NxKVxuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFnbml0dWRlO1xuICB9XG5cbiAgZ2V0IG1hZ1NxKCkge1xuICAgIHJldHVybiAodGhpcy54ICogdGhpcy54KSArICh0aGlzLnkgKiB0aGlzLnkpO1xuICB9XG4gIGdldCBsZW5TcSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYWdTcTtcbiAgfVxuXG5cbiAgLy8gTWV0aG9kc1xuXG4gIHN0YXRpYyByYW5kb20obWluWCwgbWF4WCwgbWluWSwgbWF4WSkge1xuICAgIHJldHVybiBuZXcgVmVjKHJhbmRvbS5udW0obWluWCwgbWF4WCksIHJhbmRvbS5udW0obWluWSwgbWF4WSkpO1xuICB9XG5cbiAgc3RhdGljIGZyb21QdHMoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gbmV3IFZlYyh4MiAtIHgxLCB5MiAtIHkxKTtcbiAgfVxuXG4gIGRpc3RUbyhwdCkge1xuICAgIHJldHVybiBnZW9tLmRpc3QodGhpcy54LCB0aGlzLnksIHB0LngsIHB0LnkpO1xuICB9XG4gIGRpc3RUb1hZKHgsIHkpIHtcbiAgICByZXR1cm4gZ2VvbS5kaXN0KHRoaXMueCwgdGhpcy55LCB4LCB5KTtcbiAgfVxuICBkaXN0U3FUbyhwdCkge1xuICAgIHJldHVybiBnZW9tLmRpc3RTcSh0aGlzLngsIHRoaXMueSwgcHQueCwgcHQueSk7XG4gIH1cbiAgZGlzdFNxVG9YWSh4LCB5KSB7XG4gICAgcmV0dXJuIGdlb20uZGlzdFNxKHRoaXMueCwgdGhpcy55LCB4LCB5KTtcbiAgfVxuXG4gIGFkZCh2KSB7XG4gICAgdGhpcy54ICArPSB2Lng7XG4gICAgdGhpcy55ICArPSB2Lnk7XG4gIH1cbiAgc3VidHJhY3Qodikge1xuICAgIHRoaXMueCAgLT0gdi54O1xuICAgIHRoaXMueSAgLT0gdi55O1xuICB9XG4gIG11bHRpcGx5KHZhbCkge1xuICAgIHRoaXMueCAgKj0gdmFsO1xuICAgIHRoaXMueSAgKj0gdmFsO1xuICB9XG4gIGRpdmlkZSh2YWwpIHtcbiAgICB0aGlzLnggIC89IHZhbDtcbiAgICB0aGlzLnkgIC89IHZhbDtcbiAgfVxuXG4gIG5vcm1hbGl6ZShzY2FsZSkge1xuICAgIHZhciBtYWcgID0gdGhpcy5tYWduaXR1ZGU7XG4gICAgaWYgKG1hZyAhPSAwKSB7XG4gICAgICB0aGlzLmRpdmlkZShtYWcpO1xuICAgICAgaWYgKHNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5tdWx0aXBseShzY2FsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxpbWl0KHZhbCkge1xuICAgIHZhciBtYWcgID0gdGhpcy5tYWduaXR1ZGU7XG4gICAgaWYgKG1hZyA+IHZhbCAmJiBtYWcgIT0gMCkge1xuICAgICAgdGhpcy5kaXZpZGUobWFnKTtcbiAgICAgIHRoaXMubXVsdGlwbHkodmFsKTtcbiAgICB9XG4gIH1cblxuICBkb3Qodikge1xuICAgIHJldHVybiAodGhpcy54ICogdi54KSArICh0aGlzLnkgKiB2LnkpO1xuICB9XG4gIGFuZ2xlQmV0d2Vlbih2KSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyh0aGlzLmRvdCh2KSAvICh0aGlzLm1hZ25pdHVkZSAqIHYubWFnbml0dWRlKSk7XG4gIH1cblxuICB3cmFwSW4oeCwgeSwgdywgaCkge1xuICAgIHdoaWxlICh0aGlzLnggPCB4KSB0aGlzLnggKz0gdztcbiAgICB3aGlsZSAodGhpcy55IDwgeSkgdGhpcy55ICs9IGg7XG4gICAgd2hpbGUgKHRoaXMueCA+IHcgKyB4KSB0aGlzLnggLT0gdztcbiAgICB3aGlsZSAodGhpcy55ID4gaCArIHkpIHRoaXMueSAtPSBoO1xuICB9XG4gIHdyYXBJblJlY3QocmVjdCkge1xuICAgIHRoaXMud3JhcEluKHJlY3QueCwgcmVjdC55LCByZWN0LncsIHJlY3QuaCk7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFZlYyh0aGlzLngsIHRoaXMueSk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiKHg6IFwiICsgdGhpcy54ICsgXCIsIHk6IFwiICsgdGhpcy55ICsgXCIpXCI7XG4gIH1cblxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ZhcnlkLXV0aWxzL1ZlYy5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuaW1wb3J0ICogYXMgYXJyYXlzIGZyb20gXCIuL2FycmF5c1wiO1xuaW1wb3J0ICogYXMgZ2VvbSBmcm9tIFwiLi9nZW9tXCI7XG5pbXBvcnQgKiBhcyBtYXRocyBmcm9tIFwiLi9tYXRoc1wiO1xuaW1wb3J0ICogYXMgbmV0IGZyb20gXCIuL25ldFwiO1xuaW1wb3J0ICogYXMgcmFuZG9tIGZyb20gXCIuL3JhbmRvbVwiO1xuaW1wb3J0ICogYXMgdGV4dCBmcm9tIFwiLi90ZXh0XCI7XG5cbmV4cG9ydCB7IGFycmF5cyB9O1xuZXhwb3J0IHsgZ2VvbSB9O1xuZXhwb3J0IHsgbWF0aHMgfTtcbmV4cG9ydCB7IG5ldCB9O1xuZXhwb3J0IHsgcmFuZG9tIH07XG5leHBvcnQgeyB0ZXh0IH07XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmVjdCB9IGZyb20gXCIuL1JlY3RcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmFuZ2UgfSBmcm9tIFwiLi9SYW5nZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBWZWMgfSBmcm9tIFwiLi9WZWNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGlzcGF0Y2hlciB9IGZyb20gXCIuL0Rpc3BhdGNoZXJcIjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92YXJ5ZC11dGlscy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuaW1wb3J0ICogYXMgdGV4dCBmcm9tIFwiLi90ZXh0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB4aHJGZXRjaChwYXRoLCBib2R5ID0gbnVsbCkge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblxuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgICAgLy8gU3VjY2Vzc2Z1bCBsb2NhbCBmaWxlcyB3aWxsIG5vdCByZXR1cm4gMjAwIE9LIHN0YXR1cyxcbiAgICAgIC8vIGJ1dCB0aGV5IHdpbGwgaGl0IHRoZSBvbmVycm9yIGhhbmRsZXIgaWYgdGhleSBmYWlsLFxuICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBjaGVjayB0aGVpciBzdGF0dXNcblxuICAgICAgY29uc3Qgc3RhdHVzT0sgID0gKHhoci5zdGF0dXMgPT09IDIwMCksXG4gICAgICAgICAgICBpc0xvY2FsICAgPSB0ZXh0LmJlZ2luc1dpdGgoeGhyLnJlc3BvbnNlVVJMLCAnZmlsZTonKTtcblxuICAgICAgaWYgKHN0YXR1c09LIHx8IGlzTG9jYWwpIHtcbiAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoeGhyLnJlc3BvbnNlVGV4dCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1Byb2JsZW0gbG9hZGluZzogJyArIHBhdGgpKTtcbiAgICAgIH1cblxuICAgIH1cbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdQcm9ibGVtIGxvYWRpbmc6ICcgKyBwYXRoKSk7XG4gICAgfVxuXG4gICAgeGhyLm9wZW4oJ0dFVCcsIHBhdGgpO1xuICAgIHhoci5zZW5kKGJvZHkpO1xuXG4gIH0pO1xuXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdmFyeWQtdXRpbHMvbmV0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbE1vZHVsZSkge1xyXG5cdGlmKCFvcmlnaW5hbE1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdHZhciBtb2R1bGUgPSBPYmplY3QuY3JlYXRlKG9yaWdpbmFsTW9kdWxlKTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImV4cG9ydHNcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vaGFybW9ueS1tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QTs7Ozs7QUNoRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzlCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbm5CQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbFVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDeEdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ2xIQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwZkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMvQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDelhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdEZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNIQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzVnQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pRQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0REE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5b0JBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6RUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDeEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaFRBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaklBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdENBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaldBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqSUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaENBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQ2hIQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNqSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDeE9BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3ZMQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6S0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3RmQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3J5QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM0dBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzVLQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0UEE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakxBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5SEE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5RkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNsREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6Q0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM1RkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25HQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pIQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDNUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2puQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3plQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxVkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNyQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25SQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25JQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDekpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNqSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3JGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDOUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ2pFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN0RkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDakVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNqRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ2hFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNqRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1BBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7O0FDQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM3VEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUMxQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbERBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzlHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5RUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNyTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxTEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqakJBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuc0JBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JuQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDekNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzVFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3RDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaEVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQy9FQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQy9DQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQy9OQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdEZBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM3RUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDNUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDOUhBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3hLQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNsWkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzVNQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL2tCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMvUEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL0ZBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3hEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcEVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDekRBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5RUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzVIQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3ZEQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25SQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0TkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4RkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzcmhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7Ozs7Ozs7QUNoRkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQzNLQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUN2SEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xCQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QSIsInNvdXJjZVJvb3QiOiIifQ==